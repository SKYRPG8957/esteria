{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcommands", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Scripting Custom Commands Overview 03/27/2025  There is also a video version available of this overview of Scripting Custom Commands:  Scripting Custom Commands  Commands are a critical part of nearly any creator project. Commonly, projects are boot-strapped and tested via a set of custom commands and functions, including commands that can reset environments or change configurations. In multiplayer environments, a set of commands can be used to administer games. You can also use commands to provide helpful little builder functions, to further build out your world.  Starting in Minecraft Bedrock Edition 1.21.80.22 Preview, you can now implement custom commands in script. These commands have the full capability of scripting APIs and custom logic, allowing you to implement sophisticated operations.  Note that in the current beta, context on the executing environment (e.g., the player who ran the command, or the initiator in NPC environments) is not available; we are looking to bring this execution context in future.  You can view a sample project at https://github.com/microsoft/minecraft-scripting-samples.  Using 2.0.0-beta scripting environment  To get started, we'll want to work with the 2.0.0-beta scripting environment. Custom commands and registration only run in the v2.0.0 scripting environment, which itself is currently in beta.  You'll want to make sure you use 2.0.0-beta as your scripting environment, in the manifest of your behavior pack:  JSON Copy   {     \"module_name\": \"@minecraft/server\",     \"version\": \"2.0.0-beta\"   },  Registering Commands  The first step is to register the command. You can do this within the startup event of system.beforeEvents, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Celebration size\",     permissionLevel: CustomCommandPermissionLevel.Admin,     optionalParameters: [{ type: CustomCommandParamType.Integer, name: \"celebrationSize\" }],   };   init.customCommandRegistry.registerCommand(helloCommand, helloCustomCommand); }   There are several parameters you will need to specify:  Expand table Parameter\tDescription name\tName of the command that is used. Custom commands must be namespaced (that is, follow the form of namespace:commandname). description\tDescription of the command. This will show up in autocomplete for the command. permissionLevel\tRelative permission level of the command. mandatoryParameters\tA list of mandatory parameters for the command. These will come first in the list of parameters that a command may have. optionalParameters\tA list of optional parameters for the command. These will come second in the list of parameters. Permission Levels  Commands can have a permission level that is required from executing contexts and players.  Expand table Parameter\tDescription Any\tAny player or environment can run this command. GameDirectors\tRequires a player with an \"Operator Commands\" permission to run this command. Also, scripting and command environments, like command blocks, can run this command. Admin\tRequires a player with \"Operator Commands\" permission. Commands with this level cannot be used in automations like commands or script Host\tOnly the originating game owner can run this command. Owner\tIn dedicated server environments, this command can only be exited in the hosting environment at the dedicated server console. Command Enums  As of the 1.21.80-preview.27 release you can now register custom enums for script-based commands, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const commandRegistry = event.customCommandRegistry;    commandRegistry.registerEnum(\"creator:my_enum\", [\"foo\", \"bar\", \"baz\"]);    const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Example command\",     permissionLevel: CustomCommandPermissionLevel.Any,     mandatoryParameters: [       {          type: CustomCommandParamType.Enum,          name: \"creator:my_enum\" // The parameter name must match the registered enum name above     }],   };   commandRegistry.registerCommand(helloCommand, helloCustomCommand); }  Execution  After registering your command, Minecraft will call into your function with the parameters that are specified by the command context.  Expand table Parameter Type\tCorresponding data variable type BlockType\t@minecraft/server.BlockType Boolean\tboolean EntitySelector\tEntity[] Float\tnumber Integer\tnumber ItemType\t@minecraft/server.ItemType Position\tVector3 PlayerSelector\tPlayer[] String\tstring  If the parameter is optional, then undefined is passed in if the parameter is not specified.  Note that script command function runs in a \"before\" context, meaning that most methods that change state are unavailable in the command context. To run commands that change world state, you'll want to consider wrapping them in a function that defers execution until later in the tick, such as system.run for example:  TypeScript Copy     system.run(() => {       for (const player of world.getPlayers()) {         player.dimension.createExplosion(player.location, celebrationSize);       }     });  Summary  Custom script-based commands unlocks a new organization tool for functionality you have in your creations. Whether a simple internal reset tool or a sophisticated game administration suite, we hope that providing a set of powerful commands is easy and second nature in your projects.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/resourcepack", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Resource Packs 05/07/2025  Before building your first Add-On for Minecraft: Bedrock Edition, you'll need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A resource pack is a folder structure that contains all of your custom models, sounds, textures, and other custom content.  In this tutorial, you will learn:  How a resource pack is created. How a manifest file is created. How custom textures are loaded into Minecraft: Bedrock Edition. The concept of Pack Stacking when working with Add-On content. Sample Resource Pack  There is a sample resource pack available on the Minecraft samples GitHub. This pack may be used to understand the structure of resource packs and to check your work after you complete this tutorial.  Requirements  It's recommended you complete Getting Started with Add-On Development before beginning this tutorial.  Building the Resource Pack  For Minecraft to find and use your resource files, you must set up the folders and files in a specific way. This tutorial will guide you through creating this folder and file structure.  Create a Resource Pack Folder  We will start by creating a folder called My_RESOURCE_Pack. Technically you can name this folder anything you want, but the other folders have to be named exactly as specified in this tutorial so that Minecraft knows where to find the information.  Locate com.mojang on a Windows device Open the com.mojang folder. Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK. Double-click the development_resource_packs folder to open it. Add a new folder and name it My_RESOURCE_Pack. Double-click the My_RESOURCE_Pack folder to open it.  Create a Manifest File  To load a resource pack into Minecraft, we need a manifest file. The manifest file is a JSON file that contains the following information:  Description: In-game description of what the resource pack does. Name: In-game name of the resource pack. UUID: Universally Unique Identifier. Version: Version of the resource pack. Minimum Engine Version: Minimum required version of Minecraft for this pack to work properly.   Note  To learn more about how a manifest.json file works, see the Addons Reference manifest.json documentation.  Minecraft parses the information from the manifest file and displays it in the Add-On section of the game. Inside the file, the information is split into two separate sections: Header and modules. The header section contains the overall information for the pack, while the modules section contains the dedicated packages information. To create the manifest.json file:  Right-click in the Explorer window, and select New > Text Document. Name it manifest.json. You will need to change the file extension from .txt to .json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab.  Double-click the manifest.json file to open it in a text editor. Copy and paste the following code into your file. JSON Copy {  \"format_version\": 2,  \"header\": {    \"description\": \"My dirt resource pack Add-On!\",    \"name\": \"My Resource Pack\",    \"uuid\": \"<FIRST GENERATED UUID>\",    \"version\": [1, 0, 0],    \"min_engine_version\": [1, 16, 0]   },  \"modules\": [    {      \"description\": \"My First Add-On!\",      \"type\": \"resources\",      \"uuid\": \"<SECOND GENERATED UUID>\",      \"version\": [1, 0, 0]    }  ] }  Set the UUID  A Universally Unique Identifier (UUID) is a unique number used for identification purposes. For Minecraft, the UUID is used to define a specific pack and to prevent any duplicate software from causing issues. For the header and modules, there will need to be two different UUID numbers entered in each of the \"uuid\" fields between the quotes. You can get UUIDs from an online UUID Generator such as https://www.uuidgenerator.net/.  Copy and paste a UUID into the header section. The UUID will need to be pasted in the \"uuid\":\"\" field between the quotation (\"\") marks to be read correctly. Refresh the webpage to generate a new UUID for use in the Modules section. Copy and paste the new UUID into the modules section in the \"uuid\" field between the quotation marks. Save the manifest.json file. Changing the Dirt Block  With the manifest file completed, you can now start adding custom content to Minecraft. Let's get started by applying a new texture to the Vanilla dirt block. The first part of the process involves creating a folder structure to hold the custom texture.  Open the My_RESOURCE_Pack folder and create a folder named textures. Double-click the textures folder to open it. Open the textures folder and create a folder named blocks. Double-click the blocks folder to open it. Create the texture  Now that the folder structure is created, we can start adding some custom textures. This green square is an example of the type of file created using the following steps.  You can download this green block and save it in your blocks folder or follow these steps to create your texture:  Open up an image editor such as MS Paint. Go to the File menu and select Properties. Set the Width and Height to 16 pixels each. Click OK.  You can now design a pattern or any artwork in the editor. To make the green square, a simple fill color was added.   Note  MS Paint is used in this example for quick and easy access, but you will need to use a different graphics editor for more advanced graphic features like transparency effects or .tga file support.  After editing the texture, go to the File menu and select Save As. Choose the PNG picture option. In the Save As dialog box, navigate to the blocks folder. Save the file as dirt.png. Test the pack  Now that the pack has both a manifest file and a texture file, you can launch Minecraft and test your new resource Add-On.   Important  Pack Stacking is how content is loaded on top of Vanilla content, causing each object that has the same name in both packs to be overwritten by the latest applied pack. In our example, the original dirt texture is overwritten by the custom texture.  If another pack that uses the dirt.png file is loaded after My_RESOURCE_Pack, then Minecraft will use that file instead.  Your custom texture will be used on every dirt.png block in the world, but it will not be used on blocks of dirt with grass on them because those blocks have a different name.  Launch Minecraft and select Play. Select Create New World. Under Settings, scroll down to the Add-Ons section. Click on Resource Packs to see all available packs. Click the MY PACKS drop-down. Select My RESOURCE Pack and click Activate to add the resource pack to the world. Click Create.  Troubleshooting  Resource pack woes? Don't worry, troubleshooting is a normal part of any development process.  You can use the sample resource pack on the Minecraft samples GitHub site to check the structure of your resource pack.  Your Resource Pack Does Not Appear in Minecraft  If your resource pack does not appear in the Add-Ons section of a world, the issue may be a malformed manifest.json file. Let's investigate.  Are there two different UUIDs in the manifest.json header and modules section? See the UUID section for more information. Have you turned on file extensions and paths? If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab. Double-check JSON curly braces and brackets. JSON linting tools can help. Resource Pack Shows Up, Content Doesn't Work Check that the textures folder is in the right place, and spelled correctly. Then check the blocks folder as well. Download the Vanilla resource pack and try adding your block to the existing textures/blocks folder. Make sure the new texture file is named the same as the Vanilla texture it's replacing. Move your pack above others to ensure your dirt.png texture is loaded before other resource packs. What's Next?  With a custom texture now a part of your Minecraft world, it's time to see how behavior packs alter existing entity behaviors. In our next tutorial, you will add aggressive behavior to a normally peaceful cow.  Behavior pack  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/makerseriesmakingthegoblinchef", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating a Goblin Chef 05/06/2025  This tutorial is meant to be an inside look at how professional Minecraft creators make something cool from beginning to end. Instead of teaching the basics of creation tools, this tutorial assumes some base knowledge of creating in Minecraft and lets us spend more time talking about creative decisions like color choice or finding the right proportions. The goal is to give you direct insight into how pros think while they are creating, and hopefully you can learn some tips and tricks along the way.  These videos feature Mojang 3D artist Peter Sheff, as he walks you through the creation of a custom Goblin Chef entity. Here, we will take you from the early concept phase of the Chef all the way to it being ready to be placed inside of Minecraft. There are three parts to the tutorial: Part 1 is modeling, part 2 is texturing, and part 3 is animating. These videos are 10-15 minutes each, so feel free to watch each part separately.  Part 1: Modeling  In this video, Peter starts with the fundamentals of creating a new entity. The initial focus is using the 3D shape tools in Blockbench to focus on getting the 3D form of the Goblin Chef just right.  Part 2: Texturing  Now that the basic shape of the chef has been determined, it's time to apply a set of colors and textures to our new friend. Here, Peter focuses on the process of designing your UV textures including tips, tricks, and shortcuts for using various tools within Blockbench.  Part 3: Animating  In the animating section, you'll see how Peter animates the basic parts of the Goblin Chef, adding natural animations to the head, arms, and legs to create a walk cycle. You can see how to adjust the motion of various parts by adding keyframes in the Timeline tool of Blockbench.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsintroduction", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Commands 05/07/2025  Commands are specific instructions that Minecraft: Bedrock Edition will carry out. These instructions can be as simple as changing the time of day or as complex as setting up and working with a scoreboard. There are a wide variety of commands, and each has its own potential to improve your content.  Content creators use commands to change or react to the environment around the player. Rather than having a static world, the player would be able to perform a task that a command system could detect and respond to in some way. An example of this is detecting if a player has placed a colored wool block at a specific location for a \"Complete the Monument\" style of map.  In this tutorial, you'll learn the following:  What commands are and how to begin using them. Command syntax. How to use target selectors and selector parameters. Enabling Commands  Before getting started with commands, cheats must be enabled. This can be done when you create a world or when you edit an existing one. Be aware that enabling cheats will disable achievements for that world.  Activating cheats lets you use commands in the chat interface. Running commands in the chat is essential for getting the first command block in a newly created world, which must also be enabled (in the same menu) in order to use them. Command blocks will be enabled by default, so you do not have to change that option.  While not required, it's helpful to set the default game mode to creative when starting out, as command blocks can only be edited in creative mode. Setting the default game mode to creative will also activate cheats.  Finally, you may need to enable the \"operator commands\" permission for yourself in order to run commands in the chat and access command blocks. While this setting is on by default for new worlds you create, you may need to change this on previously created worlds or for other players you would like to grant this permission to. This can be done by opening the pause menu while in the world and clicking the icon to the right of your player.  A list of various permissions will be shown. The \"operator commands\" permission in particular must be enabled in order to use commands in the chat and access command blocks.  Using the chat for commands  The first step to learning commands is learning how to use the chat functionality. This is where you run simple commands, learn syntax, test, and ultimately open the gateway to command blocks. If your settings and permissions are set correctly, typing a forward slash / in the chat will display a large number of commands.  A quick-action button also becomes available to generate a command for specific situations (such as changing the time of day or the current weather).  As you type, the list of commands displayed on the chat screen will filter to match the characters you input. You can press tab to cycle through the list at any time in order to choose the command to run. When the name of the command has been fully typed out, the list of commands changes to a list of syntaxes for the selected command.   Note  If you open the chat and press the up arrow on your keyboard, you can see the previous commands you've entered. This comes in handy when you're entering variations of the same command over and over. And over.  Command syntax  All commands follow the same grammar:  Start the command with a forward slash (/). Follow the slash with the name of the command. If there are any arguments to the command, they come after the command, separated by spaces.  For example, the /say command sends a message to the chat for all players to see:  Copy /say Hello World  It starts with a forward slash. The command's name is \"say\". Because there are arguments, a space is placed after the name. Then, the only argument for /say is provided, the message to display.  As a result, \"Hello World\" will be printed out in the chat.  Arguments  Different commands need different arguments. The /help command describes both a command and the arguments it takes. The auto-complete feature, which is available in the chat when typing out a command, displays the same information.  For example, typing /help testfor in the chat will provide the available syntax for the /testfor command.  Copy /testfor <victim: target>   The command has only one argument: a target to test for the existence of. Filling in the argument with a player name and running the command will print out a success message if the named player is logged into the world.  Copy /testfor PlayerName   Arguments can be required, optional, or literal.  A required argument is shown in help surrounded by angle brackets, like <this>. In the case of the /testfor command, you can tell that the only argument it has is required. because it is surrounded by angle brackets. If the argument is not provided, the command will fail to run.  Required arguments have a short descriptor of the argument as well as the expected input type. For /testfor, the argument is the victim, and the input type is target: a player name or target selector. Other commands can take different kinds of input values for the same argument, such as /difficulty:  Copy /difficulty <difficulty: Difficulty> /difficulty <difficulty: int>   The /difficulty command sets the world's difficulty level. You can specify it as a Difficulty, the name of a difficulty level such as \"peaceful\", \"easy\", \"normal\", or \"hard\"; you can also specify it as an int, an integer number that corresponds to a difficulty level from 0 to 3. Either of these commands sets the difficulty to hard:  Copy /difficulty hard /difficulty 3   An optional argument is shown surrounded by square brackets, like [this]. Optional arguments don't have to be provided.  Copy /gamemode <gameMode: GameMode> [player: target] /gamemode <gameMode: int> [player: target]   As with the /difficulty command, the /gamemode command has two different ways to do the same thing: you can set the game mode by using the name of a GameMode, or using an integer from 0 to 2 corresponding to a game mode.  The gameMode argument is required, but the command takes an optional argument to specify a player who will have their game mode changed. The input type is \"target\", which accepts either a player name or a target selector. Without supplying the optional argument, the command will still run. Doing so changes the game mode of the player who executed the command. By filling in the optional argument, the game mode of the target will be changed instead.  Either of the following commands will set the game mode for the specified player (\"PlayerName\") to survival mode:  Copy /gamemode survival PlayerName /gamemode 0 PlayerName   A literal argument should be typed exactly as is, and when shown in help, it has no descriptors or value types.  A literal argument that's the first argument to a command generally acts as a subcommand. For example, the /time command has a literal argument called \"set\":  Copy /time set <amount: int> /time set <time: TimeSpec>   Since set is a subcommand, it's not shown in angle brackets, but it's still required.  Copy /time set 6000 /time set noon   A literal argument can have multiple accepted values. In those cases, a vertical bar separates the possible values. The /weather command uses this for the type of weather to apply:  Copy /weather <clear|rain|thunder> [duration: int] /weather rain 10000   An optional literal argument will be shown surrounded by square brackets. The final argument of /testforblocks is an optional literal argument that can be either \"all\" or \"masked\". If none is specified, it defaults to \"all\". The \"masked\" option will cause the comparison to ignore air blocks, allowing any block to exist at the destination where there would be an air block at the source.  Copy /testforblocks <begin: x y z> <end: x y z> <destination: x y z> [masked|all] /testforblocks 0 64 0 20 64 20 100 50 100 /testforblocks 0 64 0 20 64 20 100 50 100 masked  Input types  Any argument that isn't a literal argument will specify the expected input type after the descriptor.  Copy /command <descriptor: type> /command [descriptor: type]   There are a large number of input types. The most common ones are primitive numeric values, but there are many that are exclusive to one command. The table below details the most common input types and some popular commands they belong to. Most unique input types, such as \"GameMode\" from the /gamemode command, can easily have their input checked by using the auto-complete feature in the chat.  Expand table Type\tDescription\tCommon commands Boolean\ttrue or false.\t/effect, /gamerule int\tAn integer (1, 2, 3).\t/give, /scoreboard, /time, /weather, /xp float\tA decimal number (1, 2.3, 4, 5.6).\t/spreadplayers string\tEither a single word or text within \"quotation marks\".\t/scoreboard, /summon, /tag message\tText that does not need to be in quotation marks.\t/me, /msg, /say, /tell, /title, /w x y z\t3 floats separated by spaces to specify coordinates.  Each value can also be a tilde (~), which indicates no change from the execution origin on that axis, or a tilde followed by a number (~5) to indicate the number of blocks away from the execution origin on that axis.\t/clone, /execute, /fill, /setblock, /summon, /teleport, /testforblock Block\tA block ID.\t/clone, /execute, /fill, /setblock, /testforblock Item\tAn item ID.\t/clear, /give, /replaceitem EntityType\tAn entity ID.\t/summon json\tJSON-formatted text.\t/give, /replaceitem, /summon, /tellraw, /titleraw target\tEither a player name or a target selector.\t/clear, /execute, /gamemode, /give, /kill, /replaceitem, /scoreboard, /tag, /teleport, /testfor What's Next?  Now that you've learned about commands, you can learn more about target selectors, commands, or about how to use command blocks to move beyond the chat window.  Target Selectors Popular Commands Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoaddentity", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating New Entity Types 04/16/2025  You can add new entity types to Minecraft: Bedrock Edition using a combination of behavior packs and resource packs. As you learned from the recommended tutorials, the behavior of entity types can be changed with a behavior pack, and you can change the appearance with a resource pack. Both are required to add a new entity type to the game.  This guide has two parts: the first part covers the files and folder structure needed to add a custom entity type to Minecraft. The second part shows you how to breathe life into the entity using behavior components and animations.  In this tutorial you'll learn:  How to create a new custom entity type using behavior and resource packs. How to apply various features to the entity type, including components and animations. Make use of translations for entity names.  It's recommended you complete these before beginning this tutorial:  Introduction to Behavior Packs Introduction to Resource Packs Download the min robot and full robot resource and behavior packs  In addition, it will be helpful if you have a code editor like Visual Studio Code, and if you're familiar with how the JSON format works.  File structure  In the behavior pack, an entity file is responsible for defining the entity on the server side. In the resource pack, a client entity file is responsible for telling the game how the entity will look. The following graphic shows how different files can interact to create a custom entity:  Robot entity example (minimum)  To give you a point of reference for this tutorial, we are providing two versions of the same entity: a robot that can spawn randomly in the world and has three random textures, a wheel animation, various components, and a custom water mechanic. The download link is in the Requirements section above.  To see the robot in action, pick one of the sets of resource and behavior packs you just downloaded. (We recommend trying the minimum one for now.) Put the resource and behavior packs in their respective com.mojang sub-folders, launch a world with cheats enabled, and use /summon sample:robot.  This is the structure of the finished \"minimum robot\" behavior pack and resource pack:  This looks like a lot, but you only have to think about the files with \"robot\" in the name and where they are stored.  After you get an idea how the robot acts in the game, you can remove the finished robot resource and behavior packs and re-create them from scratch with the steps of this tutorial to get an idea how all the files work together.  A good starting point would be to use the resource and behavior packs you created in the earlier tutorials. You might want to remove the attack cow entity, but that's a personal preference.  Naming  When you create an entity, one of the first things to consider is what ID you're going to give it. The files in your resource and behavior packs will need to be synced using the entity ID that you give your entity. This ID consists of a namespace and a name separated by a colon. That was the sample:robot ID we used previously to summon the robot.  Your own namespace can be a short version of your team name or product name. The ID should only include lower case letters, digits, and underscores. Don't use \"minecraft\" as the namespace for your custom content. The \"minecraft\" namespace is reserved for vanilla resources, so you should only use \"minecraft\" if you are overwriting vanilla content.  Most files that define the entity will be JSON files. To avoid confusion, we suggest you follow a standard naming convention as you create each of these files. The game ignores file names in most cases, but when working on an Add-On, messy file names can be confusing. The standard conventions are:  Expand table File Type\tFile Name Client Entity Files\tentity_name.entity.json Model Files\tentity_name.geo.json Animation Files\tentity_name.animation.json Animation Controllers\tentity_name.animation_controllers.json Render Controllers\tentity_name.render_controllers.json  entity_name should be replaced by the name of your entity, not including the namespace.  Format versions  Each JSON file should have a format_version tag. This tag is important for the game to correctly read the file. Files made in older formats will still work in newer versions of the game, but only if the format version is set correctly. Incorrect format versions are a frequent source of errors.  Behavior pack definition  The first step to add a robot into the game starts in the behavior pack. Create a new file in the entities folder of the behavior pack and name it robot.json. Copy and paste in this code.  JSON Copy {     \"format_version\": \"1.12.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"is_spawnable\": true,             \"is_summonable\": true         },         \"components\": {}     } }   Inside the description tag, we define basic attributes of the entity:  identifier sets the ID for the entity. is_spawnable adds a spawn egg into the game that allows the player to spawn this mob. is_summonable makes the entity work with the /summon command.  Inside components, we're going to add components to change the behavior of the entity. For now, we are adding only the minecraft:physics component. This will give the entity gravity and regular collision behavior.  JSON Copy \"components\": {     \"minecraft:physics\": {} }   Save your robot.json file and move on to the next step.  Client entity definition  Now, we need to add the entity to the resource pack to give it a visual appearance. In the entity folder of the resource pack, create a new JSON file called robot.entity.json.  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   This is the basic structure of the file. So far, it's similar to the behavior-side file we made in the previous section. Note that we now use client_entity instead of just entity. At the time of writing this article, 1.10.0 is the latest format version for this file.  The spawn_egg tag defines how the spawn egg will look in the inventory. Using this method, it will look like a vanilla spawn egg, but with customized colors.  Visuals  Before we can add the entity into the game, it needs a model. The Entity Modeling and Animation article explains how to create a custom model and texture, but creating a model is a lot to learn and we're not done with this tutorial yet! So for now, pretend you already created a model by copying and pasting the files from the robot resource pack. Use these same steps later to add the model you create.  Save the model inside the folder models/entity as robot.geo.json. Save the texture in textures/entity as robot.png.  Now that the model files are in place, we need a render controller to link the model, texture, and material that's used for the entity.  Open the robot.entity.json file in the entity folder in your resources pack.  For most entities (such as our robot), we can use the default render controller that's provided by the game. We will talk more about render controllers later in the more advanced part of this tutorial. For now, just know that this is where it goes and this should be the content:  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"materials\": {                 \"default\": \"entity\"             },             \"textures\": {                 \"default\": \"textures/entity/robot\"             },             \"geometry\": {                 \"default\": \"geometry.robot\"             },             \"render_controllers\": [                 \"controller.render.default\"             ],             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   The model is referenced by the geometry name. If you create a model in Blockbench, make sure the geometry name in the project settings is set to your entity name—in this case, \"robot\".  Unlike geometries, textures are linked by their path in the resource pack, minus the file extension, as shown in the example.  In most cases, a custom material is not required. Instead, you can use a default material. In this example, we use entity. If the texture has transparent parts, you can use entity_alphatest, or if your texture is translucent (like stained glass), you can use entity_alphablend.  Translation strings  Right now, neither the entity itself nor the spawn egg has a proper name in game. To define a name, we need a language file.  Create a new folder called texts inside your resource pack and create a new file called en_US.lang. This is the only language file required for custom entities, as it's used as a fallback for translations when strings in other languages aren't available.  Inside this file, add these two lines:  JSON Copy entity.sample:robot.name=Robot item.spawn_egg.entity.sample:robot.name=Spawn Robot   The first line defines the name of the entity. This will be visible in death messages and in the output of some commands. Key and value are always separated by an equals sign. The first line can be broken down into:  entity.<identifier>.name=<Name>  The second line defines the item name of the spawn egg:  item.spawn_egg.entity.<identifier>.name=<Name>  Testing  Make sure to test early and often. Encountering an issue early on helps to simplify tracking it down, which can make it easier to fix. Testing often will reveal issues soon after making changes, which helps to narrow down the cause to those recent changes.  You should be able to spawn your entity in game using the spawn egg or the summon command. If you just want a static entity, you're good to go. But if you want to customize the entity even more, keep on reading.  Robot entity example (full)  Now would be a good time to try the full robot resource and behavior packs. Compare the collection of folders and files. Then, put back your minimal robot packs so we can continue adding functionality.  Components  Components tell the entity how to act in game. Let's add a few components and explain in detail what they do.  In the behavior pack/entities/ folder, open robot.json and replace the single entry of \"minecraft:physics\": {} with all of this:  JSON Copy    \"components\": {         \"minecraft:physics\": {},         \"minecraft:nameable\": {},         \"minecraft:movement\": {             \"value\": 0.25         },         \"minecraft:movement.basic\": {},         \"minecraft:jump.static\": {},         \"minecraft:navigation.walk\": {             \"avoid_water\": true         },         \"minecraft:behavior.tempt\": {             \"priority\": 1,             \"speed_multiplier\": 1.4,             \"items\": [\"diamond\"],             \"within_radius\": 7.0         },         \"minecraft:behavior.random_stroll\":         {             \"priority\": 3,             \"speed_multiplier\": 0.8         },         \"minecraft:experience_reward\": {             \"on_death\": 8         }    }  Expand table Component Name\tDescription minecraft:nameable\tAllows the player to name the entity with a name tag. minecraft:movement\tTells the entity how fast to move. 0.25 is the regular speed of most animals in Minecraft. minecraft:movement.basic\tGives the entity the ability to move on the ground. minecraft:jump.static\tAllows the entity to jump in order to walk up blocks. minecraft:navigation.walk\tAllows the entity to navigate through the world. Avoid water is one of the options that this component comes with. minecraft:behavior.tempt\tMakes the entity follow players who hold diamonds in their hand. We are giving this behavior a higher priority so it will prioritize this action (lower number = higher priority). minecraft:behavior.random_stroll\tWill make the entity randomly walk around the place. We're setting the priority to a higher number so the entity will only do this when it has nothing else to do. The speed multiplier will decrease the speed while using this walk behavior. minecraft:experience_reward\tLets the entity drop experience when killed by a player. Animations  In this section, we'll add a simple wheel animation to the robot. If you want to learn more about animations, how to use animation controllers, and how to create animations in BlockBench, read this guide.  Animations are stored in animation files. So the first thing we need to do is create a folder called animations in the resource pack and create a file called robot.animation.json inside it. In that file, we'll create a new animation called animation.robot.drive. We also want to set loop to true so the animation will keep playing. The file should look like this:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true         }     } }   Animations allow us to animate the position, rotation, and scale of each bone. (If you don't know what \"bone\" means in that context yet, that's okay—you'll learn about bones when you learn Blockbench. For now, just know that it means a chunk of the model, like a leg or a wheel.) Animations can be done with keyframes, Molang expressions, or a combination of both. In this example, we'll just use Molang expressions.  Molang is a language just for resource and behavior packs. It allows us to get various numbers from the entity using a query and calculate a result out of these numbers using math expressions. For example, the query query.modified_distance_moved will return the distance the entity has moved. We can use it to calculate the rotation of the robot wheel on the X-axis, which will result in an animation that makes the robot look like it is driving. You have to play around with the numbers, but for this model 60 worked quite well.  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true,             \"bones\": {                 \"wheel\": {                     \"rotation\":[\"query.modified_distance_moved*60\", 0, 0]                 }             }         }     } }   Now that the animation is created, we need to link it in the client entity file. (Remember, the resource pack is the client, so open <resource pack>/entity/robot.entity.json for this next part.) The animations tag links all animations and animation controllers that are used by the entity. Each animation gets a short name that can be used to play the animation in an animation controller or directly in the file, in this case drive.  The scripts and animate sections can be used to directly play animations:  JSON Copy         \"animations\": {             \"drive\": \"animation.robot.drive\"         },         \"scripts\": {             \"animate\": [\"drive\"]         }   With these two tags added in the description tag of the client entity file, the drive animation will always be active and advance the wheel rotation while the entity is moving.  Render controllers  Render controllers allow us to change the geometry, textures, and materials of the entity using Molang. The following example shows how to use the geometry, material, and texture that have been linked in the client entity file as default:  JSON Copy {     \"format_version\": \"1.8.0\",     \"render_controllers\": {         \"controller.render.robot\": {             \"geometry\": \"Geometry.default\",             \"materials\": [ { \"*\": \"Material.default\" }],             \"textures\": [ \"Texture.default\" ]         }     } }   If we just want to use one default geometry, material, and texture, we can just leave it pointing to the default render controller as we did before. But this is a good time to learn how to add random textures, so let's break down how render controllers work.  One entity file can contain more than one render controller. Each controller goes between the braces in the value of the render_controllers key.  Each controller is named using the scheme controller.render.<entity-name>. Our one controller is named controller.render.robot. For a multi-purpose render controller, we can also use another keyword instead of the entity name.  Inside the render controller tag, the different resources are specified, but you'll notice each one uses a different JSON value.  Geometry  One render controller can display only one geometry at a time, so the geometry key can only be a single string value. This string can be a Molang expression and should always return a geometry. In this case, it's calling Geometry.default, which means that it will return the geometry that's linked as default by whatever entity using the render controller.  You can render multiple geometries on one entity by using multiple render controllers. This can be tricky though, and can lead to unexpected behavior. Therefore, it's only recommended for experienced creators.  Materials  Unlike geometry, the materials value is an array of objects. We can assign each bone a separate material. Each object in the array can have one key-value pair. The key selects a set of bones. An asterisk is used as a wildcard. This means that all bones, no matter the name, will have the default material assigned. Note that materials are assigned in order, meaning that materials further down in the list can overwrite previous materials.  JSON Copy   \"materials\": [     { \"*\": \"Material.default\" },     { \"*_arm\": \"Material.transparent\" }   ],   In this example, we first apply the default material to all bones. Then, we overwrite the material with the transparent material on all bones that end in _arm. That way, all arm bones would support transparency.  Textures  Textures are specified as an array of strings. In most cases, only one texture will be linked here, since entities don't support separate textures. There is one exception: materials can support multiple textures layered on top of each other, such as the material entity_multitexture. For example, this is used by llamas to overlay the décor.  Arrays  When working with multiple resources of one type, it can be useful to use an array. An array is a list of resource links that are defined in the render controller, and that you can pick one resource from using Molang.  We can define an array for the robot like this:  JSON Copy   \"controller.render.robot\": {     \"arrays\": {       \"textures\": {         \"Array.variant\": [           \"Texture.default\",           \"Texture.variant_b\",           \"Texture.variant_c\"         ]       }     }   }   In the arrays section we can define arrays for each of the three categories: textures, materials, and geometries. Inside the category, you can define arrays using Array.<array name> as the name. Each line inside the array links one texture that's defined in the client entity file.  You can access the array using Molang. Arrays are 0-based (that is, the first item is numbered 0, the second 1, and so on), so the first texture in this array can be accessed through Array.variant[0].  In this example, we're using the variant query to pick a texture from the array. The variant of a mob can be changed through the minecraft:variant component in the behavior file.  JSON Copy \"textures\": [ \"Array.variant[ query.variant ]\" ]   Now we need to link the additional textures in the client entity file. The regular, blue robot texture is already linked as default, and we will now create two copies of the robot texture file, edit the color, and link them as variant_b and variant_c.  JSON Copy             \"textures\": {                 \"default\": \"textures/entity/robot\",                 \"variant_b\": \"textures/entity/robot_b\",                 \"variant_c\": \"textures/entity/robot_c\"             },   Now, the textures are linked. The last step is to randomize the variant in the behavior file. We'll use component groups for this. Those are a way to add and remove a set of components from the entity at any time. We'll also use an event that randomizes which component group to add.  JSON Copy         \"description\": {             ...         },         \"components\": {             ...         },         \"component_groups\": {             \"sample:color_0\": {                 \"minecraft:variant\": {\"value\": 0}             },             \"sample:color_1\": {                 \"minecraft:variant\": {\"value\": 1}             },             \"sample:color_2\": {                 \"minecraft:variant\": {\"value\": 2}             }         },         \"events\": {             \"minecraft:entity_spawned\": {                 \"randomize\": [                     {                         \"add\": {                             \"component_groups\": [\"sample:color_0\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_1\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_2\"]                         }                     }                 ]             }         }   Now, when we first spawn the entity, it will randomly choose a component group and therefore a variant. This is a very common technique to randomize the appearance of an entity.  Spawning  Spawn rules define how entities randomly spawn in the world. We'll create a spawn rules file for our robot.  First, create a folder called spawn_rules in your behavior pack. Inside the folder, create a new text file called robot.json. The content of the file should look like this:  JSON Copy {   \"format_version\": \"1.8.0\",   \"minecraft:spawn_rules\": {     \"description\": {       \"identifier\": \"sample:robot\",       \"population_control\": \"animal\"     },   \"conditions\": []   } }   Inside minecraft:spawn_rules, there are two things that we need to consider: population control and conditions.  description defines the basic properties of the file. identifier should match the identifier of our entity. population_control defines how the game knows how many mobs to spawn and is a little more complicated.  Population control  There are different pools of entities. When the pool defined here is considered full, the game will no longer spawn mobs of this pool. There are three different options:  \"animal\": Passive mobs such as cows and pigs \"water_animal\": Water-based mobs such as tropical fish and dolphins \"monster\": Hostile mobs such as skeletons and zombies  For the robot, we're using the animal pool.  Conditions  conditions is an array of possible conditions that allow a mob to spawn in the world. Each of the conditions consists of a group of components that define when and when not to spawn the mob.  For a basic spawn rule, one condition is enough. For the robot, we will use this configuration:  JSON Copy {     \"format_version\": \"1.8.0\",     \"minecraft:spawn_rules\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"population_control\": \"animal\"         },         \"conditions\": [             {                 \"minecraft:spawns_on_surface\": {},                 \"minecraft:brightness_filter\": {                     \"min\": 12,                     \"max\": 15,                     \"adjust_for_weather\": false                 },                 \"minecraft:weight\": {                     \"default\": 40                 },                 \"minecraft:biome_filter\": {                     \"test\": \"has_biome_tag\",                     \"value\": \"animal\"                 }             }         ]     } }  Expand table Component Name\tDescription minecraft:spawns_on_surface\tThe mob spawns on the surface minecraft:brightness_filter\tOnly spawn the entity at a certain brightness. Accepts three options, min, max, and adjust_for_weather. Light levels range from 0 to 15. If adjust_for_weather is set to true, the light level decrease due to rain and thunderstorms will be taken into account. minecraft:weight\tThe weight of the entity in spawning. The higher the number, the more often the mob will spawn. minecraft:biome_filter\tFilters the biome the mob is allowed to spawn in. Biome filters work similarly to filters in behavior, which means that operators like all_of and any_of are allowed. Biomes have different tags that indicate the biome type, variant, dimension, and features like monster and animal.  Robots will now spawn anywhere on the surface where animals can spawn and where there is sufficient light. With a weight of 40, they'll also spawn quite frequently.  Behavior animations  Behavior animations work similarly to regular animations but run in the behavior pack. While regular animations animate the movement of the model as well as sounds and particles, behavior animations can run regular commands, trigger entity events, or run Molang expressions. Behavior animations are also often referred to as Entity Events, although that name tends to be a bit confusing.  Since robots don't like water, we'll add a mechanic to damage robots in water or rain. First, we're going to create an animation controller to test when the entity is in water using a Molang query. Create a new folder in the behavior pack called animation_controllers and create the file robot.animation_controllers.json inside it:  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {     \"controller.animation.robot.in_water\": {       \"states\": {         \"default\": {           \"transitions\": [             {\"in_water\": \"query.is_in_water_or_rain\"}           ]         },         \"in_water\": {           \"transitions\": [             {\"default\": \"query.is_in_water_or_rain == 0\"}           ]         }       }      }   } }   The animation controller looks very similar to regular client-side animation controllers. It has two states that get toggled depending on whether the robot is in water or not.  Now, let's add an animation to give a poison effect to the robot. Create the folder animations inside the behavior pack and create a file called robot.animation.json:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.poison\": {             \"loop\": true,             \"animation_length\": 1,             \"timeline\": {                 \"0.0\": [                     \"/effect @s poison 2 0 true\"                 ]             }         }     } }   Instead of using the bone tag here to animate bones, we're using the timeline tag. In resource packs, timelines can only be used to run Molang code. In behavior animations, you can use this to run Molang code, commands, or trigger entity events. Note that all these are provided as a string. The game will figure out the type of the string from its content. If the string starts with a slash, it will run as a command. If it matches a scheme such as @s namespace:event, it will run as an entity event. If it looks like Molang, it will run as Molang.  For that reason, it's important to start commands with a slash in behavior animations. Also, note that we're applying poison for two seconds because one would not be enough to actually apply damage. The true at the end of the command makes the status effect ambient, meaning that there won't be any particles.  As with animations in resource packs, we need to link all of our animations and animation controllers in the description tag of our entity like this:  JSON Copy   \"description\": {     \"identifier\": \"sample:robot\",      \"is_spawnable\": true,      \"is_summonable\": true,      \"animations\": {         \"poison\": \"animation.robot.poison\",         \"in_water\": \"controller.animation.robot.in_water\"       },       \"scripts\": {         \"animate\": [           \"in_water\"         ]       }   }   The animations section lists all animations and animation controllers that the entity uses and gives them a short name. In the scripts/animate section, we list the animations that should always run. We want the controller to detect the state to always run, but not the poison effect.  Now, we need to go back to the animation controller and add the poison effect. We'll also add a little regeneration mechanic along with a sound effect, so the robot won't die as easily.  JSON Copy   \"states\": {     \"default\": {       \"transitions\": [          {\"in_water\": \"query.is_in_water_or_rain\"}       ]     },     \"in_water\": {       \"animations\": [         \"poison\"       ],       \"on_exit\": [         \"/effect @s regeneration 2 4 true\",         \"/playsound random.fizz @a[r=16]\"       ],           \"transitions\": [         {           \"default\": \"query.is_in_water_or_rain == 0\"         }       ]     }   }   In the animations array, we list all the animations that should be running in this state, which is just poison in our case.  In the on_exit tag, we add two commands that will run when the robot exits the water. The first command will give the robot a regeneration effect level four for two seconds. The second command will play a fizzing sound effect.  Note that we could have also run the command in the on_entry array of the default state, but that would've also played the effects when spawning the robot or reloading the world because the game will always first transition into the default state.  To summarize the relationship between controllers and animations: an animation controller is used to control when an animation plays, while an animation itself is what occurs as a result of transitioning to the animation as determined by the controller. Animations and animation controllers are supplied to the entity behavior file.  What's Next?  In this guide we have added a complete custom entity to the game. If you used the existing model files instead of creating your own, now might be a good time to learn about Blockbench. Or, you can read more about entity behavior for the server.  Entity Modeling and Animation Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createnpcs", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create a Custom NPC 09/20/2023  Non-Player Characters (NPCs) are characters in Minecraft that are not controlled by the player. NPCs can perform commands and deliver dialog when players interact with them, making them excellent tools for creating narrative and gameplay experiences.  In this tutorial, you will learn the following:  How to create an NPC. How to change NPC skins. How to add commands to an NPC. How to add buttons to an NPC. Prequisites  To create NPCs, start in a world with the following settings:  Creative mode Cheats enabled Operator permissions   Note  Later, to interact with your custom NPCs, you will need to switch from Creative mode to either Survival mode or Adventure mode.  Spawn an NPC  To obtain a custom NPC, follow these instructions:  Get an NPC spawn egg from the creative menu or by using the command /give @p spawn_egg 1 51. Right-click to place an NPC on your desired block. If you misplace an NPC, you can left-click to despawn them. Right-click the NPC to open the NPC interface. Enter a name for your NPC. Names are limited to 32 characters. You can use color codes to change the color of the name text.  The NPC editor has a built in dialog feature to give players more information about the commands they will execute or to deliver story details.  This dialog box has a limit of 307 characters before the text goes off the screen. You can also use color codes to change the color of the text.  You can use behavior packs and commands to create a more advanced dialogue system for your custom NPCs. See NPC Dialogue Command for more information.  Change NPC skins  You can choose from a list of skins to customize the appearance of your NPC.  To change an NPC's skin, follow these instructions:  Right-click the NPC you want to edit. In the Appearance section, click the skin that you want to use for your NPC. You can use the left and right arrow buttons to see more skins. Add commands to an NPC  You can add commands to an NPC that the NPC will execute after a player closes their dialog window. Unlike a Command Block, a single NPC can execute multiple commands.  To add commands to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. If you want to add more commands, click the Add Command button and enter the commands you want to enter.  Your NPC will execute these commands in order whenever a player interacts with them and closes their dialog box. There is more information about commands in the Introduction to Commands article.  Advanced Command Settings  There are settings to customize the way commands work with NPCs.  Button Mode  If Button Mode is toggled on, a text box appears where you can enter text that will appear on a button. This command will only run if the button is pressed.  For example, we could use a combination of the command /give @p gold_ingot and a button labelled Money? When players click the Money? button, they receive one gold ingot into their inventory.  On Enter  If On Enter is toggled, then the command will run when players initiate a conversation with the NPC.  In this case, with On Enter toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box opens on dialogue initiation with the NPC.  On Exit  If On Exit is toggled, then the command will trigger when the player ends and interaction and closes the NPC dialogue.  In this case, with On Exit toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box closes and the NPC interaction ends.  Add buttons to an NPC  You can also add buttons to an NPC. If you use the Button Mode setting, an NPC command will be displayed as a button in the NPC's dialog box. Players who interact with that NPC can click the appropriate button to execute that command.  To add buttons to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. Activate Button Mode and enter the button text in the new field.  If you want to add more buttons, click the Add Command button and repeat this process.  Once you have added your button commands, your NPC will display the command buttons in order after their dialog when players interact with them.  What's Next?  With the NPC created and the first dialogue box has been created, you can learn how to create branching dialogue boxes to design your own custom narrative driven content.  NPC Dialogue Command  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoloottables", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Loot Tables 03/06/2025  When you do something fun and get rewarded with loot in Minecraft, a loot table was involved.  With just a few lines of JSON, loot tables control what you find when you break a block, open a newly discovered chest, interact with an entity, and use differently enchanted items in typical gameplay.  Loot table files live in a directory (cleverly named loot_tables) at the root level of a behavior pack.  The five categories of loot tables in Vanilla Minecraft are blocks, chests, entities, equipment, and gameplay (such as fishing, milking a mooshroom, or watching your sniffer find seeds).  If you have more than one type of loot table in your behavior pack, it would be a good idea to put each type in its own subfolder. But this is not required.  A loot table file generally consists of three main sections collectively known as a \"pool.\" As a creator, you might want to have different pools so you can drop different loot to your players if they satisfy different loot table conditions.  Rolls Rolls dictate how many times the pool will be rolled to select an entry. This could be either an integer which will result in a set amount of rolls or a min/max range from which the number of rolls can be chosen. Loot Table Conditions These are optional requirements that must be met for the pool to be rolled. Some of the more interesting functions you might want in your gameplay include setting the lore on an item (set_lore) and putting your own content into a book (set_book_contents). Entries This is a list of objects the game will select from in this roll. It can be an item, a loot_table, or empty if you want a chance of nothing happening this roll.  As an example, here is the loot table for when you have a pet cat and it brings you a gift in the morning:  JSON Copy {   \"pools\": [     {       \"rolls\": 1,       \"entries\": [         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_hide\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_foot\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:chicken\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:feather\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rotten_flesh\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:string\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:phantom_membrane\",           \"weight\": 2         }       ]     }   ] }   As you can see, getting a phantom membrane is rarer than getting a bit of string or a chicken. Imagine a cat bringing down a phantom! Now you know why they avoid cats...  What's Next?  We suggest taking a look at loot table functions next, followed by conditions, then loot overloads. Once you've gotten comfortable with all of the intricacies of those topics, jump into the tutorial and create your own loot table!  Loot and Trade Table Functions Loot Table Conditions Loot Table Overloads Creating a Loot Table  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxgettingstarted", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Ray Tracing 06/11/2025   Tip  While ray tracing is still supported, it's largely been superseded by Vibrant Visuals.  Minecraft: Bedrock Edition has cutting-edge path-traced ray tracing, enabling gamers and world builders to craft incredible new sights and immersive environments. Physically-based textures have been introduced for creating more complex and realistic (or fabulously unrealistic!) block textures. To further enhance the visual experience of RTX, creators can also define their own settings for fog via resource packs.  With these new features, creators can dramatically change the look and feel of the game. Immerse players in volumetric fog or use a cutting-edge, dynamic lighting system to make a world more vibrant.   Ray Tracing Off with Physically-Based Textures   Ray Tracing On with Physically-Based Textures  By the end of this series, you will learn:  How ray tracing can be used Minecraft. How to enable ray tracing in Minecraft. How to create a physically-based texture resource pack. Requirements  It's recommended that you have the following when working with ray tracing in Minecraft: Bedrock Edition:  Operating System (OS): Windows 64-bit GPU: DirectX hardware ray tracing capable GPU like NVIDIA GeForce® RTX 20 Series and higher, and AMD Radeon RX 6000 Series and higher Hardware: PC CPU: Intel Core i5 or equivalent RAM: At least 8 GB of RAM Minecraft: version 1.16.200 or higher   Important  Virtual Reality (VR) headsets and Mixed Reality (MR) headsets are not supported.  Ray Tracing Examples in Minecraft  Ray tracing makes Minecraft look more like the real world. Rays of light shine from different sources onto block textures that can reflect, absorb, and scatter light in different ways. The result is a highly realistic depiction of the way light behaves, creating dramatic effects.  Expand table Features\tExample Sunbeams and atmospherics - Directional shafts of light typically occur at sunrise and sunset when sunlight passes through particles in the atmosphere or underwater.\t Dynamic shadows - More realistic shadows that change as lighting conditions change.\t Ambient Occlusion - shadows cast in corners or crevices where light rays cannot escape\t Reflections - Light bounces off surfaces, both casting and picking up color as it travels. Bouncing light hits smooth surfaces and maintains a spread depending on the material. This can create diffuse reflections or very sharp ones.\t Refraction - As light passes through translucent materials, it bends and bounces. The image you see may be distorted, refracted, and its color will be affected by the translucent material.\t Explore a Ray Tracing World in Minecraft  If you meet the minimum requirements and you are on the Windows version of the game, you can check out a ray tracing world now. Many free worlds featuring PBR and ray tracing are available in the Minecraft Marketplace, with more to come. You can find all the content supporting ray tracing in the Marketplace by selecting the blue icon.  Next, we will create PBR textures as a resource pack and you can enable it in the downloaded ray tracing world.  What's Next? Introduction to Physically Based Rendering  You will learn about each new texture map creators can use to build and design photorealistic materials and lighting effects, and you will learn how to use texture maps to create a mirror in-game.  Introduction to Physically Based Rendering  Fog in Resources  Along with ray tracing, fog in Minecraft has been updated to use a similar JSON structure that allows you to create and control its in-game appearance.  Fog in Resource Packs  Feedback  Was this page helpful?  Yes No Additional resources  Documentation  Physically Based Rendering Tutorial  A guide to creating textures using RTX Physically Based Rendering with Adobe Photoshop  Fog in Resource Packs  A guide detailing the way in which fogs are established in resource packs  Actor Storage in Minecraft - Bedrock Edition  How actor data is organized in the LevelDB on disk  Show 3 more  Training  Learning path  Get Started with Azure Remote Rendering - Training  Learn the fundamentals of rendering 3D models with Azure Remote Rendering."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontostructureblocks", "text": "Learn  Minecraft Bedrock Edition  Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gametestgettingstarted", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to the GameTest Framework 06/20/2024  GameTest Framework is a toolset available to creators to build and test any new content created by you. Within the world of Minecraft: Bedrock Edition, you can express infinite forms of gameplay and variability in your content. With all these creative possibilities, sometimes you may need additional tools to help validate that your experiences are running just as you expect it, and assist you as you customize aspects of the broader Minecraft environment.  What happens if you change the behavior of Villagers? Or introduce a new Mob? Small changes can have unexpectedly big impacts that can be really hard to anticipate. With the GameTest Framework - a system for establishing sets of tests - you can track and repeat to ensure everything works the way you intend.  With these tests, you can express and document your expectations for how things should work - both for your content and games, and for the Minecraft world. You'll be able to save time by using GameTests to take the place of repeatedly needing to manually play through conditions just to validate that all is working as expected.  Submitting and using GameTests can be a great way to establish and communicate the expected behavior you are looking for. As you build more complex worlds and adventures, use the GameTest Framework as a tool to validate facets of your content.  Requirements  To get started, you'll want to begin with understanding how a behavior pack works within Minecraft. To read more about creating behavior packs, see this topic:  Introduction To Behavior Packs What's a GameTest?  A GameTest is a miniature environment along with a set of starting conditions, such as a set of mobs or items. After that environment plays out in the Minecraft world for a period of time, a GameTest has conditional code that evaluates whether expected conditions were met. If a test passes, you will receive confirmation that everything is working as expected. When a test fails, you can observe and diagnose why it may have failed.  Let's examine a potential use case for a GameTest. Let's say that we want to validate that a minecart can make its way around curves and over a complex track when Redstone triggers it. We can build a GameTest for this case by building out a track, placing a minecart at the start of the track, and then power the track with a block of Redstone. We can then validate that the minecart reaches the end of its track within a reasonable time-frame. Minecraft includes a growing set of GameTests that test various basic situations in the Minecraft world. However, you can build your own GameTests to validate any changes you introduce.  Running tests within game  To run tests within a game, you'll want to create a new world or start with a copy of your existing adventure and experience.  Within this GameTest world, you'll want to ensure that cheats are enabled and that the Beta APIs experiment is turned on. If you've created GameTest Framework tests within behavior packs, you'll want to add those behavior packs in your world. You can see an example set of gametests available at https://github.com/microsoft/minecraft-gametests. You'll want to download this pack of gametests, copy them into your developer_behavior_packs folder in Minecraft, and then create a world that uses this behavior pack.   Important  You'll also likely want to specify some additional changes in your environment:  Selecting a Creative game mode Selecting a Flat world You will want to retain Normal difficulty (mobs work differently compared to Peaceful worlds)  Once the world is loaded, use the /gametest command to run tests.  To run the default set of tests, use /gametest runset.  What's Next?  Building sets of GameTests requires building out your GameTests via a behavior pack, and writing some simple JavaScript code. When building out your own tests, you will likely want to start a new test behavior pack that is just focused on adding additional GameTests.  Build your first GameTest  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commonlyusedtools", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Commonly Used Tools 06/27/2024  There are a wide variety of tools that have been created for the purpose of increasing the efficiency of Minecraft content creation. Tools can help with a variety of things from creating skins, to crafting beautiful custom worlds. This article will explore some of the most commonly used tools currently available and some of their uses.   Important  These tools are provided by external, third-party contributors and are not Mojang/Microsoft offerings. Users should use at their own discretion.  Creating maps  Map creation is one of the largest and most time-consuming components of content creation. That being said, there are a significant number of map creation tools available to make this process significantly more efficient.  Chunker  Chunker is a Java-based tool for Minecraft: Bedrock Edition worlds. It's specifically useful for converting worlds between Minecraft: Java Edition and Bedrock Edition, as well as easily configuring world settings. Conversion includes level settings, chunk data (such as blocks and biomes), dimensions, and more. To learn more about using Chunker, you can begin with the Chunker Overview guide, which goes over the steps needed to do simple conversions and leads to more advanced features of the tool.  Amulet  Amulet is a utility tool designed to edit Minecraft maps. It can come in handy for world development, having helpful abilities such as replacing blocks in a selected area and the ability to create and remove chunks within a world. There's also a massive variety of community-made custom plugins referred to as \"operations\" that allow creators to perform a wide variety of tasks. Included below is a list of operations that can be useful for map creation:  Abrightmore's Amulet operations PREMIEREHELL's Amulet operations StealthyExpert's Amulet operations 5uso's Amulet operations Image Map  Image Map is a small application for both Bedrock Edition and Java Edition that can convert images to Minecraft maps. This can be used to add custom banners and art inside of Minecraft worlds.  Server Based Tools  Many commonly used tools are designed to be used on Java Edition servers utilizing a server software known as Spigot, which is based on the Craftbukkit API. The following tools are plugins that work on servers running this software.  Fast Async WorldEdit (FAWE)  WorldEdit is an in-game Minecraft map editor for Java Edition. It allows creators to perform a wide range of build-related commands, as well as utilize brushes that help sculpt Minecraft worlds. Some notable features include the ability to copy and paste selected areas, as well as rotate selected areas to face a different direction. This is especially useful when creating large builds with lots of repeating patterns. Linked here is the Fast Async WorldEdit project, a spinoff that includes some big performance boosts from the original WorldEdit, as well as some useful features for creative builders.  Voxel Sniper Flattened  Voxel Sniper Flattened is another in-game Minecraft map editor for Java Edition. It allows creators to edit any block in sight using an arrow (for replacing blocks) and gunpowder (for adding blocks). It contains a wide array of brushes that can be used for anything from precise block placements to large terraforming jobs. This plugin is a continuation of the original VoxelSniper.  goBrush  goBrush is a server plugin for Java Edition that adds in-game tools designed for custom terrain editing by using heightmap brushes instead of geometric shapes like tools such as WorldEdit and Voxel Sniper Flattened.  goPaint  goPaint is a server plugin for Java Edition that allows creators to efficiently \"paint\" blocks with a variety of brush shapes.  Creating Models and Visuals Blockbench  Blockbench is a free entity-modeling application for creating working Bedrock Edition entity models, as well as creating textures and the ability to animate them for Bedrock Edition maps. Blockbench has external plugin support, enabling developers to create additional tools to use within the program. It also has the ability to export models into a standard OBJ format, Java Edition block model, and more.  Snowstorm  Snowstorm is a small application for Bedrock Edition created by the developer of Blockbench that can be used to create custom particle effects that are usable in-game. To get started with Snowstorm, visit a tutorial on building particle effects with Snowstorm.  Project and JSON Definition Editing Blockception VSCode Extension  An extension that provides support for files such as .mcfunction, .json and .lang. This extension adds features like completion, validations, formatters, diagnostics, cheat-sheets, code-actions, generation of files, and development tools to help develop Minecraft: Bedrock Edition Addons or Minecraft Education. It's recommended that you use the Dark+ theme for the best color highlighting.  bridge.  bridge. is a light-weight, dedicated editor for Minecraft Add-Ons that makes it easy to get started with Add-Ons and later scales with your growing needs. It requires zero setup and provides you with an instantly bootable development environment with syntax highlighting, code completions and file diagnostics all designed to make developing Minecraft Add-Ons more convenient. To read more, please refer to bridge.'s getting started guide or learn more about why you should use bridge.  bridge. is open source and freely available to all Add-On creators on desktop and mobile platforms.  Minecraft Creator Tools  Minecraft Creator Tools is both a website and an NPM-based command line tool that you can use to start or extend your Minecraft projects. It also includes validators to help find and point out potential issues in the project.  Minecraft Creator Tools is also open source and available on GitHub.  NPC DialogueDesigner  DialogueDesigner is a Web application for Bedrock Edition created by the developer of Blockbench and Snowstorm that can be used to create NPC dialogues, as shown in this handy tutorial: NPC DialogueDesigner.  Creating Skins and Resource Packs  Skin and resource pack creation can be done primarily within any image-editing software, but there are also a few helpful applications that can make this process easier.  Blockbench  Blockbench has a skin editor that allows skins to be edited in 3D (or 2D) with Blockbench's advanced paint tools such as mirror painting and color palettes. It has presets to create entity textures for resource packs as well.  Skins can be packaged for the Marketplace using the Skin Pack Packager plugin in Blockbench.  PMCSkin3D  PMCSkin3D is a web-based dedicated skin editor from PlanetMinecraft. It has a 3D and 2D as well as split-screen mode and advanced brush options. There is also a lite edition with simplified tools.  Aseprite  Aseprite is a purchasable art application designed with pixel-art in mind. It contains many tools that can help make skin and resource pack creation easier. Aseprite also has significant documentation and tutorials to help artists of all skill levels use the application effectively.  McSkin3d  McSkin3D is software designed entirely with skin creation in mind. It has many features such as a built-in skin viewer that can be directly painted on and a split view showing both the skin in 3D alongside its 2D texture.  LookatMySkin  LookatMySkin is a skin previewer that allows you to edit a skin in your program of choice and instantly see it previewed on a 3D player model. It has a variety of features, such as limb posing, zoom, and adjustable background color. This can also be useful for taking screenshots of skins or quickly checking skins for oddities when posed in different ways.  What's Next?  While there are many more tools that exist and are constantly being created to make Minecraft content creation easier, this is a great place to start. Creators should check back here often for newly added content and take advantage of all the available tools at their disposal.  Some of these tools allow you to modify NBT data. Learning about NBT and especially learning what not to do when editing it will save you from a world of trouble.  Editing NBT safely  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/differencesbetweenbedrockandjava", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Differences Between Minecraft: Bedrock Edition and Minecraft: Java Edition 05/21/2025  We love all forms of Minecraft equally, but loving them equally doesn't mean they're identical. As a creator, it's important to know as much as you can about the differences between the flavors of Minecraft. So, we're going to review some of the major differences between Minecraft: Java Edition and Minecraft: Bedrock Edition, and what they may mean for you as a creator.  A brief history of Minecraft  Minecraft: Java Edition is the current iteration of the original version, released in 2009 (simply as \"Minecraft\"). Minecraft: Bedrock Edition started as Minecraft: Pocket Edition with an alpha release in 2011, and remained in alpha until its full release in 2016. In 2017, with version 1.2.0, Pocket Edition officially became Minecraft: Bedrock Edition, unifying the various non-Java releases across platforms. Currently, both versions are active and have broad, passionate audiences. For clarity, we'll refer to the versions as \"Java\" and \"Bedrock\" respectively.  World format  A major difference between Java and Bedrock is the world format. Bedrock uses the LevelDB format for world storage, while Java uses the Anvil format. Due to this, most third-party tools created for editing a world will only work in the version for which it was created.  The two versions also use a fairly different block format. Java has flattened its block format using a unique string for individual blocks, and stores the state of that block separately. Similarly, Bedrock uses a string-based system with block states, while some blocks are grouped together by data value. Because of this, blocks are named differently between the versions. For example, granite is defined as stone 1 in Bedrock, while in Java it's referred to as granite.  Commands and redstone  Bedrock and Java have different structures and implementation of commands. Bedrock's command structure is similar to the system used in versions of Java up to 1.13. It also uses a component-based system for commands instead of raw JSON strings. Instead of using JSON strings to customize entities, you can summon an entity with an event to fire and name it in a single command.  There are also differences per version in the way that redstone works, and while the majority of redstone circuits work well between versions, more complex circuits may not work as well in Bedrock. This is because Bedrock doesn't support quasi-connectivity, while Java does. Systems that use mechanics such as Block Update Detector (BUD) switches won't work the same way in Bedrock. Pistons require one tick to retract, and won't leave blocks behind if given a one-tick pulse. Additionally, the way updates happen is slightly different.  Resource packs  The idea behind resource packs is the same in both editions: change how various aspects of the game look. The capabilities and layout of resource packs are very different depending on the version, however. To get into the details of how things work in Bedrock, take a look at our Introduction to Resource Packs (as an added bonus, you'll learn how to change the look of grass blocks in your world!).  Behavior packs  Bedrock's behavior packs are equivalent to Java's data packs. While they share some similarities, the differences are significant. For example:  To animate textures, Bedrock uses a single file called flipbook_textures.json, while Java uses individual .mcmeta files for each texture. Java can create custom fonts and GLSL shaders, while Bedrock cannot. Bedrock can create custom particles and fogs, while Java cannot. Controls  Currently, both versions of Minecraft support mouse and keyboard controls, but only Bedrock has controller support. Additionally, depending on the hardware used to access Bedrock, there is a significant chance that users may be using touch controls. This becomes an important consideration when determining which type of content to create for each version.  Crossplay  Java is currently available on Windows, Mac, and Linux PCs, meaning that any content you create will be played by users on a computer. Bedrock is available for Windows PCs, consoles, and mobile devices. This means that players in the same world may be having vastly different experiences depending upon the devices they are using. For additional guidance on designing your content for users on varied devices, check out Designing Gameplay for Various Devices.  Next steps  If you're entering the world of Bedrock creation, your next stop should be our add-on concept articles. Here are some excellent follow-up articles for your review:  Getting Started with Add-Ons Comprehensive List of Add-On Pack Contents  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/redstoneguide", "text": "Learn  Minecraft Bedrock Edition  Ask Learn A Guide to Redstone 09/20/2023  This guide is intended to show you some basic ways to use redstone components so that you might feel inspired to try your own projects and feel more prepared to go learn from other redstone creators.  In this tutorial you will learn the following:  Basic redstone components and how they work. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction to Commands  This guide assumes that you know how to make a flat, creative-mode world and how to give yourself the things you need, like redstone dust and pistons.  Redstone Fundamentals  What is redstone? Redstone is kind of like electrical circuits within Minecraft. As with electrical circuits, it's possible to build incredibly sophisticated machines based on the combination of simple connections and switches among components.  Using redstone torches, redstone blocks, and redstone dust  You can power most redstone devices, like a redstone lamp, by putting a redstone torch on an adjacent block.  Putting the torch on the lamp itself will not power it.  Placing a redstone block on the lamp will power it.  Redstone dust acts like a conduit between a power source and a component. As the power signal travels farther from the power source, it gets weaker at a predictable rate. The redstone signal coming out of a power source starts at 15 and decreases by 1 for each block the line of redstone dust is extended.  Let's do an experiment to test this:  Give yourself redstone dust and a redstone torch.  Place one handful of redstone dust dust on the ground. It makes a dark red blob.  Place a redstone torch next to the blob. The redstone blob will glow and align itself to point towards the torch. Neat!  Place more redstone dust to continue the line in one direction. Notice that the glow gets fainter as you get farther from the torch.  Extend the line at least 15 blocks.  Give yourself a piston and place it anywhere around the dark end of the redstone line. The pistons won't do anything if the signal is too weak to make the redstone touching the piston glow.  Place another piston next to the glowing part of the redstone. It should extend.  You could also add another redstone torch to boost the power.  Random redstone dust, torch, and block facts, in no particular order A blob of redstone dust will power all the blocks around it and the block it is placed on. Redstone blocks and redstone torches each have a signal strength of 15. Power radiates out from a redstone torch in all directions, as shown in this grid that is powered by one redstone torch.  A redstone torch powers the block above it, takes redstone signal from it, and powers all adjacent redstone components including above and below the torch.  A redstone torch will not power the is block it is placed on. Placing a redstone torch on a powered block will deactivate the block.  The redstone torch or redstone block must be next to or below the piston to power it. Placing the torch or block in front of the piston will not power it.  Redstone torches don't power the block they're on. For example, putting a redstone torch on top of a piston will not power it, but placing a redstone block on top of a piston will power it.  A redstone torch can be deactivated by powering the block it is placed on.  Power from a redstone torch is continuous. Power can also travel in pulses called \"ticks\" and there are ways to vary the rate.  Time Tick and Redstone Tick  In Minecraft, the term for time passing is \"ticks\" and time passes at 20 ticks per second. Redstone signals pass at the rate of 10 ticks per second. By controlling the speed of the ticks, you can control the speed at which a component does something. So, as you experiment with how different components are powered, keep in mind that the power does not have to be continuous.  Components that emit redstone power  These are things that can power redstone components even though there is no redstone in their recipes.  Button: press to get a short pulse of power. Lever: toggles full signal strength on or off. Pressure plate, wood or stone: sends a pulse of power when you press or step on it. They can be activated by mobs stepping on them, too. Different mobs may activate the pressure plates at different strengths. For example, the signal strength emitted when a creeper steps on the plate is lower than the strength emitted when an iron golem steps on it. When the player or mob leaves the plate, it will deactivate after 5 redstone ticks. A wooden pressure plate also activates if an item is dropped on it. Weighted pressure plate, iron (\"heavy\") or gold (\"light\"): signal strength grows as the number of entities (players, mobs, or items) on top of it increases. Light plate requires fewer items for maximum signal strength than heavy plate needs. Tripwire: emits signal strength when wire is activated (tripped). Lectern with a book on it: emits a pulse of power as you turn the pages. Common redstone components  Piston and sticky piston: These stay extended for as long as they are powered. A piston can push up to 12 blocks. Sticky pistons can pull the block stuck to it back again. Pistons take one tick to extend, zero ticks to retract.  Repeater: Place along a line of redstone dust to continue the signal. As long as a signal strength of 1 or higher is going into the repeater, it will output the maximum level of 15. Redstone repeaters only power the dust or component directly in front of them. They have a built-in delay of 1 tick and can be toggled to extend the delay to 4 ticks. If the input pulse delay is shorter than the delay toggled on the repeater, it will extend the pulse. For example, if you route a 1-tick pulse into a 4-tick repeater, the pulse gets extended to 4 ticks.  Comparator: Unlike a repeater, the comparator outputs the same signal strength that comes into the back of it. Comparators also take in a signal running into the side and compare it to the strength of the signal coming into the back. In normal mode (when the light is NOT switched on) then it will not output a signal if the strength of the signal running into the side is stronger than the signal strength running into the back. If the redstone comparator is in subtract mode (meaning the light is on), it will subtract the signal strength that comes into the side from the signal strength that comes into the back and output the result. So, if a signal strength of 10 is running through a comparator that is in subtract mode (light ON) and we put in a signal strength of 7, the it will output a signal strength of 3.  (Remember, the signal starts at 15 and then goes down by one for each segment of redstone dust.)  Daylight sensor: Produces different levels of power depending on the level of light it detects. It can be inverted to emit light when it detects darkness. To invert it, place one and right-click on it. It will turn blue.  Dropper: Spits out a random item from its inventory when powered directly or powered by an adjacent block. For example, if loaded with a horse spawn egg, when activated, it drops a horse spawn egg. If loaded with arrows, it spits out an arrow.  Dispenser: Works like the dropper, but has special powers depending on what items are loaded into it. For example, if it is loaded with a horse spawn egg, it dispenses a horse. If loaded with arrows, it will fire the arrow. Other items with special behavior include armor stands, boats, bone meal, potions, and buckets.  Observer: When it detects block updates with its face, it sends a one-tick pulse through the red spot on the back. Observers will emit a pulse when they are moved by pistons.  Trapped chest: Activates when opened. Signal varies according to how many players are viewing the contents.  Noteblock: Plays a note when it receives a signal.  Redstone lamp: Produces light when powered.  TNT: Activates when powered directly or by an adjacent powered block. Fuse time is 40 redstone ticks.  What's Next?  Now that you know more about redstone, you could use it to enhance a \"Complete the Monument\" map.  Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/packagingaskinpack", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Packaging a Skin Pack 12/15/2023  Skin packs are some of the most popular content available, offering players multiple looks for their avatars and fundamentally changing the feel of their gameplay experience. Creating a skin pack is not only a great way to offer something new to players, it's also a lot of fun both technically and artistically!  In this guide you will learn:  The folder and file structure for skin packs in Minecraft: Bedrock Edition. How to construct the necessary metadata files for a skin pack and how to define skins using them. Skin Pack Folder Structure  manifest.json  A manifest tells Minecraft general information about your skin pack. Create a JSON file named manifest.json at the root of the skin pack. Within it contains the following:  name: the name of the pack, which is always pack.name. version: the version of the pack. For example, [1, 0 ,0] would indicate version 1.0.0. uuid: a unique identifier to prevent package conflicts, which can be generated from this site: https://www.uuidgenerator.net/version4 (two different UUIDs need to be generated). type: set to skin_pack to tell the game to treat this pack as a skin pack. Template manifest.json JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 1 }  skins.json  A skins.json file will define the skins that come with your skin pack. Create a JSON file named skins.json at the root of the skin pack. Within it contains the following:  localization_name and serialize_name: these will be the same and are the localization keys whose value will be defined later in en_US.lang with the full key being skinpack.<localization_name>. That value will be the title of the pack. The key will also always be prepended to each individual skin's localization key. skins: a collection of definitions, each defining a single skin.  Each individual skin definition will then contain the following:  localization_name: the localization key whose value is defined later in en_US.lang. The value will be the name of the individual skin. geometry: the base model this skin is for. geometry.humanoid.customSlim is the Alex model and geometry.humanoid.custom is the Steve model. texture: the file name for each of the skin textures as they appear in the root of the skin pack. type: either free or paid. Template skins.json   Note  Unfortunately, it's not possible to add custom models to skin packs at this time using the skin pack JSON capability.  JSON Copy {   \"serialize_name\": \"TemplateSkinPack\",   \"localization_name\": \"TemplateSkinPack\",   \"skins\": [     {       \"localization_name\": \"TemplateSkin1\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name1.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin2\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name2.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin3\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name3.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin4\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name4.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin5\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name5.png\",       \"type\": \"paid\"     }   ] }  Skin Textures  The actual skin textures are PNGs. The file names are referred to in the skins.json metadata file. They can be used only at the root of the skin pack. You can use Blockbench to create a usable skin PNG for your skin pack.  Texts Folder  Inside this folder are the en_US.lang and languages.json files, which define the actual names of your pack and skins and the supported languages of your pack. The names after the = are what show up in-game, such as in the skin picker.  en_US.lang  This is the file where you name your pack and the skins.  Pack name: skinpack.[skins.json localization_name]=[name of pack] Skin names: skin.[skins.json localization_name].[skins.json single skin localization_name]=[name of skin]  The below template uses the \"localization keys\" from the template skin.json to name the pack \"Your Skin Pack Name Here\" and to name the individual skins \"Skin Name 1-5\".  Template en_US.lang JSON Copy skinpack.TemplateSkinPack=Your Skin Pack Name Here skin.TemplateSkinPack.TemplateSkin1=Skin Name 1 skin.TemplateSkinPack.TemplateSkin2=Skin Name 2 skin.TemplateSkinPack.TemplateSkin3=Skin Name 3 skin.TemplateSkinPack.TemplateSkin4=Skin Name 4 skin.TemplateSkinPack.TemplateSkin5=Skin Name 5  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/actorstorage", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Actor Storage in Minecraft: Bedrock Edition 09/08/2023  Minecraft has inspired many third parties to create useful world file viewing and editing tools that exist outside the client. Tools like the Universal Minecraft Editor and MCEdit are community favorites and are dependent upon knowing where to find each piece of the level's data on disk in the LevelDB files. With the upgrade from legacy actor storage to modern actor storage in 1.18.20, the locations in the LevelDB files which the data for actors (entities) is stored has changed and these third party developers need to be aware.  What did legacy actor data look like?  Before version 1.18.30, actor data was stored per chunk as a blob of all actors in that chunk. This meant that whenever a single actor changed, we would:  Collect the data from every individual actor in the chunk Append the data for each actor into a single buffer/blob Write that grouped data to the chunk Why are we moving actor data?  The legacy actor data storage format meant if one actor in a chunk is changed you have to save them all, even if only one actually changed. This resulted in a lot of unnecessary operations and made handling the transfer of entities between chunks an expensive and fragile system.  How is modern actor data stored on disk?  Modern actor storage moves to storing each Actor under a unique individual LevelDB key. This enables us to have save operations that act only in individual actors. This also means that there is no key-value pair for all actors in a chunk. In fact the individual actor keys are separated into their own key space from the rest of chunk data and chunks do not have data on disk directly referencing actors they contain.  Instead, we use data from the chunk to deterministically generate a key that is unique to the chunk in which we store a digest of the LevelDB keys for the Actors in the chunk. These digest entries are also separated from the non-actor chunk data and the actor key space.  Let's take a look at how this appears on disk:  Chunk Key Space  On the left of the diagram, we can see the chunk key space. These keys take the legacy chunk key form of <Chunk Position><DimensionID>. There is a very old legacy chunk format in which there is no dimension ID, so it is possible to load a really old world in which chunk keys do not have a dimension ID. They will be saved out under a new key with the dimension ID. This is old behavior that still exists.  These are the smallest keys used by pushing them together contiguously on disk. The chunk key is used as a prefix for keys which store all non-actor data from the chunk. Each type of data from the chunk has its own key ID that is appended to the chunk key prefix.  Non-Actor Data Chunk Key IDs C++ Copy enum class LevelChunkTag : char {   Data3D = 43,   Version, // This was moved to the front as needed for the extended heights feature. Old chunks will not have this data.   Data2D,   Data2DLegacy,   SubChunkPrefix,   LegacyTerrain,   BlockEntity,   Entity,   PendingTicks,   LegacyBlockExtraData,   BiomeState,   FinalizedState,   ConversionData, // data that the converter provides, that are used at runtime for things like blending   BorderBlocks,   HardcodedSpawners,   RandomTicks,   CheckSums,   GenerationSeed,   GeneratedPreCavesAndCliffsBlending = 61, // not used, DON'T REMOVE   BlendingBiomeHeight = 62, // not used, DON'T REMOVE   MetaDataHash,   BlendingData,   ActorDigestVersion,   LegacyVersion = 118, };    Actor Digest Key Space  In the middle, we have the digest key space. Each digest key takes the form digp<Chunk Key>.  digp is a hardcoded prefix for all digest keys. This forces all digests to be contiguous on disk and increases the size of all digest keys such that they are placed ahead of the non-actor chunk data in the LevelDB.  <Chunk Key> is the same key string used by the chunk the data is associated with.  Actor Key Space  On the right, we have the actor key space. Each actor key takes the form actorprefix<ActorUniqueID>.  actorprefix is a hardcoded prefix used for all actor keys. This forces all actor data to be contiguous on disk and increases the size of all actor keys such that they are placed ahead of the non-actor chunk data and all digests in the LevelDB.  <ActorUniqueID> is a unique ID that is generated for each actor when it is added to the level. This ID is consistent between play sessions and is only unique to this world. Other actors in other worlds may have the same ID, but no actor in the same world will have the same ID.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourintro", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating Worlds and Game Development - Parkour World 09/21/2023  This series will cover how to build an obstacle course, commonly known as a parkour world, from the ground up. We'll reverse engineer an existing world, talk through the various challenges, touch on player mechanics, and finally build and share our own world.  By the end of this series, you will learn:  What goes into planning and building a world in Minecraft. How to create gameplay mechanics and loops for players to enjoy. How to share content with other players. Overview Part 1 - Parkour World Walkthrough  Not sure how to start developing a game? Let's discuss lots of best practices to have in mind by checking out a parkour world as an example. Parkour World Walkthrough  Part 2 - Creating and Sharing a World  Let's create a smaller parkour world, combining our favorite elements of game development, design, and fun.  Creating and Sharing a World  What's Next?  Check out the Parkour World Walkthrough to see how a fun gameplay loop was developed using different parkour mechanics in Minecraft.  Parkour World Walkthrough  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourintro?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating Worlds and Game Development - Parkour World 09/21/2023  This series will cover how to build an obstacle course, commonly known as a parkour world, from the ground up. We'll reverse engineer an existing world, talk through the various challenges, touch on player mechanics, and finally build and share our own world.  By the end of this series, you will learn:  What goes into planning and building a world in Minecraft. How to create gameplay mechanics and loops for players to enjoy. How to share content with other players. Overview Part 1 - Parkour World Walkthrough  Not sure how to start developing a game? Let's discuss lots of best practices to have in mind by checking out a parkour world as an example. Parkour World Walkthrough  Part 2 - Creating and Sharing a World  Let's create a smaller parkour world, combining our favorite elements of game development, design, and fun.  Creating and Sharing a World  What's Next?  Check out the Parkour World Walkthrough to see how a fun gameplay loop was developed using different parkour mechanics in Minecraft.  Parkour World Walkthrough  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourintro?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating Worlds and Game Development - Parkour World 09/21/2023  This series will cover how to build an obstacle course, commonly known as a parkour world, from the ground up. We'll reverse engineer an existing world, talk through the various challenges, touch on player mechanics, and finally build and share our own world.  By the end of this series, you will learn:  What goes into planning and building a world in Minecraft. How to create gameplay mechanics and loops for players to enjoy. How to share content with other players. Overview Part 1 - Parkour World Walkthrough  Not sure how to start developing a game? Let's discuss lots of best practices to have in mind by checking out a parkour world as an example. Parkour World Walkthrough  Part 2 - Creating and Sharing a World  Let's create a smaller parkour world, combining our favorite elements of game development, design, and fun.  Creating and Sharing a World  What's Next?  Check out the Parkour World Walkthrough to see how a fun gameplay loop was developed using different parkour mechanics in Minecraft.  Parkour World Walkthrough  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/survivalspawncreation?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Survival Spawn Creation 04/16/2025  Survival spawns take on many shapes and forms, all with their own considerations. This article focuses on creating a survival spawn that represents the starting of a player's journey in survival Minecraft. Whether it exists in a naturally generated terrain or a custom-crafted one, the player should be able to experience the normal Minecraft survival loop.  Getting Started   Minecraft: Java Edition terrain meets Minecraft: Bedrock Edition terrain.  Survival spawns should generally contain everything necessary for players to experience the Minecraft survival loop. That means access to ores and materials for crafting, as well as access to the End and the Nether. It should also contain substantial edits to the base seed world.  If you're depending on your build blending into natural generation, your first step should be locating an appropriate Bedrock Edition seed to base your world on and then generating an area to build on. As of 1.18, Bedrock and Java have seed parity so long as the seed number is 9 or fewer characters.  The most stable way to build a survival spawn is to build it directly in Bedrock Edition, however most publicly available tools for building in Minecraft exist for Java Edition. Fortunately, tools such as Chunker that allow converting Bedrock Edition worlds into Java Edition worlds exist.  Generating Bedrock Terrain  Trying to convert a newly created Bedrock Edition world to Java Edition would result in very few Bedrock Edition chunks converting. This is because chunks need to be generated before you can convert a Bedrock Edition world. Currently, chunks must be generated by traversing the world and loading in terrain. This can be accomplished by flying around the world, however, this can be very time-consuming depending on the desired map size. A more efficient way of doing this would be to create a system using commands that teleports the player around the map using relative coordinates to the player. Other tools such as Code Connection (available through the Microsoft Store) and the JavaScript API can be leveraged for the task as well.  Converting Worlds  Converting worlds used to be a clunky and confusing process that was prone to error. With the introduction of Chunker, that process has been made exponentially easier. Not only can you use Chunker to convert worlds, but you can also use it to prune chunks, change world settings, and much much more! Read how to utilize the power of Chunker to help prepare your worlds!  Things to Keep in Mind While Building  It's important to keep in mind the purpose of your survival spawn while building it. Survival spawns are generally intended to enhance the survival Minecraft experience. In those cases, survival spawns should be crafted with survival mechanics in mind. Anything that's possible to do within a newly created survival world, such as finding lava to make a Nether portal, or finding an End portal frame to be able to enter the End should also be possible.  Users playing a survival spawn should be able to find ores and caves under the terrain where it makes sense to do so, as well as Overworld resources above ground. If custom terrain is built with a certain biome in mind, creators should consider making sure the actual biome for that region is appropriate (e.g., a cold biome for a snowy forest so the snow doesn't melt). Unintentional voids or air pockets in terrain should also be removed in consideration of players' underground exploration.  Structures should also be created with survival in mind. In survival mode, players can break and place blocks anywhere they choose. Spaces such as hollow unfurnished attics or crawl spaces under the build, as well as evidence that external tools such as WorldEdit were used will most likely be discovered by players and should be removed to preserve the survival experience. Buildings that are facades and contain nothing are also discouraged in survival spawns because players may attempt to break through facades to see what's inside.  Survival spawns are an excellent place to start with content creation. While there are many challenging aspects to them such as terrain generation, conversions, and survival mechanics to consider, creating survival spawns is an excellent way to gain valuable experience in world-building, player experience, and general usage of various tools available.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/survivalspawncreation?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Survival Spawn Creation 04/16/2025  Survival spawns take on many shapes and forms, all with their own considerations. This article focuses on creating a survival spawn that represents the starting of a player's journey in survival Minecraft. Whether it exists in a naturally generated terrain or a custom-crafted one, the player should be able to experience the normal Minecraft survival loop.  Getting Started   Minecraft: Java Edition terrain meets Minecraft: Bedrock Edition terrain.  Survival spawns should generally contain everything necessary for players to experience the Minecraft survival loop. That means access to ores and materials for crafting, as well as access to the End and the Nether. It should also contain substantial edits to the base seed world.  If you're depending on your build blending into natural generation, your first step should be locating an appropriate Bedrock Edition seed to base your world on and then generating an area to build on. As of 1.18, Bedrock and Java have seed parity so long as the seed number is 9 or fewer characters.  The most stable way to build a survival spawn is to build it directly in Bedrock Edition, however most publicly available tools for building in Minecraft exist for Java Edition. Fortunately, tools such as Chunker that allow converting Bedrock Edition worlds into Java Edition worlds exist.  Generating Bedrock Terrain  Trying to convert a newly created Bedrock Edition world to Java Edition would result in very few Bedrock Edition chunks converting. This is because chunks need to be generated before you can convert a Bedrock Edition world. Currently, chunks must be generated by traversing the world and loading in terrain. This can be accomplished by flying around the world, however, this can be very time-consuming depending on the desired map size. A more efficient way of doing this would be to create a system using commands that teleports the player around the map using relative coordinates to the player. Other tools such as Code Connection (available through the Microsoft Store) and the JavaScript API can be leveraged for the task as well.  Converting Worlds  Converting worlds used to be a clunky and confusing process that was prone to error. With the introduction of Chunker, that process has been made exponentially easier. Not only can you use Chunker to convert worlds, but you can also use it to prune chunks, change world settings, and much much more! Read how to utilize the power of Chunker to help prepare your worlds!  Things to Keep in Mind While Building  It's important to keep in mind the purpose of your survival spawn while building it. Survival spawns are generally intended to enhance the survival Minecraft experience. In those cases, survival spawns should be crafted with survival mechanics in mind. Anything that's possible to do within a newly created survival world, such as finding lava to make a Nether portal, or finding an End portal frame to be able to enter the End should also be possible.  Users playing a survival spawn should be able to find ores and caves under the terrain where it makes sense to do so, as well as Overworld resources above ground. If custom terrain is built with a certain biome in mind, creators should consider making sure the actual biome for that region is appropriate (e.g., a cold biome for a snowy forest so the snow doesn't melt). Unintentional voids or air pockets in terrain should also be removed in consideration of players' underground exploration.  Structures should also be created with survival in mind. In survival mode, players can break and place blocks anywhere they choose. Spaces such as hollow unfurnished attics or crawl spaces under the build, as well as evidence that external tools such as WorldEdit were used will most likely be discovered by players and should be removed to preserve the survival experience. Buildings that are facades and contain nothing are also discouraged in survival spawns because players may attempt to break through facades to see what's inside.  Survival spawns are an excellent place to start with content creation. While there are many challenging aspects to them such as terrain generation, conversions, and survival mechanics to consider, creating survival spawns is an excellent way to gain valuable experience in world-building, player experience, and general usage of various tools available.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/introductiontostructureblocks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Structure Blocks 02/27/2025  Structure blocks are used in Minecraft: Bedrock Edition to save and load blocks and entities that may or may not be arranged in the form of a structure. They can be useful both as building tools and for gameplay animations. Structure blocks can do more than just save and load structures, but that's where we're going to start with this document so we can learn the basics.  You can only edit a structure block in creative mode and they are unbreakable in the survival and adventure game modes.  Like command blocks, you obtain them by using the /give command in the chat, and right-click them to open the settings window.   Note  Any block saved with a structure block will have its state saved. Command blocks will have command information, chests will have their inventory, and even structure blocks will have their structure information when the structure is loaded.  The first thing to notice is the Mode setting. The four structure block modes are:  Save - Saves a structure into a structure block's memory Load - Loads a saved structure from a structure block's memory Corner Can be used to save a specific section of a structure into memory, using two blocks to define the selection around a structure 3D Export Exports a .glb file that can be used to 3D print a model  The settings for Corner and 3D Export are different and we will cover those when we get to them. The buttons under the image of the structure change depending on mode, too.  Save Mode  This is the mode you use when you like entering coordinates to fine-tune your selection. We are going to select a house, save it, and then load it into a different area, basically making a copy of the house.  Start by giving yourself a structure block:  /give @s structure_block  Place the structure block in a nice, clear area and notice how the selection bounding box is oriented.  Next, go place a structure block next to something interesting like a village house.  Open the settings page and adjust the Size and Offset settings of the selection bounding box until you have as much of the house and the surrounding area as you want.  Size: Adjusts the boundaries of the selection bounding box. Offset: Adjusts the position of the selection box, relative to the structure block. You can enter values in the X, Y, and Z fields to pinpoint the exact location you want.  Notice that the colors of the coordinates corresponds to the colors of the lines of the bounding box.  The maximum size values are:  X: 64 Y: 257 Z: 64  If you enter too large of a value for any of these coordinates, it will be changed to the highest possible value. You can click and drag the selection image to get a better view of your selection.  The maximum offset values, from sea-level (Y=63) are -127 to 252.  Offset values are relative to the placement of the structure block. There are not limits for the X: and Z: offset values. As long as the area is loaded, you can grab it.  In the Structure Name field, give the structure a short and memorable filename like \"house1\" and be sure to use only lowercase letters, numbers, underscores, and hyphens in the name.  The namespace \"mystructure:\" will be appended to the name when you click outside of the field.  Make a note of your structure name.  mystructure:house1  You might even want to copy it and paste it to a text file. You will need it to be exact when we load your saved house back in.  For now, don't worry about the Detect button. We will use it later in Corner mode.  We are also going to leave these settings as they are:  Include Entities: Saves any entities like animals or mobs that may be present in the selection. Remove Blocks: Removes all blocks and captures only the entities within the selection. Redstone Save Mode: You can use redstone to activate a structure block and make it save or load a structure into your world. We're not doing that yet, so feel free to ignore this setting for now. Save in Memory is faster, but you can only load the structure in this one world. This is the more common way to save. Save to Disk is slower, but saves the structure to be used in different play sessions. Show Bounding Box: Toggle this on and off to see your selection without the lines around it.  Click the Save button under the selection image. There will be a Structure Saved! message briefly displayed over the structure.  Save Mode - Reset button  After you make changes to the size and offset settings, if you don't like those settings, you can click Reset to put the coordinates back to the defaults.  These are the defaults:  Size:  X: 5 Y: 5 Z: 5  Offset:  X: 0 Y: -1 Z: 0 Exporting and Importing a Structure  After you make a selection, you can export it as a .mcstructure file to save it on your device.  Then you can load the exported structure into a different world.  In a creative mode world, place a structure block and put it in Load mode. Then, click import. This imports the structure into your world, and you can see that the bounding box adjusts to the shape of the imported structure. You can still adjust the load offset. When you're happy with the placement, click Load to load the structure into your world.  Loading a Structure with Load Mode  To load a structure, start by placing a structure block and put it in 'Load' mode.  Importing a Saved Structure  Notice the Import button. This button allows you to import a .mcstructure file from anywhere on your computer into your Minecraft world.  When you click the Import button, a file picker opens that allows you to choose the file you would like to import into your world.  After you have chosen a file, the structure block will then fill out all of the necessary information about the structure into the structure block itself, and ready the structure to load.  For this example, mystructure:1 was chosen, and the structure block's name and bounds were automatically updated to reflect the information in the .mcstructure file.  When a structure is successfully loaded, you will see a message in the structure block UI telling you the structure has been successfully imported.  After the structure is imported, and the structure block UI looks similar to the UI above, the structure can be loaded into the world.  This is what it will look like when the Load button is clicked:  Here are some other important notes about importing a structure:  The import button is limited to the windows version of the game (much like the export button). You can import multiple different structures into a world with the Import button. The structure will be saved to the world once it is loaded into it by clicking the 'Load' button. You can only import structures to a world if you are the host of the world. If you are a guest in someone else's world, the import will fail. Corner Mode  This mode uses three structure blocks: two to set the size and position of the selection, and one to detect the area selected by the other two blocks.  Place a structure block in corner mode outside of one of the structure's sides. Remember the name you use to save it. Place another structure block in corner mode on the opposite corner of the structure and give it the same name. Place a third structure block and select Save Mode. Enter the same name again that was used for the other two corner mode structure blocks. Click Detect. The selection box should encompass the area between the corners of the corner mode blocks. All three blocks must have the same name and there must be at least 1 block between the corners for the Save block to detect the structure.  3D Export Mode  Export mode is used to create a .glb file that will be usable in behavior packs or a file that can be used to 3D print a Minecraft structure.  To export a 3D file, follow these steps:  In the Structure Name field, enter a name for the structure using only lowercase characters. For Relative Position, select the origin of the structure outline. You can select portions into the ground. Structure size sets the distance from the relative position to build that cube in space in Minecraft. Choose to Remove blocks so that inner blocks will not be printed. What's Next?  Now we have seen a structure block in action, you can learn more about how they work and what else you can do with them. Use structure blocks to save and load structures, learn the /structure command, and even learn a simple animation using a command block in the tutorial.  Structure Blocks Tutorial  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/introductiontostructureblocks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Structure Blocks 02/27/2025  Structure blocks are used in Minecraft: Bedrock Edition to save and load blocks and entities that may or may not be arranged in the form of a structure. They can be useful both as building tools and for gameplay animations. Structure blocks can do more than just save and load structures, but that's where we're going to start with this document so we can learn the basics.  You can only edit a structure block in creative mode and they are unbreakable in the survival and adventure game modes.  Like command blocks, you obtain them by using the /give command in the chat, and right-click them to open the settings window.   Note  Any block saved with a structure block will have its state saved. Command blocks will have command information, chests will have their inventory, and even structure blocks will have their structure information when the structure is loaded.  The first thing to notice is the Mode setting. The four structure block modes are:  Save - Saves a structure into a structure block's memory Load - Loads a saved structure from a structure block's memory Corner Can be used to save a specific section of a structure into memory, using two blocks to define the selection around a structure 3D Export Exports a .glb file that can be used to 3D print a model  The settings for Corner and 3D Export are different and we will cover those when we get to them. The buttons under the image of the structure change depending on mode, too.  Save Mode  This is the mode you use when you like entering coordinates to fine-tune your selection. We are going to select a house, save it, and then load it into a different area, basically making a copy of the house.  Start by giving yourself a structure block:  /give @s structure_block  Place the structure block in a nice, clear area and notice how the selection bounding box is oriented.  Next, go place a structure block next to something interesting like a village house.  Open the settings page and adjust the Size and Offset settings of the selection bounding box until you have as much of the house and the surrounding area as you want.  Size: Adjusts the boundaries of the selection bounding box. Offset: Adjusts the position of the selection box, relative to the structure block. You can enter values in the X, Y, and Z fields to pinpoint the exact location you want.  Notice that the colors of the coordinates corresponds to the colors of the lines of the bounding box.  The maximum size values are:  X: 64 Y: 257 Z: 64  If you enter too large of a value for any of these coordinates, it will be changed to the highest possible value. You can click and drag the selection image to get a better view of your selection.  The maximum offset values, from sea-level (Y=63) are -127 to 252.  Offset values are relative to the placement of the structure block. There are not limits for the X: and Z: offset values. As long as the area is loaded, you can grab it.  In the Structure Name field, give the structure a short and memorable filename like \"house1\" and be sure to use only lowercase letters, numbers, underscores, and hyphens in the name.  The namespace \"mystructure:\" will be appended to the name when you click outside of the field.  Make a note of your structure name.  mystructure:house1  You might even want to copy it and paste it to a text file. You will need it to be exact when we load your saved house back in.  For now, don't worry about the Detect button. We will use it later in Corner mode.  We are also going to leave these settings as they are:  Include Entities: Saves any entities like animals or mobs that may be present in the selection. Remove Blocks: Removes all blocks and captures only the entities within the selection. Redstone Save Mode: You can use redstone to activate a structure block and make it save or load a structure into your world. We're not doing that yet, so feel free to ignore this setting for now. Save in Memory is faster, but you can only load the structure in this one world. This is the more common way to save. Save to Disk is slower, but saves the structure to be used in different play sessions. Show Bounding Box: Toggle this on and off to see your selection without the lines around it.  Click the Save button under the selection image. There will be a Structure Saved! message briefly displayed over the structure.  Save Mode - Reset button  After you make changes to the size and offset settings, if you don't like those settings, you can click Reset to put the coordinates back to the defaults.  These are the defaults:  Size:  X: 5 Y: 5 Z: 5  Offset:  X: 0 Y: -1 Z: 0 Exporting and Importing a Structure  After you make a selection, you can export it as a .mcstructure file to save it on your device.  Then you can load the exported structure into a different world.  In a creative mode world, place a structure block and put it in Load mode. Then, click import. This imports the structure into your world, and you can see that the bounding box adjusts to the shape of the imported structure. You can still adjust the load offset. When you're happy with the placement, click Load to load the structure into your world.  Loading a Structure with Load Mode  To load a structure, start by placing a structure block and put it in 'Load' mode.  Importing a Saved Structure  Notice the Import button. This button allows you to import a .mcstructure file from anywhere on your computer into your Minecraft world.  When you click the Import button, a file picker opens that allows you to choose the file you would like to import into your world.  After you have chosen a file, the structure block will then fill out all of the necessary information about the structure into the structure block itself, and ready the structure to load.  For this example, mystructure:1 was chosen, and the structure block's name and bounds were automatically updated to reflect the information in the .mcstructure file.  When a structure is successfully loaded, you will see a message in the structure block UI telling you the structure has been successfully imported.  After the structure is imported, and the structure block UI looks similar to the UI above, the structure can be loaded into the world.  This is what it will look like when the Load button is clicked:  Here are some other important notes about importing a structure:  The import button is limited to the windows version of the game (much like the export button). You can import multiple different structures into a world with the Import button. The structure will be saved to the world once it is loaded into it by clicking the 'Load' button. You can only import structures to a world if you are the host of the world. If you are a guest in someone else's world, the import will fail. Corner Mode  This mode uses three structure blocks: two to set the size and position of the selection, and one to detect the area selected by the other two blocks.  Place a structure block in corner mode outside of one of the structure's sides. Remember the name you use to save it. Place another structure block in corner mode on the opposite corner of the structure and give it the same name. Place a third structure block and select Save Mode. Enter the same name again that was used for the other two corner mode structure blocks. Click Detect. The selection box should encompass the area between the corners of the corner mode blocks. All three blocks must have the same name and there must be at least 1 block between the corners for the Save block to detect the structure.  3D Export Mode  Export mode is used to create a .glb file that will be usable in behavior packs or a file that can be used to 3D print a Minecraft structure.  To export a 3D file, follow these steps:  In the Structure Name field, enter a name for the structure using only lowercase characters. For Relative Position, select the origin of the structure outline. You can select portions into the ground. Structure size sets the distance from the relative position to build that cube in space in Minecraft. Choose to Remove blocks so that inner blocks will not be printed. What's Next?  Now we have seen a structure block in action, you can learn more about how they work and what else you can do with them. Use structure blocks to save and load structures, learn the /structure command, and even learn a simple animation using a command block in the tutorial.  Structure Blocks Tutorial  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/datadrivenoverworldheight?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Data-Driven Overworld Height and Void Generation 09/20/2023  Creators can use this feature to change the height of an existing world or to create void maps in the Overworld, Nether, and The End. This will improve performance by reducing memory and enabling more creative flexibility.  In this tutorial, you will learn the following:  How to create a void world in Minecraft: Bedrock Edition. How to change the height of an existing world. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction To Behavior Packs Limitations  This feature will not modify your existing world generation to fit into a new height range. Instead, when you add the behavior pack containing the JSON file to an existing world, the world will be sliced at the given min and max values and the chunks outside the min and max range will be saved in LevelDB, but will not be visible.  Everything outside of the min and max coordinates will become invisible and above that height will not be buildable. Additionally, there will be no new world generation outside of your saved areas and those areas will generate as type=void.  There is currently no blending and world generation will not scale to the custom height.  This feature will not impact existing and saved custom biomes as it just slices the view at the customized heights However, it will stop new custom biomes from generating since all unsaved areas will generate as void.  The scope of this feature is to introduce a void generator with modifiable heights to reduce memory usage and make this functionality easier for creators.  How to use the Data Driven Overworld Height Behavior Pack First, use it to create a void world  Close Minecraft if you have it running.  Create the behavior pack folder with the usual manifest.json file.  Create a folder on the same level as the manifest file and name it dimensions.  Create a file inside the dimensions folder and name it overworld.json.  Put this code into the file and save it. Note that the only mutable values in this code for now are the min and max values. You cannot modify the generator type or the dimension identifier.  JSON Copy {   \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:overworld\"       },       \"components\": {         \"minecraft:dimension_bounds\": {           \"min\": -16,           \"max\": 256       },       \"minecraft:generation\": {           \"generator_type\": \"void\"       }     }   } }   Load the behavior pack as usual.  Launch Minecraft and make a creative mode world with coordinates shown and the behavior pack active.  Go into the world. It should look like this:  The buildable height of the void world is constrained by the min and max bounds. In this case, we set it to (-16, 256). If you try to place a block outside of the min and max values you set in the JSON file, you get a message saying that the block couldn't be placed.  About those min and max values...  You can change the values for min and max to any multiples of 16 between -512 and 512 that you like.  Next, use it on an existing world  In this section, we will see what happens if we apply the data pack to a \"vanilla\" generated world. (This can also be done on your existing custom world, but as always, we recommend you make a backup first!)  Make a vanilla creative world with Show Coordinates active, but do not apply the behavior pack to it yet.  Go into the world so that it generates and saves terrain at the usual height.  Save and Quit the world, then shut down Minecraft.  Open the overworld.json file you created in the previous section and set the min and max to values that you know are smaller than the generated world. (We're using smaller values just for the purpose of this demo, of course you can set it larger, too!) Remember, they have to be multiples of 16. To really see a drastic difference, you could set them to min: -16 and max: 16.  Launch Minecraft and activate the behavior pack for the world.  When you go back into the world, it should look quite a bit different. It will be cut down to the height you specified and you will not be able to build beyond those limits.  (I assure you this was perfectly normal vanilla world before the data pack was applied.)  What happened  When you take an existing world and add the data driven dimension behavior pack, two things happen:  The buildable height range is restricted to whatever heights you specified.  Void generation occurs outside of your saved areas. This means if you ran around a world on the x coordinate in a circle with a radius of 12, and then you add the behavior pack, only the chunks in that radius (plus the buffer of chunks that we save beyond that radius) will be saved. Outside of that, the terrain will generate as void.  Using this feature will stop world generation beyond the saved areas. It works by generating any new areas as a void. You will see this if you run to the edge of originally saved our areas of your world.  What if I Remove the Behavior Pack?  Your original height range will be restored, along with saved chunks that were hidden from the height restriction.If you go to new (unsaved) areas, regular world generation will occur, but parts that were explored when the behavior pack was active will remain void - because that is how they were generated and saved.  This is why you should always make backups, so you can iterate on your desired changes!  Void Generation in Other Dimensions  The Nether and The End both support void generation, but do not support custom height. To add void generation to these dimensions, start by creating a JSON file for the dimensions you want, like nether.json or the_end.json. Place these inside the dimensions folder created for Overworld void.  The format for the JSON is the same as Overworld void - just remove the \"minecraft:dimension_bounds\" section containing custom height.  Here is an example of the nether.json document:  JSON Copy {     \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:nether\"       },       \"components\": {        \"minecraft:generation\": {           \"generator_type\": \"void\"         }       }     } }   Changing the identifier field to \"minecraft:the_end\" will generate void in The End.  The same traits apply for void in the Nether and The End, so make sure to create a backup of your worlds!  What's Next?  Now that you have seen how this behavior pack works, here are some tutorials about doing even more customization to your world.  Creating New Entity Types Introduction to Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/datadrivenoverworldheight?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Data-Driven Overworld Height and Void Generation 09/20/2023  Creators can use this feature to change the height of an existing world or to create void maps in the Overworld, Nether, and The End. This will improve performance by reducing memory and enabling more creative flexibility.  In this tutorial, you will learn the following:  How to create a void world in Minecraft: Bedrock Edition. How to change the height of an existing world. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction To Behavior Packs Limitations  This feature will not modify your existing world generation to fit into a new height range. Instead, when you add the behavior pack containing the JSON file to an existing world, the world will be sliced at the given min and max values and the chunks outside the min and max range will be saved in LevelDB, but will not be visible.  Everything outside of the min and max coordinates will become invisible and above that height will not be buildable. Additionally, there will be no new world generation outside of your saved areas and those areas will generate as type=void.  There is currently no blending and world generation will not scale to the custom height.  This feature will not impact existing and saved custom biomes as it just slices the view at the customized heights However, it will stop new custom biomes from generating since all unsaved areas will generate as void.  The scope of this feature is to introduce a void generator with modifiable heights to reduce memory usage and make this functionality easier for creators.  How to use the Data Driven Overworld Height Behavior Pack First, use it to create a void world  Close Minecraft if you have it running.  Create the behavior pack folder with the usual manifest.json file.  Create a folder on the same level as the manifest file and name it dimensions.  Create a file inside the dimensions folder and name it overworld.json.  Put this code into the file and save it. Note that the only mutable values in this code for now are the min and max values. You cannot modify the generator type or the dimension identifier.  JSON Copy {   \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:overworld\"       },       \"components\": {         \"minecraft:dimension_bounds\": {           \"min\": -16,           \"max\": 256       },       \"minecraft:generation\": {           \"generator_type\": \"void\"       }     }   } }   Load the behavior pack as usual.  Launch Minecraft and make a creative mode world with coordinates shown and the behavior pack active.  Go into the world. It should look like this:  The buildable height of the void world is constrained by the min and max bounds. In this case, we set it to (-16, 256). If you try to place a block outside of the min and max values you set in the JSON file, you get a message saying that the block couldn't be placed.  About those min and max values...  You can change the values for min and max to any multiples of 16 between -512 and 512 that you like.  Next, use it on an existing world  In this section, we will see what happens if we apply the data pack to a \"vanilla\" generated world. (This can also be done on your existing custom world, but as always, we recommend you make a backup first!)  Make a vanilla creative world with Show Coordinates active, but do not apply the behavior pack to it yet.  Go into the world so that it generates and saves terrain at the usual height.  Save and Quit the world, then shut down Minecraft.  Open the overworld.json file you created in the previous section and set the min and max to values that you know are smaller than the generated world. (We're using smaller values just for the purpose of this demo, of course you can set it larger, too!) Remember, they have to be multiples of 16. To really see a drastic difference, you could set them to min: -16 and max: 16.  Launch Minecraft and activate the behavior pack for the world.  When you go back into the world, it should look quite a bit different. It will be cut down to the height you specified and you will not be able to build beyond those limits.  (I assure you this was perfectly normal vanilla world before the data pack was applied.)  What happened  When you take an existing world and add the data driven dimension behavior pack, two things happen:  The buildable height range is restricted to whatever heights you specified.  Void generation occurs outside of your saved areas. This means if you ran around a world on the x coordinate in a circle with a radius of 12, and then you add the behavior pack, only the chunks in that radius (plus the buffer of chunks that we save beyond that radius) will be saved. Outside of that, the terrain will generate as void.  Using this feature will stop world generation beyond the saved areas. It works by generating any new areas as a void. You will see this if you run to the edge of originally saved our areas of your world.  What if I Remove the Behavior Pack?  Your original height range will be restored, along with saved chunks that were hidden from the height restriction.If you go to new (unsaved) areas, regular world generation will occur, but parts that were explored when the behavior pack was active will remain void - because that is how they were generated and saved.  This is why you should always make backups, so you can iterate on your desired changes!  Void Generation in Other Dimensions  The Nether and The End both support void generation, but do not support custom height. To add void generation to these dimensions, start by creating a JSON file for the dimensions you want, like nether.json or the_end.json. Place these inside the dimensions folder created for Overworld void.  The format for the JSON is the same as Overworld void - just remove the \"minecraft:dimension_bounds\" section containing custom height.  Here is an example of the nether.json document:  JSON Copy {     \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:nether\"       },       \"components\": {        \"minecraft:generation\": {           \"generator_type\": \"void\"         }       }     } }   Changing the identifier field to \"minecraft:the_end\" will generate void in The End.  The same traits apply for void in the Nether and The End, so make sure to create a backup of your worlds!  What's Next?  Now that you have seen how this behavior pack works, here are some tutorials about doing even more customization to your world.  Creating New Entity Types Introduction to Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/foginresourcepacks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fog in Resource Packs 05/19/2025  Fogs in Minecraft: Bedrock Edition use JSON files to determine their values. Creators can define their own sets of fog values in their resource packs. A new folder can be made at the root of a resource pack called fogs. Any JSON files within this folder will be registered as new fog definitions that can be used by the game.  In this tutorial you will learn the following:  What a fog file looks like and what options are available for customization. The order that fog is applied based on various features, including biome definitions and the /fog command. Requirements  It's recommended you complete Introduction to Resource Packs before beginning this tutorial.  JSON Example  The Vanilla Resource Pack template contains all of the fog files used in the game. These files can serve as examples for creating your own fog definitions. A completed fog file will look similar to the following:  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"minecraft:fog_default\"     },     \"distance\": {       \"air\": {         \"fog_start\": 0.92,         \"fog_end\": 1.0,         \"fog_color\": \"#ABD2FF\",         \"render_distance_type\": \"render\"       },       \"water\": {         \"fog_start\": 0,         \"fog_end\": 60.0,         \"fog_color\": \"#44AFF5\",         \"render_distance_type\": \"fixed\",         \"transition_fog\": {           \"init_fog\": {             \"fog_start\": 0.0,             \"fog_end\": 0.01,             \"fog_color\": \"#44AFF5\",             \"render_distance_type\": \"fixed\"           },           \"min_percent\": 0.25,           \"mid_seconds\": 5,           \"mid_percent\": 0.6,           \"max_seconds\": 30         }       },       \"weather\": {         \"fog_start\": 0.23,         \"fog_end\": 0.7,         \"fog_color\": \"#666666\",         \"render_distance_type\": \"render\"       },       \"lava\": {         \"fog_start\": 0.0,         \"fog_end\": 0.64,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       },       \"lava_resistance\": {         \"fog_start\": 2.0,         \"fog_end\": 4.0,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       }     }   } }  Variables format_version  The resource pack version that this fog setting was built for. This is used for determining upgrade paths and backwards compatibility in newer versions of the game. The minimum version is 1.16.100.  minecraft:fog_settings  Contains the definitions and options of the fog.  description  Holds the description for this fog setting, which primarily contains an identifier.  identifier  Held within the description object.  The unique name to refer to this fog setting. Each identifier requires a namespace. You also must have each identifier be unique or you will get an error. The minecraft namespace is allowed to be used only by the vanilla resource packs.  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"custom_pack:example\"     },     ...   } }  distance  This object contains the values for distance-based fog. This is the fog that limits the player from seeing anything beyond a specific distance from them. Each field within this object contains one type of distance value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and the Lava Resistance effect is active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"distance\": {       \"air\": {         ...       },       \"water\": {         ...       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each distance setting type, you can set the following variables:  fog_start: The distance where the fog will begin to appear. fog_end: The distance where the fog will become completely opaque. render_distance_type: Setting this will determine how the start and end values are used for calculating the fog distances. fixed: The distance is measured in the number of blocks away. render: The distance is multiplied against the current render distance. fog_color: The color that the fog will take on. transition_fog   Note  transition_fog works only for fog in a water setting.  With transition_fog specified, players will see a fog transition from init_fog setting to the water setting when they move into water. The speed of transition can be controlled by percent and second values.  In each transition_fog setting type, you can set the following variables:  init_fog: Initial fog that will slowly transition into water distance fog of the biome when player goes into water. min_percent: Minimum progress of fog transition. mid_seconds: The time takes to reach certain progress('mid_percent') of fog transition. mid_percent: The progress of fog transition after 'mid_seconds' seconds. max_seconds: Total amount of time it takes to complete the fog transition. volumetric  This object contains the values for volumetric fog. This fog will be displayed as a calculation from light passing through blocks. Currently this is only used for Ray Tracing.  density  Held within the volumetric object. Each field within it contains one type of density value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and they have the Lava Resistance effect active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"density\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each density setting type, you can set the following variables:  max_density: the multiplier on how much the fog disrupts the light. 0.0 will have no fog, and 1.0 will be near opaque. uniform: when set to true, the fog density will occur evenly across all heights. zero_density_height: the height in blocks that the fog will begin to appear. This can only be set if uniform is set to false. max_density_height: the height in blocks that the fog will become its max_density. This can be set only if uniform is set to false. media_coefficients  Held within the volumetric object.  Each field within this object defines one type of coefficient value. These are used to determine how the light is dispersed or refracted by the fog as rays travel through different mediums/blocks.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water. cloud: used when light is passing through clouds.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"media_coefficients\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each coefficient setting type, you can set the following variables:  scattering: how much of the RGB of the light the fog will spread. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. absorption: how much of the RGB of the light the fog will absorb. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. Henyey-Greenstein G  Available in format_version 1.21.90 and above, and only applicable in Vibrant Visuals resource packs.  Held within the volumetric object.  Each field within this object defines one type of g value. These are used to determine the distribution of scattered light in different mediums.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"henyey_greenstein_g\": {         \"air\": {           \"henyey_greenstein_g\": 0.75         },         \"water\": {           \"henyey_greenstein_g\": 0.6         }       }     }   In each medium setting type, you can set the following variable:  henyey_greenstein_g: Controls the distribution of scattered light. Values can range from [-1.0, 1.0]. Positive values will result in forward-scattering, while negative values will result in back-scattering. The default value for air is 0.75, while the default for water is 0.6. Active Fog Stack  The active fog stack is used to determine which fog setting to use at any given time in the game. Each player has a unique fog stack.  Whenever the game needs to determine the values for the fog, it will start at the top of the fog stack and check down it until it has found a value for the current setting type. If a fog setting on the stack does not have a setting, then the game will continue checking down the stack. If the game finds no such setting, it will instead use the defaults defined by the engine.  The fog stack is initially setup as follows, with the highest precedence starting at the top:  Command: the settings set on the player by server commands. Biomes: the settings defined to be on each biome. Data Default: the default data driven settings. Engine Default: hard code values. Command  At the top of the stack, the command layer has all the settings set by the /fog command and is evaluated as one stack from top to bottom. More details about the command's usage is found in the \"Fog Command\" section.  Biomes  The biome layer is an average of all the settings defined by the biomes around the player's position. Fog settings can be defined for each individual biome within the biomes_client.json file located at the root of a resource pack. In each biome entry, you can have a variable called fog_identifier and set a name that matches the fog setting you want to use with that biome.  JSON Copy {   \"biomes\": {     ...     \"ice_plains\": {       \"fog_identifier\": \"minecraft:fog_ice_plains\",       ...     },     ...     \"mesa_plateau\": {       \"fog_identifier\": \"minecraft:fog_mesa_plateau\",       ...     },     ...   } }   The default entry can also be set this way and will be used underneath the biome entries in the active fog stack. So, a biome's fog setting does not completely replace the default setting, but instead the biome is read on top of the default as described in the \"Data Default\" section.  Data Default  The data default layer is defined within the default object in the biomes_client.json file in the root of a resource pack, provided that it references a fog definition via the fog_identifier field.  JSON Copy {   \"biomes\": {     \"default\": {       \"fog_identifier\": \"minecraft:fog_default\",       ...     }   },   ... }  Engine Default  The bottom of the stack uses hard-coded values in case there are no data driven values. As such, these cannot be changed and there cannot be any layers beneath it.  Fog Command  The /fog command can be used to manage fog settings at the \"command\" layer of the active fog stack for each player.  Fog settings in this layer are ordered via the push, pop, and remove modes of the /fog command described below. Fog settings are evaluated top-to-bottom in the active fog stack which includes top-to-bottom in this layer first.  Fog settings in this layer are saved and then restored on world load per player. In this way, a fog setting that is pushed before a world save will still apply after a world load and can then be popped.  Push  Pushes a new fog setting to specified player(s), along with a user provided ID, onto the top of the Fog Command layers of the players' active fog stacks.  Pop  Removes the top-most fog setting from selected player(s) that matches the user provided ID, as provided previously via a /fog push command.  Remove  Removes all matching fog settings, from the selected player(s), that matches the user-provided ID, as as provided previously via one or more /fog push commands.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/foginresourcepacks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fog in Resource Packs 05/19/2025  Fogs in Minecraft: Bedrock Edition use JSON files to determine their values. Creators can define their own sets of fog values in their resource packs. A new folder can be made at the root of a resource pack called fogs. Any JSON files within this folder will be registered as new fog definitions that can be used by the game.  In this tutorial you will learn the following:  What a fog file looks like and what options are available for customization. The order that fog is applied based on various features, including biome definitions and the /fog command. Requirements  It's recommended you complete Introduction to Resource Packs before beginning this tutorial.  JSON Example  The Vanilla Resource Pack template contains all of the fog files used in the game. These files can serve as examples for creating your own fog definitions. A completed fog file will look similar to the following:  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"minecraft:fog_default\"     },     \"distance\": {       \"air\": {         \"fog_start\": 0.92,         \"fog_end\": 1.0,         \"fog_color\": \"#ABD2FF\",         \"render_distance_type\": \"render\"       },       \"water\": {         \"fog_start\": 0,         \"fog_end\": 60.0,         \"fog_color\": \"#44AFF5\",         \"render_distance_type\": \"fixed\",         \"transition_fog\": {           \"init_fog\": {             \"fog_start\": 0.0,             \"fog_end\": 0.01,             \"fog_color\": \"#44AFF5\",             \"render_distance_type\": \"fixed\"           },           \"min_percent\": 0.25,           \"mid_seconds\": 5,           \"mid_percent\": 0.6,           \"max_seconds\": 30         }       },       \"weather\": {         \"fog_start\": 0.23,         \"fog_end\": 0.7,         \"fog_color\": \"#666666\",         \"render_distance_type\": \"render\"       },       \"lava\": {         \"fog_start\": 0.0,         \"fog_end\": 0.64,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       },       \"lava_resistance\": {         \"fog_start\": 2.0,         \"fog_end\": 4.0,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       }     }   } }  Variables format_version  The resource pack version that this fog setting was built for. This is used for determining upgrade paths and backwards compatibility in newer versions of the game. The minimum version is 1.16.100.  minecraft:fog_settings  Contains the definitions and options of the fog.  description  Holds the description for this fog setting, which primarily contains an identifier.  identifier  Held within the description object.  The unique name to refer to this fog setting. Each identifier requires a namespace. You also must have each identifier be unique or you will get an error. The minecraft namespace is allowed to be used only by the vanilla resource packs.  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"custom_pack:example\"     },     ...   } }  distance  This object contains the values for distance-based fog. This is the fog that limits the player from seeing anything beyond a specific distance from them. Each field within this object contains one type of distance value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and the Lava Resistance effect is active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"distance\": {       \"air\": {         ...       },       \"water\": {         ...       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each distance setting type, you can set the following variables:  fog_start: The distance where the fog will begin to appear. fog_end: The distance where the fog will become completely opaque. render_distance_type: Setting this will determine how the start and end values are used for calculating the fog distances. fixed: The distance is measured in the number of blocks away. render: The distance is multiplied against the current render distance. fog_color: The color that the fog will take on. transition_fog   Note  transition_fog works only for fog in a water setting.  With transition_fog specified, players will see a fog transition from init_fog setting to the water setting when they move into water. The speed of transition can be controlled by percent and second values.  In each transition_fog setting type, you can set the following variables:  init_fog: Initial fog that will slowly transition into water distance fog of the biome when player goes into water. min_percent: Minimum progress of fog transition. mid_seconds: The time takes to reach certain progress('mid_percent') of fog transition. mid_percent: The progress of fog transition after 'mid_seconds' seconds. max_seconds: Total amount of time it takes to complete the fog transition. volumetric  This object contains the values for volumetric fog. This fog will be displayed as a calculation from light passing through blocks. Currently this is only used for Ray Tracing.  density  Held within the volumetric object. Each field within it contains one type of density value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and they have the Lava Resistance effect active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"density\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each density setting type, you can set the following variables:  max_density: the multiplier on how much the fog disrupts the light. 0.0 will have no fog, and 1.0 will be near opaque. uniform: when set to true, the fog density will occur evenly across all heights. zero_density_height: the height in blocks that the fog will begin to appear. This can only be set if uniform is set to false. max_density_height: the height in blocks that the fog will become its max_density. This can be set only if uniform is set to false. media_coefficients  Held within the volumetric object.  Each field within this object defines one type of coefficient value. These are used to determine how the light is dispersed or refracted by the fog as rays travel through different mediums/blocks.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water. cloud: used when light is passing through clouds.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"media_coefficients\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each coefficient setting type, you can set the following variables:  scattering: how much of the RGB of the light the fog will spread. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. absorption: how much of the RGB of the light the fog will absorb. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. Henyey-Greenstein G  Available in format_version 1.21.90 and above, and only applicable in Vibrant Visuals resource packs.  Held within the volumetric object.  Each field within this object defines one type of g value. These are used to determine the distribution of scattered light in different mediums.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"henyey_greenstein_g\": {         \"air\": {           \"henyey_greenstein_g\": 0.75         },         \"water\": {           \"henyey_greenstein_g\": 0.6         }       }     }   In each medium setting type, you can set the following variable:  henyey_greenstein_g: Controls the distribution of scattered light. Values can range from [-1.0, 1.0]. Positive values will result in forward-scattering, while negative values will result in back-scattering. The default value for air is 0.75, while the default for water is 0.6. Active Fog Stack  The active fog stack is used to determine which fog setting to use at any given time in the game. Each player has a unique fog stack.  Whenever the game needs to determine the values for the fog, it will start at the top of the fog stack and check down it until it has found a value for the current setting type. If a fog setting on the stack does not have a setting, then the game will continue checking down the stack. If the game finds no such setting, it will instead use the defaults defined by the engine.  The fog stack is initially setup as follows, with the highest precedence starting at the top:  Command: the settings set on the player by server commands. Biomes: the settings defined to be on each biome. Data Default: the default data driven settings. Engine Default: hard code values. Command  At the top of the stack, the command layer has all the settings set by the /fog command and is evaluated as one stack from top to bottom. More details about the command's usage is found in the \"Fog Command\" section.  Biomes  The biome layer is an average of all the settings defined by the biomes around the player's position. Fog settings can be defined for each individual biome within the biomes_client.json file located at the root of a resource pack. In each biome entry, you can have a variable called fog_identifier and set a name that matches the fog setting you want to use with that biome.  JSON Copy {   \"biomes\": {     ...     \"ice_plains\": {       \"fog_identifier\": \"minecraft:fog_ice_plains\",       ...     },     ...     \"mesa_plateau\": {       \"fog_identifier\": \"minecraft:fog_mesa_plateau\",       ...     },     ...   } }   The default entry can also be set this way and will be used underneath the biome entries in the active fog stack. So, a biome's fog setting does not completely replace the default setting, but instead the biome is read on top of the default as described in the \"Data Default\" section.  Data Default  The data default layer is defined within the default object in the biomes_client.json file in the root of a resource pack, provided that it references a fog definition via the fog_identifier field.  JSON Copy {   \"biomes\": {     \"default\": {       \"fog_identifier\": \"minecraft:fog_default\",       ...     }   },   ... }  Engine Default  The bottom of the stack uses hard-coded values in case there are no data driven values. As such, these cannot be changed and there cannot be any layers beneath it.  Fog Command  The /fog command can be used to manage fog settings at the \"command\" layer of the active fog stack for each player.  Fog settings in this layer are ordered via the push, pop, and remove modes of the /fog command described below. Fog settings are evaluated top-to-bottom in the active fog stack which includes top-to-bottom in this layer first.  Fog settings in this layer are saved and then restored on world load per player. In this way, a fog setting that is pushed before a world save will still apply after a world load and can then be popped.  Push  Pushes a new fog setting to specified player(s), along with a user provided ID, onto the top of the Fog Command layers of the players' active fog stacks.  Pop  Removes the top-most fog setting from selected player(s) that matches the user provided ID, as provided previously via a /fog push command.  Remove  Removes all matching fog settings, from the selected player(s), that matches the user-provided ID, as as provided previously via one or more /fog push commands.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/controlschemes?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Control Schemes 05/28/2025  In Minecraft: Bedrock Edition, players can choose from a set of schemes that define how the player and the camera move in response to controller input. These provide great flexibility for different gameplay scenarios.  The control scheme can be manually set by using the /controlscheme command. It can also be set with camera presets.  Control scheme types  Each control scheme defines how Minecraft responds to game controllers, touch input on mobile devices, keyboard and mouse combos, and full keyboard controls.  Player relative  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Use the right stick to rotate the camera when using the third-person Follow Orbit camera.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Drag on the screen to rotate the camera when using the third-person Follow Orbit camera.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Use the mouse to rotate the camera when using the third-person Follow Orbit camera.  Full Keyboard: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Press the left and right arrows to rotate the camera when using the third-person Follow Orbit camera. The numeric keypad can also be used for camera rotation if enabled.  Player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to the left or right without turning (strafe). Push the right stick in a direction to have the player look in that direction.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing. Push it left or right to move the player to their left or right without turning (strafe). Touch and drag on the screen to have your character look at the point you are touching. Note: this control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. The character will look toward where the mouse is on screen.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. Press the left and right arrows to rotate the player. The numeric keypad can also be used for player rotation if enabled.  Locked player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to their left or right without turning (strafe). Push the right stick left or right to turn the player to their left or right. Pushing the right stick up or down will make the player's aim rotate up or down.  Touch: Push the virtual joystick or D-pad forward or backward to make the player move forward or backward in the direction they're facing. Push the virtual joystick or D-pad left or right to move the player to their left or right without turning (strafe). Swiping left or right rotates the player, while swiping up or down makes the player look up or down. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Moving the mouse left or right will turn the player to their left or right. Moving the mouse forward or back will move the player's aim up or down.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Press the left and right arrows to rotate the player. Press the up and down arrows to rotate the player's aim up or down. The numeric keypad can also be used for player rotation if enabled.  Camera relative  Controller: Use the left stick to control player movement; the player automatically faces the direction of motion. Down moves toward the camera, up moves away, left moves toward the left side of the screen, and right moves toward the right side. Use the right stick to rotate the camera.  Touch: Push the virtual joystick or D-pad to control player movement; the player automatically faces the direction of motion. Drag on the screen to rotate the camera.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Use the mouse to rotate the camera.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Press the left and right arrows to rotate the camera. The numeric keypad can also be used for camera rotation if enabled.  Camera relative strafe   Note  This scheme is experimental, and requires the Experimental Creator Camera setting to be enabled.  Controller: Use the left stick to move the player without turning (strafe). Use the right stick to rotate the player to look in the direction the stick is moved.  Touch: Push the virtual joystick or D-pad to move the player without turning (strafe). Drag on the screen to rotate the player to look toward the point being touched. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. The player will rotate to look toward the mouse location.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. Press the arrow keys to rotate the player to look in that direction. The numeric keypad can also be used for rotation if enabled.  Control schemes and camera presets  When you use camera presets, you can use the control_scheme key in the camera.json file to associate a control scheme with a preset.  JSON Copy {     \"format_version\": \"1.19.50\",     \"minecraft:camera_preset\": {         \"identifier\": \"example:custom\",         \"inherit_from\": \"minecraft:follow_orbit\",         \"control_scheme\": \"camera_relative\"     } }   Setting a control scheme in a camera preset will override the preset's default control scheme, as long as the scheme is allowed in that camera mode. If the scheme is not allowed in that mode, or you don't include the control_scheme key in that preset, the default control scheme of the camera mode will be used instead.  Here are the allowed control schemes for each built-in camera preset. The default control scheme for all built-in presets is locked player relative strafe.  Expand table Camera Preset\tAllowed Control Schemes minecraft:first_person\tlocked player relative strafe minecraft:third_person\tlocked player relative strafe minecraft:third_person_front\tlocked player relative strafe minecraft:free\tlocked player relative strafe player relative strafe player relative camera relative camera relative strafe minecraft:follow_orbit\tlocked player relative strafe player relative camera relative minecraft:fixed_boom\tlocked player relative strafe camera relative camera relative strafe player relative strafe player relative Switching control schemes  To switch schemes from the command line, use the /controlscheme command.  /controlscheme <player> set <control_scheme>  Possible control schemes are:  camera_relative camera_relative_strafe player_relative player_relative_strafe locked_player_relative_strafe  You can reset the control scheme to the default for the current camera mode with the clear subcommand:  /controlscheme <player> clear  Note that you can only switch to a control scheme that's allowed in the current camera mode.  Control scheme inheritance  A custom camera preset inherits the allowed control schemes of the built-in camera preset it descends from. It will use the default control scheme of its parent camera if its own control_scheme is not defined, or if the defined scheme is not supported by the camera.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/controlschemes?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Control Schemes 05/28/2025  In Minecraft: Bedrock Edition, players can choose from a set of schemes that define how the player and the camera move in response to controller input. These provide great flexibility for different gameplay scenarios.  The control scheme can be manually set by using the /controlscheme command. It can also be set with camera presets.  Control scheme types  Each control scheme defines how Minecraft responds to game controllers, touch input on mobile devices, keyboard and mouse combos, and full keyboard controls.  Player relative  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Use the right stick to rotate the camera when using the third-person Follow Orbit camera.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Drag on the screen to rotate the camera when using the third-person Follow Orbit camera.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Use the mouse to rotate the camera when using the third-person Follow Orbit camera.  Full Keyboard: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Press the left and right arrows to rotate the camera when using the third-person Follow Orbit camera. The numeric keypad can also be used for camera rotation if enabled.  Player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to the left or right without turning (strafe). Push the right stick in a direction to have the player look in that direction.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing. Push it left or right to move the player to their left or right without turning (strafe). Touch and drag on the screen to have your character look at the point you are touching. Note: this control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. The character will look toward where the mouse is on screen.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. Press the left and right arrows to rotate the player. The numeric keypad can also be used for player rotation if enabled.  Locked player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to their left or right without turning (strafe). Push the right stick left or right to turn the player to their left or right. Pushing the right stick up or down will make the player's aim rotate up or down.  Touch: Push the virtual joystick or D-pad forward or backward to make the player move forward or backward in the direction they're facing. Push the virtual joystick or D-pad left or right to move the player to their left or right without turning (strafe). Swiping left or right rotates the player, while swiping up or down makes the player look up or down. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Moving the mouse left or right will turn the player to their left or right. Moving the mouse forward or back will move the player's aim up or down.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Press the left and right arrows to rotate the player. Press the up and down arrows to rotate the player's aim up or down. The numeric keypad can also be used for player rotation if enabled.  Camera relative  Controller: Use the left stick to control player movement; the player automatically faces the direction of motion. Down moves toward the camera, up moves away, left moves toward the left side of the screen, and right moves toward the right side. Use the right stick to rotate the camera.  Touch: Push the virtual joystick or D-pad to control player movement; the player automatically faces the direction of motion. Drag on the screen to rotate the camera.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Use the mouse to rotate the camera.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Press the left and right arrows to rotate the camera. The numeric keypad can also be used for camera rotation if enabled.  Camera relative strafe   Note  This scheme is experimental, and requires the Experimental Creator Camera setting to be enabled.  Controller: Use the left stick to move the player without turning (strafe). Use the right stick to rotate the player to look in the direction the stick is moved.  Touch: Push the virtual joystick or D-pad to move the player without turning (strafe). Drag on the screen to rotate the player to look toward the point being touched. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. The player will rotate to look toward the mouse location.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. Press the arrow keys to rotate the player to look in that direction. The numeric keypad can also be used for rotation if enabled.  Control schemes and camera presets  When you use camera presets, you can use the control_scheme key in the camera.json file to associate a control scheme with a preset.  JSON Copy {     \"format_version\": \"1.19.50\",     \"minecraft:camera_preset\": {         \"identifier\": \"example:custom\",         \"inherit_from\": \"minecraft:follow_orbit\",         \"control_scheme\": \"camera_relative\"     } }   Setting a control scheme in a camera preset will override the preset's default control scheme, as long as the scheme is allowed in that camera mode. If the scheme is not allowed in that mode, or you don't include the control_scheme key in that preset, the default control scheme of the camera mode will be used instead.  Here are the allowed control schemes for each built-in camera preset. The default control scheme for all built-in presets is locked player relative strafe.  Expand table Camera Preset\tAllowed Control Schemes minecraft:first_person\tlocked player relative strafe minecraft:third_person\tlocked player relative strafe minecraft:third_person_front\tlocked player relative strafe minecraft:free\tlocked player relative strafe player relative strafe player relative camera relative camera relative strafe minecraft:follow_orbit\tlocked player relative strafe player relative camera relative minecraft:fixed_boom\tlocked player relative strafe camera relative camera relative strafe player relative strafe player relative Switching control schemes  To switch schemes from the command line, use the /controlscheme command.  /controlscheme <player> set <control_scheme>  Possible control schemes are:  camera_relative camera_relative_strafe player_relative player_relative_strafe locked_player_relative_strafe  You can reset the control scheme to the default for the current camera mode with the clear subcommand:  /controlscheme <player> clear  Note that you can only switch to a control scheme that's allowed in the current camera mode.  Control scheme inheritance  A custom camera preset inherits the allowed control schemes of the built-in camera preset it descends from. It will use the default control scheme of its parent camera if its own control_scheme is not defined, or if the defined scheme is not supported by the camera.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcommands", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Scripting Custom Commands Overview 03/27/2025  There is also a video version available of this overview of Scripting Custom Commands:  Scripting Custom Commands  Commands are a critical part of nearly any creator project. Commonly, projects are boot-strapped and tested via a set of custom commands and functions, including commands that can reset environments or change configurations. In multiplayer environments, a set of commands can be used to administer games. You can also use commands to provide helpful little builder functions, to further build out your world.  Starting in Minecraft Bedrock Edition 1.21.80.22 Preview, you can now implement custom commands in script. These commands have the full capability of scripting APIs and custom logic, allowing you to implement sophisticated operations.  Note that in the current beta, context on the executing environment (e.g., the player who ran the command, or the initiator in NPC environments) is not available; we are looking to bring this execution context in future.  You can view a sample project at https://github.com/microsoft/minecraft-scripting-samples.  Using 2.0.0-beta scripting environment  To get started, we'll want to work with the 2.0.0-beta scripting environment. Custom commands and registration only run in the v2.0.0 scripting environment, which itself is currently in beta.  You'll want to make sure you use 2.0.0-beta as your scripting environment, in the manifest of your behavior pack:  JSON Copy   {     \"module_name\": \"@minecraft/server\",     \"version\": \"2.0.0-beta\"   },  Registering Commands  The first step is to register the command. You can do this within the startup event of system.beforeEvents, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Celebration size\",     permissionLevel: CustomCommandPermissionLevel.Admin,     optionalParameters: [{ type: CustomCommandParamType.Integer, name: \"celebrationSize\" }],   };   init.customCommandRegistry.registerCommand(helloCommand, helloCustomCommand); }   There are several parameters you will need to specify:  Expand table Parameter\tDescription name\tName of the command that is used. Custom commands must be namespaced (that is, follow the form of namespace:commandname). description\tDescription of the command. This will show up in autocomplete for the command. permissionLevel\tRelative permission level of the command. mandatoryParameters\tA list of mandatory parameters for the command. These will come first in the list of parameters that a command may have. optionalParameters\tA list of optional parameters for the command. These will come second in the list of parameters. Permission Levels  Commands can have a permission level that is required from executing contexts and players.  Expand table Parameter\tDescription Any\tAny player or environment can run this command. GameDirectors\tRequires a player with an \"Operator Commands\" permission to run this command. Also, scripting and command environments, like command blocks, can run this command. Admin\tRequires a player with \"Operator Commands\" permission. Commands with this level cannot be used in automations like commands or script Host\tOnly the originating game owner can run this command. Owner\tIn dedicated server environments, this command can only be exited in the hosting environment at the dedicated server console. Command Enums  As of the 1.21.80-preview.27 release you can now register custom enums for script-based commands, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const commandRegistry = event.customCommandRegistry;    commandRegistry.registerEnum(\"creator:my_enum\", [\"foo\", \"bar\", \"baz\"]);    const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Example command\",     permissionLevel: CustomCommandPermissionLevel.Any,     mandatoryParameters: [       {          type: CustomCommandParamType.Enum,          name: \"creator:my_enum\" // The parameter name must match the registered enum name above     }],   };   commandRegistry.registerCommand(helloCommand, helloCustomCommand); }  Execution  After registering your command, Minecraft will call into your function with the parameters that are specified by the command context.  Expand table Parameter Type\tCorresponding data variable type BlockType\t@minecraft/server.BlockType Boolean\tboolean EntitySelector\tEntity[] Float\tnumber Integer\tnumber ItemType\t@minecraft/server.ItemType Position\tVector3 PlayerSelector\tPlayer[] String\tstring  If the parameter is optional, then undefined is passed in if the parameter is not specified.  Note that script command function runs in a \"before\" context, meaning that most methods that change state are unavailable in the command context. To run commands that change world state, you'll want to consider wrapping them in a function that defers execution until later in the tick, such as system.run for example:  TypeScript Copy     system.run(() => {       for (const player of world.getPlayers()) {         player.dimension.createExplosion(player.location, celebrationSize);       }     });  Summary  Custom script-based commands unlocks a new organization tool for functionality you have in your creations. Whether a simple internal reset tool or a sophisticated game administration suite, we hope that providing a set of powerful commands is easy and second nature in your projects.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/resourcepack", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Resource Packs 05/07/2025  Before building your first Add-On for Minecraft: Bedrock Edition, you'll need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A resource pack is a folder structure that contains all of your custom models, sounds, textures, and other custom content.  In this tutorial, you will learn:  How a resource pack is created. How a manifest file is created. How custom textures are loaded into Minecraft: Bedrock Edition. The concept of Pack Stacking when working with Add-On content. Sample Resource Pack  There is a sample resource pack available on the Minecraft samples GitHub. This pack may be used to understand the structure of resource packs and to check your work after you complete this tutorial.  Requirements  It's recommended you complete Getting Started with Add-On Development before beginning this tutorial.  Building the Resource Pack  For Minecraft to find and use your resource files, you must set up the folders and files in a specific way. This tutorial will guide you through creating this folder and file structure.  Create a Resource Pack Folder  We will start by creating a folder called My_RESOURCE_Pack. Technically you can name this folder anything you want, but the other folders have to be named exactly as specified in this tutorial so that Minecraft knows where to find the information.  Locate com.mojang on a Windows device Open the com.mojang folder. Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK. Double-click the development_resource_packs folder to open it. Add a new folder and name it My_RESOURCE_Pack. Double-click the My_RESOURCE_Pack folder to open it.  Create a Manifest File  To load a resource pack into Minecraft, we need a manifest file. The manifest file is a JSON file that contains the following information:  Description: In-game description of what the resource pack does. Name: In-game name of the resource pack. UUID: Universally Unique Identifier. Version: Version of the resource pack. Minimum Engine Version: Minimum required version of Minecraft for this pack to work properly.   Note  To learn more about how a manifest.json file works, see the Addons Reference manifest.json documentation.  Minecraft parses the information from the manifest file and displays it in the Add-On section of the game. Inside the file, the information is split into two separate sections: Header and modules. The header section contains the overall information for the pack, while the modules section contains the dedicated packages information. To create the manifest.json file:  Right-click in the Explorer window, and select New > Text Document. Name it manifest.json. You will need to change the file extension from .txt to .json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab.  Double-click the manifest.json file to open it in a text editor. Copy and paste the following code into your file. JSON Copy {  \"format_version\": 2,  \"header\": {    \"description\": \"My dirt resource pack Add-On!\",    \"name\": \"My Resource Pack\",    \"uuid\": \"<FIRST GENERATED UUID>\",    \"version\": [1, 0, 0],    \"min_engine_version\": [1, 16, 0]   },  \"modules\": [    {      \"description\": \"My First Add-On!\",      \"type\": \"resources\",      \"uuid\": \"<SECOND GENERATED UUID>\",      \"version\": [1, 0, 0]    }  ] }  Set the UUID  A Universally Unique Identifier (UUID) is a unique number used for identification purposes. For Minecraft, the UUID is used to define a specific pack and to prevent any duplicate software from causing issues. For the header and modules, there will need to be two different UUID numbers entered in each of the \"uuid\" fields between the quotes. You can get UUIDs from an online UUID Generator such as https://www.uuidgenerator.net/.  Copy and paste a UUID into the header section. The UUID will need to be pasted in the \"uuid\":\"\" field between the quotation (\"\") marks to be read correctly. Refresh the webpage to generate a new UUID for use in the Modules section. Copy and paste the new UUID into the modules section in the \"uuid\" field between the quotation marks. Save the manifest.json file. Changing the Dirt Block  With the manifest file completed, you can now start adding custom content to Minecraft. Let's get started by applying a new texture to the Vanilla dirt block. The first part of the process involves creating a folder structure to hold the custom texture.  Open the My_RESOURCE_Pack folder and create a folder named textures. Double-click the textures folder to open it. Open the textures folder and create a folder named blocks. Double-click the blocks folder to open it. Create the texture  Now that the folder structure is created, we can start adding some custom textures. This green square is an example of the type of file created using the following steps.  You can download this green block and save it in your blocks folder or follow these steps to create your texture:  Open up an image editor such as MS Paint. Go to the File menu and select Properties. Set the Width and Height to 16 pixels each. Click OK.  You can now design a pattern or any artwork in the editor. To make the green square, a simple fill color was added.   Note  MS Paint is used in this example for quick and easy access, but you will need to use a different graphics editor for more advanced graphic features like transparency effects or .tga file support.  After editing the texture, go to the File menu and select Save As. Choose the PNG picture option. In the Save As dialog box, navigate to the blocks folder. Save the file as dirt.png. Test the pack  Now that the pack has both a manifest file and a texture file, you can launch Minecraft and test your new resource Add-On.   Important  Pack Stacking is how content is loaded on top of Vanilla content, causing each object that has the same name in both packs to be overwritten by the latest applied pack. In our example, the original dirt texture is overwritten by the custom texture.  If another pack that uses the dirt.png file is loaded after My_RESOURCE_Pack, then Minecraft will use that file instead.  Your custom texture will be used on every dirt.png block in the world, but it will not be used on blocks of dirt with grass on them because those blocks have a different name.  Launch Minecraft and select Play. Select Create New World. Under Settings, scroll down to the Add-Ons section. Click on Resource Packs to see all available packs. Click the MY PACKS drop-down. Select My RESOURCE Pack and click Activate to add the resource pack to the world. Click Create.  Troubleshooting  Resource pack woes? Don't worry, troubleshooting is a normal part of any development process.  You can use the sample resource pack on the Minecraft samples GitHub site to check the structure of your resource pack.  Your Resource Pack Does Not Appear in Minecraft  If your resource pack does not appear in the Add-Ons section of a world, the issue may be a malformed manifest.json file. Let's investigate.  Are there two different UUIDs in the manifest.json header and modules section? See the UUID section for more information. Have you turned on file extensions and paths? If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab. Double-check JSON curly braces and brackets. JSON linting tools can help. Resource Pack Shows Up, Content Doesn't Work Check that the textures folder is in the right place, and spelled correctly. Then check the blocks folder as well. Download the Vanilla resource pack and try adding your block to the existing textures/blocks folder. Make sure the new texture file is named the same as the Vanilla texture it's replacing. Move your pack above others to ensure your dirt.png texture is loaded before other resource packs. What's Next?  With a custom texture now a part of your Minecraft world, it's time to see how behavior packs alter existing entity behaviors. In our next tutorial, you will add aggressive behavior to a normally peaceful cow.  Behavior pack  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/makerseriesmakingthegoblinchef", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating a Goblin Chef 05/06/2025  This tutorial is meant to be an inside look at how professional Minecraft creators make something cool from beginning to end. Instead of teaching the basics of creation tools, this tutorial assumes some base knowledge of creating in Minecraft and lets us spend more time talking about creative decisions like color choice or finding the right proportions. The goal is to give you direct insight into how pros think while they are creating, and hopefully you can learn some tips and tricks along the way.  These videos feature Mojang 3D artist Peter Sheff, as he walks you through the creation of a custom Goblin Chef entity. Here, we will take you from the early concept phase of the Chef all the way to it being ready to be placed inside of Minecraft. There are three parts to the tutorial: Part 1 is modeling, part 2 is texturing, and part 3 is animating. These videos are 10-15 minutes each, so feel free to watch each part separately.  Part 1: Modeling  In this video, Peter starts with the fundamentals of creating a new entity. The initial focus is using the 3D shape tools in Blockbench to focus on getting the 3D form of the Goblin Chef just right.  Part 2: Texturing  Now that the basic shape of the chef has been determined, it's time to apply a set of colors and textures to our new friend. Here, Peter focuses on the process of designing your UV textures including tips, tricks, and shortcuts for using various tools within Blockbench.  Part 3: Animating  In the animating section, you'll see how Peter animates the basic parts of the Goblin Chef, adding natural animations to the head, arms, and legs to create a walk cycle. You can see how to adjust the motion of various parts by adding keyframes in the Timeline tool of Blockbench.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsintroduction", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Commands 05/07/2025  Commands are specific instructions that Minecraft: Bedrock Edition will carry out. These instructions can be as simple as changing the time of day or as complex as setting up and working with a scoreboard. There are a wide variety of commands, and each has its own potential to improve your content.  Content creators use commands to change or react to the environment around the player. Rather than having a static world, the player would be able to perform a task that a command system could detect and respond to in some way. An example of this is detecting if a player has placed a colored wool block at a specific location for a \"Complete the Monument\" style of map.  In this tutorial, you'll learn the following:  What commands are and how to begin using them. Command syntax. How to use target selectors and selector parameters. Enabling Commands  Before getting started with commands, cheats must be enabled. This can be done when you create a world or when you edit an existing one. Be aware that enabling cheats will disable achievements for that world.  Activating cheats lets you use commands in the chat interface. Running commands in the chat is essential for getting the first command block in a newly created world, which must also be enabled (in the same menu) in order to use them. Command blocks will be enabled by default, so you do not have to change that option.  While not required, it's helpful to set the default game mode to creative when starting out, as command blocks can only be edited in creative mode. Setting the default game mode to creative will also activate cheats.  Finally, you may need to enable the \"operator commands\" permission for yourself in order to run commands in the chat and access command blocks. While this setting is on by default for new worlds you create, you may need to change this on previously created worlds or for other players you would like to grant this permission to. This can be done by opening the pause menu while in the world and clicking the icon to the right of your player.  A list of various permissions will be shown. The \"operator commands\" permission in particular must be enabled in order to use commands in the chat and access command blocks.  Using the chat for commands  The first step to learning commands is learning how to use the chat functionality. This is where you run simple commands, learn syntax, test, and ultimately open the gateway to command blocks. If your settings and permissions are set correctly, typing a forward slash / in the chat will display a large number of commands.  A quick-action button also becomes available to generate a command for specific situations (such as changing the time of day or the current weather).  As you type, the list of commands displayed on the chat screen will filter to match the characters you input. You can press tab to cycle through the list at any time in order to choose the command to run. When the name of the command has been fully typed out, the list of commands changes to a list of syntaxes for the selected command.   Note  If you open the chat and press the up arrow on your keyboard, you can see the previous commands you've entered. This comes in handy when you're entering variations of the same command over and over. And over.  Command syntax  All commands follow the same grammar:  Start the command with a forward slash (/). Follow the slash with the name of the command. If there are any arguments to the command, they come after the command, separated by spaces.  For example, the /say command sends a message to the chat for all players to see:  Copy /say Hello World  It starts with a forward slash. The command's name is \"say\". Because there are arguments, a space is placed after the name. Then, the only argument for /say is provided, the message to display.  As a result, \"Hello World\" will be printed out in the chat.  Arguments  Different commands need different arguments. The /help command describes both a command and the arguments it takes. The auto-complete feature, which is available in the chat when typing out a command, displays the same information.  For example, typing /help testfor in the chat will provide the available syntax for the /testfor command.  Copy /testfor <victim: target>   The command has only one argument: a target to test for the existence of. Filling in the argument with a player name and running the command will print out a success message if the named player is logged into the world.  Copy /testfor PlayerName   Arguments can be required, optional, or literal.  A required argument is shown in help surrounded by angle brackets, like <this>. In the case of the /testfor command, you can tell that the only argument it has is required. because it is surrounded by angle brackets. If the argument is not provided, the command will fail to run.  Required arguments have a short descriptor of the argument as well as the expected input type. For /testfor, the argument is the victim, and the input type is target: a player name or target selector. Other commands can take different kinds of input values for the same argument, such as /difficulty:  Copy /difficulty <difficulty: Difficulty> /difficulty <difficulty: int>   The /difficulty command sets the world's difficulty level. You can specify it as a Difficulty, the name of a difficulty level such as \"peaceful\", \"easy\", \"normal\", or \"hard\"; you can also specify it as an int, an integer number that corresponds to a difficulty level from 0 to 3. Either of these commands sets the difficulty to hard:  Copy /difficulty hard /difficulty 3   An optional argument is shown surrounded by square brackets, like [this]. Optional arguments don't have to be provided.  Copy /gamemode <gameMode: GameMode> [player: target] /gamemode <gameMode: int> [player: target]   As with the /difficulty command, the /gamemode command has two different ways to do the same thing: you can set the game mode by using the name of a GameMode, or using an integer from 0 to 2 corresponding to a game mode.  The gameMode argument is required, but the command takes an optional argument to specify a player who will have their game mode changed. The input type is \"target\", which accepts either a player name or a target selector. Without supplying the optional argument, the command will still run. Doing so changes the game mode of the player who executed the command. By filling in the optional argument, the game mode of the target will be changed instead.  Either of the following commands will set the game mode for the specified player (\"PlayerName\") to survival mode:  Copy /gamemode survival PlayerName /gamemode 0 PlayerName   A literal argument should be typed exactly as is, and when shown in help, it has no descriptors or value types.  A literal argument that's the first argument to a command generally acts as a subcommand. For example, the /time command has a literal argument called \"set\":  Copy /time set <amount: int> /time set <time: TimeSpec>   Since set is a subcommand, it's not shown in angle brackets, but it's still required.  Copy /time set 6000 /time set noon   A literal argument can have multiple accepted values. In those cases, a vertical bar separates the possible values. The /weather command uses this for the type of weather to apply:  Copy /weather <clear|rain|thunder> [duration: int] /weather rain 10000   An optional literal argument will be shown surrounded by square brackets. The final argument of /testforblocks is an optional literal argument that can be either \"all\" or \"masked\". If none is specified, it defaults to \"all\". The \"masked\" option will cause the comparison to ignore air blocks, allowing any block to exist at the destination where there would be an air block at the source.  Copy /testforblocks <begin: x y z> <end: x y z> <destination: x y z> [masked|all] /testforblocks 0 64 0 20 64 20 100 50 100 /testforblocks 0 64 0 20 64 20 100 50 100 masked  Input types  Any argument that isn't a literal argument will specify the expected input type after the descriptor.  Copy /command <descriptor: type> /command [descriptor: type]   There are a large number of input types. The most common ones are primitive numeric values, but there are many that are exclusive to one command. The table below details the most common input types and some popular commands they belong to. Most unique input types, such as \"GameMode\" from the /gamemode command, can easily have their input checked by using the auto-complete feature in the chat.  Expand table Type\tDescription\tCommon commands Boolean\ttrue or false.\t/effect, /gamerule int\tAn integer (1, 2, 3).\t/give, /scoreboard, /time, /weather, /xp float\tA decimal number (1, 2.3, 4, 5.6).\t/spreadplayers string\tEither a single word or text within \"quotation marks\".\t/scoreboard, /summon, /tag message\tText that does not need to be in quotation marks.\t/me, /msg, /say, /tell, /title, /w x y z\t3 floats separated by spaces to specify coordinates.  Each value can also be a tilde (~), which indicates no change from the execution origin on that axis, or a tilde followed by a number (~5) to indicate the number of blocks away from the execution origin on that axis.\t/clone, /execute, /fill, /setblock, /summon, /teleport, /testforblock Block\tA block ID.\t/clone, /execute, /fill, /setblock, /testforblock Item\tAn item ID.\t/clear, /give, /replaceitem EntityType\tAn entity ID.\t/summon json\tJSON-formatted text.\t/give, /replaceitem, /summon, /tellraw, /titleraw target\tEither a player name or a target selector.\t/clear, /execute, /gamemode, /give, /kill, /replaceitem, /scoreboard, /tag, /teleport, /testfor What's Next?  Now that you've learned about commands, you can learn more about target selectors, commands, or about how to use command blocks to move beyond the chat window.  Target Selectors Popular Commands Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoaddentity", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating New Entity Types 04/16/2025  You can add new entity types to Minecraft: Bedrock Edition using a combination of behavior packs and resource packs. As you learned from the recommended tutorials, the behavior of entity types can be changed with a behavior pack, and you can change the appearance with a resource pack. Both are required to add a new entity type to the game.  This guide has two parts: the first part covers the files and folder structure needed to add a custom entity type to Minecraft. The second part shows you how to breathe life into the entity using behavior components and animations.  In this tutorial you'll learn:  How to create a new custom entity type using behavior and resource packs. How to apply various features to the entity type, including components and animations. Make use of translations for entity names.  It's recommended you complete these before beginning this tutorial:  Introduction to Behavior Packs Introduction to Resource Packs Download the min robot and full robot resource and behavior packs  In addition, it will be helpful if you have a code editor like Visual Studio Code, and if you're familiar with how the JSON format works.  File structure  In the behavior pack, an entity file is responsible for defining the entity on the server side. In the resource pack, a client entity file is responsible for telling the game how the entity will look. The following graphic shows how different files can interact to create a custom entity:  Robot entity example (minimum)  To give you a point of reference for this tutorial, we are providing two versions of the same entity: a robot that can spawn randomly in the world and has three random textures, a wheel animation, various components, and a custom water mechanic. The download link is in the Requirements section above.  To see the robot in action, pick one of the sets of resource and behavior packs you just downloaded. (We recommend trying the minimum one for now.) Put the resource and behavior packs in their respective com.mojang sub-folders, launch a world with cheats enabled, and use /summon sample:robot.  This is the structure of the finished \"minimum robot\" behavior pack and resource pack:  This looks like a lot, but you only have to think about the files with \"robot\" in the name and where they are stored.  After you get an idea how the robot acts in the game, you can remove the finished robot resource and behavior packs and re-create them from scratch with the steps of this tutorial to get an idea how all the files work together.  A good starting point would be to use the resource and behavior packs you created in the earlier tutorials. You might want to remove the attack cow entity, but that's a personal preference.  Naming  When you create an entity, one of the first things to consider is what ID you're going to give it. The files in your resource and behavior packs will need to be synced using the entity ID that you give your entity. This ID consists of a namespace and a name separated by a colon. That was the sample:robot ID we used previously to summon the robot.  Your own namespace can be a short version of your team name or product name. The ID should only include lower case letters, digits, and underscores. Don't use \"minecraft\" as the namespace for your custom content. The \"minecraft\" namespace is reserved for vanilla resources, so you should only use \"minecraft\" if you are overwriting vanilla content.  Most files that define the entity will be JSON files. To avoid confusion, we suggest you follow a standard naming convention as you create each of these files. The game ignores file names in most cases, but when working on an Add-On, messy file names can be confusing. The standard conventions are:  Expand table File Type\tFile Name Client Entity Files\tentity_name.entity.json Model Files\tentity_name.geo.json Animation Files\tentity_name.animation.json Animation Controllers\tentity_name.animation_controllers.json Render Controllers\tentity_name.render_controllers.json  entity_name should be replaced by the name of your entity, not including the namespace.  Format versions  Each JSON file should have a format_version tag. This tag is important for the game to correctly read the file. Files made in older formats will still work in newer versions of the game, but only if the format version is set correctly. Incorrect format versions are a frequent source of errors.  Behavior pack definition  The first step to add a robot into the game starts in the behavior pack. Create a new file in the entities folder of the behavior pack and name it robot.json. Copy and paste in this code.  JSON Copy {     \"format_version\": \"1.12.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"is_spawnable\": true,             \"is_summonable\": true         },         \"components\": {}     } }   Inside the description tag, we define basic attributes of the entity:  identifier sets the ID for the entity. is_spawnable adds a spawn egg into the game that allows the player to spawn this mob. is_summonable makes the entity work with the /summon command.  Inside components, we're going to add components to change the behavior of the entity. For now, we are adding only the minecraft:physics component. This will give the entity gravity and regular collision behavior.  JSON Copy \"components\": {     \"minecraft:physics\": {} }   Save your robot.json file and move on to the next step.  Client entity definition  Now, we need to add the entity to the resource pack to give it a visual appearance. In the entity folder of the resource pack, create a new JSON file called robot.entity.json.  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   This is the basic structure of the file. So far, it's similar to the behavior-side file we made in the previous section. Note that we now use client_entity instead of just entity. At the time of writing this article, 1.10.0 is the latest format version for this file.  The spawn_egg tag defines how the spawn egg will look in the inventory. Using this method, it will look like a vanilla spawn egg, but with customized colors.  Visuals  Before we can add the entity into the game, it needs a model. The Entity Modeling and Animation article explains how to create a custom model and texture, but creating a model is a lot to learn and we're not done with this tutorial yet! So for now, pretend you already created a model by copying and pasting the files from the robot resource pack. Use these same steps later to add the model you create.  Save the model inside the folder models/entity as robot.geo.json. Save the texture in textures/entity as robot.png.  Now that the model files are in place, we need a render controller to link the model, texture, and material that's used for the entity.  Open the robot.entity.json file in the entity folder in your resources pack.  For most entities (such as our robot), we can use the default render controller that's provided by the game. We will talk more about render controllers later in the more advanced part of this tutorial. For now, just know that this is where it goes and this should be the content:  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"materials\": {                 \"default\": \"entity\"             },             \"textures\": {                 \"default\": \"textures/entity/robot\"             },             \"geometry\": {                 \"default\": \"geometry.robot\"             },             \"render_controllers\": [                 \"controller.render.default\"             ],             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   The model is referenced by the geometry name. If you create a model in Blockbench, make sure the geometry name in the project settings is set to your entity name—in this case, \"robot\".  Unlike geometries, textures are linked by their path in the resource pack, minus the file extension, as shown in the example.  In most cases, a custom material is not required. Instead, you can use a default material. In this example, we use entity. If the texture has transparent parts, you can use entity_alphatest, or if your texture is translucent (like stained glass), you can use entity_alphablend.  Translation strings  Right now, neither the entity itself nor the spawn egg has a proper name in game. To define a name, we need a language file.  Create a new folder called texts inside your resource pack and create a new file called en_US.lang. This is the only language file required for custom entities, as it's used as a fallback for translations when strings in other languages aren't available.  Inside this file, add these two lines:  JSON Copy entity.sample:robot.name=Robot item.spawn_egg.entity.sample:robot.name=Spawn Robot   The first line defines the name of the entity. This will be visible in death messages and in the output of some commands. Key and value are always separated by an equals sign. The first line can be broken down into:  entity.<identifier>.name=<Name>  The second line defines the item name of the spawn egg:  item.spawn_egg.entity.<identifier>.name=<Name>  Testing  Make sure to test early and often. Encountering an issue early on helps to simplify tracking it down, which can make it easier to fix. Testing often will reveal issues soon after making changes, which helps to narrow down the cause to those recent changes.  You should be able to spawn your entity in game using the spawn egg or the summon command. If you just want a static entity, you're good to go. But if you want to customize the entity even more, keep on reading.  Robot entity example (full)  Now would be a good time to try the full robot resource and behavior packs. Compare the collection of folders and files. Then, put back your minimal robot packs so we can continue adding functionality.  Components  Components tell the entity how to act in game. Let's add a few components and explain in detail what they do.  In the behavior pack/entities/ folder, open robot.json and replace the single entry of \"minecraft:physics\": {} with all of this:  JSON Copy    \"components\": {         \"minecraft:physics\": {},         \"minecraft:nameable\": {},         \"minecraft:movement\": {             \"value\": 0.25         },         \"minecraft:movement.basic\": {},         \"minecraft:jump.static\": {},         \"minecraft:navigation.walk\": {             \"avoid_water\": true         },         \"minecraft:behavior.tempt\": {             \"priority\": 1,             \"speed_multiplier\": 1.4,             \"items\": [\"diamond\"],             \"within_radius\": 7.0         },         \"minecraft:behavior.random_stroll\":         {             \"priority\": 3,             \"speed_multiplier\": 0.8         },         \"minecraft:experience_reward\": {             \"on_death\": 8         }    }  Expand table Component Name\tDescription minecraft:nameable\tAllows the player to name the entity with a name tag. minecraft:movement\tTells the entity how fast to move. 0.25 is the regular speed of most animals in Minecraft. minecraft:movement.basic\tGives the entity the ability to move on the ground. minecraft:jump.static\tAllows the entity to jump in order to walk up blocks. minecraft:navigation.walk\tAllows the entity to navigate through the world. Avoid water is one of the options that this component comes with. minecraft:behavior.tempt\tMakes the entity follow players who hold diamonds in their hand. We are giving this behavior a higher priority so it will prioritize this action (lower number = higher priority). minecraft:behavior.random_stroll\tWill make the entity randomly walk around the place. We're setting the priority to a higher number so the entity will only do this when it has nothing else to do. The speed multiplier will decrease the speed while using this walk behavior. minecraft:experience_reward\tLets the entity drop experience when killed by a player. Animations  In this section, we'll add a simple wheel animation to the robot. If you want to learn more about animations, how to use animation controllers, and how to create animations in BlockBench, read this guide.  Animations are stored in animation files. So the first thing we need to do is create a folder called animations in the resource pack and create a file called robot.animation.json inside it. In that file, we'll create a new animation called animation.robot.drive. We also want to set loop to true so the animation will keep playing. The file should look like this:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true         }     } }   Animations allow us to animate the position, rotation, and scale of each bone. (If you don't know what \"bone\" means in that context yet, that's okay—you'll learn about bones when you learn Blockbench. For now, just know that it means a chunk of the model, like a leg or a wheel.) Animations can be done with keyframes, Molang expressions, or a combination of both. In this example, we'll just use Molang expressions.  Molang is a language just for resource and behavior packs. It allows us to get various numbers from the entity using a query and calculate a result out of these numbers using math expressions. For example, the query query.modified_distance_moved will return the distance the entity has moved. We can use it to calculate the rotation of the robot wheel on the X-axis, which will result in an animation that makes the robot look like it is driving. You have to play around with the numbers, but for this model 60 worked quite well.  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true,             \"bones\": {                 \"wheel\": {                     \"rotation\":[\"query.modified_distance_moved*60\", 0, 0]                 }             }         }     } }   Now that the animation is created, we need to link it in the client entity file. (Remember, the resource pack is the client, so open <resource pack>/entity/robot.entity.json for this next part.) The animations tag links all animations and animation controllers that are used by the entity. Each animation gets a short name that can be used to play the animation in an animation controller or directly in the file, in this case drive.  The scripts and animate sections can be used to directly play animations:  JSON Copy         \"animations\": {             \"drive\": \"animation.robot.drive\"         },         \"scripts\": {             \"animate\": [\"drive\"]         }   With these two tags added in the description tag of the client entity file, the drive animation will always be active and advance the wheel rotation while the entity is moving.  Render controllers  Render controllers allow us to change the geometry, textures, and materials of the entity using Molang. The following example shows how to use the geometry, material, and texture that have been linked in the client entity file as default:  JSON Copy {     \"format_version\": \"1.8.0\",     \"render_controllers\": {         \"controller.render.robot\": {             \"geometry\": \"Geometry.default\",             \"materials\": [ { \"*\": \"Material.default\" }],             \"textures\": [ \"Texture.default\" ]         }     } }   If we just want to use one default geometry, material, and texture, we can just leave it pointing to the default render controller as we did before. But this is a good time to learn how to add random textures, so let's break down how render controllers work.  One entity file can contain more than one render controller. Each controller goes between the braces in the value of the render_controllers key.  Each controller is named using the scheme controller.render.<entity-name>. Our one controller is named controller.render.robot. For a multi-purpose render controller, we can also use another keyword instead of the entity name.  Inside the render controller tag, the different resources are specified, but you'll notice each one uses a different JSON value.  Geometry  One render controller can display only one geometry at a time, so the geometry key can only be a single string value. This string can be a Molang expression and should always return a geometry. In this case, it's calling Geometry.default, which means that it will return the geometry that's linked as default by whatever entity using the render controller.  You can render multiple geometries on one entity by using multiple render controllers. This can be tricky though, and can lead to unexpected behavior. Therefore, it's only recommended for experienced creators.  Materials  Unlike geometry, the materials value is an array of objects. We can assign each bone a separate material. Each object in the array can have one key-value pair. The key selects a set of bones. An asterisk is used as a wildcard. This means that all bones, no matter the name, will have the default material assigned. Note that materials are assigned in order, meaning that materials further down in the list can overwrite previous materials.  JSON Copy   \"materials\": [     { \"*\": \"Material.default\" },     { \"*_arm\": \"Material.transparent\" }   ],   In this example, we first apply the default material to all bones. Then, we overwrite the material with the transparent material on all bones that end in _arm. That way, all arm bones would support transparency.  Textures  Textures are specified as an array of strings. In most cases, only one texture will be linked here, since entities don't support separate textures. There is one exception: materials can support multiple textures layered on top of each other, such as the material entity_multitexture. For example, this is used by llamas to overlay the décor.  Arrays  When working with multiple resources of one type, it can be useful to use an array. An array is a list of resource links that are defined in the render controller, and that you can pick one resource from using Molang.  We can define an array for the robot like this:  JSON Copy   \"controller.render.robot\": {     \"arrays\": {       \"textures\": {         \"Array.variant\": [           \"Texture.default\",           \"Texture.variant_b\",           \"Texture.variant_c\"         ]       }     }   }   In the arrays section we can define arrays for each of the three categories: textures, materials, and geometries. Inside the category, you can define arrays using Array.<array name> as the name. Each line inside the array links one texture that's defined in the client entity file.  You can access the array using Molang. Arrays are 0-based (that is, the first item is numbered 0, the second 1, and so on), so the first texture in this array can be accessed through Array.variant[0].  In this example, we're using the variant query to pick a texture from the array. The variant of a mob can be changed through the minecraft:variant component in the behavior file.  JSON Copy \"textures\": [ \"Array.variant[ query.variant ]\" ]   Now we need to link the additional textures in the client entity file. The regular, blue robot texture is already linked as default, and we will now create two copies of the robot texture file, edit the color, and link them as variant_b and variant_c.  JSON Copy             \"textures\": {                 \"default\": \"textures/entity/robot\",                 \"variant_b\": \"textures/entity/robot_b\",                 \"variant_c\": \"textures/entity/robot_c\"             },   Now, the textures are linked. The last step is to randomize the variant in the behavior file. We'll use component groups for this. Those are a way to add and remove a set of components from the entity at any time. We'll also use an event that randomizes which component group to add.  JSON Copy         \"description\": {             ...         },         \"components\": {             ...         },         \"component_groups\": {             \"sample:color_0\": {                 \"minecraft:variant\": {\"value\": 0}             },             \"sample:color_1\": {                 \"minecraft:variant\": {\"value\": 1}             },             \"sample:color_2\": {                 \"minecraft:variant\": {\"value\": 2}             }         },         \"events\": {             \"minecraft:entity_spawned\": {                 \"randomize\": [                     {                         \"add\": {                             \"component_groups\": [\"sample:color_0\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_1\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_2\"]                         }                     }                 ]             }         }   Now, when we first spawn the entity, it will randomly choose a component group and therefore a variant. This is a very common technique to randomize the appearance of an entity.  Spawning  Spawn rules define how entities randomly spawn in the world. We'll create a spawn rules file for our robot.  First, create a folder called spawn_rules in your behavior pack. Inside the folder, create a new text file called robot.json. The content of the file should look like this:  JSON Copy {   \"format_version\": \"1.8.0\",   \"minecraft:spawn_rules\": {     \"description\": {       \"identifier\": \"sample:robot\",       \"population_control\": \"animal\"     },   \"conditions\": []   } }   Inside minecraft:spawn_rules, there are two things that we need to consider: population control and conditions.  description defines the basic properties of the file. identifier should match the identifier of our entity. population_control defines how the game knows how many mobs to spawn and is a little more complicated.  Population control  There are different pools of entities. When the pool defined here is considered full, the game will no longer spawn mobs of this pool. There are three different options:  \"animal\": Passive mobs such as cows and pigs \"water_animal\": Water-based mobs such as tropical fish and dolphins \"monster\": Hostile mobs such as skeletons and zombies  For the robot, we're using the animal pool.  Conditions  conditions is an array of possible conditions that allow a mob to spawn in the world. Each of the conditions consists of a group of components that define when and when not to spawn the mob.  For a basic spawn rule, one condition is enough. For the robot, we will use this configuration:  JSON Copy {     \"format_version\": \"1.8.0\",     \"minecraft:spawn_rules\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"population_control\": \"animal\"         },         \"conditions\": [             {                 \"minecraft:spawns_on_surface\": {},                 \"minecraft:brightness_filter\": {                     \"min\": 12,                     \"max\": 15,                     \"adjust_for_weather\": false                 },                 \"minecraft:weight\": {                     \"default\": 40                 },                 \"minecraft:biome_filter\": {                     \"test\": \"has_biome_tag\",                     \"value\": \"animal\"                 }             }         ]     } }  Expand table Component Name\tDescription minecraft:spawns_on_surface\tThe mob spawns on the surface minecraft:brightness_filter\tOnly spawn the entity at a certain brightness. Accepts three options, min, max, and adjust_for_weather. Light levels range from 0 to 15. If adjust_for_weather is set to true, the light level decrease due to rain and thunderstorms will be taken into account. minecraft:weight\tThe weight of the entity in spawning. The higher the number, the more often the mob will spawn. minecraft:biome_filter\tFilters the biome the mob is allowed to spawn in. Biome filters work similarly to filters in behavior, which means that operators like all_of and any_of are allowed. Biomes have different tags that indicate the biome type, variant, dimension, and features like monster and animal.  Robots will now spawn anywhere on the surface where animals can spawn and where there is sufficient light. With a weight of 40, they'll also spawn quite frequently.  Behavior animations  Behavior animations work similarly to regular animations but run in the behavior pack. While regular animations animate the movement of the model as well as sounds and particles, behavior animations can run regular commands, trigger entity events, or run Molang expressions. Behavior animations are also often referred to as Entity Events, although that name tends to be a bit confusing.  Since robots don't like water, we'll add a mechanic to damage robots in water or rain. First, we're going to create an animation controller to test when the entity is in water using a Molang query. Create a new folder in the behavior pack called animation_controllers and create the file robot.animation_controllers.json inside it:  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {     \"controller.animation.robot.in_water\": {       \"states\": {         \"default\": {           \"transitions\": [             {\"in_water\": \"query.is_in_water_or_rain\"}           ]         },         \"in_water\": {           \"transitions\": [             {\"default\": \"query.is_in_water_or_rain == 0\"}           ]         }       }      }   } }   The animation controller looks very similar to regular client-side animation controllers. It has two states that get toggled depending on whether the robot is in water or not.  Now, let's add an animation to give a poison effect to the robot. Create the folder animations inside the behavior pack and create a file called robot.animation.json:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.poison\": {             \"loop\": true,             \"animation_length\": 1,             \"timeline\": {                 \"0.0\": [                     \"/effect @s poison 2 0 true\"                 ]             }         }     } }   Instead of using the bone tag here to animate bones, we're using the timeline tag. In resource packs, timelines can only be used to run Molang code. In behavior animations, you can use this to run Molang code, commands, or trigger entity events. Note that all these are provided as a string. The game will figure out the type of the string from its content. If the string starts with a slash, it will run as a command. If it matches a scheme such as @s namespace:event, it will run as an entity event. If it looks like Molang, it will run as Molang.  For that reason, it's important to start commands with a slash in behavior animations. Also, note that we're applying poison for two seconds because one would not be enough to actually apply damage. The true at the end of the command makes the status effect ambient, meaning that there won't be any particles.  As with animations in resource packs, we need to link all of our animations and animation controllers in the description tag of our entity like this:  JSON Copy   \"description\": {     \"identifier\": \"sample:robot\",      \"is_spawnable\": true,      \"is_summonable\": true,      \"animations\": {         \"poison\": \"animation.robot.poison\",         \"in_water\": \"controller.animation.robot.in_water\"       },       \"scripts\": {         \"animate\": [           \"in_water\"         ]       }   }   The animations section lists all animations and animation controllers that the entity uses and gives them a short name. In the scripts/animate section, we list the animations that should always run. We want the controller to detect the state to always run, but not the poison effect.  Now, we need to go back to the animation controller and add the poison effect. We'll also add a little regeneration mechanic along with a sound effect, so the robot won't die as easily.  JSON Copy   \"states\": {     \"default\": {       \"transitions\": [          {\"in_water\": \"query.is_in_water_or_rain\"}       ]     },     \"in_water\": {       \"animations\": [         \"poison\"       ],       \"on_exit\": [         \"/effect @s regeneration 2 4 true\",         \"/playsound random.fizz @a[r=16]\"       ],           \"transitions\": [         {           \"default\": \"query.is_in_water_or_rain == 0\"         }       ]     }   }   In the animations array, we list all the animations that should be running in this state, which is just poison in our case.  In the on_exit tag, we add two commands that will run when the robot exits the water. The first command will give the robot a regeneration effect level four for two seconds. The second command will play a fizzing sound effect.  Note that we could have also run the command in the on_entry array of the default state, but that would've also played the effects when spawning the robot or reloading the world because the game will always first transition into the default state.  To summarize the relationship between controllers and animations: an animation controller is used to control when an animation plays, while an animation itself is what occurs as a result of transitioning to the animation as determined by the controller. Animations and animation controllers are supplied to the entity behavior file.  What's Next?  In this guide we have added a complete custom entity to the game. If you used the existing model files instead of creating your own, now might be a good time to learn about Blockbench. Or, you can read more about entity behavior for the server.  Entity Modeling and Animation Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createnpcs", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create a Custom NPC 09/20/2023  Non-Player Characters (NPCs) are characters in Minecraft that are not controlled by the player. NPCs can perform commands and deliver dialog when players interact with them, making them excellent tools for creating narrative and gameplay experiences.  In this tutorial, you will learn the following:  How to create an NPC. How to change NPC skins. How to add commands to an NPC. How to add buttons to an NPC. Prequisites  To create NPCs, start in a world with the following settings:  Creative mode Cheats enabled Operator permissions   Note  Later, to interact with your custom NPCs, you will need to switch from Creative mode to either Survival mode or Adventure mode.  Spawn an NPC  To obtain a custom NPC, follow these instructions:  Get an NPC spawn egg from the creative menu or by using the command /give @p spawn_egg 1 51. Right-click to place an NPC on your desired block. If you misplace an NPC, you can left-click to despawn them. Right-click the NPC to open the NPC interface. Enter a name for your NPC. Names are limited to 32 characters. You can use color codes to change the color of the name text.  The NPC editor has a built in dialog feature to give players more information about the commands they will execute or to deliver story details.  This dialog box has a limit of 307 characters before the text goes off the screen. You can also use color codes to change the color of the text.  You can use behavior packs and commands to create a more advanced dialogue system for your custom NPCs. See NPC Dialogue Command for more information.  Change NPC skins  You can choose from a list of skins to customize the appearance of your NPC.  To change an NPC's skin, follow these instructions:  Right-click the NPC you want to edit. In the Appearance section, click the skin that you want to use for your NPC. You can use the left and right arrow buttons to see more skins. Add commands to an NPC  You can add commands to an NPC that the NPC will execute after a player closes their dialog window. Unlike a Command Block, a single NPC can execute multiple commands.  To add commands to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. If you want to add more commands, click the Add Command button and enter the commands you want to enter.  Your NPC will execute these commands in order whenever a player interacts with them and closes their dialog box. There is more information about commands in the Introduction to Commands article.  Advanced Command Settings  There are settings to customize the way commands work with NPCs.  Button Mode  If Button Mode is toggled on, a text box appears where you can enter text that will appear on a button. This command will only run if the button is pressed.  For example, we could use a combination of the command /give @p gold_ingot and a button labelled Money? When players click the Money? button, they receive one gold ingot into their inventory.  On Enter  If On Enter is toggled, then the command will run when players initiate a conversation with the NPC.  In this case, with On Enter toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box opens on dialogue initiation with the NPC.  On Exit  If On Exit is toggled, then the command will trigger when the player ends and interaction and closes the NPC dialogue.  In this case, with On Exit toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box closes and the NPC interaction ends.  Add buttons to an NPC  You can also add buttons to an NPC. If you use the Button Mode setting, an NPC command will be displayed as a button in the NPC's dialog box. Players who interact with that NPC can click the appropriate button to execute that command.  To add buttons to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. Activate Button Mode and enter the button text in the new field.  If you want to add more buttons, click the Add Command button and repeat this process.  Once you have added your button commands, your NPC will display the command buttons in order after their dialog when players interact with them.  What's Next?  With the NPC created and the first dialogue box has been created, you can learn how to create branching dialogue boxes to design your own custom narrative driven content.  NPC Dialogue Command  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoloottables", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Loot Tables 03/06/2025  When you do something fun and get rewarded with loot in Minecraft, a loot table was involved.  With just a few lines of JSON, loot tables control what you find when you break a block, open a newly discovered chest, interact with an entity, and use differently enchanted items in typical gameplay.  Loot table files live in a directory (cleverly named loot_tables) at the root level of a behavior pack.  The five categories of loot tables in Vanilla Minecraft are blocks, chests, entities, equipment, and gameplay (such as fishing, milking a mooshroom, or watching your sniffer find seeds).  If you have more than one type of loot table in your behavior pack, it would be a good idea to put each type in its own subfolder. But this is not required.  A loot table file generally consists of three main sections collectively known as a \"pool.\" As a creator, you might want to have different pools so you can drop different loot to your players if they satisfy different loot table conditions.  Rolls Rolls dictate how many times the pool will be rolled to select an entry. This could be either an integer which will result in a set amount of rolls or a min/max range from which the number of rolls can be chosen. Loot Table Conditions These are optional requirements that must be met for the pool to be rolled. Some of the more interesting functions you might want in your gameplay include setting the lore on an item (set_lore) and putting your own content into a book (set_book_contents). Entries This is a list of objects the game will select from in this roll. It can be an item, a loot_table, or empty if you want a chance of nothing happening this roll.  As an example, here is the loot table for when you have a pet cat and it brings you a gift in the morning:  JSON Copy {   \"pools\": [     {       \"rolls\": 1,       \"entries\": [         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_hide\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_foot\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:chicken\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:feather\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rotten_flesh\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:string\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:phantom_membrane\",           \"weight\": 2         }       ]     }   ] }   As you can see, getting a phantom membrane is rarer than getting a bit of string or a chicken. Imagine a cat bringing down a phantom! Now you know why they avoid cats...  What's Next?  We suggest taking a look at loot table functions next, followed by conditions, then loot overloads. Once you've gotten comfortable with all of the intricacies of those topics, jump into the tutorial and create your own loot table!  Loot and Trade Table Functions Loot Table Conditions Loot Table Overloads Creating a Loot Table  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxgettingstarted", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Ray Tracing 06/11/2025   Tip  While ray tracing is still supported, it's largely been superseded by Vibrant Visuals.  Minecraft: Bedrock Edition has cutting-edge path-traced ray tracing, enabling gamers and world builders to craft incredible new sights and immersive environments. Physically-based textures have been introduced for creating more complex and realistic (or fabulously unrealistic!) block textures. To further enhance the visual experience of RTX, creators can also define their own settings for fog via resource packs.  With these new features, creators can dramatically change the look and feel of the game. Immerse players in volumetric fog or use a cutting-edge, dynamic lighting system to make a world more vibrant.   Ray Tracing Off with Physically-Based Textures   Ray Tracing On with Physically-Based Textures  By the end of this series, you will learn:  How ray tracing can be used Minecraft. How to enable ray tracing in Minecraft. How to create a physically-based texture resource pack. Requirements  It's recommended that you have the following when working with ray tracing in Minecraft: Bedrock Edition:  Operating System (OS): Windows 64-bit GPU: DirectX hardware ray tracing capable GPU like NVIDIA GeForce® RTX 20 Series and higher, and AMD Radeon RX 6000 Series and higher Hardware: PC CPU: Intel Core i5 or equivalent RAM: At least 8 GB of RAM Minecraft: version 1.16.200 or higher   Important  Virtual Reality (VR) headsets and Mixed Reality (MR) headsets are not supported.  Ray Tracing Examples in Minecraft  Ray tracing makes Minecraft look more like the real world. Rays of light shine from different sources onto block textures that can reflect, absorb, and scatter light in different ways. The result is a highly realistic depiction of the way light behaves, creating dramatic effects.  Expand table Features\tExample Sunbeams and atmospherics - Directional shafts of light typically occur at sunrise and sunset when sunlight passes through particles in the atmosphere or underwater.\t Dynamic shadows - More realistic shadows that change as lighting conditions change.\t Ambient Occlusion - shadows cast in corners or crevices where light rays cannot escape\t Reflections - Light bounces off surfaces, both casting and picking up color as it travels. Bouncing light hits smooth surfaces and maintains a spread depending on the material. This can create diffuse reflections or very sharp ones.\t Refraction - As light passes through translucent materials, it bends and bounces. The image you see may be distorted, refracted, and its color will be affected by the translucent material.\t Explore a Ray Tracing World in Minecraft  If you meet the minimum requirements and you are on the Windows version of the game, you can check out a ray tracing world now. Many free worlds featuring PBR and ray tracing are available in the Minecraft Marketplace, with more to come. You can find all the content supporting ray tracing in the Marketplace by selecting the blue icon.  Next, we will create PBR textures as a resource pack and you can enable it in the downloaded ray tracing world.  What's Next? Introduction to Physically Based Rendering  You will learn about each new texture map creators can use to build and design photorealistic materials and lighting effects, and you will learn how to use texture maps to create a mirror in-game.  Introduction to Physically Based Rendering  Fog in Resources  Along with ray tracing, fog in Minecraft has been updated to use a similar JSON structure that allows you to create and control its in-game appearance.  Fog in Resource Packs  Feedback  Was this page helpful?  Yes No Additional resources  Documentation  Physically Based Rendering Tutorial  A guide to creating textures using RTX Physically Based Rendering with Adobe Photoshop  Fog in Resource Packs  A guide detailing the way in which fogs are established in resource packs  Actor Storage in Minecraft - Bedrock Edition  How actor data is organized in the LevelDB on disk  Show 3 more  Training  Learning path  Get Started with Azure Remote Rendering - Training  Learn the fundamentals of rendering 3D models with Azure Remote Rendering."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontostructureblocks", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gametestgettingstarted", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to the GameTest Framework 06/20/2024  GameTest Framework is a toolset available to creators to build and test any new content created by you. Within the world of Minecraft: Bedrock Edition, you can express infinite forms of gameplay and variability in your content. With all these creative possibilities, sometimes you may need additional tools to help validate that your experiences are running just as you expect it, and assist you as you customize aspects of the broader Minecraft environment.  What happens if you change the behavior of Villagers? Or introduce a new Mob? Small changes can have unexpectedly big impacts that can be really hard to anticipate. With the GameTest Framework - a system for establishing sets of tests - you can track and repeat to ensure everything works the way you intend.  With these tests, you can express and document your expectations for how things should work - both for your content and games, and for the Minecraft world. You'll be able to save time by using GameTests to take the place of repeatedly needing to manually play through conditions just to validate that all is working as expected.  Submitting and using GameTests can be a great way to establish and communicate the expected behavior you are looking for. As you build more complex worlds and adventures, use the GameTest Framework as a tool to validate facets of your content.  Requirements  To get started, you'll want to begin with understanding how a behavior pack works within Minecraft. To read more about creating behavior packs, see this topic:  Introduction To Behavior Packs What's a GameTest?  A GameTest is a miniature environment along with a set of starting conditions, such as a set of mobs or items. After that environment plays out in the Minecraft world for a period of time, a GameTest has conditional code that evaluates whether expected conditions were met. If a test passes, you will receive confirmation that everything is working as expected. When a test fails, you can observe and diagnose why it may have failed.  Let's examine a potential use case for a GameTest. Let's say that we want to validate that a minecart can make its way around curves and over a complex track when Redstone triggers it. We can build a GameTest for this case by building out a track, placing a minecart at the start of the track, and then power the track with a block of Redstone. We can then validate that the minecart reaches the end of its track within a reasonable time-frame. Minecraft includes a growing set of GameTests that test various basic situations in the Minecraft world. However, you can build your own GameTests to validate any changes you introduce.  Running tests within game  To run tests within a game, you'll want to create a new world or start with a copy of your existing adventure and experience.  Within this GameTest world, you'll want to ensure that cheats are enabled and that the Beta APIs experiment is turned on. If you've created GameTest Framework tests within behavior packs, you'll want to add those behavior packs in your world. You can see an example set of gametests available at https://github.com/microsoft/minecraft-gametests. You'll want to download this pack of gametests, copy them into your developer_behavior_packs folder in Minecraft, and then create a world that uses this behavior pack.   Important  You'll also likely want to specify some additional changes in your environment:  Selecting a Creative game mode Selecting a Flat world You will want to retain Normal difficulty (mobs work differently compared to Peaceful worlds)  Once the world is loaded, use the /gametest command to run tests.  To run the default set of tests, use /gametest runset.  What's Next?  Building sets of GameTests requires building out your GameTests via a behavior pack, and writing some simple JavaScript code. When building out your own tests, you will likely want to start a new test behavior pack that is just focused on adding additional GameTests.  Build your first GameTest  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commonlyusedtools", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Commonly Used Tools 06/27/2024  There are a wide variety of tools that have been created for the purpose of increasing the efficiency of Minecraft content creation. Tools can help with a variety of things from creating skins, to crafting beautiful custom worlds. This article will explore some of the most commonly used tools currently available and some of their uses.   Important  These tools are provided by external, third-party contributors and are not Mojang/Microsoft offerings. Users should use at their own discretion.  Creating maps  Map creation is one of the largest and most time-consuming components of content creation. That being said, there are a significant number of map creation tools available to make this process significantly more efficient.  Chunker  Chunker is a Java-based tool for Minecraft: Bedrock Edition worlds. It's specifically useful for converting worlds between Minecraft: Java Edition and Bedrock Edition, as well as easily configuring world settings. Conversion includes level settings, chunk data (such as blocks and biomes), dimensions, and more. To learn more about using Chunker, you can begin with the Chunker Overview guide, which goes over the steps needed to do simple conversions and leads to more advanced features of the tool.  Amulet  Amulet is a utility tool designed to edit Minecraft maps. It can come in handy for world development, having helpful abilities such as replacing blocks in a selected area and the ability to create and remove chunks within a world. There's also a massive variety of community-made custom plugins referred to as \"operations\" that allow creators to perform a wide variety of tasks. Included below is a list of operations that can be useful for map creation:  Abrightmore's Amulet operations PREMIEREHELL's Amulet operations StealthyExpert's Amulet operations 5uso's Amulet operations Image Map  Image Map is a small application for both Bedrock Edition and Java Edition that can convert images to Minecraft maps. This can be used to add custom banners and art inside of Minecraft worlds.  Server Based Tools  Many commonly used tools are designed to be used on Java Edition servers utilizing a server software known as Spigot, which is based on the Craftbukkit API. The following tools are plugins that work on servers running this software.  Fast Async WorldEdit (FAWE)  WorldEdit is an in-game Minecraft map editor for Java Edition. It allows creators to perform a wide range of build-related commands, as well as utilize brushes that help sculpt Minecraft worlds. Some notable features include the ability to copy and paste selected areas, as well as rotate selected areas to face a different direction. This is especially useful when creating large builds with lots of repeating patterns. Linked here is the Fast Async WorldEdit project, a spinoff that includes some big performance boosts from the original WorldEdit, as well as some useful features for creative builders.  Voxel Sniper Flattened  Voxel Sniper Flattened is another in-game Minecraft map editor for Java Edition. It allows creators to edit any block in sight using an arrow (for replacing blocks) and gunpowder (for adding blocks). It contains a wide array of brushes that can be used for anything from precise block placements to large terraforming jobs. This plugin is a continuation of the original VoxelSniper.  goBrush  goBrush is a server plugin for Java Edition that adds in-game tools designed for custom terrain editing by using heightmap brushes instead of geometric shapes like tools such as WorldEdit and Voxel Sniper Flattened.  goPaint  goPaint is a server plugin for Java Edition that allows creators to efficiently \"paint\" blocks with a variety of brush shapes.  Creating Models and Visuals Blockbench  Blockbench is a free entity-modeling application for creating working Bedrock Edition entity models, as well as creating textures and the ability to animate them for Bedrock Edition maps. Blockbench has external plugin support, enabling developers to create additional tools to use within the program. It also has the ability to export models into a standard OBJ format, Java Edition block model, and more.  Snowstorm  Snowstorm is a small application for Bedrock Edition created by the developer of Blockbench that can be used to create custom particle effects that are usable in-game. To get started with Snowstorm, visit a tutorial on building particle effects with Snowstorm.  Project and JSON Definition Editing Blockception VSCode Extension  An extension that provides support for files such as .mcfunction, .json and .lang. This extension adds features like completion, validations, formatters, diagnostics, cheat-sheets, code-actions, generation of files, and development tools to help develop Minecraft: Bedrock Edition Addons or Minecraft Education. It's recommended that you use the Dark+ theme for the best color highlighting.  bridge.  bridge. is a light-weight, dedicated editor for Minecraft Add-Ons that makes it easy to get started with Add-Ons and later scales with your growing needs. It requires zero setup and provides you with an instantly bootable development environment with syntax highlighting, code completions and file diagnostics all designed to make developing Minecraft Add-Ons more convenient. To read more, please refer to bridge.'s getting started guide or learn more about why you should use bridge.  bridge. is open source and freely available to all Add-On creators on desktop and mobile platforms.  Minecraft Creator Tools  Minecraft Creator Tools is both a website and an NPM-based command line tool that you can use to start or extend your Minecraft projects. It also includes validators to help find and point out potential issues in the project.  Minecraft Creator Tools is also open source and available on GitHub.  NPC DialogueDesigner  DialogueDesigner is a Web application for Bedrock Edition created by the developer of Blockbench and Snowstorm that can be used to create NPC dialogues, as shown in this handy tutorial: NPC DialogueDesigner.  Creating Skins and Resource Packs  Skin and resource pack creation can be done primarily within any image-editing software, but there are also a few helpful applications that can make this process easier.  Blockbench  Blockbench has a skin editor that allows skins to be edited in 3D (or 2D) with Blockbench's advanced paint tools such as mirror painting and color palettes. It has presets to create entity textures for resource packs as well.  Skins can be packaged for the Marketplace using the Skin Pack Packager plugin in Blockbench.  PMCSkin3D  PMCSkin3D is a web-based dedicated skin editor from PlanetMinecraft. It has a 3D and 2D as well as split-screen mode and advanced brush options. There is also a lite edition with simplified tools.  Aseprite  Aseprite is a purchasable art application designed with pixel-art in mind. It contains many tools that can help make skin and resource pack creation easier. Aseprite also has significant documentation and tutorials to help artists of all skill levels use the application effectively.  McSkin3d  McSkin3D is software designed entirely with skin creation in mind. It has many features such as a built-in skin viewer that can be directly painted on and a split view showing both the skin in 3D alongside its 2D texture.  LookatMySkin  LookatMySkin is a skin previewer that allows you to edit a skin in your program of choice and instantly see it previewed on a 3D player model. It has a variety of features, such as limb posing, zoom, and adjustable background color. This can also be useful for taking screenshots of skins or quickly checking skins for oddities when posed in different ways.  What's Next?  While there are many more tools that exist and are constantly being created to make Minecraft content creation easier, this is a great place to start. Creators should check back here often for newly added content and take advantage of all the available tools at their disposal.  Some of these tools allow you to modify NBT data. Learning about NBT and especially learning what not to do when editing it will save you from a world of trouble.  Editing NBT safely  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/differencesbetweenbedrockandjava", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Differences Between Minecraft: Bedrock Edition and Minecraft: Java Edition 05/21/2025  We love all forms of Minecraft equally, but loving them equally doesn't mean they're identical. As a creator, it's important to know as much as you can about the differences between the flavors of Minecraft. So, we're going to review some of the major differences between Minecraft: Java Edition and Minecraft: Bedrock Edition, and what they may mean for you as a creator.  A brief history of Minecraft  Minecraft: Java Edition is the current iteration of the original version, released in 2009 (simply as \"Minecraft\"). Minecraft: Bedrock Edition started as Minecraft: Pocket Edition with an alpha release in 2011, and remained in alpha until its full release in 2016. In 2017, with version 1.2.0, Pocket Edition officially became Minecraft: Bedrock Edition, unifying the various non-Java releases across platforms. Currently, both versions are active and have broad, passionate audiences. For clarity, we'll refer to the versions as \"Java\" and \"Bedrock\" respectively.  World format  A major difference between Java and Bedrock is the world format. Bedrock uses the LevelDB format for world storage, while Java uses the Anvil format. Due to this, most third-party tools created for editing a world will only work in the version for which it was created.  The two versions also use a fairly different block format. Java has flattened its block format using a unique string for individual blocks, and stores the state of that block separately. Similarly, Bedrock uses a string-based system with block states, while some blocks are grouped together by data value. Because of this, blocks are named differently between the versions. For example, granite is defined as stone 1 in Bedrock, while in Java it's referred to as granite.  Commands and redstone  Bedrock and Java have different structures and implementation of commands. Bedrock's command structure is similar to the system used in versions of Java up to 1.13. It also uses a component-based system for commands instead of raw JSON strings. Instead of using JSON strings to customize entities, you can summon an entity with an event to fire and name it in a single command.  There are also differences per version in the way that redstone works, and while the majority of redstone circuits work well between versions, more complex circuits may not work as well in Bedrock. This is because Bedrock doesn't support quasi-connectivity, while Java does. Systems that use mechanics such as Block Update Detector (BUD) switches won't work the same way in Bedrock. Pistons require one tick to retract, and won't leave blocks behind if given a one-tick pulse. Additionally, the way updates happen is slightly different.  Resource packs  The idea behind resource packs is the same in both editions: change how various aspects of the game look. The capabilities and layout of resource packs are very different depending on the version, however. To get into the details of how things work in Bedrock, take a look at our Introduction to Resource Packs (as an added bonus, you'll learn how to change the look of grass blocks in your world!).  Behavior packs  Bedrock's behavior packs are equivalent to Java's data packs. While they share some similarities, the differences are significant. For example:  To animate textures, Bedrock uses a single file called flipbook_textures.json, while Java uses individual .mcmeta files for each texture. Java can create custom fonts and GLSL shaders, while Bedrock cannot. Bedrock can create custom particles and fogs, while Java cannot. Controls  Currently, both versions of Minecraft support mouse and keyboard controls, but only Bedrock has controller support. Additionally, depending on the hardware used to access Bedrock, there is a significant chance that users may be using touch controls. This becomes an important consideration when determining which type of content to create for each version.  Crossplay  Java is currently available on Windows, Mac, and Linux PCs, meaning that any content you create will be played by users on a computer. Bedrock is available for Windows PCs, consoles, and mobile devices. This means that players in the same world may be having vastly different experiences depending upon the devices they are using. For additional guidance on designing your content for users on varied devices, check out Designing Gameplay for Various Devices.  Next steps  If you're entering the world of Bedrock creation, your next stop should be our add-on concept articles. Here are some excellent follow-up articles for your review:  Getting Started with Add-Ons Comprehensive List of Add-On Pack Contents  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/redstoneguide", "text": "Learn  Minecraft Bedrock Edition  Ask Learn A Guide to Redstone 09/20/2023  This guide is intended to show you some basic ways to use redstone components so that you might feel inspired to try your own projects and feel more prepared to go learn from other redstone creators.  In this tutorial you will learn the following:  Basic redstone components and how they work. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction to Commands  This guide assumes that you know how to make a flat, creative-mode world and how to give yourself the things you need, like redstone dust and pistons.  Redstone Fundamentals  What is redstone? Redstone is kind of like electrical circuits within Minecraft. As with electrical circuits, it's possible to build incredibly sophisticated machines based on the combination of simple connections and switches among components.  Using redstone torches, redstone blocks, and redstone dust  You can power most redstone devices, like a redstone lamp, by putting a redstone torch on an adjacent block.  Putting the torch on the lamp itself will not power it.  Placing a redstone block on the lamp will power it.  Redstone dust acts like a conduit between a power source and a component. As the power signal travels farther from the power source, it gets weaker at a predictable rate. The redstone signal coming out of a power source starts at 15 and decreases by 1 for each block the line of redstone dust is extended.  Let's do an experiment to test this:  Give yourself redstone dust and a redstone torch.  Place one handful of redstone dust dust on the ground. It makes a dark red blob.  Place a redstone torch next to the blob. The redstone blob will glow and align itself to point towards the torch. Neat!  Place more redstone dust to continue the line in one direction. Notice that the glow gets fainter as you get farther from the torch.  Extend the line at least 15 blocks.  Give yourself a piston and place it anywhere around the dark end of the redstone line. The pistons won't do anything if the signal is too weak to make the redstone touching the piston glow.  Place another piston next to the glowing part of the redstone. It should extend.  You could also add another redstone torch to boost the power.  Random redstone dust, torch, and block facts, in no particular order A blob of redstone dust will power all the blocks around it and the block it is placed on. Redstone blocks and redstone torches each have a signal strength of 15. Power radiates out from a redstone torch in all directions, as shown in this grid that is powered by one redstone torch.  A redstone torch powers the block above it, takes redstone signal from it, and powers all adjacent redstone components including above and below the torch.  A redstone torch will not power the is block it is placed on. Placing a redstone torch on a powered block will deactivate the block.  The redstone torch or redstone block must be next to or below the piston to power it. Placing the torch or block in front of the piston will not power it.  Redstone torches don't power the block they're on. For example, putting a redstone torch on top of a piston will not power it, but placing a redstone block on top of a piston will power it.  A redstone torch can be deactivated by powering the block it is placed on.  Power from a redstone torch is continuous. Power can also travel in pulses called \"ticks\" and there are ways to vary the rate.  Time Tick and Redstone Tick  In Minecraft, the term for time passing is \"ticks\" and time passes at 20 ticks per second. Redstone signals pass at the rate of 10 ticks per second. By controlling the speed of the ticks, you can control the speed at which a component does something. So, as you experiment with how different components are powered, keep in mind that the power does not have to be continuous.  Components that emit redstone power  These are things that can power redstone components even though there is no redstone in their recipes.  Button: press to get a short pulse of power. Lever: toggles full signal strength on or off. Pressure plate, wood or stone: sends a pulse of power when you press or step on it. They can be activated by mobs stepping on them, too. Different mobs may activate the pressure plates at different strengths. For example, the signal strength emitted when a creeper steps on the plate is lower than the strength emitted when an iron golem steps on it. When the player or mob leaves the plate, it will deactivate after 5 redstone ticks. A wooden pressure plate also activates if an item is dropped on it. Weighted pressure plate, iron (\"heavy\") or gold (\"light\"): signal strength grows as the number of entities (players, mobs, or items) on top of it increases. Light plate requires fewer items for maximum signal strength than heavy plate needs. Tripwire: emits signal strength when wire is activated (tripped). Lectern with a book on it: emits a pulse of power as you turn the pages. Common redstone components  Piston and sticky piston: These stay extended for as long as they are powered. A piston can push up to 12 blocks. Sticky pistons can pull the block stuck to it back again. Pistons take one tick to extend, zero ticks to retract.  Repeater: Place along a line of redstone dust to continue the signal. As long as a signal strength of 1 or higher is going into the repeater, it will output the maximum level of 15. Redstone repeaters only power the dust or component directly in front of them. They have a built-in delay of 1 tick and can be toggled to extend the delay to 4 ticks. If the input pulse delay is shorter than the delay toggled on the repeater, it will extend the pulse. For example, if you route a 1-tick pulse into a 4-tick repeater, the pulse gets extended to 4 ticks.  Comparator: Unlike a repeater, the comparator outputs the same signal strength that comes into the back of it. Comparators also take in a signal running into the side and compare it to the strength of the signal coming into the back. In normal mode (when the light is NOT switched on) then it will not output a signal if the strength of the signal running into the side is stronger than the signal strength running into the back. If the redstone comparator is in subtract mode (meaning the light is on), it will subtract the signal strength that comes into the side from the signal strength that comes into the back and output the result. So, if a signal strength of 10 is running through a comparator that is in subtract mode (light ON) and we put in a signal strength of 7, the it will output a signal strength of 3.  (Remember, the signal starts at 15 and then goes down by one for each segment of redstone dust.)  Daylight sensor: Produces different levels of power depending on the level of light it detects. It can be inverted to emit light when it detects darkness. To invert it, place one and right-click on it. It will turn blue.  Dropper: Spits out a random item from its inventory when powered directly or powered by an adjacent block. For example, if loaded with a horse spawn egg, when activated, it drops a horse spawn egg. If loaded with arrows, it spits out an arrow.  Dispenser: Works like the dropper, but has special powers depending on what items are loaded into it. For example, if it is loaded with a horse spawn egg, it dispenses a horse. If loaded with arrows, it will fire the arrow. Other items with special behavior include armor stands, boats, bone meal, potions, and buckets.  Observer: When it detects block updates with its face, it sends a one-tick pulse through the red spot on the back. Observers will emit a pulse when they are moved by pistons.  Trapped chest: Activates when opened. Signal varies according to how many players are viewing the contents.  Noteblock: Plays a note when it receives a signal.  Redstone lamp: Produces light when powered.  TNT: Activates when powered directly or by an adjacent powered block. Fuse time is 40 redstone ticks.  What's Next?  Now that you know more about redstone, you could use it to enhance a \"Complete the Monument\" map.  Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/packagingaskinpack", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Packaging a Skin Pack 12/15/2023  Skin packs are some of the most popular content available, offering players multiple looks for their avatars and fundamentally changing the feel of their gameplay experience. Creating a skin pack is not only a great way to offer something new to players, it's also a lot of fun both technically and artistically!  In this guide you will learn:  The folder and file structure for skin packs in Minecraft: Bedrock Edition. How to construct the necessary metadata files for a skin pack and how to define skins using them. Skin Pack Folder Structure  manifest.json  A manifest tells Minecraft general information about your skin pack. Create a JSON file named manifest.json at the root of the skin pack. Within it contains the following:  name: the name of the pack, which is always pack.name. version: the version of the pack. For example, [1, 0 ,0] would indicate version 1.0.0. uuid: a unique identifier to prevent package conflicts, which can be generated from this site: https://www.uuidgenerator.net/version4 (two different UUIDs need to be generated). type: set to skin_pack to tell the game to treat this pack as a skin pack. Template manifest.json JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 1 }  skins.json  A skins.json file will define the skins that come with your skin pack. Create a JSON file named skins.json at the root of the skin pack. Within it contains the following:  localization_name and serialize_name: these will be the same and are the localization keys whose value will be defined later in en_US.lang with the full key being skinpack.<localization_name>. That value will be the title of the pack. The key will also always be prepended to each individual skin's localization key. skins: a collection of definitions, each defining a single skin.  Each individual skin definition will then contain the following:  localization_name: the localization key whose value is defined later in en_US.lang. The value will be the name of the individual skin. geometry: the base model this skin is for. geometry.humanoid.customSlim is the Alex model and geometry.humanoid.custom is the Steve model. texture: the file name for each of the skin textures as they appear in the root of the skin pack. type: either free or paid. Template skins.json   Note  Unfortunately, it's not possible to add custom models to skin packs at this time using the skin pack JSON capability.  JSON Copy {   \"serialize_name\": \"TemplateSkinPack\",   \"localization_name\": \"TemplateSkinPack\",   \"skins\": [     {       \"localization_name\": \"TemplateSkin1\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name1.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin2\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name2.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin3\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name3.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin4\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name4.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin5\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name5.png\",       \"type\": \"paid\"     }   ] }  Skin Textures  The actual skin textures are PNGs. The file names are referred to in the skins.json metadata file. They can be used only at the root of the skin pack. You can use Blockbench to create a usable skin PNG for your skin pack.  Texts Folder  Inside this folder are the en_US.lang and languages.json files, which define the actual names of your pack and skins and the supported languages of your pack. The names after the = are what show up in-game, such as in the skin picker.  en_US.lang  This is the file where you name your pack and the skins.  Pack name: skinpack.[skins.json localization_name]=[name of pack] Skin names: skin.[skins.json localization_name].[skins.json single skin localization_name]=[name of skin]  The below template uses the \"localization keys\" from the template skin.json to name the pack \"Your Skin Pack Name Here\" and to name the individual skins \"Skin Name 1-5\".  Template en_US.lang JSON Copy skinpack.TemplateSkinPack=Your Skin Pack Name Here skin.TemplateSkinPack.TemplateSkin1=Skin Name 1 skin.TemplateSkinPack.TemplateSkin2=Skin Name 2 skin.TemplateSkinPack.TemplateSkin3=Skin Name 3 skin.TemplateSkinPack.TemplateSkin4=Skin Name 4 skin.TemplateSkinPack.TemplateSkin5=Skin Name 5  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/actorstorage", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Actor Storage in Minecraft: Bedrock Edition 09/08/2023  Minecraft has inspired many third parties to create useful world file viewing and editing tools that exist outside the client. Tools like the Universal Minecraft Editor and MCEdit are community favorites and are dependent upon knowing where to find each piece of the level's data on disk in the LevelDB files. With the upgrade from legacy actor storage to modern actor storage in 1.18.20, the locations in the LevelDB files which the data for actors (entities) is stored has changed and these third party developers need to be aware.  What did legacy actor data look like?  Before version 1.18.30, actor data was stored per chunk as a blob of all actors in that chunk. This meant that whenever a single actor changed, we would:  Collect the data from every individual actor in the chunk Append the data for each actor into a single buffer/blob Write that grouped data to the chunk Why are we moving actor data?  The legacy actor data storage format meant if one actor in a chunk is changed you have to save them all, even if only one actually changed. This resulted in a lot of unnecessary operations and made handling the transfer of entities between chunks an expensive and fragile system.  How is modern actor data stored on disk?  Modern actor storage moves to storing each Actor under a unique individual LevelDB key. This enables us to have save operations that act only in individual actors. This also means that there is no key-value pair for all actors in a chunk. In fact the individual actor keys are separated into their own key space from the rest of chunk data and chunks do not have data on disk directly referencing actors they contain.  Instead, we use data from the chunk to deterministically generate a key that is unique to the chunk in which we store a digest of the LevelDB keys for the Actors in the chunk. These digest entries are also separated from the non-actor chunk data and the actor key space.  Let's take a look at how this appears on disk:  Chunk Key Space  On the left of the diagram, we can see the chunk key space. These keys take the legacy chunk key form of <Chunk Position><DimensionID>. There is a very old legacy chunk format in which there is no dimension ID, so it is possible to load a really old world in which chunk keys do not have a dimension ID. They will be saved out under a new key with the dimension ID. This is old behavior that still exists.  These are the smallest keys used by pushing them together contiguously on disk. The chunk key is used as a prefix for keys which store all non-actor data from the chunk. Each type of data from the chunk has its own key ID that is appended to the chunk key prefix.  Non-Actor Data Chunk Key IDs C++ Copy enum class LevelChunkTag : char {   Data3D = 43,   Version, // This was moved to the front as needed for the extended heights feature. Old chunks will not have this data.   Data2D,   Data2DLegacy,   SubChunkPrefix,   LegacyTerrain,   BlockEntity,   Entity,   PendingTicks,   LegacyBlockExtraData,   BiomeState,   FinalizedState,   ConversionData, // data that the converter provides, that are used at runtime for things like blending   BorderBlocks,   HardcodedSpawners,   RandomTicks,   CheckSums,   GenerationSeed,   GeneratedPreCavesAndCliffsBlending = 61, // not used, DON'T REMOVE   BlendingBiomeHeight = 62, // not used, DON'T REMOVE   MetaDataHash,   BlendingData,   ActorDigestVersion,   LegacyVersion = 118, };    Actor Digest Key Space  In the middle, we have the digest key space. Each digest key takes the form digp<Chunk Key>.  digp is a hardcoded prefix for all digest keys. This forces all digests to be contiguous on disk and increases the size of all digest keys such that they are placed ahead of the non-actor chunk data in the LevelDB.  <Chunk Key> is the same key string used by the chunk the data is associated with.  Actor Key Space  On the right, we have the actor key space. Each actor key takes the form actorprefix<ActorUniqueID>.  actorprefix is a hardcoded prefix used for all actor keys. This forces all actor data to be contiguous on disk and increases the size of all actor keys such that they are placed ahead of the non-actor chunk data and all digests in the LevelDB.  <ActorUniqueID> is a unique ID that is generated for each actor when it is added to the level. This ID is consistent between play sessions and is only unique to this world. Other actors in other worlds may have the same ID, but no actor in the same world will have the same ID.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourintro", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating Worlds and Game Development - Parkour World 09/21/2023  This series will cover how to build an obstacle course, commonly known as a parkour world, from the ground up. We'll reverse engineer an existing world, talk through the various challenges, touch on player mechanics, and finally build and share our own world.  By the end of this series, you will learn:  What goes into planning and building a world in Minecraft. How to create gameplay mechanics and loops for players to enjoy. How to share content with other players. Overview Part 1 - Parkour World Walkthrough  Not sure how to start developing a game? Let's discuss lots of best practices to have in mind by checking out a parkour world as an example. Parkour World Walkthrough  Part 2 - Creating and Sharing a World  Let's create a smaller parkour world, combining our favorite elements of game development, design, and fun.  Creating and Sharing a World  What's Next?  Check out the Parkour World Walkthrough to see how a fun gameplay loop was developed using different parkour mechanics in Minecraft.  Parkour World Walkthrough  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourintro?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating Worlds and Game Development - Parkour World 09/21/2023  This series will cover how to build an obstacle course, commonly known as a parkour world, from the ground up. We'll reverse engineer an existing world, talk through the various challenges, touch on player mechanics, and finally build and share our own world.  By the end of this series, you will learn:  What goes into planning and building a world in Minecraft. How to create gameplay mechanics and loops for players to enjoy. How to share content with other players. Overview Part 1 - Parkour World Walkthrough  Not sure how to start developing a game? Let's discuss lots of best practices to have in mind by checking out a parkour world as an example. Parkour World Walkthrough  Part 2 - Creating and Sharing a World  Let's create a smaller parkour world, combining our favorite elements of game development, design, and fun.  Creating and Sharing a World  What's Next?  Check out the Parkour World Walkthrough to see how a fun gameplay loop was developed using different parkour mechanics in Minecraft.  Parkour World Walkthrough  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourintro?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating Worlds and Game Development - Parkour World 09/21/2023  This series will cover how to build an obstacle course, commonly known as a parkour world, from the ground up. We'll reverse engineer an existing world, talk through the various challenges, touch on player mechanics, and finally build and share our own world.  By the end of this series, you will learn:  What goes into planning and building a world in Minecraft. How to create gameplay mechanics and loops for players to enjoy. How to share content with other players. Overview Part 1 - Parkour World Walkthrough  Not sure how to start developing a game? Let's discuss lots of best practices to have in mind by checking out a parkour world as an example. Parkour World Walkthrough  Part 2 - Creating and Sharing a World  Let's create a smaller parkour world, combining our favorite elements of game development, design, and fun.  Creating and Sharing a World  What's Next?  Check out the Parkour World Walkthrough to see how a fun gameplay loop was developed using different parkour mechanics in Minecraft.  Parkour World Walkthrough  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/survivalspawncreation?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Survival Spawn Creation 04/16/2025  Survival spawns take on many shapes and forms, all with their own considerations. This article focuses on creating a survival spawn that represents the starting of a player's journey in survival Minecraft. Whether it exists in a naturally generated terrain or a custom-crafted one, the player should be able to experience the normal Minecraft survival loop.  Getting Started   Minecraft: Java Edition terrain meets Minecraft: Bedrock Edition terrain.  Survival spawns should generally contain everything necessary for players to experience the Minecraft survival loop. That means access to ores and materials for crafting, as well as access to the End and the Nether. It should also contain substantial edits to the base seed world.  If you're depending on your build blending into natural generation, your first step should be locating an appropriate Bedrock Edition seed to base your world on and then generating an area to build on. As of 1.18, Bedrock and Java have seed parity so long as the seed number is 9 or fewer characters.  The most stable way to build a survival spawn is to build it directly in Bedrock Edition, however most publicly available tools for building in Minecraft exist for Java Edition. Fortunately, tools such as Chunker that allow converting Bedrock Edition worlds into Java Edition worlds exist.  Generating Bedrock Terrain  Trying to convert a newly created Bedrock Edition world to Java Edition would result in very few Bedrock Edition chunks converting. This is because chunks need to be generated before you can convert a Bedrock Edition world. Currently, chunks must be generated by traversing the world and loading in terrain. This can be accomplished by flying around the world, however, this can be very time-consuming depending on the desired map size. A more efficient way of doing this would be to create a system using commands that teleports the player around the map using relative coordinates to the player. Other tools such as Code Connection (available through the Microsoft Store) and the JavaScript API can be leveraged for the task as well.  Converting Worlds  Converting worlds used to be a clunky and confusing process that was prone to error. With the introduction of Chunker, that process has been made exponentially easier. Not only can you use Chunker to convert worlds, but you can also use it to prune chunks, change world settings, and much much more! Read how to utilize the power of Chunker to help prepare your worlds!  Things to Keep in Mind While Building  It's important to keep in mind the purpose of your survival spawn while building it. Survival spawns are generally intended to enhance the survival Minecraft experience. In those cases, survival spawns should be crafted with survival mechanics in mind. Anything that's possible to do within a newly created survival world, such as finding lava to make a Nether portal, or finding an End portal frame to be able to enter the End should also be possible.  Users playing a survival spawn should be able to find ores and caves under the terrain where it makes sense to do so, as well as Overworld resources above ground. If custom terrain is built with a certain biome in mind, creators should consider making sure the actual biome for that region is appropriate (e.g., a cold biome for a snowy forest so the snow doesn't melt). Unintentional voids or air pockets in terrain should also be removed in consideration of players' underground exploration.  Structures should also be created with survival in mind. In survival mode, players can break and place blocks anywhere they choose. Spaces such as hollow unfurnished attics or crawl spaces under the build, as well as evidence that external tools such as WorldEdit were used will most likely be discovered by players and should be removed to preserve the survival experience. Buildings that are facades and contain nothing are also discouraged in survival spawns because players may attempt to break through facades to see what's inside.  Survival spawns are an excellent place to start with content creation. While there are many challenging aspects to them such as terrain generation, conversions, and survival mechanics to consider, creating survival spawns is an excellent way to gain valuable experience in world-building, player experience, and general usage of various tools available.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/survivalspawncreation?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Survival Spawn Creation 04/16/2025  Survival spawns take on many shapes and forms, all with their own considerations. This article focuses on creating a survival spawn that represents the starting of a player's journey in survival Minecraft. Whether it exists in a naturally generated terrain or a custom-crafted one, the player should be able to experience the normal Minecraft survival loop.  Getting Started   Minecraft: Java Edition terrain meets Minecraft: Bedrock Edition terrain.  Survival spawns should generally contain everything necessary for players to experience the Minecraft survival loop. That means access to ores and materials for crafting, as well as access to the End and the Nether. It should also contain substantial edits to the base seed world.  If you're depending on your build blending into natural generation, your first step should be locating an appropriate Bedrock Edition seed to base your world on and then generating an area to build on. As of 1.18, Bedrock and Java have seed parity so long as the seed number is 9 or fewer characters.  The most stable way to build a survival spawn is to build it directly in Bedrock Edition, however most publicly available tools for building in Minecraft exist for Java Edition. Fortunately, tools such as Chunker that allow converting Bedrock Edition worlds into Java Edition worlds exist.  Generating Bedrock Terrain  Trying to convert a newly created Bedrock Edition world to Java Edition would result in very few Bedrock Edition chunks converting. This is because chunks need to be generated before you can convert a Bedrock Edition world. Currently, chunks must be generated by traversing the world and loading in terrain. This can be accomplished by flying around the world, however, this can be very time-consuming depending on the desired map size. A more efficient way of doing this would be to create a system using commands that teleports the player around the map using relative coordinates to the player. Other tools such as Code Connection (available through the Microsoft Store) and the JavaScript API can be leveraged for the task as well.  Converting Worlds  Converting worlds used to be a clunky and confusing process that was prone to error. With the introduction of Chunker, that process has been made exponentially easier. Not only can you use Chunker to convert worlds, but you can also use it to prune chunks, change world settings, and much much more! Read how to utilize the power of Chunker to help prepare your worlds!  Things to Keep in Mind While Building  It's important to keep in mind the purpose of your survival spawn while building it. Survival spawns are generally intended to enhance the survival Minecraft experience. In those cases, survival spawns should be crafted with survival mechanics in mind. Anything that's possible to do within a newly created survival world, such as finding lava to make a Nether portal, or finding an End portal frame to be able to enter the End should also be possible.  Users playing a survival spawn should be able to find ores and caves under the terrain where it makes sense to do so, as well as Overworld resources above ground. If custom terrain is built with a certain biome in mind, creators should consider making sure the actual biome for that region is appropriate (e.g., a cold biome for a snowy forest so the snow doesn't melt). Unintentional voids or air pockets in terrain should also be removed in consideration of players' underground exploration.  Structures should also be created with survival in mind. In survival mode, players can break and place blocks anywhere they choose. Spaces such as hollow unfurnished attics or crawl spaces under the build, as well as evidence that external tools such as WorldEdit were used will most likely be discovered by players and should be removed to preserve the survival experience. Buildings that are facades and contain nothing are also discouraged in survival spawns because players may attempt to break through facades to see what's inside.  Survival spawns are an excellent place to start with content creation. While there are many challenging aspects to them such as terrain generation, conversions, and survival mechanics to consider, creating survival spawns is an excellent way to gain valuable experience in world-building, player experience, and general usage of various tools available.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/introductiontostructureblocks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Structure Blocks 02/27/2025  Structure blocks are used in Minecraft: Bedrock Edition to save and load blocks and entities that may or may not be arranged in the form of a structure. They can be useful both as building tools and for gameplay animations. Structure blocks can do more than just save and load structures, but that's where we're going to start with this document so we can learn the basics.  You can only edit a structure block in creative mode and they are unbreakable in the survival and adventure game modes.  Like command blocks, you obtain them by using the /give command in the chat, and right-click them to open the settings window.   Note  Any block saved with a structure block will have its state saved. Command blocks will have command information, chests will have their inventory, and even structure blocks will have their structure information when the structure is loaded.  The first thing to notice is the Mode setting. The four structure block modes are:  Save - Saves a structure into a structure block's memory Load - Loads a saved structure from a structure block's memory Corner Can be used to save a specific section of a structure into memory, using two blocks to define the selection around a structure 3D Export Exports a .glb file that can be used to 3D print a model  The settings for Corner and 3D Export are different and we will cover those when we get to them. The buttons under the image of the structure change depending on mode, too.  Save Mode  This is the mode you use when you like entering coordinates to fine-tune your selection. We are going to select a house, save it, and then load it into a different area, basically making a copy of the house.  Start by giving yourself a structure block:  /give @s structure_block  Place the structure block in a nice, clear area and notice how the selection bounding box is oriented.  Next, go place a structure block next to something interesting like a village house.  Open the settings page and adjust the Size and Offset settings of the selection bounding box until you have as much of the house and the surrounding area as you want.  Size: Adjusts the boundaries of the selection bounding box. Offset: Adjusts the position of the selection box, relative to the structure block. You can enter values in the X, Y, and Z fields to pinpoint the exact location you want.  Notice that the colors of the coordinates corresponds to the colors of the lines of the bounding box.  The maximum size values are:  X: 64 Y: 257 Z: 64  If you enter too large of a value for any of these coordinates, it will be changed to the highest possible value. You can click and drag the selection image to get a better view of your selection.  The maximum offset values, from sea-level (Y=63) are -127 to 252.  Offset values are relative to the placement of the structure block. There are not limits for the X: and Z: offset values. As long as the area is loaded, you can grab it.  In the Structure Name field, give the structure a short and memorable filename like \"house1\" and be sure to use only lowercase letters, numbers, underscores, and hyphens in the name.  The namespace \"mystructure:\" will be appended to the name when you click outside of the field.  Make a note of your structure name.  mystructure:house1  You might even want to copy it and paste it to a text file. You will need it to be exact when we load your saved house back in.  For now, don't worry about the Detect button. We will use it later in Corner mode.  We are also going to leave these settings as they are:  Include Entities: Saves any entities like animals or mobs that may be present in the selection. Remove Blocks: Removes all blocks and captures only the entities within the selection. Redstone Save Mode: You can use redstone to activate a structure block and make it save or load a structure into your world. We're not doing that yet, so feel free to ignore this setting for now. Save in Memory is faster, but you can only load the structure in this one world. This is the more common way to save. Save to Disk is slower, but saves the structure to be used in different play sessions. Show Bounding Box: Toggle this on and off to see your selection without the lines around it.  Click the Save button under the selection image. There will be a Structure Saved! message briefly displayed over the structure.  Save Mode - Reset button  After you make changes to the size and offset settings, if you don't like those settings, you can click Reset to put the coordinates back to the defaults.  These are the defaults:  Size:  X: 5 Y: 5 Z: 5  Offset:  X: 0 Y: -1 Z: 0 Exporting and Importing a Structure  After you make a selection, you can export it as a .mcstructure file to save it on your device.  Then you can load the exported structure into a different world.  In a creative mode world, place a structure block and put it in Load mode. Then, click import. This imports the structure into your world, and you can see that the bounding box adjusts to the shape of the imported structure. You can still adjust the load offset. When you're happy with the placement, click Load to load the structure into your world.  Loading a Structure with Load Mode  To load a structure, start by placing a structure block and put it in 'Load' mode.  Importing a Saved Structure  Notice the Import button. This button allows you to import a .mcstructure file from anywhere on your computer into your Minecraft world.  When you click the Import button, a file picker opens that allows you to choose the file you would like to import into your world.  After you have chosen a file, the structure block will then fill out all of the necessary information about the structure into the structure block itself, and ready the structure to load.  For this example, mystructure:1 was chosen, and the structure block's name and bounds were automatically updated to reflect the information in the .mcstructure file.  When a structure is successfully loaded, you will see a message in the structure block UI telling you the structure has been successfully imported.  After the structure is imported, and the structure block UI looks similar to the UI above, the structure can be loaded into the world.  This is what it will look like when the Load button is clicked:  Here are some other important notes about importing a structure:  The import button is limited to the windows version of the game (much like the export button). You can import multiple different structures into a world with the Import button. The structure will be saved to the world once it is loaded into it by clicking the 'Load' button. You can only import structures to a world if you are the host of the world. If you are a guest in someone else's world, the import will fail. Corner Mode  This mode uses three structure blocks: two to set the size and position of the selection, and one to detect the area selected by the other two blocks.  Place a structure block in corner mode outside of one of the structure's sides. Remember the name you use to save it. Place another structure block in corner mode on the opposite corner of the structure and give it the same name. Place a third structure block and select Save Mode. Enter the same name again that was used for the other two corner mode structure blocks. Click Detect. The selection box should encompass the area between the corners of the corner mode blocks. All three blocks must have the same name and there must be at least 1 block between the corners for the Save block to detect the structure.  3D Export Mode  Export mode is used to create a .glb file that will be usable in behavior packs or a file that can be used to 3D print a Minecraft structure.  To export a 3D file, follow these steps:  In the Structure Name field, enter a name for the structure using only lowercase characters. For Relative Position, select the origin of the structure outline. You can select portions into the ground. Structure size sets the distance from the relative position to build that cube in space in Minecraft. Choose to Remove blocks so that inner blocks will not be printed. What's Next?  Now we have seen a structure block in action, you can learn more about how they work and what else you can do with them. Use structure blocks to save and load structures, learn the /structure command, and even learn a simple animation using a command block in the tutorial.  Structure Blocks Tutorial  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/introductiontostructureblocks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Structure Blocks 02/27/2025  Structure blocks are used in Minecraft: Bedrock Edition to save and load blocks and entities that may or may not be arranged in the form of a structure. They can be useful both as building tools and for gameplay animations. Structure blocks can do more than just save and load structures, but that's where we're going to start with this document so we can learn the basics.  You can only edit a structure block in creative mode and they are unbreakable in the survival and adventure game modes.  Like command blocks, you obtain them by using the /give command in the chat, and right-click them to open the settings window.   Note  Any block saved with a structure block will have its state saved. Command blocks will have command information, chests will have their inventory, and even structure blocks will have their structure information when the structure is loaded.  The first thing to notice is the Mode setting. The four structure block modes are:  Save - Saves a structure into a structure block's memory Load - Loads a saved structure from a structure block's memory Corner Can be used to save a specific section of a structure into memory, using two blocks to define the selection around a structure 3D Export Exports a .glb file that can be used to 3D print a model  The settings for Corner and 3D Export are different and we will cover those when we get to them. The buttons under the image of the structure change depending on mode, too.  Save Mode  This is the mode you use when you like entering coordinates to fine-tune your selection. We are going to select a house, save it, and then load it into a different area, basically making a copy of the house.  Start by giving yourself a structure block:  /give @s structure_block  Place the structure block in a nice, clear area and notice how the selection bounding box is oriented.  Next, go place a structure block next to something interesting like a village house.  Open the settings page and adjust the Size and Offset settings of the selection bounding box until you have as much of the house and the surrounding area as you want.  Size: Adjusts the boundaries of the selection bounding box. Offset: Adjusts the position of the selection box, relative to the structure block. You can enter values in the X, Y, and Z fields to pinpoint the exact location you want.  Notice that the colors of the coordinates corresponds to the colors of the lines of the bounding box.  The maximum size values are:  X: 64 Y: 257 Z: 64  If you enter too large of a value for any of these coordinates, it will be changed to the highest possible value. You can click and drag the selection image to get a better view of your selection.  The maximum offset values, from sea-level (Y=63) are -127 to 252.  Offset values are relative to the placement of the structure block. There are not limits for the X: and Z: offset values. As long as the area is loaded, you can grab it.  In the Structure Name field, give the structure a short and memorable filename like \"house1\" and be sure to use only lowercase letters, numbers, underscores, and hyphens in the name.  The namespace \"mystructure:\" will be appended to the name when you click outside of the field.  Make a note of your structure name.  mystructure:house1  You might even want to copy it and paste it to a text file. You will need it to be exact when we load your saved house back in.  For now, don't worry about the Detect button. We will use it later in Corner mode.  We are also going to leave these settings as they are:  Include Entities: Saves any entities like animals or mobs that may be present in the selection. Remove Blocks: Removes all blocks and captures only the entities within the selection. Redstone Save Mode: You can use redstone to activate a structure block and make it save or load a structure into your world. We're not doing that yet, so feel free to ignore this setting for now. Save in Memory is faster, but you can only load the structure in this one world. This is the more common way to save. Save to Disk is slower, but saves the structure to be used in different play sessions. Show Bounding Box: Toggle this on and off to see your selection without the lines around it.  Click the Save button under the selection image. There will be a Structure Saved! message briefly displayed over the structure.  Save Mode - Reset button  After you make changes to the size and offset settings, if you don't like those settings, you can click Reset to put the coordinates back to the defaults.  These are the defaults:  Size:  X: 5 Y: 5 Z: 5  Offset:  X: 0 Y: -1 Z: 0 Exporting and Importing a Structure  After you make a selection, you can export it as a .mcstructure file to save it on your device.  Then you can load the exported structure into a different world.  In a creative mode world, place a structure block and put it in Load mode. Then, click import. This imports the structure into your world, and you can see that the bounding box adjusts to the shape of the imported structure. You can still adjust the load offset. When you're happy with the placement, click Load to load the structure into your world.  Loading a Structure with Load Mode  To load a structure, start by placing a structure block and put it in 'Load' mode.  Importing a Saved Structure  Notice the Import button. This button allows you to import a .mcstructure file from anywhere on your computer into your Minecraft world.  When you click the Import button, a file picker opens that allows you to choose the file you would like to import into your world.  After you have chosen a file, the structure block will then fill out all of the necessary information about the structure into the structure block itself, and ready the structure to load.  For this example, mystructure:1 was chosen, and the structure block's name and bounds were automatically updated to reflect the information in the .mcstructure file.  When a structure is successfully loaded, you will see a message in the structure block UI telling you the structure has been successfully imported.  After the structure is imported, and the structure block UI looks similar to the UI above, the structure can be loaded into the world.  This is what it will look like when the Load button is clicked:  Here are some other important notes about importing a structure:  The import button is limited to the windows version of the game (much like the export button). You can import multiple different structures into a world with the Import button. The structure will be saved to the world once it is loaded into it by clicking the 'Load' button. You can only import structures to a world if you are the host of the world. If you are a guest in someone else's world, the import will fail. Corner Mode  This mode uses three structure blocks: two to set the size and position of the selection, and one to detect the area selected by the other two blocks.  Place a structure block in corner mode outside of one of the structure's sides. Remember the name you use to save it. Place another structure block in corner mode on the opposite corner of the structure and give it the same name. Place a third structure block and select Save Mode. Enter the same name again that was used for the other two corner mode structure blocks. Click Detect. The selection box should encompass the area between the corners of the corner mode blocks. All three blocks must have the same name and there must be at least 1 block between the corners for the Save block to detect the structure.  3D Export Mode  Export mode is used to create a .glb file that will be usable in behavior packs or a file that can be used to 3D print a Minecraft structure.  To export a 3D file, follow these steps:  In the Structure Name field, enter a name for the structure using only lowercase characters. For Relative Position, select the origin of the structure outline. You can select portions into the ground. Structure size sets the distance from the relative position to build that cube in space in Minecraft. Choose to Remove blocks so that inner blocks will not be printed. What's Next?  Now we have seen a structure block in action, you can learn more about how they work and what else you can do with them. Use structure blocks to save and load structures, learn the /structure command, and even learn a simple animation using a command block in the tutorial.  Structure Blocks Tutorial  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/datadrivenoverworldheight?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Data-Driven Overworld Height and Void Generation 09/20/2023  Creators can use this feature to change the height of an existing world or to create void maps in the Overworld, Nether, and The End. This will improve performance by reducing memory and enabling more creative flexibility.  In this tutorial, you will learn the following:  How to create a void world in Minecraft: Bedrock Edition. How to change the height of an existing world. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction To Behavior Packs Limitations  This feature will not modify your existing world generation to fit into a new height range. Instead, when you add the behavior pack containing the JSON file to an existing world, the world will be sliced at the given min and max values and the chunks outside the min and max range will be saved in LevelDB, but will not be visible.  Everything outside of the min and max coordinates will become invisible and above that height will not be buildable. Additionally, there will be no new world generation outside of your saved areas and those areas will generate as type=void.  There is currently no blending and world generation will not scale to the custom height.  This feature will not impact existing and saved custom biomes as it just slices the view at the customized heights However, it will stop new custom biomes from generating since all unsaved areas will generate as void.  The scope of this feature is to introduce a void generator with modifiable heights to reduce memory usage and make this functionality easier for creators.  How to use the Data Driven Overworld Height Behavior Pack First, use it to create a void world  Close Minecraft if you have it running.  Create the behavior pack folder with the usual manifest.json file.  Create a folder on the same level as the manifest file and name it dimensions.  Create a file inside the dimensions folder and name it overworld.json.  Put this code into the file and save it. Note that the only mutable values in this code for now are the min and max values. You cannot modify the generator type or the dimension identifier.  JSON Copy {   \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:overworld\"       },       \"components\": {         \"minecraft:dimension_bounds\": {           \"min\": -16,           \"max\": 256       },       \"minecraft:generation\": {           \"generator_type\": \"void\"       }     }   } }   Load the behavior pack as usual.  Launch Minecraft and make a creative mode world with coordinates shown and the behavior pack active.  Go into the world. It should look like this:  The buildable height of the void world is constrained by the min and max bounds. In this case, we set it to (-16, 256). If you try to place a block outside of the min and max values you set in the JSON file, you get a message saying that the block couldn't be placed.  About those min and max values...  You can change the values for min and max to any multiples of 16 between -512 and 512 that you like.  Next, use it on an existing world  In this section, we will see what happens if we apply the data pack to a \"vanilla\" generated world. (This can also be done on your existing custom world, but as always, we recommend you make a backup first!)  Make a vanilla creative world with Show Coordinates active, but do not apply the behavior pack to it yet.  Go into the world so that it generates and saves terrain at the usual height.  Save and Quit the world, then shut down Minecraft.  Open the overworld.json file you created in the previous section and set the min and max to values that you know are smaller than the generated world. (We're using smaller values just for the purpose of this demo, of course you can set it larger, too!) Remember, they have to be multiples of 16. To really see a drastic difference, you could set them to min: -16 and max: 16.  Launch Minecraft and activate the behavior pack for the world.  When you go back into the world, it should look quite a bit different. It will be cut down to the height you specified and you will not be able to build beyond those limits.  (I assure you this was perfectly normal vanilla world before the data pack was applied.)  What happened  When you take an existing world and add the data driven dimension behavior pack, two things happen:  The buildable height range is restricted to whatever heights you specified.  Void generation occurs outside of your saved areas. This means if you ran around a world on the x coordinate in a circle with a radius of 12, and then you add the behavior pack, only the chunks in that radius (plus the buffer of chunks that we save beyond that radius) will be saved. Outside of that, the terrain will generate as void.  Using this feature will stop world generation beyond the saved areas. It works by generating any new areas as a void. You will see this if you run to the edge of originally saved our areas of your world.  What if I Remove the Behavior Pack?  Your original height range will be restored, along with saved chunks that were hidden from the height restriction.If you go to new (unsaved) areas, regular world generation will occur, but parts that were explored when the behavior pack was active will remain void - because that is how they were generated and saved.  This is why you should always make backups, so you can iterate on your desired changes!  Void Generation in Other Dimensions  The Nether and The End both support void generation, but do not support custom height. To add void generation to these dimensions, start by creating a JSON file for the dimensions you want, like nether.json or the_end.json. Place these inside the dimensions folder created for Overworld void.  The format for the JSON is the same as Overworld void - just remove the \"minecraft:dimension_bounds\" section containing custom height.  Here is an example of the nether.json document:  JSON Copy {     \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:nether\"       },       \"components\": {        \"minecraft:generation\": {           \"generator_type\": \"void\"         }       }     } }   Changing the identifier field to \"minecraft:the_end\" will generate void in The End.  The same traits apply for void in the Nether and The End, so make sure to create a backup of your worlds!  What's Next?  Now that you have seen how this behavior pack works, here are some tutorials about doing even more customization to your world.  Creating New Entity Types Introduction to Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/datadrivenoverworldheight?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Data-Driven Overworld Height and Void Generation 09/20/2023  Creators can use this feature to change the height of an existing world or to create void maps in the Overworld, Nether, and The End. This will improve performance by reducing memory and enabling more creative flexibility.  In this tutorial, you will learn the following:  How to create a void world in Minecraft: Bedrock Edition. How to change the height of an existing world. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction To Behavior Packs Limitations  This feature will not modify your existing world generation to fit into a new height range. Instead, when you add the behavior pack containing the JSON file to an existing world, the world will be sliced at the given min and max values and the chunks outside the min and max range will be saved in LevelDB, but will not be visible.  Everything outside of the min and max coordinates will become invisible and above that height will not be buildable. Additionally, there will be no new world generation outside of your saved areas and those areas will generate as type=void.  There is currently no blending and world generation will not scale to the custom height.  This feature will not impact existing and saved custom biomes as it just slices the view at the customized heights However, it will stop new custom biomes from generating since all unsaved areas will generate as void.  The scope of this feature is to introduce a void generator with modifiable heights to reduce memory usage and make this functionality easier for creators.  How to use the Data Driven Overworld Height Behavior Pack First, use it to create a void world  Close Minecraft if you have it running.  Create the behavior pack folder with the usual manifest.json file.  Create a folder on the same level as the manifest file and name it dimensions.  Create a file inside the dimensions folder and name it overworld.json.  Put this code into the file and save it. Note that the only mutable values in this code for now are the min and max values. You cannot modify the generator type or the dimension identifier.  JSON Copy {   \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:overworld\"       },       \"components\": {         \"minecraft:dimension_bounds\": {           \"min\": -16,           \"max\": 256       },       \"minecraft:generation\": {           \"generator_type\": \"void\"       }     }   } }   Load the behavior pack as usual.  Launch Minecraft and make a creative mode world with coordinates shown and the behavior pack active.  Go into the world. It should look like this:  The buildable height of the void world is constrained by the min and max bounds. In this case, we set it to (-16, 256). If you try to place a block outside of the min and max values you set in the JSON file, you get a message saying that the block couldn't be placed.  About those min and max values...  You can change the values for min and max to any multiples of 16 between -512 and 512 that you like.  Next, use it on an existing world  In this section, we will see what happens if we apply the data pack to a \"vanilla\" generated world. (This can also be done on your existing custom world, but as always, we recommend you make a backup first!)  Make a vanilla creative world with Show Coordinates active, but do not apply the behavior pack to it yet.  Go into the world so that it generates and saves terrain at the usual height.  Save and Quit the world, then shut down Minecraft.  Open the overworld.json file you created in the previous section and set the min and max to values that you know are smaller than the generated world. (We're using smaller values just for the purpose of this demo, of course you can set it larger, too!) Remember, they have to be multiples of 16. To really see a drastic difference, you could set them to min: -16 and max: 16.  Launch Minecraft and activate the behavior pack for the world.  When you go back into the world, it should look quite a bit different. It will be cut down to the height you specified and you will not be able to build beyond those limits.  (I assure you this was perfectly normal vanilla world before the data pack was applied.)  What happened  When you take an existing world and add the data driven dimension behavior pack, two things happen:  The buildable height range is restricted to whatever heights you specified.  Void generation occurs outside of your saved areas. This means if you ran around a world on the x coordinate in a circle with a radius of 12, and then you add the behavior pack, only the chunks in that radius (plus the buffer of chunks that we save beyond that radius) will be saved. Outside of that, the terrain will generate as void.  Using this feature will stop world generation beyond the saved areas. It works by generating any new areas as a void. You will see this if you run to the edge of originally saved our areas of your world.  What if I Remove the Behavior Pack?  Your original height range will be restored, along with saved chunks that were hidden from the height restriction.If you go to new (unsaved) areas, regular world generation will occur, but parts that were explored when the behavior pack was active will remain void - because that is how they were generated and saved.  This is why you should always make backups, so you can iterate on your desired changes!  Void Generation in Other Dimensions  The Nether and The End both support void generation, but do not support custom height. To add void generation to these dimensions, start by creating a JSON file for the dimensions you want, like nether.json or the_end.json. Place these inside the dimensions folder created for Overworld void.  The format for the JSON is the same as Overworld void - just remove the \"minecraft:dimension_bounds\" section containing custom height.  Here is an example of the nether.json document:  JSON Copy {     \"format_version\": \"1.18.0\",     \"minecraft:dimension\": {       \"description\": {         \"identifier\": \"minecraft:nether\"       },       \"components\": {        \"minecraft:generation\": {           \"generator_type\": \"void\"         }       }     } }   Changing the identifier field to \"minecraft:the_end\" will generate void in The End.  The same traits apply for void in the Nether and The End, so make sure to create a backup of your worlds!  What's Next?  Now that you have seen how this behavior pack works, here are some tutorials about doing even more customization to your world.  Creating New Entity Types Introduction to Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/foginresourcepacks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fog in Resource Packs 05/19/2025  Fogs in Minecraft: Bedrock Edition use JSON files to determine their values. Creators can define their own sets of fog values in their resource packs. A new folder can be made at the root of a resource pack called fogs. Any JSON files within this folder will be registered as new fog definitions that can be used by the game.  In this tutorial you will learn the following:  What a fog file looks like and what options are available for customization. The order that fog is applied based on various features, including biome definitions and the /fog command. Requirements  It's recommended you complete Introduction to Resource Packs before beginning this tutorial.  JSON Example  The Vanilla Resource Pack template contains all of the fog files used in the game. These files can serve as examples for creating your own fog definitions. A completed fog file will look similar to the following:  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"minecraft:fog_default\"     },     \"distance\": {       \"air\": {         \"fog_start\": 0.92,         \"fog_end\": 1.0,         \"fog_color\": \"#ABD2FF\",         \"render_distance_type\": \"render\"       },       \"water\": {         \"fog_start\": 0,         \"fog_end\": 60.0,         \"fog_color\": \"#44AFF5\",         \"render_distance_type\": \"fixed\",         \"transition_fog\": {           \"init_fog\": {             \"fog_start\": 0.0,             \"fog_end\": 0.01,             \"fog_color\": \"#44AFF5\",             \"render_distance_type\": \"fixed\"           },           \"min_percent\": 0.25,           \"mid_seconds\": 5,           \"mid_percent\": 0.6,           \"max_seconds\": 30         }       },       \"weather\": {         \"fog_start\": 0.23,         \"fog_end\": 0.7,         \"fog_color\": \"#666666\",         \"render_distance_type\": \"render\"       },       \"lava\": {         \"fog_start\": 0.0,         \"fog_end\": 0.64,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       },       \"lava_resistance\": {         \"fog_start\": 2.0,         \"fog_end\": 4.0,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       }     }   } }  Variables format_version  The resource pack version that this fog setting was built for. This is used for determining upgrade paths and backwards compatibility in newer versions of the game. The minimum version is 1.16.100.  minecraft:fog_settings  Contains the definitions and options of the fog.  description  Holds the description for this fog setting, which primarily contains an identifier.  identifier  Held within the description object.  The unique name to refer to this fog setting. Each identifier requires a namespace. You also must have each identifier be unique or you will get an error. The minecraft namespace is allowed to be used only by the vanilla resource packs.  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"custom_pack:example\"     },     ...   } }  distance  This object contains the values for distance-based fog. This is the fog that limits the player from seeing anything beyond a specific distance from them. Each field within this object contains one type of distance value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and the Lava Resistance effect is active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"distance\": {       \"air\": {         ...       },       \"water\": {         ...       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each distance setting type, you can set the following variables:  fog_start: The distance where the fog will begin to appear. fog_end: The distance where the fog will become completely opaque. render_distance_type: Setting this will determine how the start and end values are used for calculating the fog distances. fixed: The distance is measured in the number of blocks away. render: The distance is multiplied against the current render distance. fog_color: The color that the fog will take on. transition_fog   Note  transition_fog works only for fog in a water setting.  With transition_fog specified, players will see a fog transition from init_fog setting to the water setting when they move into water. The speed of transition can be controlled by percent and second values.  In each transition_fog setting type, you can set the following variables:  init_fog: Initial fog that will slowly transition into water distance fog of the biome when player goes into water. min_percent: Minimum progress of fog transition. mid_seconds: The time takes to reach certain progress('mid_percent') of fog transition. mid_percent: The progress of fog transition after 'mid_seconds' seconds. max_seconds: Total amount of time it takes to complete the fog transition. volumetric  This object contains the values for volumetric fog. This fog will be displayed as a calculation from light passing through blocks. Currently this is only used for Ray Tracing.  density  Held within the volumetric object. Each field within it contains one type of density value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and they have the Lava Resistance effect active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"density\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each density setting type, you can set the following variables:  max_density: the multiplier on how much the fog disrupts the light. 0.0 will have no fog, and 1.0 will be near opaque. uniform: when set to true, the fog density will occur evenly across all heights. zero_density_height: the height in blocks that the fog will begin to appear. This can only be set if uniform is set to false. max_density_height: the height in blocks that the fog will become its max_density. This can be set only if uniform is set to false. media_coefficients  Held within the volumetric object.  Each field within this object defines one type of coefficient value. These are used to determine how the light is dispersed or refracted by the fog as rays travel through different mediums/blocks.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water. cloud: used when light is passing through clouds.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"media_coefficients\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each coefficient setting type, you can set the following variables:  scattering: how much of the RGB of the light the fog will spread. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. absorption: how much of the RGB of the light the fog will absorb. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. Henyey-Greenstein G  Available in format_version 1.21.90 and above, and only applicable in Vibrant Visuals resource packs.  Held within the volumetric object.  Each field within this object defines one type of g value. These are used to determine the distribution of scattered light in different mediums.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"henyey_greenstein_g\": {         \"air\": {           \"henyey_greenstein_g\": 0.75         },         \"water\": {           \"henyey_greenstein_g\": 0.6         }       }     }   In each medium setting type, you can set the following variable:  henyey_greenstein_g: Controls the distribution of scattered light. Values can range from [-1.0, 1.0]. Positive values will result in forward-scattering, while negative values will result in back-scattering. The default value for air is 0.75, while the default for water is 0.6. Active Fog Stack  The active fog stack is used to determine which fog setting to use at any given time in the game. Each player has a unique fog stack.  Whenever the game needs to determine the values for the fog, it will start at the top of the fog stack and check down it until it has found a value for the current setting type. If a fog setting on the stack does not have a setting, then the game will continue checking down the stack. If the game finds no such setting, it will instead use the defaults defined by the engine.  The fog stack is initially setup as follows, with the highest precedence starting at the top:  Command: the settings set on the player by server commands. Biomes: the settings defined to be on each biome. Data Default: the default data driven settings. Engine Default: hard code values. Command  At the top of the stack, the command layer has all the settings set by the /fog command and is evaluated as one stack from top to bottom. More details about the command's usage is found in the \"Fog Command\" section.  Biomes  The biome layer is an average of all the settings defined by the biomes around the player's position. Fog settings can be defined for each individual biome within the biomes_client.json file located at the root of a resource pack. In each biome entry, you can have a variable called fog_identifier and set a name that matches the fog setting you want to use with that biome.  JSON Copy {   \"biomes\": {     ...     \"ice_plains\": {       \"fog_identifier\": \"minecraft:fog_ice_plains\",       ...     },     ...     \"mesa_plateau\": {       \"fog_identifier\": \"minecraft:fog_mesa_plateau\",       ...     },     ...   } }   The default entry can also be set this way and will be used underneath the biome entries in the active fog stack. So, a biome's fog setting does not completely replace the default setting, but instead the biome is read on top of the default as described in the \"Data Default\" section.  Data Default  The data default layer is defined within the default object in the biomes_client.json file in the root of a resource pack, provided that it references a fog definition via the fog_identifier field.  JSON Copy {   \"biomes\": {     \"default\": {       \"fog_identifier\": \"minecraft:fog_default\",       ...     }   },   ... }  Engine Default  The bottom of the stack uses hard-coded values in case there are no data driven values. As such, these cannot be changed and there cannot be any layers beneath it.  Fog Command  The /fog command can be used to manage fog settings at the \"command\" layer of the active fog stack for each player.  Fog settings in this layer are ordered via the push, pop, and remove modes of the /fog command described below. Fog settings are evaluated top-to-bottom in the active fog stack which includes top-to-bottom in this layer first.  Fog settings in this layer are saved and then restored on world load per player. In this way, a fog setting that is pushed before a world save will still apply after a world load and can then be popped.  Push  Pushes a new fog setting to specified player(s), along with a user provided ID, onto the top of the Fog Command layers of the players' active fog stacks.  Pop  Removes the top-most fog setting from selected player(s) that matches the user provided ID, as provided previously via a /fog push command.  Remove  Removes all matching fog settings, from the selected player(s), that matches the user-provided ID, as as provided previously via one or more /fog push commands.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/foginresourcepacks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fog in Resource Packs 05/19/2025  Fogs in Minecraft: Bedrock Edition use JSON files to determine their values. Creators can define their own sets of fog values in their resource packs. A new folder can be made at the root of a resource pack called fogs. Any JSON files within this folder will be registered as new fog definitions that can be used by the game.  In this tutorial you will learn the following:  What a fog file looks like and what options are available for customization. The order that fog is applied based on various features, including biome definitions and the /fog command. Requirements  It's recommended you complete Introduction to Resource Packs before beginning this tutorial.  JSON Example  The Vanilla Resource Pack template contains all of the fog files used in the game. These files can serve as examples for creating your own fog definitions. A completed fog file will look similar to the following:  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"minecraft:fog_default\"     },     \"distance\": {       \"air\": {         \"fog_start\": 0.92,         \"fog_end\": 1.0,         \"fog_color\": \"#ABD2FF\",         \"render_distance_type\": \"render\"       },       \"water\": {         \"fog_start\": 0,         \"fog_end\": 60.0,         \"fog_color\": \"#44AFF5\",         \"render_distance_type\": \"fixed\",         \"transition_fog\": {           \"init_fog\": {             \"fog_start\": 0.0,             \"fog_end\": 0.01,             \"fog_color\": \"#44AFF5\",             \"render_distance_type\": \"fixed\"           },           \"min_percent\": 0.25,           \"mid_seconds\": 5,           \"mid_percent\": 0.6,           \"max_seconds\": 30         }       },       \"weather\": {         \"fog_start\": 0.23,         \"fog_end\": 0.7,         \"fog_color\": \"#666666\",         \"render_distance_type\": \"render\"       },       \"lava\": {         \"fog_start\": 0.0,         \"fog_end\": 0.64,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       },       \"lava_resistance\": {         \"fog_start\": 2.0,         \"fog_end\": 4.0,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       }     }   } }  Variables format_version  The resource pack version that this fog setting was built for. This is used for determining upgrade paths and backwards compatibility in newer versions of the game. The minimum version is 1.16.100.  minecraft:fog_settings  Contains the definitions and options of the fog.  description  Holds the description for this fog setting, which primarily contains an identifier.  identifier  Held within the description object.  The unique name to refer to this fog setting. Each identifier requires a namespace. You also must have each identifier be unique or you will get an error. The minecraft namespace is allowed to be used only by the vanilla resource packs.  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"custom_pack:example\"     },     ...   } }  distance  This object contains the values for distance-based fog. This is the fog that limits the player from seeing anything beyond a specific distance from them. Each field within this object contains one type of distance value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and the Lava Resistance effect is active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"distance\": {       \"air\": {         ...       },       \"water\": {         ...       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each distance setting type, you can set the following variables:  fog_start: The distance where the fog will begin to appear. fog_end: The distance where the fog will become completely opaque. render_distance_type: Setting this will determine how the start and end values are used for calculating the fog distances. fixed: The distance is measured in the number of blocks away. render: The distance is multiplied against the current render distance. fog_color: The color that the fog will take on. transition_fog   Note  transition_fog works only for fog in a water setting.  With transition_fog specified, players will see a fog transition from init_fog setting to the water setting when they move into water. The speed of transition can be controlled by percent and second values.  In each transition_fog setting type, you can set the following variables:  init_fog: Initial fog that will slowly transition into water distance fog of the biome when player goes into water. min_percent: Minimum progress of fog transition. mid_seconds: The time takes to reach certain progress('mid_percent') of fog transition. mid_percent: The progress of fog transition after 'mid_seconds' seconds. max_seconds: Total amount of time it takes to complete the fog transition. volumetric  This object contains the values for volumetric fog. This fog will be displayed as a calculation from light passing through blocks. Currently this is only used for Ray Tracing.  density  Held within the volumetric object. Each field within it contains one type of density value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and they have the Lava Resistance effect active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"density\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each density setting type, you can set the following variables:  max_density: the multiplier on how much the fog disrupts the light. 0.0 will have no fog, and 1.0 will be near opaque. uniform: when set to true, the fog density will occur evenly across all heights. zero_density_height: the height in blocks that the fog will begin to appear. This can only be set if uniform is set to false. max_density_height: the height in blocks that the fog will become its max_density. This can be set only if uniform is set to false. media_coefficients  Held within the volumetric object.  Each field within this object defines one type of coefficient value. These are used to determine how the light is dispersed or refracted by the fog as rays travel through different mediums/blocks.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water. cloud: used when light is passing through clouds.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"media_coefficients\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each coefficient setting type, you can set the following variables:  scattering: how much of the RGB of the light the fog will spread. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. absorption: how much of the RGB of the light the fog will absorb. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. Henyey-Greenstein G  Available in format_version 1.21.90 and above, and only applicable in Vibrant Visuals resource packs.  Held within the volumetric object.  Each field within this object defines one type of g value. These are used to determine the distribution of scattered light in different mediums.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"henyey_greenstein_g\": {         \"air\": {           \"henyey_greenstein_g\": 0.75         },         \"water\": {           \"henyey_greenstein_g\": 0.6         }       }     }   In each medium setting type, you can set the following variable:  henyey_greenstein_g: Controls the distribution of scattered light. Values can range from [-1.0, 1.0]. Positive values will result in forward-scattering, while negative values will result in back-scattering. The default value for air is 0.75, while the default for water is 0.6. Active Fog Stack  The active fog stack is used to determine which fog setting to use at any given time in the game. Each player has a unique fog stack.  Whenever the game needs to determine the values for the fog, it will start at the top of the fog stack and check down it until it has found a value for the current setting type. If a fog setting on the stack does not have a setting, then the game will continue checking down the stack. If the game finds no such setting, it will instead use the defaults defined by the engine.  The fog stack is initially setup as follows, with the highest precedence starting at the top:  Command: the settings set on the player by server commands. Biomes: the settings defined to be on each biome. Data Default: the default data driven settings. Engine Default: hard code values. Command  At the top of the stack, the command layer has all the settings set by the /fog command and is evaluated as one stack from top to bottom. More details about the command's usage is found in the \"Fog Command\" section.  Biomes  The biome layer is an average of all the settings defined by the biomes around the player's position. Fog settings can be defined for each individual biome within the biomes_client.json file located at the root of a resource pack. In each biome entry, you can have a variable called fog_identifier and set a name that matches the fog setting you want to use with that biome.  JSON Copy {   \"biomes\": {     ...     \"ice_plains\": {       \"fog_identifier\": \"minecraft:fog_ice_plains\",       ...     },     ...     \"mesa_plateau\": {       \"fog_identifier\": \"minecraft:fog_mesa_plateau\",       ...     },     ...   } }   The default entry can also be set this way and will be used underneath the biome entries in the active fog stack. So, a biome's fog setting does not completely replace the default setting, but instead the biome is read on top of the default as described in the \"Data Default\" section.  Data Default  The data default layer is defined within the default object in the biomes_client.json file in the root of a resource pack, provided that it references a fog definition via the fog_identifier field.  JSON Copy {   \"biomes\": {     \"default\": {       \"fog_identifier\": \"minecraft:fog_default\",       ...     }   },   ... }  Engine Default  The bottom of the stack uses hard-coded values in case there are no data driven values. As such, these cannot be changed and there cannot be any layers beneath it.  Fog Command  The /fog command can be used to manage fog settings at the \"command\" layer of the active fog stack for each player.  Fog settings in this layer are ordered via the push, pop, and remove modes of the /fog command described below. Fog settings are evaluated top-to-bottom in the active fog stack which includes top-to-bottom in this layer first.  Fog settings in this layer are saved and then restored on world load per player. In this way, a fog setting that is pushed before a world save will still apply after a world load and can then be popped.  Push  Pushes a new fog setting to specified player(s), along with a user provided ID, onto the top of the Fog Command layers of the players' active fog stacks.  Pop  Removes the top-most fog setting from selected player(s) that matches the user provided ID, as provided previously via a /fog push command.  Remove  Removes all matching fog settings, from the selected player(s), that matches the user-provided ID, as as provided previously via one or more /fog push commands.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/controlschemes?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Control Schemes 05/28/2025  In Minecraft: Bedrock Edition, players can choose from a set of schemes that define how the player and the camera move in response to controller input. These provide great flexibility for different gameplay scenarios.  The control scheme can be manually set by using the /controlscheme command. It can also be set with camera presets.  Control scheme types  Each control scheme defines how Minecraft responds to game controllers, touch input on mobile devices, keyboard and mouse combos, and full keyboard controls.  Player relative  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Use the right stick to rotate the camera when using the third-person Follow Orbit camera.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Drag on the screen to rotate the camera when using the third-person Follow Orbit camera.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Use the mouse to rotate the camera when using the third-person Follow Orbit camera.  Full Keyboard: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Press the left and right arrows to rotate the camera when using the third-person Follow Orbit camera. The numeric keypad can also be used for camera rotation if enabled.  Player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to the left or right without turning (strafe). Push the right stick in a direction to have the player look in that direction.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing. Push it left or right to move the player to their left or right without turning (strafe). Touch and drag on the screen to have your character look at the point you are touching. Note: this control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. The character will look toward where the mouse is on screen.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. Press the left and right arrows to rotate the player. The numeric keypad can also be used for player rotation if enabled.  Locked player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to their left or right without turning (strafe). Push the right stick left or right to turn the player to their left or right. Pushing the right stick up or down will make the player's aim rotate up or down.  Touch: Push the virtual joystick or D-pad forward or backward to make the player move forward or backward in the direction they're facing. Push the virtual joystick or D-pad left or right to move the player to their left or right without turning (strafe). Swiping left or right rotates the player, while swiping up or down makes the player look up or down. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Moving the mouse left or right will turn the player to their left or right. Moving the mouse forward or back will move the player's aim up or down.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Press the left and right arrows to rotate the player. Press the up and down arrows to rotate the player's aim up or down. The numeric keypad can also be used for player rotation if enabled.  Camera relative  Controller: Use the left stick to control player movement; the player automatically faces the direction of motion. Down moves toward the camera, up moves away, left moves toward the left side of the screen, and right moves toward the right side. Use the right stick to rotate the camera.  Touch: Push the virtual joystick or D-pad to control player movement; the player automatically faces the direction of motion. Drag on the screen to rotate the camera.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Use the mouse to rotate the camera.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Press the left and right arrows to rotate the camera. The numeric keypad can also be used for camera rotation if enabled.  Camera relative strafe   Note  This scheme is experimental, and requires the Experimental Creator Camera setting to be enabled.  Controller: Use the left stick to move the player without turning (strafe). Use the right stick to rotate the player to look in the direction the stick is moved.  Touch: Push the virtual joystick or D-pad to move the player without turning (strafe). Drag on the screen to rotate the player to look toward the point being touched. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. The player will rotate to look toward the mouse location.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. Press the arrow keys to rotate the player to look in that direction. The numeric keypad can also be used for rotation if enabled.  Control schemes and camera presets  When you use camera presets, you can use the control_scheme key in the camera.json file to associate a control scheme with a preset.  JSON Copy {     \"format_version\": \"1.19.50\",     \"minecraft:camera_preset\": {         \"identifier\": \"example:custom\",         \"inherit_from\": \"minecraft:follow_orbit\",         \"control_scheme\": \"camera_relative\"     } }   Setting a control scheme in a camera preset will override the preset's default control scheme, as long as the scheme is allowed in that camera mode. If the scheme is not allowed in that mode, or you don't include the control_scheme key in that preset, the default control scheme of the camera mode will be used instead.  Here are the allowed control schemes for each built-in camera preset. The default control scheme for all built-in presets is locked player relative strafe.  Expand table Camera Preset\tAllowed Control Schemes minecraft:first_person\tlocked player relative strafe minecraft:third_person\tlocked player relative strafe minecraft:third_person_front\tlocked player relative strafe minecraft:free\tlocked player relative strafe player relative strafe player relative camera relative camera relative strafe minecraft:follow_orbit\tlocked player relative strafe player relative camera relative minecraft:fixed_boom\tlocked player relative strafe camera relative camera relative strafe player relative strafe player relative Switching control schemes  To switch schemes from the command line, use the /controlscheme command.  /controlscheme <player> set <control_scheme>  Possible control schemes are:  camera_relative camera_relative_strafe player_relative player_relative_strafe locked_player_relative_strafe  You can reset the control scheme to the default for the current camera mode with the clear subcommand:  /controlscheme <player> clear  Note that you can only switch to a control scheme that's allowed in the current camera mode.  Control scheme inheritance  A custom camera preset inherits the allowed control schemes of the built-in camera preset it descends from. It will use the default control scheme of its parent camera if its own control_scheme is not defined, or if the defined scheme is not supported by the camera.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/controlschemes?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Control Schemes 05/28/2025  In Minecraft: Bedrock Edition, players can choose from a set of schemes that define how the player and the camera move in response to controller input. These provide great flexibility for different gameplay scenarios.  The control scheme can be manually set by using the /controlscheme command. It can also be set with camera presets.  Control scheme types  Each control scheme defines how Minecraft responds to game controllers, touch input on mobile devices, keyboard and mouse combos, and full keyboard controls.  Player relative  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Use the right stick to rotate the camera when using the third-person Follow Orbit camera.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing, and left or right to rotate the player to the left or right. Drag on the screen to rotate the camera when using the third-person Follow Orbit camera.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Use the mouse to rotate the camera when using the third-person Follow Orbit camera.  Full Keyboard: Press W to move the player forward, S to move backward, A to rotate them left, and D to rotate right. Press the left and right arrows to rotate the camera when using the third-person Follow Orbit camera. The numeric keypad can also be used for camera rotation if enabled.  Player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to the left or right without turning (strafe). Push the right stick in a direction to have the player look in that direction.  Touch: Push the virtual joystick or D-pad forward or backward to move forward or backward in the direction they're facing. Push it left or right to move the player to their left or right without turning (strafe). Touch and drag on the screen to have your character look at the point you are touching. Note: this control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. The character will look toward where the mouse is on screen.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the character's left, and D to move (strafe) to the character's right. Press the left and right arrows to rotate the player. The numeric keypad can also be used for player rotation if enabled.  Locked player relative strafe  Controller: Push the left stick forward or backward to move the player forward or backward in the direction they're facing, and left or right to move the player to their left or right without turning (strafe). Push the right stick left or right to turn the player to their left or right. Pushing the right stick up or down will make the player's aim rotate up or down.  Touch: Push the virtual joystick or D-pad forward or backward to make the player move forward or backward in the direction they're facing. Push the virtual joystick or D-pad left or right to move the player to their left or right without turning (strafe). Swiping left or right rotates the player, while swiping up or down makes the player look up or down. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Moving the mouse left or right will turn the player to their left or right. Moving the mouse forward or back will move the player's aim up or down.  Full Keyboard: Press W to move the player forward, S to move backward, A to move (strafe) to the player's left, and D to move (strafe) to the player's right. Press the left and right arrows to rotate the player. Press the up and down arrows to rotate the player's aim up or down. The numeric keypad can also be used for player rotation if enabled.  Camera relative  Controller: Use the left stick to control player movement; the player automatically faces the direction of motion. Down moves toward the camera, up moves away, left moves toward the left side of the screen, and right moves toward the right side. Use the right stick to rotate the camera.  Touch: Push the virtual joystick or D-pad to control player movement; the player automatically faces the direction of motion. Drag on the screen to rotate the camera.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Use the mouse to rotate the camera.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right; the player automatically faces the direction of motion. Press the left and right arrows to rotate the camera. The numeric keypad can also be used for camera rotation if enabled.  Camera relative strafe   Note  This scheme is experimental, and requires the Experimental Creator Camera setting to be enabled.  Controller: Use the left stick to move the player without turning (strafe). Use the right stick to rotate the player to look in the direction the stick is moved.  Touch: Push the virtual joystick or D-pad to move the player without turning (strafe). Drag on the screen to rotate the player to look toward the point being touched. Note: This control scheme will force the visible joystick option on.  Keyboard + Mouse: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. The player will rotate to look toward the mouse location.  Full Keyboard: Press W to move the player in the direction the camera faces, S to move backward toward the camera, A to move screen left, and D to move screen right. Press the arrow keys to rotate the player to look in that direction. The numeric keypad can also be used for rotation if enabled.  Control schemes and camera presets  When you use camera presets, you can use the control_scheme key in the camera.json file to associate a control scheme with a preset.  JSON Copy {     \"format_version\": \"1.19.50\",     \"minecraft:camera_preset\": {         \"identifier\": \"example:custom\",         \"inherit_from\": \"minecraft:follow_orbit\",         \"control_scheme\": \"camera_relative\"     } }   Setting a control scheme in a camera preset will override the preset's default control scheme, as long as the scheme is allowed in that camera mode. If the scheme is not allowed in that mode, or you don't include the control_scheme key in that preset, the default control scheme of the camera mode will be used instead.  Here are the allowed control schemes for each built-in camera preset. The default control scheme for all built-in presets is locked player relative strafe.  Expand table Camera Preset\tAllowed Control Schemes minecraft:first_person\tlocked player relative strafe minecraft:third_person\tlocked player relative strafe minecraft:third_person_front\tlocked player relative strafe minecraft:free\tlocked player relative strafe player relative strafe player relative camera relative camera relative strafe minecraft:follow_orbit\tlocked player relative strafe player relative camera relative minecraft:fixed_boom\tlocked player relative strafe camera relative camera relative strafe player relative strafe player relative Switching control schemes  To switch schemes from the command line, use the /controlscheme command.  /controlscheme <player> set <control_scheme>  Possible control schemes are:  camera_relative camera_relative_strafe player_relative player_relative_strafe locked_player_relative_strafe  You can reset the control scheme to the default for the current camera mode with the clear subcommand:  /controlscheme <player> clear  Note that you can only switch to a control scheme that's allowed in the current camera mode.  Control scheme inheritance  A custom camera preset inherits the allowed control schemes of the built-in camera preset it descends from. It will use the default control scheme of its parent camera if its own control_scheme is not defined, or if the defined scheme is not supported by the camera.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/resourcepack?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Resource Packs 05/07/2025  Before building your first Add-On for Minecraft: Bedrock Edition, you'll need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A resource pack is a folder structure that contains all of your custom models, sounds, textures, and other custom content.  In this tutorial, you will learn:  How a resource pack is created. How a manifest file is created. How custom textures are loaded into Minecraft: Bedrock Edition. The concept of Pack Stacking when working with Add-On content. Sample Resource Pack  There is a sample resource pack available on the Minecraft samples GitHub. This pack may be used to understand the structure of resource packs and to check your work after you complete this tutorial.  Requirements  It's recommended you complete Getting Started with Add-On Development before beginning this tutorial.  Building the Resource Pack  For Minecraft to find and use your resource files, you must set up the folders and files in a specific way. This tutorial will guide you through creating this folder and file structure.  Create a Resource Pack Folder  We will start by creating a folder called My_RESOURCE_Pack. Technically you can name this folder anything you want, but the other folders have to be named exactly as specified in this tutorial so that Minecraft knows where to find the information.  Locate com.mojang on a Windows device Open the com.mojang folder. Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK. Double-click the development_resource_packs folder to open it. Add a new folder and name it My_RESOURCE_Pack. Double-click the My_RESOURCE_Pack folder to open it.  Create a Manifest File  To load a resource pack into Minecraft, we need a manifest file. The manifest file is a JSON file that contains the following information:  Description: In-game description of what the resource pack does. Name: In-game name of the resource pack. UUID: Universally Unique Identifier. Version: Version of the resource pack. Minimum Engine Version: Minimum required version of Minecraft for this pack to work properly.   Note  To learn more about how a manifest.json file works, see the Addons Reference manifest.json documentation.  Minecraft parses the information from the manifest file and displays it in the Add-On section of the game. Inside the file, the information is split into two separate sections: Header and modules. The header section contains the overall information for the pack, while the modules section contains the dedicated packages information. To create the manifest.json file:  Right-click in the Explorer window, and select New > Text Document. Name it manifest.json. You will need to change the file extension from .txt to .json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab.  Double-click the manifest.json file to open it in a text editor. Copy and paste the following code into your file. JSON Copy {  \"format_version\": 2,  \"header\": {    \"description\": \"My dirt resource pack Add-On!\",    \"name\": \"My Resource Pack\",    \"uuid\": \"<FIRST GENERATED UUID>\",    \"version\": [1, 0, 0],    \"min_engine_version\": [1, 16, 0]   },  \"modules\": [    {      \"description\": \"My First Add-On!\",      \"type\": \"resources\",      \"uuid\": \"<SECOND GENERATED UUID>\",      \"version\": [1, 0, 0]    }  ] }  Set the UUID  A Universally Unique Identifier (UUID) is a unique number used for identification purposes. For Minecraft, the UUID is used to define a specific pack and to prevent any duplicate software from causing issues. For the header and modules, there will need to be two different UUID numbers entered in each of the \"uuid\" fields between the quotes. You can get UUIDs from an online UUID Generator such as https://www.uuidgenerator.net/.  Copy and paste a UUID into the header section. The UUID will need to be pasted in the \"uuid\":\"\" field between the quotation (\"\") marks to be read correctly. Refresh the webpage to generate a new UUID for use in the Modules section. Copy and paste the new UUID into the modules section in the \"uuid\" field between the quotation marks. Save the manifest.json file. Changing the Dirt Block  With the manifest file completed, you can now start adding custom content to Minecraft. Let's get started by applying a new texture to the Vanilla dirt block. The first part of the process involves creating a folder structure to hold the custom texture.  Open the My_RESOURCE_Pack folder and create a folder named textures. Double-click the textures folder to open it. Open the textures folder and create a folder named blocks. Double-click the blocks folder to open it. Create the texture  Now that the folder structure is created, we can start adding some custom textures. This green square is an example of the type of file created using the following steps.  You can download this green block and save it in your blocks folder or follow these steps to create your texture:  Open up an image editor such as MS Paint. Go to the File menu and select Properties. Set the Width and Height to 16 pixels each. Click OK.  You can now design a pattern or any artwork in the editor. To make the green square, a simple fill color was added.   Note  MS Paint is used in this example for quick and easy access, but you will need to use a different graphics editor for more advanced graphic features like transparency effects or .tga file support.  After editing the texture, go to the File menu and select Save As. Choose the PNG picture option. In the Save As dialog box, navigate to the blocks folder. Save the file as dirt.png. Test the pack  Now that the pack has both a manifest file and a texture file, you can launch Minecraft and test your new resource Add-On.   Important  Pack Stacking is how content is loaded on top of Vanilla content, causing each object that has the same name in both packs to be overwritten by the latest applied pack. In our example, the original dirt texture is overwritten by the custom texture.  If another pack that uses the dirt.png file is loaded after My_RESOURCE_Pack, then Minecraft will use that file instead.  Your custom texture will be used on every dirt.png block in the world, but it will not be used on blocks of dirt with grass on them because those blocks have a different name.  Launch Minecraft and select Play. Select Create New World. Under Settings, scroll down to the Add-Ons section. Click on Resource Packs to see all available packs. Click the MY PACKS drop-down. Select My RESOURCE Pack and click Activate to add the resource pack to the world. Click Create.  Troubleshooting  Resource pack woes? Don't worry, troubleshooting is a normal part of any development process.  You can use the sample resource pack on the Minecraft samples GitHub site to check the structure of your resource pack.  Your Resource Pack Does Not Appear in Minecraft  If your resource pack does not appear in the Add-Ons section of a world, the issue may be a malformed manifest.json file. Let's investigate.  Are there two different UUIDs in the manifest.json header and modules section? See the UUID section for more information. Have you turned on file extensions and paths? If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab. Double-check JSON curly braces and brackets. JSON linting tools can help. Resource Pack Shows Up, Content Doesn't Work Check that the textures folder is in the right place, and spelled correctly. Then check the blocks folder as well. Download the Vanilla resource pack and try adding your block to the existing textures/blocks folder. Make sure the new texture file is named the same as the Vanilla texture it's replacing. Move your pack above others to ensure your dirt.png texture is loaded before other resource packs. What's Next?  With a custom texture now a part of your Minecraft world, it's time to see how behavior packs alter existing entity behaviors. In our next tutorial, you will add aggressive behavior to a normally peaceful cow.  Behavior pack  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/resourcepack?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Resource Packs 05/07/2025  Before building your first Add-On for Minecraft: Bedrock Edition, you'll need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A resource pack is a folder structure that contains all of your custom models, sounds, textures, and other custom content.  In this tutorial, you will learn:  How a resource pack is created. How a manifest file is created. How custom textures are loaded into Minecraft: Bedrock Edition. The concept of Pack Stacking when working with Add-On content. Sample Resource Pack  There is a sample resource pack available on the Minecraft samples GitHub. This pack may be used to understand the structure of resource packs and to check your work after you complete this tutorial.  Requirements  It's recommended you complete Getting Started with Add-On Development before beginning this tutorial.  Building the Resource Pack  For Minecraft to find and use your resource files, you must set up the folders and files in a specific way. This tutorial will guide you through creating this folder and file structure.  Create a Resource Pack Folder  We will start by creating a folder called My_RESOURCE_Pack. Technically you can name this folder anything you want, but the other folders have to be named exactly as specified in this tutorial so that Minecraft knows where to find the information.  Locate com.mojang on a Windows device Open the com.mojang folder. Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK. Double-click the development_resource_packs folder to open it. Add a new folder and name it My_RESOURCE_Pack. Double-click the My_RESOURCE_Pack folder to open it.  Create a Manifest File  To load a resource pack into Minecraft, we need a manifest file. The manifest file is a JSON file that contains the following information:  Description: In-game description of what the resource pack does. Name: In-game name of the resource pack. UUID: Universally Unique Identifier. Version: Version of the resource pack. Minimum Engine Version: Minimum required version of Minecraft for this pack to work properly.   Note  To learn more about how a manifest.json file works, see the Addons Reference manifest.json documentation.  Minecraft parses the information from the manifest file and displays it in the Add-On section of the game. Inside the file, the information is split into two separate sections: Header and modules. The header section contains the overall information for the pack, while the modules section contains the dedicated packages information. To create the manifest.json file:  Right-click in the Explorer window, and select New > Text Document. Name it manifest.json. You will need to change the file extension from .txt to .json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab.  Double-click the manifest.json file to open it in a text editor. Copy and paste the following code into your file. JSON Copy {  \"format_version\": 2,  \"header\": {    \"description\": \"My dirt resource pack Add-On!\",    \"name\": \"My Resource Pack\",    \"uuid\": \"<FIRST GENERATED UUID>\",    \"version\": [1, 0, 0],    \"min_engine_version\": [1, 16, 0]   },  \"modules\": [    {      \"description\": \"My First Add-On!\",      \"type\": \"resources\",      \"uuid\": \"<SECOND GENERATED UUID>\",      \"version\": [1, 0, 0]    }  ] }  Set the UUID  A Universally Unique Identifier (UUID) is a unique number used for identification purposes. For Minecraft, the UUID is used to define a specific pack and to prevent any duplicate software from causing issues. For the header and modules, there will need to be two different UUID numbers entered in each of the \"uuid\" fields between the quotes. You can get UUIDs from an online UUID Generator such as https://www.uuidgenerator.net/.  Copy and paste a UUID into the header section. The UUID will need to be pasted in the \"uuid\":\"\" field between the quotation (\"\") marks to be read correctly. Refresh the webpage to generate a new UUID for use in the Modules section. Copy and paste the new UUID into the modules section in the \"uuid\" field between the quotation marks. Save the manifest.json file. Changing the Dirt Block  With the manifest file completed, you can now start adding custom content to Minecraft. Let's get started by applying a new texture to the Vanilla dirt block. The first part of the process involves creating a folder structure to hold the custom texture.  Open the My_RESOURCE_Pack folder and create a folder named textures. Double-click the textures folder to open it. Open the textures folder and create a folder named blocks. Double-click the blocks folder to open it. Create the texture  Now that the folder structure is created, we can start adding some custom textures. This green square is an example of the type of file created using the following steps.  You can download this green block and save it in your blocks folder or follow these steps to create your texture:  Open up an image editor such as MS Paint. Go to the File menu and select Properties. Set the Width and Height to 16 pixels each. Click OK.  You can now design a pattern or any artwork in the editor. To make the green square, a simple fill color was added.   Note  MS Paint is used in this example for quick and easy access, but you will need to use a different graphics editor for more advanced graphic features like transparency effects or .tga file support.  After editing the texture, go to the File menu and select Save As. Choose the PNG picture option. In the Save As dialog box, navigate to the blocks folder. Save the file as dirt.png. Test the pack  Now that the pack has both a manifest file and a texture file, you can launch Minecraft and test your new resource Add-On.   Important  Pack Stacking is how content is loaded on top of Vanilla content, causing each object that has the same name in both packs to be overwritten by the latest applied pack. In our example, the original dirt texture is overwritten by the custom texture.  If another pack that uses the dirt.png file is loaded after My_RESOURCE_Pack, then Minecraft will use that file instead.  Your custom texture will be used on every dirt.png block in the world, but it will not be used on blocks of dirt with grass on them because those blocks have a different name.  Launch Minecraft and select Play. Select Create New World. Under Settings, scroll down to the Add-Ons section. Click on Resource Packs to see all available packs. Click the MY PACKS drop-down. Select My RESOURCE Pack and click Activate to add the resource pack to the world. Click Create.  Troubleshooting  Resource pack woes? Don't worry, troubleshooting is a normal part of any development process.  You can use the sample resource pack on the Minecraft samples GitHub site to check the structure of your resource pack.  Your Resource Pack Does Not Appear in Minecraft  If your resource pack does not appear in the Add-Ons section of a world, the issue may be a malformed manifest.json file. Let's investigate.  Are there two different UUIDs in the manifest.json header and modules section? See the UUID section for more information. Have you turned on file extensions and paths? If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab. Double-check JSON curly braces and brackets. JSON linting tools can help. Resource Pack Shows Up, Content Doesn't Work Check that the textures folder is in the right place, and spelled correctly. Then check the blocks folder as well. Download the Vanilla resource pack and try adding your block to the existing textures/blocks folder. Make sure the new texture file is named the same as the Vanilla texture it's replacing. Move your pack above others to ensure your dirt.png texture is loaded before other resource packs. What's Next?  With a custom texture now a part of your Minecraft world, it's time to see how behavior packs alter existing entity behaviors. In our next tutorial, you will add aggressive behavior to a normally peaceful cow.  Behavior pack  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/learningjourneyguide?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creator Learning Journey 05/21/2025  So you love Minecraft Bedrock and you've been inspired to create or modify a world that is all your own. That's a great place to start!  If you've never done anything like that before, maybe the best first step is to prove that it can be done.  You, as a creator, can add your favorite things to our favorite game by using Add-Ons.  Along the way, you will learn how to use computer science stuff like files and directories, JavaScript Object Notation (JSON), reference documentation, and the same tools your fellow creators use to create and test the contents of their Add-On packs.  Oh! That's a good thing to learn now: resource packs, behavior packs, and skin packs are collectively known as Add-On packs, or just Add-Ons.  Step 1: Learn what goes where  Getting Started with Add-On Development for Bedrock Edition - Start here to learn about the file and folder structure of Minecraft, specifically, where to put your add-on packs.  Comprehensive List of Add-on Pack Contents - After you get an idea about where your add-on packs will go, here is a page about the structures and content for each of those add-on packs.  Just take a quick look and maybe use this later when you plan your packs!  Step 2: Make something  This is where we learn to create resource and behavior packs to affect things in the world:  Create Custom Grass Blocks: An Introduction to Resource Packs Create an Angry Cow: An Introduction to Behavior Packs Step 3: Make more complex things  You've mastered the basics, and now it's time to move to the next level. These creations are slightly more complex, but learning about them can help you create a more personalized Minecraft experience.  Add a Custom Sound Create an Entity Create a Custom Block Create a Sushi Block: Advanced Custom Blocks Create a Custom Item Change Your Look with a Skin Pack Advanced stuff that might not use add-on packs  After you pushed through both the basic and intermediate creations, you come to the top of the mountain. These are the advanced-level tutorials and—I'm not going to lie—they can get complex. However, by mastering these creations, you'll bring yourself closer to making your Minecraft dreams into Minecraft reality.  Commonly Used Tools Animate a Block Texture Create a Goblin Chef Entity Create a Loot Table Create a Village with Structure Blocks Create an In-World Game with Commands Non-Player Character (NPC) Dialogue Minecraft Bedrock Editor Next steps  If you've made it this far, congratulations! You went on an amazing creator experience and came out the other side. Now that you've completed our suggested path, we have good news and better news.  The good news is that you now have an incredible set of skills at your disposal to make custom content and provide players with something unique and fun. The better news is that this is just a small sample of what you can find on the creator learning portal. So take some time and look around, continue to create, and always keep learning!  Survival Spawn Creation Introduction to Game Rules Bedrock Creator Camp 2025  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/learningjourneyguide?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creator Learning Journey 05/21/2025  So you love Minecraft Bedrock and you've been inspired to create or modify a world that is all your own. That's a great place to start!  If you've never done anything like that before, maybe the best first step is to prove that it can be done.  You, as a creator, can add your favorite things to our favorite game by using Add-Ons.  Along the way, you will learn how to use computer science stuff like files and directories, JavaScript Object Notation (JSON), reference documentation, and the same tools your fellow creators use to create and test the contents of their Add-On packs.  Oh! That's a good thing to learn now: resource packs, behavior packs, and skin packs are collectively known as Add-On packs, or just Add-Ons.  Step 1: Learn what goes where  Getting Started with Add-On Development for Bedrock Edition - Start here to learn about the file and folder structure of Minecraft, specifically, where to put your add-on packs.  Comprehensive List of Add-on Pack Contents - After you get an idea about where your add-on packs will go, here is a page about the structures and content for each of those add-on packs.  Just take a quick look and maybe use this later when you plan your packs!  Step 2: Make something  This is where we learn to create resource and behavior packs to affect things in the world:  Create Custom Grass Blocks: An Introduction to Resource Packs Create an Angry Cow: An Introduction to Behavior Packs Step 3: Make more complex things  You've mastered the basics, and now it's time to move to the next level. These creations are slightly more complex, but learning about them can help you create a more personalized Minecraft experience.  Add a Custom Sound Create an Entity Create a Custom Block Create a Sushi Block: Advanced Custom Blocks Create a Custom Item Change Your Look with a Skin Pack Advanced stuff that might not use add-on packs  After you pushed through both the basic and intermediate creations, you come to the top of the mountain. These are the advanced-level tutorials and—I'm not going to lie—they can get complex. However, by mastering these creations, you'll bring yourself closer to making your Minecraft dreams into Minecraft reality.  Commonly Used Tools Animate a Block Texture Create a Goblin Chef Entity Create a Loot Table Create a Village with Structure Blocks Create an In-World Game with Commands Non-Player Character (NPC) Dialogue Minecraft Bedrock Editor Next steps  If you've made it this far, congratulations! You went on an amazing creator experience and came out the other side. Now that you've completed our suggested path, we have good news and better news.  The good news is that you now have an incredible set of skills at your disposal to make custom content and provide players with something unique and fun. The better news is that this is just a small sample of what you can find on the creator learning portal. So take some time and look around, continue to create, and always keep learning!  Survival Spawn Creation Introduction to Game Rules Bedrock Creator Camp 2025  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gettingstarted?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Add-On Development for Bedrock Edition 05/07/2025  Whether you create them yourself or get them from another creator, add-ons are the first step on the journey of bringing greater levels of customization to Minecraft: Bedrock Edition. Add-ons allow players to transform the look of their worlds and even change the behavior of entities. For example, you can change the blast radius of a creeper and the texture it's wearing.  In this article, you'll learn:  How to download add-ons for various devices. The file structure used by Minecraft add-ons. How Visual Studio Code can be used for editing JSON files. Where to find applicable extensions for Visual Studio Code. Installing add-ons  Add-ons can be installed on a variety of platforms running Minecraft. Here's how:  Windows 10 or Windows 11 Realms/Console Android iOS Oculus Rift First, you'll need a Windows 10 or Windows 11 computer with Minecraft: Bedrock Edition installed. Download the world or add-on file from the provided source. If the file downloads as a .zip file, change the file extension name to \".mcworld\" or \".mcpack\". Navigate to the directory where you downloaded the file. Open the file and the add-on should open in Minecraft. If you're opening a .mcworld that contains add-ons, the game will notify you that you've successfully imported the world. It will then be available from the \"Play\" menu. If you're opening a .mcpack, a pop-up notification will alert you that you've successfully imported the pack. Depending on the pack type, this will then be available when editing worlds in either the Behavior Pack tab or Resource Pack tab. The com.mojang folder  A folder called com.mojang was added to the AppData folder during Minecraft installation. You'll need to find this folder so you can add your content to it.  To locate the com.mojang folder on your computer, you'll need to have the Hidden items checkbox set to true, as shown below. Also, check the box for File name extensions.  Showing hidden items Open File Explorer from the taskbar. Select the View tab. In the Show/hide section, select the checkboxes for File name extensions and Hidden items.  Locating com.mojang on a Windows device Press Win+R to open Run. If you are using the main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using the preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.   Tip  This is a great time to save a shortcut to this folder on your desktop.  As shown in the image below, there are multiple subdirectories located within the com.mojang folder.   Tip  If you see more content in this folder than what is shown above, do not panic! This image shows a fresh install of Minecraft.  Behavior, Skin, and Resource Packs  There are three folders called behavior_packs, resource_packs, and skin_packs that will store finalized custom content that will be added to Minecraft: Bedrock Edition. Don't worry about these folders right now; you're going to be developing content, so you'll be working in the development versions of these folders, as discussed in the next section.  Development Packs  Use the development_resource_packs and development_behavior_packs folders for the Resource Pack and Behavior Pack tutorials. Development pack folders are updated each time Minecraft is launched, so you can quickly load and test the changes you made to their contents.  minecraftWorlds  minecraftWorlds contains each world that has been generated within the current build of Minecraft. Each folder also contains resource and behavior pack folders for any packs that may be in use within the world.   Tip  When installing a new build of Minecraft, you should save a copy of this folder as a backup to prevent any potential loss of Minecraft worlds that you may have.  Visual Studio Code  The files you'll be creating to customize Minecraft: Bedrock Edition will be written in JSON, a popular format for describing data. JSON can be edited in any text editor such as Notepad or Word, but it's easier to edit it with a programming editor that understands JSON natively. Microsoft's Visual Studio Code is a free programming editor that not only works great with JSON, it supports extensions that add functionality—including some built specifically for Bedrock development.  Installing Visual Studio Code  Follow this link to install Visual Studio Code.  Visual Studio Code Extensions  Visual Studio Code supports extensions created by the Visual Studio Code developer community. Extensions are a great way to help write and understand Minecraft syntax when working on resource and behavior packs.  Here's two recommended extensions for Minecraft development:  Blockception's Minecraft Bedrock Development Bedrock Definitions What's next?  Now that your development environment is set up, you can start creating your first add-on and learn more about resource packs.  Introduction to Resource Packs  Alternatively, if you'd like to learn how to use commands, head on over to Getting Started with Command Blocks and learn how to use command blocks to chain together different commands.  Getting Started with Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gettingstarted?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Add-On Development for Bedrock Edition 05/07/2025  Whether you create them yourself or get them from another creator, add-ons are the first step on the journey of bringing greater levels of customization to Minecraft: Bedrock Edition. Add-ons allow players to transform the look of their worlds and even change the behavior of entities. For example, you can change the blast radius of a creeper and the texture it's wearing.  In this article, you'll learn:  How to download add-ons for various devices. The file structure used by Minecraft add-ons. How Visual Studio Code can be used for editing JSON files. Where to find applicable extensions for Visual Studio Code. Installing add-ons  Add-ons can be installed on a variety of platforms running Minecraft. Here's how:  Windows 10 or Windows 11 Realms/Console Android iOS Oculus Rift First, you'll need a Windows 10 or Windows 11 computer with Minecraft: Bedrock Edition installed. Download the world or add-on file from the provided source. If the file downloads as a .zip file, change the file extension name to \".mcworld\" or \".mcpack\". Navigate to the directory where you downloaded the file. Open the file and the add-on should open in Minecraft. If you're opening a .mcworld that contains add-ons, the game will notify you that you've successfully imported the world. It will then be available from the \"Play\" menu. If you're opening a .mcpack, a pop-up notification will alert you that you've successfully imported the pack. Depending on the pack type, this will then be available when editing worlds in either the Behavior Pack tab or Resource Pack tab. The com.mojang folder  A folder called com.mojang was added to the AppData folder during Minecraft installation. You'll need to find this folder so you can add your content to it.  To locate the com.mojang folder on your computer, you'll need to have the Hidden items checkbox set to true, as shown below. Also, check the box for File name extensions.  Showing hidden items Open File Explorer from the taskbar. Select the View tab. In the Show/hide section, select the checkboxes for File name extensions and Hidden items.  Locating com.mojang on a Windows device Press Win+R to open Run. If you are using the main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using the preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.   Tip  This is a great time to save a shortcut to this folder on your desktop.  As shown in the image below, there are multiple subdirectories located within the com.mojang folder.   Tip  If you see more content in this folder than what is shown above, do not panic! This image shows a fresh install of Minecraft.  Behavior, Skin, and Resource Packs  There are three folders called behavior_packs, resource_packs, and skin_packs that will store finalized custom content that will be added to Minecraft: Bedrock Edition. Don't worry about these folders right now; you're going to be developing content, so you'll be working in the development versions of these folders, as discussed in the next section.  Development Packs  Use the development_resource_packs and development_behavior_packs folders for the Resource Pack and Behavior Pack tutorials. Development pack folders are updated each time Minecraft is launched, so you can quickly load and test the changes you made to their contents.  minecraftWorlds  minecraftWorlds contains each world that has been generated within the current build of Minecraft. Each folder also contains resource and behavior pack folders for any packs that may be in use within the world.   Tip  When installing a new build of Minecraft, you should save a copy of this folder as a backup to prevent any potential loss of Minecraft worlds that you may have.  Visual Studio Code  The files you'll be creating to customize Minecraft: Bedrock Edition will be written in JSON, a popular format for describing data. JSON can be edited in any text editor such as Notepad or Word, but it's easier to edit it with a programming editor that understands JSON natively. Microsoft's Visual Studio Code is a free programming editor that not only works great with JSON, it supports extensions that add functionality—including some built specifically for Bedrock development.  Installing Visual Studio Code  Follow this link to install Visual Studio Code.  Visual Studio Code Extensions  Visual Studio Code supports extensions created by the Visual Studio Code developer community. Extensions are a great way to help write and understand Minecraft syntax when working on resource and behavior packs.  Here's two recommended extensions for Minecraft development:  Blockception's Minecraft Bedrock Development Bedrock Definitions What's next?  Now that your development environment is set up, you can start creating your first add-on and learn more about resource packs.  Introduction to Resource Packs  Alternatively, if you'd like to learn how to use commands, head on over to Getting Started with Command Blocks and learn how to use command blocks to chain together different commands.  Getting Started with Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/behaviorpack?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Behavior Packs 04/24/2025  Before building your first Add-On for Minecraft: Bedrock Edition, you'll need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A behavior pack is a folder structure that contains files that drive entity behaviors, loot drops, spawn rules, items, recipes, and trade tables.  This tutorial covers how behavior packs are created and how to add behaviors to an in-game cow entity to make it aggressive.  On the Minecraft Creator Channel  If you prefer to watch a video version of this tutorial, you can view it on the Minecraft Creator Channel, available here.  Tutorial Overview  In this tutorial, you will learn the following:  How to change an entity's behavior in Minecraft: Bedrock Edition. How to link a Behavior Pack to a Resource Pack.   Note  The current version of this tutorial uses mctools.dev to simplify the process of creating a behavior pack. If you'd prefer to see creating a behavior pack \"from scratch\", see this article.  Requirements  It's recommended you complete these before beginning this tutorial:  Getting Started with Add-On Development Introduction To Resource Packs Building the Behavior Pack  A behavior pack contains files that creators use to add, remove, or alter gameplay behavior of entities within Minecraft. An entity's behavior file is what makes each entity do certain actions, like how a chicken follows a player who's holding seeds.  For Minecraft to find and use your behavior files, you have to set up the folders and files in a particular structure. This tutorial will guide you through creating this folder and file structure.  Use mctools.dev to Get Started  In this section, we'll get started with a toolset called Minecraft Creator Tools. This toolset is an open source project from Mojang that helps do all of the management work of creating a new project.  Start by visiting mctools.dev.  In the Add-On Starter section, click New.  In the Title field, give your project a name like myBehaviorPack.  Enter your name in the Creator Name field.  Notice that a Short Name is generated for your project, but you can change this.  You can also add a Description for your project.  Click OK.  Understand the Project Files  MCTools will add all of the files your project needs. You can click the \"Eye\" button to show all related files.  If you right-click on a file and select View as JSON, you can see the contents of that file.  If you view the manifest file for the behavior pack, you will notice several elements.  The behavior pack manifest file is similar to the one created for the resource pack, but it has two additional sections.  modules - Defines the pack so that Minecraft knows how to apply it to the world. Behavior packs use the data type. dependencies - Creates a link between behavior packs and resource packs to add custom textures and visuals to Minecraft.   Note  To learn more about how a manifest.json file works, see the Add-ons Reference manifest.json documentation.  Add a Cow To add a cow to your project, select the down arrow next to new script. Select the New Mob button.  Select the cow and click Add.  Make the Cow an Angry Cow Select the cow JSON file underneath Entity Types. Within the Components section of the JSON, add the following elements which turns cows into aggressive killing machines:  JSON Copy             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             },  Test the Pack  Now that the behavior pack has a modified cow entity, it is time to launch Minecraft and test your new Add-On.  Within MCTools.dev, select Run and then Flat World with Packs.  Within the Downloads section of your browser, click Open file to open the downloaded file. The file should now open and import into Minecraft.  Launch Minecraft and select Play.  Select the world that was just imported. The file should be named based on your project and the time at which it was saved.  Summon your cow using the summon command: /summon cont_bp:cow (Your namespace might vary based on your creator name.)  Your cow might not attack you in creative mode, so select /gamemode s to turn the world into a survival world.  Adding Your Pack to Minecraft  Once you verify that your behavior pack works on mctools.dev, the final step is configuring the pack to be recognized by your local Minecraft instance. Check out this Introduction to Scripting for a guide on best practices for configuring and editing your new behavior pack.  Troubleshooting  Behavior pack woes? Troubleshooting is a normal part of any development process. Here are some places to begin troubleshooting a behavior pack:  Check the content error logs for detected problems that could cause instability or unpredictable behavior.  Use the sample behavior pack on the Minecraft samples Github to check the structure of your behavior pack.  What's Next?  Now that you have seen a behavior pack in action, you can learn more about how they work and what else you can do with them.  Creating New Entity Types Entity JSON Documentation  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/behaviorpack?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Behavior Packs 04/24/2025  Before building your first Add-On for Minecraft: Bedrock Edition, you'll need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A behavior pack is a folder structure that contains files that drive entity behaviors, loot drops, spawn rules, items, recipes, and trade tables.  This tutorial covers how behavior packs are created and how to add behaviors to an in-game cow entity to make it aggressive.  On the Minecraft Creator Channel  If you prefer to watch a video version of this tutorial, you can view it on the Minecraft Creator Channel, available here.  Tutorial Overview  In this tutorial, you will learn the following:  How to change an entity's behavior in Minecraft: Bedrock Edition. How to link a Behavior Pack to a Resource Pack.   Note  The current version of this tutorial uses mctools.dev to simplify the process of creating a behavior pack. If you'd prefer to see creating a behavior pack \"from scratch\", see this article.  Requirements  It's recommended you complete these before beginning this tutorial:  Getting Started with Add-On Development Introduction To Resource Packs Building the Behavior Pack  A behavior pack contains files that creators use to add, remove, or alter gameplay behavior of entities within Minecraft. An entity's behavior file is what makes each entity do certain actions, like how a chicken follows a player who's holding seeds.  For Minecraft to find and use your behavior files, you have to set up the folders and files in a particular structure. This tutorial will guide you through creating this folder and file structure.  Use mctools.dev to Get Started  In this section, we'll get started with a toolset called Minecraft Creator Tools. This toolset is an open source project from Mojang that helps do all of the management work of creating a new project.  Start by visiting mctools.dev.  In the Add-On Starter section, click New.  In the Title field, give your project a name like myBehaviorPack.  Enter your name in the Creator Name field.  Notice that a Short Name is generated for your project, but you can change this.  You can also add a Description for your project.  Click OK.  Understand the Project Files  MCTools will add all of the files your project needs. You can click the \"Eye\" button to show all related files.  If you right-click on a file and select View as JSON, you can see the contents of that file.  If you view the manifest file for the behavior pack, you will notice several elements.  The behavior pack manifest file is similar to the one created for the resource pack, but it has two additional sections.  modules - Defines the pack so that Minecraft knows how to apply it to the world. Behavior packs use the data type. dependencies - Creates a link between behavior packs and resource packs to add custom textures and visuals to Minecraft.   Note  To learn more about how a manifest.json file works, see the Add-ons Reference manifest.json documentation.  Add a Cow To add a cow to your project, select the down arrow next to new script. Select the New Mob button.  Select the cow and click Add.  Make the Cow an Angry Cow Select the cow JSON file underneath Entity Types. Within the Components section of the JSON, add the following elements which turns cows into aggressive killing machines:  JSON Copy             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             },  Test the Pack  Now that the behavior pack has a modified cow entity, it is time to launch Minecraft and test your new Add-On.  Within MCTools.dev, select Run and then Flat World with Packs.  Within the Downloads section of your browser, click Open file to open the downloaded file. The file should now open and import into Minecraft.  Launch Minecraft and select Play.  Select the world that was just imported. The file should be named based on your project and the time at which it was saved.  Summon your cow using the summon command: /summon cont_bp:cow (Your namespace might vary based on your creator name.)  Your cow might not attack you in creative mode, so select /gamemode s to turn the world into a survival world.  Adding Your Pack to Minecraft  Once you verify that your behavior pack works on mctools.dev, the final step is configuring the pack to be recognized by your local Minecraft instance. Check out this Introduction to Scripting for a guide on best practices for configuring and editing your new behavior pack.  Troubleshooting  Behavior pack woes? Troubleshooting is a normal part of any development process. Here are some places to begin troubleshooting a behavior pack:  Check the content error logs for detected problems that could cause instability or unpredictable behavior.  Use the sample behavior pack on the Minecraft samples Github to check the structure of your behavior pack.  What's Next?  Now that you have seen a behavior pack in action, you can learn more about how they work and what else you can do with them.  Creating New Entity Types Entity JSON Documentation  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/addcustomsounds?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating and Adding Custom Sounds to Minecraft 05/02/2025  Sounds are a great way to add a sense of immersion to your content. Whether it's blocks, animals, or the ever-important music disc, the sounds you hear while playing Minecraft pull you into the experience. In this tutorial, we'll be adding a custom sound that will play when we open a chest, increasing the immersion and personalization of your world.  Prerequisites  We recommend completing the following before beginning this tutorial:  Getting Started with Add-On Development Introduction to Resource Packs Introduction to Behavior Packs  You will also need to download the Vanilla resource pack.  Create a resource pack  The first step in our journey is to create a resource pack to hold your custom sounds. If you completed the prerequisites as suggested (hint, hint), you're already familiar with this process. Name your resource pack custom_sound_pack  For a quick refresher, see Introduction to Resource Packs.  For detailed information on resource packs, see the Comprehensive Resource Pack guide.  Setting up a sound directory  Now that the resource pack has been created, it's time to set up a place for our sound files.  In File Explorer, navigate to the com.mojang folder.  Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.  Open the development_resource_packs folder.  Open custom_sound_pack.  Create a folder called sounds.  When you're finished, your file structure will look like this:  You'll need to create more sub-folders along the way, but we'll get into that at in a bit.  Finding the right sound  The stage is set, and now it's time to get your custom sound ready! For our example, we will be using Audacity. However, any audio processing software will work as long as it can export files in the .OGG format.  You can either record a sound using your audio software, or use the software to open a sound that has been saved to your computer. Once your file is open in the audio software, it needs to be exported as a .OGG file. This can be done in Audacity by navigating to File > Export > Export as OGG.  For this tutorial, we'll export a custom sound file with the name chestopen.ogg (you'll see why, later).  If you'd like an example sound file to use, download this sample .OGG file.  Housing your sound  Congratulations, things are moving along nicely. You have a sound to replace, a new sound ready, and your resource pack is set up. Now it's time to figure out where your sound will live.  The vanilla resource pack contains every sound in vanilla Minecraft, and this folder will show you how to structure your custom resource pack so that you can replace the sounds you want.  From here, you could scroll through the list of every Minecraft sound and find the sound file for a chest opening. Instead, we recommend using CTRL+F to find the file. For our example, the file we are looking for is the chestopen file; it happens to be located at sounds/random/chestopen.  Now we know where to place our custom sound file. Navigate to com.mojang > development_resource_packs > custom_sound_pack > sounds. In the sounds folder, create a new folder named random and place your custom chestopen.ogg file into it.  If you want to replace other sounds, locate them in the vanilla resource pack and recreate the folder structure in your resource pack. For example, if you want to change one of the sounds for rain in your world, you'll need to create the following sub-folders:  com.mojang > development_resource_packs > sounds > ambient > weather  Inside the weather folder you can add files for the rain sounds you want to replace.   Note  You must give your new sound file the exact same name as the file you want to replace; however, you do not need to use the same format. So you can replace rain1.fsb with rain1.ogg, as long as the file name before the extension matches exactly.  Testing your sound  The hard work is over, and now it's time to the test our custom sound! In order to test our sound, create a test world with your custom_sound_pack enabled and cheats turned ON, which will allow you to use the /give command.  Open the chat box Type the following command: /give @s chest  Opening the chest should result in your custom sound playing. If that doesn't happen, some troubleshooting may be needed. Some common steps include:  Checking your file structure Checking the file type of your custom sound file Adding new sounds  So four different types of rain sounds aren't enough for you? Then let's discover how to add brand new sounds to Minecraft. For this task, we'll dive into the sounds.json and sound_defnitions.json files. If you don't already have them, create sounds.json under com.mojang > development_resource_packs > custom_sound_pack and sound_definitions.json under com.mojang > development_resource_packs > custom_sound_pack > sounds.  Use the sample sounds.json file in the vanilla resource pack to locate the category of sound you want to add.  So now, instead of replacing the sound of a chest opening, like we did earlier, let's say we want to have two different sounds that play randomly when we open a chest. Navigate back to your com.mojang > development_resource_packs > custom_sound_pack > sounds > random folder and rename chestopen.ogg to chestopen2.ogg  In sounds.json, add the following code:  JSON Copy {     \"individual_event_sounds\" : {         \"events\" : {             \"chest.open\" : {                 \"pitch\" : [ 0.90, 1.0 ],                 \"sound\" : \"random.chestopen\",                 \"volume\" : 0.50             }         }     } }   In sound_definitions.json, add the following code:  JSON Copy \"format_version\" : \"1.20.20\", \"sound_definitions\" : {     \"random.chestopen\" : {         \"__use_legacy_max_distance\" : \"true\",         \"category\" : \"block\",         \"max_distance\" : null,         \"min_distance\" : null,         \"sounds\" : [              \"sounds/random/chestopen\",             \"sounds/random/chestopen2\"         ]     } }   When we test our sound again, you should notice that opening a chest will play one of your two chest open sounds randomly!  Using the /playsound command  You can also add custom sounds that aren't played by in-game events. You can use the /playsound command to play any sound in the game, including the sounds added in your resource packs. Even if your sounds don't play automatically, you can still play them manually or use resources like command blocks to play your sounds at appropriate times based on your world and game modes.  To learn more about the /playsound command, see the reference docs.  Next steps  Congratulations, you've successfully added a custom sound to your world! Now you can create a world that sounds the way you want to hear. You can make blocks that squeak, swords that apologize when you attack with them, or a world where everything is voiced by you! As always, the only limit is what you can imagine.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/addcustomsounds?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating and Adding Custom Sounds to Minecraft 05/02/2025  Sounds are a great way to add a sense of immersion to your content. Whether it's blocks, animals, or the ever-important music disc, the sounds you hear while playing Minecraft pull you into the experience. In this tutorial, we'll be adding a custom sound that will play when we open a chest, increasing the immersion and personalization of your world.  Prerequisites  We recommend completing the following before beginning this tutorial:  Getting Started with Add-On Development Introduction to Resource Packs Introduction to Behavior Packs  You will also need to download the Vanilla resource pack.  Create a resource pack  The first step in our journey is to create a resource pack to hold your custom sounds. If you completed the prerequisites as suggested (hint, hint), you're already familiar with this process. Name your resource pack custom_sound_pack  For a quick refresher, see Introduction to Resource Packs.  For detailed information on resource packs, see the Comprehensive Resource Pack guide.  Setting up a sound directory  Now that the resource pack has been created, it's time to set up a place for our sound files.  In File Explorer, navigate to the com.mojang folder.  Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.  Open the development_resource_packs folder.  Open custom_sound_pack.  Create a folder called sounds.  When you're finished, your file structure will look like this:  You'll need to create more sub-folders along the way, but we'll get into that at in a bit.  Finding the right sound  The stage is set, and now it's time to get your custom sound ready! For our example, we will be using Audacity. However, any audio processing software will work as long as it can export files in the .OGG format.  You can either record a sound using your audio software, or use the software to open a sound that has been saved to your computer. Once your file is open in the audio software, it needs to be exported as a .OGG file. This can be done in Audacity by navigating to File > Export > Export as OGG.  For this tutorial, we'll export a custom sound file with the name chestopen.ogg (you'll see why, later).  If you'd like an example sound file to use, download this sample .OGG file.  Housing your sound  Congratulations, things are moving along nicely. You have a sound to replace, a new sound ready, and your resource pack is set up. Now it's time to figure out where your sound will live.  The vanilla resource pack contains every sound in vanilla Minecraft, and this folder will show you how to structure your custom resource pack so that you can replace the sounds you want.  From here, you could scroll through the list of every Minecraft sound and find the sound file for a chest opening. Instead, we recommend using CTRL+F to find the file. For our example, the file we are looking for is the chestopen file; it happens to be located at sounds/random/chestopen.  Now we know where to place our custom sound file. Navigate to com.mojang > development_resource_packs > custom_sound_pack > sounds. In the sounds folder, create a new folder named random and place your custom chestopen.ogg file into it.  If you want to replace other sounds, locate them in the vanilla resource pack and recreate the folder structure in your resource pack. For example, if you want to change one of the sounds for rain in your world, you'll need to create the following sub-folders:  com.mojang > development_resource_packs > sounds > ambient > weather  Inside the weather folder you can add files for the rain sounds you want to replace.   Note  You must give your new sound file the exact same name as the file you want to replace; however, you do not need to use the same format. So you can replace rain1.fsb with rain1.ogg, as long as the file name before the extension matches exactly.  Testing your sound  The hard work is over, and now it's time to the test our custom sound! In order to test our sound, create a test world with your custom_sound_pack enabled and cheats turned ON, which will allow you to use the /give command.  Open the chat box Type the following command: /give @s chest  Opening the chest should result in your custom sound playing. If that doesn't happen, some troubleshooting may be needed. Some common steps include:  Checking your file structure Checking the file type of your custom sound file Adding new sounds  So four different types of rain sounds aren't enough for you? Then let's discover how to add brand new sounds to Minecraft. For this task, we'll dive into the sounds.json and sound_defnitions.json files. If you don't already have them, create sounds.json under com.mojang > development_resource_packs > custom_sound_pack and sound_definitions.json under com.mojang > development_resource_packs > custom_sound_pack > sounds.  Use the sample sounds.json file in the vanilla resource pack to locate the category of sound you want to add.  So now, instead of replacing the sound of a chest opening, like we did earlier, let's say we want to have two different sounds that play randomly when we open a chest. Navigate back to your com.mojang > development_resource_packs > custom_sound_pack > sounds > random folder and rename chestopen.ogg to chestopen2.ogg  In sounds.json, add the following code:  JSON Copy {     \"individual_event_sounds\" : {         \"events\" : {             \"chest.open\" : {                 \"pitch\" : [ 0.90, 1.0 ],                 \"sound\" : \"random.chestopen\",                 \"volume\" : 0.50             }         }     } }   In sound_definitions.json, add the following code:  JSON Copy \"format_version\" : \"1.20.20\", \"sound_definitions\" : {     \"random.chestopen\" : {         \"__use_legacy_max_distance\" : \"true\",         \"category\" : \"block\",         \"max_distance\" : null,         \"min_distance\" : null,         \"sounds\" : [              \"sounds/random/chestopen\",             \"sounds/random/chestopen2\"         ]     } }   When we test our sound again, you should notice that opening a chest will play one of your two chest open sounds randomly!  Using the /playsound command  You can also add custom sounds that aren't played by in-game events. You can use the /playsound command to play any sound in the game, including the sounds added in your resource packs. Even if your sounds don't play automatically, you can still play them manually or use resources like command blocks to play your sounds at appropriate times based on your world and game modes.  To learn more about the /playsound command, see the reference docs.  Next steps  Congratulations, you've successfully added a custom sound to your world! Now you can create a world that sounds the way you want to hear. You can make blocks that squeak, swords that apologize when you attack with them, or a world where everything is voiced by you! As always, the only limit is what you can imagine.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoaddentity?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating New Entity Types 04/16/2025  You can add new entity types to Minecraft: Bedrock Edition using a combination of behavior packs and resource packs. As you learned from the recommended tutorials, the behavior of entity types can be changed with a behavior pack, and you can change the appearance with a resource pack. Both are required to add a new entity type to the game.  This guide has two parts: the first part covers the files and folder structure needed to add a custom entity type to Minecraft. The second part shows you how to breathe life into the entity using behavior components and animations.  In this tutorial you'll learn:  How to create a new custom entity type using behavior and resource packs. How to apply various features to the entity type, including components and animations. Make use of translations for entity names.  It's recommended you complete these before beginning this tutorial:  Introduction to Behavior Packs Introduction to Resource Packs Download the min robot and full robot resource and behavior packs  In addition, it will be helpful if you have a code editor like Visual Studio Code, and if you're familiar with how the JSON format works.  File structure  In the behavior pack, an entity file is responsible for defining the entity on the server side. In the resource pack, a client entity file is responsible for telling the game how the entity will look. The following graphic shows how different files can interact to create a custom entity:  Robot entity example (minimum)  To give you a point of reference for this tutorial, we are providing two versions of the same entity: a robot that can spawn randomly in the world and has three random textures, a wheel animation, various components, and a custom water mechanic. The download link is in the Requirements section above.  To see the robot in action, pick one of the sets of resource and behavior packs you just downloaded. (We recommend trying the minimum one for now.) Put the resource and behavior packs in their respective com.mojang sub-folders, launch a world with cheats enabled, and use /summon sample:robot.  This is the structure of the finished \"minimum robot\" behavior pack and resource pack:  This looks like a lot, but you only have to think about the files with \"robot\" in the name and where they are stored.  After you get an idea how the robot acts in the game, you can remove the finished robot resource and behavior packs and re-create them from scratch with the steps of this tutorial to get an idea how all the files work together.  A good starting point would be to use the resource and behavior packs you created in the earlier tutorials. You might want to remove the attack cow entity, but that's a personal preference.  Naming  When you create an entity, one of the first things to consider is what ID you're going to give it. The files in your resource and behavior packs will need to be synced using the entity ID that you give your entity. This ID consists of a namespace and a name separated by a colon. That was the sample:robot ID we used previously to summon the robot.  Your own namespace can be a short version of your team name or product name. The ID should only include lower case letters, digits, and underscores. Don't use \"minecraft\" as the namespace for your custom content. The \"minecraft\" namespace is reserved for vanilla resources, so you should only use \"minecraft\" if you are overwriting vanilla content.  Most files that define the entity will be JSON files. To avoid confusion, we suggest you follow a standard naming convention as you create each of these files. The game ignores file names in most cases, but when working on an Add-On, messy file names can be confusing. The standard conventions are:  Expand table File Type\tFile Name Client Entity Files\tentity_name.entity.json Model Files\tentity_name.geo.json Animation Files\tentity_name.animation.json Animation Controllers\tentity_name.animation_controllers.json Render Controllers\tentity_name.render_controllers.json  entity_name should be replaced by the name of your entity, not including the namespace.  Format versions  Each JSON file should have a format_version tag. This tag is important for the game to correctly read the file. Files made in older formats will still work in newer versions of the game, but only if the format version is set correctly. Incorrect format versions are a frequent source of errors.  Behavior pack definition  The first step to add a robot into the game starts in the behavior pack. Create a new file in the entities folder of the behavior pack and name it robot.json. Copy and paste in this code.  JSON Copy {     \"format_version\": \"1.12.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"is_spawnable\": true,             \"is_summonable\": true         },         \"components\": {}     } }   Inside the description tag, we define basic attributes of the entity:  identifier sets the ID for the entity. is_spawnable adds a spawn egg into the game that allows the player to spawn this mob. is_summonable makes the entity work with the /summon command.  Inside components, we're going to add components to change the behavior of the entity. For now, we are adding only the minecraft:physics component. This will give the entity gravity and regular collision behavior.  JSON Copy \"components\": {     \"minecraft:physics\": {} }   Save your robot.json file and move on to the next step.  Client entity definition  Now, we need to add the entity to the resource pack to give it a visual appearance. In the entity folder of the resource pack, create a new JSON file called robot.entity.json.  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   This is the basic structure of the file. So far, it's similar to the behavior-side file we made in the previous section. Note that we now use client_entity instead of just entity. At the time of writing this article, 1.10.0 is the latest format version for this file.  The spawn_egg tag defines how the spawn egg will look in the inventory. Using this method, it will look like a vanilla spawn egg, but with customized colors.  Visuals  Before we can add the entity into the game, it needs a model. The Entity Modeling and Animation article explains how to create a custom model and texture, but creating a model is a lot to learn and we're not done with this tutorial yet! So for now, pretend you already created a model by copying and pasting the files from the robot resource pack. Use these same steps later to add the model you create.  Save the model inside the folder models/entity as robot.geo.json. Save the texture in textures/entity as robot.png.  Now that the model files are in place, we need a render controller to link the model, texture, and material that's used for the entity.  Open the robot.entity.json file in the entity folder in your resources pack.  For most entities (such as our robot), we can use the default render controller that's provided by the game. We will talk more about render controllers later in the more advanced part of this tutorial. For now, just know that this is where it goes and this should be the content:  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"materials\": {                 \"default\": \"entity\"             },             \"textures\": {                 \"default\": \"textures/entity/robot\"             },             \"geometry\": {                 \"default\": \"geometry.robot\"             },             \"render_controllers\": [                 \"controller.render.default\"             ],             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   The model is referenced by the geometry name. If you create a model in Blockbench, make sure the geometry name in the project settings is set to your entity name—in this case, \"robot\".  Unlike geometries, textures are linked by their path in the resource pack, minus the file extension, as shown in the example.  In most cases, a custom material is not required. Instead, you can use a default material. In this example, we use entity. If the texture has transparent parts, you can use entity_alphatest, or if your texture is translucent (like stained glass), you can use entity_alphablend.  Translation strings  Right now, neither the entity itself nor the spawn egg has a proper name in game. To define a name, we need a language file.  Create a new folder called texts inside your resource pack and create a new file called en_US.lang. This is the only language file required for custom entities, as it's used as a fallback for translations when strings in other languages aren't available.  Inside this file, add these two lines:  JSON Copy entity.sample:robot.name=Robot item.spawn_egg.entity.sample:robot.name=Spawn Robot   The first line defines the name of the entity. This will be visible in death messages and in the output of some commands. Key and value are always separated by an equals sign. The first line can be broken down into:  entity.<identifier>.name=<Name>  The second line defines the item name of the spawn egg:  item.spawn_egg.entity.<identifier>.name=<Name>  Testing  Make sure to test early and often. Encountering an issue early on helps to simplify tracking it down, which can make it easier to fix. Testing often will reveal issues soon after making changes, which helps to narrow down the cause to those recent changes.  You should be able to spawn your entity in game using the spawn egg or the summon command. If you just want a static entity, you're good to go. But if you want to customize the entity even more, keep on reading.  Robot entity example (full)  Now would be a good time to try the full robot resource and behavior packs. Compare the collection of folders and files. Then, put back your minimal robot packs so we can continue adding functionality.  Components  Components tell the entity how to act in game. Let's add a few components and explain in detail what they do.  In the behavior pack/entities/ folder, open robot.json and replace the single entry of \"minecraft:physics\": {} with all of this:  JSON Copy    \"components\": {         \"minecraft:physics\": {},         \"minecraft:nameable\": {},         \"minecraft:movement\": {             \"value\": 0.25         },         \"minecraft:movement.basic\": {},         \"minecraft:jump.static\": {},         \"minecraft:navigation.walk\": {             \"avoid_water\": true         },         \"minecraft:behavior.tempt\": {             \"priority\": 1,             \"speed_multiplier\": 1.4,             \"items\": [\"diamond\"],             \"within_radius\": 7.0         },         \"minecraft:behavior.random_stroll\":         {             \"priority\": 3,             \"speed_multiplier\": 0.8         },         \"minecraft:experience_reward\": {             \"on_death\": 8         }    }  Expand table Component Name\tDescription minecraft:nameable\tAllows the player to name the entity with a name tag. minecraft:movement\tTells the entity how fast to move. 0.25 is the regular speed of most animals in Minecraft. minecraft:movement.basic\tGives the entity the ability to move on the ground. minecraft:jump.static\tAllows the entity to jump in order to walk up blocks. minecraft:navigation.walk\tAllows the entity to navigate through the world. Avoid water is one of the options that this component comes with. minecraft:behavior.tempt\tMakes the entity follow players who hold diamonds in their hand. We are giving this behavior a higher priority so it will prioritize this action (lower number = higher priority). minecraft:behavior.random_stroll\tWill make the entity randomly walk around the place. We're setting the priority to a higher number so the entity will only do this when it has nothing else to do. The speed multiplier will decrease the speed while using this walk behavior. minecraft:experience_reward\tLets the entity drop experience when killed by a player. Animations  In this section, we'll add a simple wheel animation to the robot. If you want to learn more about animations, how to use animation controllers, and how to create animations in BlockBench, read this guide.  Animations are stored in animation files. So the first thing we need to do is create a folder called animations in the resource pack and create a file called robot.animation.json inside it. In that file, we'll create a new animation called animation.robot.drive. We also want to set loop to true so the animation will keep playing. The file should look like this:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true         }     } }   Animations allow us to animate the position, rotation, and scale of each bone. (If you don't know what \"bone\" means in that context yet, that's okay—you'll learn about bones when you learn Blockbench. For now, just know that it means a chunk of the model, like a leg or a wheel.) Animations can be done with keyframes, Molang expressions, or a combination of both. In this example, we'll just use Molang expressions.  Molang is a language just for resource and behavior packs. It allows us to get various numbers from the entity using a query and calculate a result out of these numbers using math expressions. For example, the query query.modified_distance_moved will return the distance the entity has moved. We can use it to calculate the rotation of the robot wheel on the X-axis, which will result in an animation that makes the robot look like it is driving. You have to play around with the numbers, but for this model 60 worked quite well.  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true,             \"bones\": {                 \"wheel\": {                     \"rotation\":[\"query.modified_distance_moved*60\", 0, 0]                 }             }         }     } }   Now that the animation is created, we need to link it in the client entity file. (Remember, the resource pack is the client, so open <resource pack>/entity/robot.entity.json for this next part.) The animations tag links all animations and animation controllers that are used by the entity. Each animation gets a short name that can be used to play the animation in an animation controller or directly in the file, in this case drive.  The scripts and animate sections can be used to directly play animations:  JSON Copy         \"animations\": {             \"drive\": \"animation.robot.drive\"         },         \"scripts\": {             \"animate\": [\"drive\"]         }   With these two tags added in the description tag of the client entity file, the drive animation will always be active and advance the wheel rotation while the entity is moving.  Render controllers  Render controllers allow us to change the geometry, textures, and materials of the entity using Molang. The following example shows how to use the geometry, material, and texture that have been linked in the client entity file as default:  JSON Copy {     \"format_version\": \"1.8.0\",     \"render_controllers\": {         \"controller.render.robot\": {             \"geometry\": \"Geometry.default\",             \"materials\": [ { \"*\": \"Material.default\" }],             \"textures\": [ \"Texture.default\" ]         }     } }   If we just want to use one default geometry, material, and texture, we can just leave it pointing to the default render controller as we did before. But this is a good time to learn how to add random textures, so let's break down how render controllers work.  One entity file can contain more than one render controller. Each controller goes between the braces in the value of the render_controllers key.  Each controller is named using the scheme controller.render.<entity-name>. Our one controller is named controller.render.robot. For a multi-purpose render controller, we can also use another keyword instead of the entity name.  Inside the render controller tag, the different resources are specified, but you'll notice each one uses a different JSON value.  Geometry  One render controller can display only one geometry at a time, so the geometry key can only be a single string value. This string can be a Molang expression and should always return a geometry. In this case, it's calling Geometry.default, which means that it will return the geometry that's linked as default by whatever entity using the render controller.  You can render multiple geometries on one entity by using multiple render controllers. This can be tricky though, and can lead to unexpected behavior. Therefore, it's only recommended for experienced creators.  Materials  Unlike geometry, the materials value is an array of objects. We can assign each bone a separate material. Each object in the array can have one key-value pair. The key selects a set of bones. An asterisk is used as a wildcard. This means that all bones, no matter the name, will have the default material assigned. Note that materials are assigned in order, meaning that materials further down in the list can overwrite previous materials.  JSON Copy   \"materials\": [     { \"*\": \"Material.default\" },     { \"*_arm\": \"Material.transparent\" }   ],   In this example, we first apply the default material to all bones. Then, we overwrite the material with the transparent material on all bones that end in _arm. That way, all arm bones would support transparency.  Textures  Textures are specified as an array of strings. In most cases, only one texture will be linked here, since entities don't support separate textures. There is one exception: materials can support multiple textures layered on top of each other, such as the material entity_multitexture. For example, this is used by llamas to overlay the décor.  Arrays  When working with multiple resources of one type, it can be useful to use an array. An array is a list of resource links that are defined in the render controller, and that you can pick one resource from using Molang.  We can define an array for the robot like this:  JSON Copy   \"controller.render.robot\": {     \"arrays\": {       \"textures\": {         \"Array.variant\": [           \"Texture.default\",           \"Texture.variant_b\",           \"Texture.variant_c\"         ]       }     }   }   In the arrays section we can define arrays for each of the three categories: textures, materials, and geometries. Inside the category, you can define arrays using Array.<array name> as the name. Each line inside the array links one texture that's defined in the client entity file.  You can access the array using Molang. Arrays are 0-based (that is, the first item is numbered 0, the second 1, and so on), so the first texture in this array can be accessed through Array.variant[0].  In this example, we're using the variant query to pick a texture from the array. The variant of a mob can be changed through the minecraft:variant component in the behavior file.  JSON Copy \"textures\": [ \"Array.variant[ query.variant ]\" ]   Now we need to link the additional textures in the client entity file. The regular, blue robot texture is already linked as default, and we will now create two copies of the robot texture file, edit the color, and link them as variant_b and variant_c.  JSON Copy             \"textures\": {                 \"default\": \"textures/entity/robot\",                 \"variant_b\": \"textures/entity/robot_b\",                 \"variant_c\": \"textures/entity/robot_c\"             },   Now, the textures are linked. The last step is to randomize the variant in the behavior file. We'll use component groups for this. Those are a way to add and remove a set of components from the entity at any time. We'll also use an event that randomizes which component group to add.  JSON Copy         \"description\": {             ...         },         \"components\": {             ...         },         \"component_groups\": {             \"sample:color_0\": {                 \"minecraft:variant\": {\"value\": 0}             },             \"sample:color_1\": {                 \"minecraft:variant\": {\"value\": 1}             },             \"sample:color_2\": {                 \"minecraft:variant\": {\"value\": 2}             }         },         \"events\": {             \"minecraft:entity_spawned\": {                 \"randomize\": [                     {                         \"add\": {                             \"component_groups\": [\"sample:color_0\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_1\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_2\"]                         }                     }                 ]             }         }   Now, when we first spawn the entity, it will randomly choose a component group and therefore a variant. This is a very common technique to randomize the appearance of an entity.  Spawning  Spawn rules define how entities randomly spawn in the world. We'll create a spawn rules file for our robot.  First, create a folder called spawn_rules in your behavior pack. Inside the folder, create a new text file called robot.json. The content of the file should look like this:  JSON Copy {   \"format_version\": \"1.8.0\",   \"minecraft:spawn_rules\": {     \"description\": {       \"identifier\": \"sample:robot\",       \"population_control\": \"animal\"     },   \"conditions\": []   } }   Inside minecraft:spawn_rules, there are two things that we need to consider: population control and conditions.  description defines the basic properties of the file. identifier should match the identifier of our entity. population_control defines how the game knows how many mobs to spawn and is a little more complicated.  Population control  There are different pools of entities. When the pool defined here is considered full, the game will no longer spawn mobs of this pool. There are three different options:  \"animal\": Passive mobs such as cows and pigs \"water_animal\": Water-based mobs such as tropical fish and dolphins \"monster\": Hostile mobs such as skeletons and zombies  For the robot, we're using the animal pool.  Conditions  conditions is an array of possible conditions that allow a mob to spawn in the world. Each of the conditions consists of a group of components that define when and when not to spawn the mob.  For a basic spawn rule, one condition is enough. For the robot, we will use this configuration:  JSON Copy {     \"format_version\": \"1.8.0\",     \"minecraft:spawn_rules\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"population_control\": \"animal\"         },         \"conditions\": [             {                 \"minecraft:spawns_on_surface\": {},                 \"minecraft:brightness_filter\": {                     \"min\": 12,                     \"max\": 15,                     \"adjust_for_weather\": false                 },                 \"minecraft:weight\": {                     \"default\": 40                 },                 \"minecraft:biome_filter\": {                     \"test\": \"has_biome_tag\",                     \"value\": \"animal\"                 }             }         ]     } }  Expand table Component Name\tDescription minecraft:spawns_on_surface\tThe mob spawns on the surface minecraft:brightness_filter\tOnly spawn the entity at a certain brightness. Accepts three options, min, max, and adjust_for_weather. Light levels range from 0 to 15. If adjust_for_weather is set to true, the light level decrease due to rain and thunderstorms will be taken into account. minecraft:weight\tThe weight of the entity in spawning. The higher the number, the more often the mob will spawn. minecraft:biome_filter\tFilters the biome the mob is allowed to spawn in. Biome filters work similarly to filters in behavior, which means that operators like all_of and any_of are allowed. Biomes have different tags that indicate the biome type, variant, dimension, and features like monster and animal.  Robots will now spawn anywhere on the surface where animals can spawn and where there is sufficient light. With a weight of 40, they'll also spawn quite frequently.  Behavior animations  Behavior animations work similarly to regular animations but run in the behavior pack. While regular animations animate the movement of the model as well as sounds and particles, behavior animations can run regular commands, trigger entity events, or run Molang expressions. Behavior animations are also often referred to as Entity Events, although that name tends to be a bit confusing.  Since robots don't like water, we'll add a mechanic to damage robots in water or rain. First, we're going to create an animation controller to test when the entity is in water using a Molang query. Create a new folder in the behavior pack called animation_controllers and create the file robot.animation_controllers.json inside it:  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {     \"controller.animation.robot.in_water\": {       \"states\": {         \"default\": {           \"transitions\": [             {\"in_water\": \"query.is_in_water_or_rain\"}           ]         },         \"in_water\": {           \"transitions\": [             {\"default\": \"query.is_in_water_or_rain == 0\"}           ]         }       }      }   } }   The animation controller looks very similar to regular client-side animation controllers. It has two states that get toggled depending on whether the robot is in water or not.  Now, let's add an animation to give a poison effect to the robot. Create the folder animations inside the behavior pack and create a file called robot.animation.json:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.poison\": {             \"loop\": true,             \"animation_length\": 1,             \"timeline\": {                 \"0.0\": [                     \"/effect @s poison 2 0 true\"                 ]             }         }     } }   Instead of using the bone tag here to animate bones, we're using the timeline tag. In resource packs, timelines can only be used to run Molang code. In behavior animations, you can use this to run Molang code, commands, or trigger entity events. Note that all these are provided as a string. The game will figure out the type of the string from its content. If the string starts with a slash, it will run as a command. If it matches a scheme such as @s namespace:event, it will run as an entity event. If it looks like Molang, it will run as Molang.  For that reason, it's important to start commands with a slash in behavior animations. Also, note that we're applying poison for two seconds because one would not be enough to actually apply damage. The true at the end of the command makes the status effect ambient, meaning that there won't be any particles.  As with animations in resource packs, we need to link all of our animations and animation controllers in the description tag of our entity like this:  JSON Copy   \"description\": {     \"identifier\": \"sample:robot\",      \"is_spawnable\": true,      \"is_summonable\": true,      \"animations\": {         \"poison\": \"animation.robot.poison\",         \"in_water\": \"controller.animation.robot.in_water\"       },       \"scripts\": {         \"animate\": [           \"in_water\"         ]       }   }   The animations section lists all animations and animation controllers that the entity uses and gives them a short name. In the scripts/animate section, we list the animations that should always run. We want the controller to detect the state to always run, but not the poison effect.  Now, we need to go back to the animation controller and add the poison effect. We'll also add a little regeneration mechanic along with a sound effect, so the robot won't die as easily.  JSON Copy   \"states\": {     \"default\": {       \"transitions\": [          {\"in_water\": \"query.is_in_water_or_rain\"}       ]     },     \"in_water\": {       \"animations\": [         \"poison\"       ],       \"on_exit\": [         \"/effect @s regeneration 2 4 true\",         \"/playsound random.fizz @a[r=16]\"       ],           \"transitions\": [         {           \"default\": \"query.is_in_water_or_rain == 0\"         }       ]     }   }   In the animations array, we list all the animations that should be running in this state, which is just poison in our case.  In the on_exit tag, we add two commands that will run when the robot exits the water. The first command will give the robot a regeneration effect level four for two seconds. The second command will play a fizzing sound effect.  Note that we could have also run the command in the on_entry array of the default state, but that would've also played the effects when spawning the robot or reloading the world because the game will always first transition into the default state.  To summarize the relationship between controllers and animations: an animation controller is used to control when an animation plays, while an animation itself is what occurs as a result of transitioning to the animation as determined by the controller. Animations and animation controllers are supplied to the entity behavior file.  What's Next?  In this guide we have added a complete custom entity to the game. If you used the existing model files instead of creating your own, now might be a good time to learn about Blockbench. Or, you can read more about entity behavior for the server.  Entity Modeling and Animation Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoaddentity?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating New Entity Types 04/16/2025  You can add new entity types to Minecraft: Bedrock Edition using a combination of behavior packs and resource packs. As you learned from the recommended tutorials, the behavior of entity types can be changed with a behavior pack, and you can change the appearance with a resource pack. Both are required to add a new entity type to the game.  This guide has two parts: the first part covers the files and folder structure needed to add a custom entity type to Minecraft. The second part shows you how to breathe life into the entity using behavior components and animations.  In this tutorial you'll learn:  How to create a new custom entity type using behavior and resource packs. How to apply various features to the entity type, including components and animations. Make use of translations for entity names.  It's recommended you complete these before beginning this tutorial:  Introduction to Behavior Packs Introduction to Resource Packs Download the min robot and full robot resource and behavior packs  In addition, it will be helpful if you have a code editor like Visual Studio Code, and if you're familiar with how the JSON format works.  File structure  In the behavior pack, an entity file is responsible for defining the entity on the server side. In the resource pack, a client entity file is responsible for telling the game how the entity will look. The following graphic shows how different files can interact to create a custom entity:  Robot entity example (minimum)  To give you a point of reference for this tutorial, we are providing two versions of the same entity: a robot that can spawn randomly in the world and has three random textures, a wheel animation, various components, and a custom water mechanic. The download link is in the Requirements section above.  To see the robot in action, pick one of the sets of resource and behavior packs you just downloaded. (We recommend trying the minimum one for now.) Put the resource and behavior packs in their respective com.mojang sub-folders, launch a world with cheats enabled, and use /summon sample:robot.  This is the structure of the finished \"minimum robot\" behavior pack and resource pack:  This looks like a lot, but you only have to think about the files with \"robot\" in the name and where they are stored.  After you get an idea how the robot acts in the game, you can remove the finished robot resource and behavior packs and re-create them from scratch with the steps of this tutorial to get an idea how all the files work together.  A good starting point would be to use the resource and behavior packs you created in the earlier tutorials. You might want to remove the attack cow entity, but that's a personal preference.  Naming  When you create an entity, one of the first things to consider is what ID you're going to give it. The files in your resource and behavior packs will need to be synced using the entity ID that you give your entity. This ID consists of a namespace and a name separated by a colon. That was the sample:robot ID we used previously to summon the robot.  Your own namespace can be a short version of your team name or product name. The ID should only include lower case letters, digits, and underscores. Don't use \"minecraft\" as the namespace for your custom content. The \"minecraft\" namespace is reserved for vanilla resources, so you should only use \"minecraft\" if you are overwriting vanilla content.  Most files that define the entity will be JSON files. To avoid confusion, we suggest you follow a standard naming convention as you create each of these files. The game ignores file names in most cases, but when working on an Add-On, messy file names can be confusing. The standard conventions are:  Expand table File Type\tFile Name Client Entity Files\tentity_name.entity.json Model Files\tentity_name.geo.json Animation Files\tentity_name.animation.json Animation Controllers\tentity_name.animation_controllers.json Render Controllers\tentity_name.render_controllers.json  entity_name should be replaced by the name of your entity, not including the namespace.  Format versions  Each JSON file should have a format_version tag. This tag is important for the game to correctly read the file. Files made in older formats will still work in newer versions of the game, but only if the format version is set correctly. Incorrect format versions are a frequent source of errors.  Behavior pack definition  The first step to add a robot into the game starts in the behavior pack. Create a new file in the entities folder of the behavior pack and name it robot.json. Copy and paste in this code.  JSON Copy {     \"format_version\": \"1.12.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"is_spawnable\": true,             \"is_summonable\": true         },         \"components\": {}     } }   Inside the description tag, we define basic attributes of the entity:  identifier sets the ID for the entity. is_spawnable adds a spawn egg into the game that allows the player to spawn this mob. is_summonable makes the entity work with the /summon command.  Inside components, we're going to add components to change the behavior of the entity. For now, we are adding only the minecraft:physics component. This will give the entity gravity and regular collision behavior.  JSON Copy \"components\": {     \"minecraft:physics\": {} }   Save your robot.json file and move on to the next step.  Client entity definition  Now, we need to add the entity to the resource pack to give it a visual appearance. In the entity folder of the resource pack, create a new JSON file called robot.entity.json.  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   This is the basic structure of the file. So far, it's similar to the behavior-side file we made in the previous section. Note that we now use client_entity instead of just entity. At the time of writing this article, 1.10.0 is the latest format version for this file.  The spawn_egg tag defines how the spawn egg will look in the inventory. Using this method, it will look like a vanilla spawn egg, but with customized colors.  Visuals  Before we can add the entity into the game, it needs a model. The Entity Modeling and Animation article explains how to create a custom model and texture, but creating a model is a lot to learn and we're not done with this tutorial yet! So for now, pretend you already created a model by copying and pasting the files from the robot resource pack. Use these same steps later to add the model you create.  Save the model inside the folder models/entity as robot.geo.json. Save the texture in textures/entity as robot.png.  Now that the model files are in place, we need a render controller to link the model, texture, and material that's used for the entity.  Open the robot.entity.json file in the entity folder in your resources pack.  For most entities (such as our robot), we can use the default render controller that's provided by the game. We will talk more about render controllers later in the more advanced part of this tutorial. For now, just know that this is where it goes and this should be the content:  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"materials\": {                 \"default\": \"entity\"             },             \"textures\": {                 \"default\": \"textures/entity/robot\"             },             \"geometry\": {                 \"default\": \"geometry.robot\"             },             \"render_controllers\": [                 \"controller.render.default\"             ],             \"spawn_egg\": {                 \"base_color\": \"#505152\",                 \"overlay_color\": \"#3b9dff\"             }         }     } }   The model is referenced by the geometry name. If you create a model in Blockbench, make sure the geometry name in the project settings is set to your entity name—in this case, \"robot\".  Unlike geometries, textures are linked by their path in the resource pack, minus the file extension, as shown in the example.  In most cases, a custom material is not required. Instead, you can use a default material. In this example, we use entity. If the texture has transparent parts, you can use entity_alphatest, or if your texture is translucent (like stained glass), you can use entity_alphablend.  Translation strings  Right now, neither the entity itself nor the spawn egg has a proper name in game. To define a name, we need a language file.  Create a new folder called texts inside your resource pack and create a new file called en_US.lang. This is the only language file required for custom entities, as it's used as a fallback for translations when strings in other languages aren't available.  Inside this file, add these two lines:  JSON Copy entity.sample:robot.name=Robot item.spawn_egg.entity.sample:robot.name=Spawn Robot   The first line defines the name of the entity. This will be visible in death messages and in the output of some commands. Key and value are always separated by an equals sign. The first line can be broken down into:  entity.<identifier>.name=<Name>  The second line defines the item name of the spawn egg:  item.spawn_egg.entity.<identifier>.name=<Name>  Testing  Make sure to test early and often. Encountering an issue early on helps to simplify tracking it down, which can make it easier to fix. Testing often will reveal issues soon after making changes, which helps to narrow down the cause to those recent changes.  You should be able to spawn your entity in game using the spawn egg or the summon command. If you just want a static entity, you're good to go. But if you want to customize the entity even more, keep on reading.  Robot entity example (full)  Now would be a good time to try the full robot resource and behavior packs. Compare the collection of folders and files. Then, put back your minimal robot packs so we can continue adding functionality.  Components  Components tell the entity how to act in game. Let's add a few components and explain in detail what they do.  In the behavior pack/entities/ folder, open robot.json and replace the single entry of \"minecraft:physics\": {} with all of this:  JSON Copy    \"components\": {         \"minecraft:physics\": {},         \"minecraft:nameable\": {},         \"minecraft:movement\": {             \"value\": 0.25         },         \"minecraft:movement.basic\": {},         \"minecraft:jump.static\": {},         \"minecraft:navigation.walk\": {             \"avoid_water\": true         },         \"minecraft:behavior.tempt\": {             \"priority\": 1,             \"speed_multiplier\": 1.4,             \"items\": [\"diamond\"],             \"within_radius\": 7.0         },         \"minecraft:behavior.random_stroll\":         {             \"priority\": 3,             \"speed_multiplier\": 0.8         },         \"minecraft:experience_reward\": {             \"on_death\": 8         }    }  Expand table Component Name\tDescription minecraft:nameable\tAllows the player to name the entity with a name tag. minecraft:movement\tTells the entity how fast to move. 0.25 is the regular speed of most animals in Minecraft. minecraft:movement.basic\tGives the entity the ability to move on the ground. minecraft:jump.static\tAllows the entity to jump in order to walk up blocks. minecraft:navigation.walk\tAllows the entity to navigate through the world. Avoid water is one of the options that this component comes with. minecraft:behavior.tempt\tMakes the entity follow players who hold diamonds in their hand. We are giving this behavior a higher priority so it will prioritize this action (lower number = higher priority). minecraft:behavior.random_stroll\tWill make the entity randomly walk around the place. We're setting the priority to a higher number so the entity will only do this when it has nothing else to do. The speed multiplier will decrease the speed while using this walk behavior. minecraft:experience_reward\tLets the entity drop experience when killed by a player. Animations  In this section, we'll add a simple wheel animation to the robot. If you want to learn more about animations, how to use animation controllers, and how to create animations in BlockBench, read this guide.  Animations are stored in animation files. So the first thing we need to do is create a folder called animations in the resource pack and create a file called robot.animation.json inside it. In that file, we'll create a new animation called animation.robot.drive. We also want to set loop to true so the animation will keep playing. The file should look like this:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true         }     } }   Animations allow us to animate the position, rotation, and scale of each bone. (If you don't know what \"bone\" means in that context yet, that's okay—you'll learn about bones when you learn Blockbench. For now, just know that it means a chunk of the model, like a leg or a wheel.) Animations can be done with keyframes, Molang expressions, or a combination of both. In this example, we'll just use Molang expressions.  Molang is a language just for resource and behavior packs. It allows us to get various numbers from the entity using a query and calculate a result out of these numbers using math expressions. For example, the query query.modified_distance_moved will return the distance the entity has moved. We can use it to calculate the rotation of the robot wheel on the X-axis, which will result in an animation that makes the robot look like it is driving. You have to play around with the numbers, but for this model 60 worked quite well.  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.drive\": {             \"loop\": true,             \"bones\": {                 \"wheel\": {                     \"rotation\":[\"query.modified_distance_moved*60\", 0, 0]                 }             }         }     } }   Now that the animation is created, we need to link it in the client entity file. (Remember, the resource pack is the client, so open <resource pack>/entity/robot.entity.json for this next part.) The animations tag links all animations and animation controllers that are used by the entity. Each animation gets a short name that can be used to play the animation in an animation controller or directly in the file, in this case drive.  The scripts and animate sections can be used to directly play animations:  JSON Copy         \"animations\": {             \"drive\": \"animation.robot.drive\"         },         \"scripts\": {             \"animate\": [\"drive\"]         }   With these two tags added in the description tag of the client entity file, the drive animation will always be active and advance the wheel rotation while the entity is moving.  Render controllers  Render controllers allow us to change the geometry, textures, and materials of the entity using Molang. The following example shows how to use the geometry, material, and texture that have been linked in the client entity file as default:  JSON Copy {     \"format_version\": \"1.8.0\",     \"render_controllers\": {         \"controller.render.robot\": {             \"geometry\": \"Geometry.default\",             \"materials\": [ { \"*\": \"Material.default\" }],             \"textures\": [ \"Texture.default\" ]         }     } }   If we just want to use one default geometry, material, and texture, we can just leave it pointing to the default render controller as we did before. But this is a good time to learn how to add random textures, so let's break down how render controllers work.  One entity file can contain more than one render controller. Each controller goes between the braces in the value of the render_controllers key.  Each controller is named using the scheme controller.render.<entity-name>. Our one controller is named controller.render.robot. For a multi-purpose render controller, we can also use another keyword instead of the entity name.  Inside the render controller tag, the different resources are specified, but you'll notice each one uses a different JSON value.  Geometry  One render controller can display only one geometry at a time, so the geometry key can only be a single string value. This string can be a Molang expression and should always return a geometry. In this case, it's calling Geometry.default, which means that it will return the geometry that's linked as default by whatever entity using the render controller.  You can render multiple geometries on one entity by using multiple render controllers. This can be tricky though, and can lead to unexpected behavior. Therefore, it's only recommended for experienced creators.  Materials  Unlike geometry, the materials value is an array of objects. We can assign each bone a separate material. Each object in the array can have one key-value pair. The key selects a set of bones. An asterisk is used as a wildcard. This means that all bones, no matter the name, will have the default material assigned. Note that materials are assigned in order, meaning that materials further down in the list can overwrite previous materials.  JSON Copy   \"materials\": [     { \"*\": \"Material.default\" },     { \"*_arm\": \"Material.transparent\" }   ],   In this example, we first apply the default material to all bones. Then, we overwrite the material with the transparent material on all bones that end in _arm. That way, all arm bones would support transparency.  Textures  Textures are specified as an array of strings. In most cases, only one texture will be linked here, since entities don't support separate textures. There is one exception: materials can support multiple textures layered on top of each other, such as the material entity_multitexture. For example, this is used by llamas to overlay the décor.  Arrays  When working with multiple resources of one type, it can be useful to use an array. An array is a list of resource links that are defined in the render controller, and that you can pick one resource from using Molang.  We can define an array for the robot like this:  JSON Copy   \"controller.render.robot\": {     \"arrays\": {       \"textures\": {         \"Array.variant\": [           \"Texture.default\",           \"Texture.variant_b\",           \"Texture.variant_c\"         ]       }     }   }   In the arrays section we can define arrays for each of the three categories: textures, materials, and geometries. Inside the category, you can define arrays using Array.<array name> as the name. Each line inside the array links one texture that's defined in the client entity file.  You can access the array using Molang. Arrays are 0-based (that is, the first item is numbered 0, the second 1, and so on), so the first texture in this array can be accessed through Array.variant[0].  In this example, we're using the variant query to pick a texture from the array. The variant of a mob can be changed through the minecraft:variant component in the behavior file.  JSON Copy \"textures\": [ \"Array.variant[ query.variant ]\" ]   Now we need to link the additional textures in the client entity file. The regular, blue robot texture is already linked as default, and we will now create two copies of the robot texture file, edit the color, and link them as variant_b and variant_c.  JSON Copy             \"textures\": {                 \"default\": \"textures/entity/robot\",                 \"variant_b\": \"textures/entity/robot_b\",                 \"variant_c\": \"textures/entity/robot_c\"             },   Now, the textures are linked. The last step is to randomize the variant in the behavior file. We'll use component groups for this. Those are a way to add and remove a set of components from the entity at any time. We'll also use an event that randomizes which component group to add.  JSON Copy         \"description\": {             ...         },         \"components\": {             ...         },         \"component_groups\": {             \"sample:color_0\": {                 \"minecraft:variant\": {\"value\": 0}             },             \"sample:color_1\": {                 \"minecraft:variant\": {\"value\": 1}             },             \"sample:color_2\": {                 \"minecraft:variant\": {\"value\": 2}             }         },         \"events\": {             \"minecraft:entity_spawned\": {                 \"randomize\": [                     {                         \"add\": {                             \"component_groups\": [\"sample:color_0\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_1\"]                         }                     }, {                         \"add\": {                             \"component_groups\": [\"sample:color_2\"]                         }                     }                 ]             }         }   Now, when we first spawn the entity, it will randomly choose a component group and therefore a variant. This is a very common technique to randomize the appearance of an entity.  Spawning  Spawn rules define how entities randomly spawn in the world. We'll create a spawn rules file for our robot.  First, create a folder called spawn_rules in your behavior pack. Inside the folder, create a new text file called robot.json. The content of the file should look like this:  JSON Copy {   \"format_version\": \"1.8.0\",   \"minecraft:spawn_rules\": {     \"description\": {       \"identifier\": \"sample:robot\",       \"population_control\": \"animal\"     },   \"conditions\": []   } }   Inside minecraft:spawn_rules, there are two things that we need to consider: population control and conditions.  description defines the basic properties of the file. identifier should match the identifier of our entity. population_control defines how the game knows how many mobs to spawn and is a little more complicated.  Population control  There are different pools of entities. When the pool defined here is considered full, the game will no longer spawn mobs of this pool. There are three different options:  \"animal\": Passive mobs such as cows and pigs \"water_animal\": Water-based mobs such as tropical fish and dolphins \"monster\": Hostile mobs such as skeletons and zombies  For the robot, we're using the animal pool.  Conditions  conditions is an array of possible conditions that allow a mob to spawn in the world. Each of the conditions consists of a group of components that define when and when not to spawn the mob.  For a basic spawn rule, one condition is enough. For the robot, we will use this configuration:  JSON Copy {     \"format_version\": \"1.8.0\",     \"minecraft:spawn_rules\": {         \"description\": {             \"identifier\": \"sample:robot\",             \"population_control\": \"animal\"         },         \"conditions\": [             {                 \"minecraft:spawns_on_surface\": {},                 \"minecraft:brightness_filter\": {                     \"min\": 12,                     \"max\": 15,                     \"adjust_for_weather\": false                 },                 \"minecraft:weight\": {                     \"default\": 40                 },                 \"minecraft:biome_filter\": {                     \"test\": \"has_biome_tag\",                     \"value\": \"animal\"                 }             }         ]     } }  Expand table Component Name\tDescription minecraft:spawns_on_surface\tThe mob spawns on the surface minecraft:brightness_filter\tOnly spawn the entity at a certain brightness. Accepts three options, min, max, and adjust_for_weather. Light levels range from 0 to 15. If adjust_for_weather is set to true, the light level decrease due to rain and thunderstorms will be taken into account. minecraft:weight\tThe weight of the entity in spawning. The higher the number, the more often the mob will spawn. minecraft:biome_filter\tFilters the biome the mob is allowed to spawn in. Biome filters work similarly to filters in behavior, which means that operators like all_of and any_of are allowed. Biomes have different tags that indicate the biome type, variant, dimension, and features like monster and animal.  Robots will now spawn anywhere on the surface where animals can spawn and where there is sufficient light. With a weight of 40, they'll also spawn quite frequently.  Behavior animations  Behavior animations work similarly to regular animations but run in the behavior pack. While regular animations animate the movement of the model as well as sounds and particles, behavior animations can run regular commands, trigger entity events, or run Molang expressions. Behavior animations are also often referred to as Entity Events, although that name tends to be a bit confusing.  Since robots don't like water, we'll add a mechanic to damage robots in water or rain. First, we're going to create an animation controller to test when the entity is in water using a Molang query. Create a new folder in the behavior pack called animation_controllers and create the file robot.animation_controllers.json inside it:  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {     \"controller.animation.robot.in_water\": {       \"states\": {         \"default\": {           \"transitions\": [             {\"in_water\": \"query.is_in_water_or_rain\"}           ]         },         \"in_water\": {           \"transitions\": [             {\"default\": \"query.is_in_water_or_rain == 0\"}           ]         }       }      }   } }   The animation controller looks very similar to regular client-side animation controllers. It has two states that get toggled depending on whether the robot is in water or not.  Now, let's add an animation to give a poison effect to the robot. Create the folder animations inside the behavior pack and create a file called robot.animation.json:  JSON Copy {     \"format_version\": \"1.8.0\",     \"animations\": {         \"animation.robot.poison\": {             \"loop\": true,             \"animation_length\": 1,             \"timeline\": {                 \"0.0\": [                     \"/effect @s poison 2 0 true\"                 ]             }         }     } }   Instead of using the bone tag here to animate bones, we're using the timeline tag. In resource packs, timelines can only be used to run Molang code. In behavior animations, you can use this to run Molang code, commands, or trigger entity events. Note that all these are provided as a string. The game will figure out the type of the string from its content. If the string starts with a slash, it will run as a command. If it matches a scheme such as @s namespace:event, it will run as an entity event. If it looks like Molang, it will run as Molang.  For that reason, it's important to start commands with a slash in behavior animations. Also, note that we're applying poison for two seconds because one would not be enough to actually apply damage. The true at the end of the command makes the status effect ambient, meaning that there won't be any particles.  As with animations in resource packs, we need to link all of our animations and animation controllers in the description tag of our entity like this:  JSON Copy   \"description\": {     \"identifier\": \"sample:robot\",      \"is_spawnable\": true,      \"is_summonable\": true,      \"animations\": {         \"poison\": \"animation.robot.poison\",         \"in_water\": \"controller.animation.robot.in_water\"       },       \"scripts\": {         \"animate\": [           \"in_water\"         ]       }   }   The animations section lists all animations and animation controllers that the entity uses and gives them a short name. In the scripts/animate section, we list the animations that should always run. We want the controller to detect the state to always run, but not the poison effect.  Now, we need to go back to the animation controller and add the poison effect. We'll also add a little regeneration mechanic along with a sound effect, so the robot won't die as easily.  JSON Copy   \"states\": {     \"default\": {       \"transitions\": [          {\"in_water\": \"query.is_in_water_or_rain\"}       ]     },     \"in_water\": {       \"animations\": [         \"poison\"       ],       \"on_exit\": [         \"/effect @s regeneration 2 4 true\",         \"/playsound random.fizz @a[r=16]\"       ],           \"transitions\": [         {           \"default\": \"query.is_in_water_or_rain == 0\"         }       ]     }   }   In the animations array, we list all the animations that should be running in this state, which is just poison in our case.  In the on_exit tag, we add two commands that will run when the robot exits the water. The first command will give the robot a regeneration effect level four for two seconds. The second command will play a fizzing sound effect.  Note that we could have also run the command in the on_entry array of the default state, but that would've also played the effects when spawning the robot or reloading the world because the game will always first transition into the default state.  To summarize the relationship between controllers and animations: an animation controller is used to control when an animation plays, while an animation itself is what occurs as a result of transitioning to the animation as determined by the controller. Animations and animation controllers are supplied to the entity behavior file.  What's Next?  In this guide we have added a complete custom entity to the game. If you used the existing model files instead of creating your own, now might be a good time to learn about Blockbench. Or, you can read more about entity behavior for the server.  Entity Modeling and Animation Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/addcustomdieblock?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks Part 1: The Simplest Block 05/05/2025  Minecraft's behavior packs and resource packs allow you to create amazing custom content for the game. Custom blocks are an excellent way for creators to start adding interactive content. Through this tutorial, you will build a custom die block (don't be scared, that just means a singular dice!) that has different textures and can be placed in the world by a player.  In this tutorial you'll learn the following:  How to use JSON to define a new block. How to assign textures to a new block. Some of the behaviors and components that blocks can access. What .lang is and how it's used for in-game text. Prerequisites  It is recommended that the following be completed before beginning this tutorial:  This video is an excellent way to quickly get up to speed!  Getting Started with Add-On Development Introduction to Resource Packs Introduction to Behavior Packs  You'll also need to download the Vanilla resource pack.  Creating Custom Blocks with Resource and Behavior Packs  We even have a video for you to follow if that's your preference!  You'll be making changes in both a resource pack and a behavior pack to get custom looks and behavior for each custom block you will be creating. Here is the file structure we'll follow for this tutorial:  The behavior pack contains the <custom_block>.json file that holds all of the information about a block's behavior. It specifies components that give specific behaviors such as friction, flammability, destructibility, and more. Components can also control some visual elements such as geometry, materials, render methods, and lighting.   Note  If components are given in the behavior pack to control the visual properties of a block, they will override the visual properties specified for that block in the blocks.json file. That's why blocks.json becomes optional once you start relying on behavior packs more heavily.  In this tutorial, we'll be making a fairly simple custom block. We will be using blocks.json to specify the visual properties of the block, and won't be using any components. While it is recommended to complete this tutorial before moving forward, there is also a tutorial on using components called Advanced Custom Blocks.  Let's create a custom die block with six different-colored sides that becomes a different color in-hand. Small customizations like this can make a block feel more unique to players.  Behavior pack Create a behavior pack  We'll begin by creating a behavior pack for the custom block:  In File Explorer, navigate to the com.mojang folder.  Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.  Open the development_behavior_packs folder.  Create a folder and name it custom_block_behavior_pack.  Open the custom_block_behavior_pack folder, and create a text file.  Rename the text file manifest.json.  Open manifest.json in a text editor.  Copy the code below into the manifest.json file.  Get new UUIDs from UUIDgenerator.net.  JSON Copy {  \"format_version\": 2,   \"header\": {    \"description\": \"This is a behavior pack used to demo components!\",    \"name\": \"Demo Behavior Pack\",    \"uuid\": \"<UUID>\",    \"version\": [ 1, 0, 0 ],    \"min_engine_version\": [ 1, 19, 20 ]   },   \"modules\": [    {     \"description\": \"Demo Behavior Pack\",     \"type\": \"data\",     \"uuid\": \"<UUID>\",     \"version\": [ 1, 0, 0 ]    }   ],   \"dependencies\": [    {     \"uuid\": \"<Resource Pack UUID>\",     \"version\": [ 1, 0, 0 ]    }   ]  }   Now, let's create the custom block behavior JSON file in the behavior pack.  Inside the custom_block_behavior_pack folder, create a folder and name it blocks. Open the blocks folder. Inside the blocks folder, create a text document and name it die.json. Open die.json in a text editor. Create the behavior custom block json file  In the file, you will need to define what the block is, similar to the manifest.json file.  Copy and paste the following code into your die.json file: JSON Copy {    \"format_version\": \"1.19.30\",    \"minecraft:block\": {      \"description\": {        \"identifier\": \"demo:die\"      },      \"components\": {      }    }  }   Save the file.  Custom block files have several requirements for them to be functional:  format_version should be the latest, in case any components change in the future. minecraft:block is the block definition, which contains the \"description\" and \"components\" sections of a block. The description object requires an identifier with a namespace, separated by a colon. In this case, the namespace is \"demo\" and the identifier is \"die\". A components section contains the components that describe the block's behavior.  There are several components you may choose to use in custom blocks. To learn more, view the full list of custom block components in the reference documentation. For now, we'll leave the die block with only the identifier.  Resource Pack  Now that you've set up the custom block.json file in the behavior pack, it's time to include the resources Minecraft will need to create the block: Textures, names, and even a fun sound.  Create a resource pack  We will begin by creating a resource pack for the custom block:  In File Explorer, navigate to the com.mojang folder. Open the development_resource_packs folder. Create a new folder named custom_block_resource_pack. Inside the custom_block_resource_pack folder, create a manifest.json file. Open the manifest.json file in a text editor. Copy the code below into the manifest.json file. See the Introduction to Behavior Packs Tutorial to learn how to use UUIDs to create the dependency of this behavior pack on the resource pack, and get any new UUIDs from UUIDgenerator.net. JSON Copy {   \"format_version\": 2,   \"header\": {    \"description\": \"This is a resource pack used to demo components!\",    \"name\": \"Demo Resource Pack\",    \"uuid\": \"<UUID>\",    \"version\": [ 1, 0, 0 ],    \"min_engine_version\": [ 1, 19, 20 ]   },   \"modules\": [    {     \"description\": \"Demo Resource Pack\",     \"type\": \"resources\",     \"uuid\": \"<UUID>\",     \"version\": [ 1, 0, 0 ]    }   ]  }   Set the block name with .lang  Let's add the name of the block using a .lang file. '.lang' files are used to organize all custom text within an Add-On in a single location, and to localize creator content.  Inside the custom_block_resource_pack folder, create a folder and name it texts. Open the texts folder. Inside the texts folder, create a new text document and name it en_US.lang. Open en_US.lang in a text editor. Copy and paste the following into en_US.lang: tile.demo:die.name=Die Save and close the file.  This code sets the name of the block to Die in the game.  Save the custom block textures  The die block texture will need to be created and placed in the Resource Pack. When creating your own custom textures, make sure they are 16x16 for custom blocks not using custom geometries.  These were made in Paint and are 16x16 pixels. There are 7 images because it's a die block (6 sides) plus red for the in-hand texture.  The image that shows the 1 side should be named die_1, 2 should be named die_2, and so on. The in-hand image should be named die_red.   Note  The images above have been provided for the die block, but feel free to use different textures. If you do, be very careful about naming throughout the tutorial!  If you are using the resources provided:  Download the files to your computer. In custom_block_resource_pack, create a folder named textures. Inside the textures folder, create a folder named blocks. Place the die block .png files in the blocks folder. Add a friendly name in terrain_texture.json  The next step is to associate the texture names with a texture file path. This is done in a terrain_texture.json file.  In File Explorer, navigate to the custom_block_resource_pack folder and open the textures folder. Inside the textures folder, create a text document and name it terrain_texture.json. Open terrain_texture.json in a text editor. Copy and paste in the following code: JSON Copy {    \"resource_pack_name\": \"custom_block_resource_pack\",    \"texture_name\": \"atlas.terrain\",    \"padding\": 8,    \"num_mip_levels\": 4,    \"texture_data\": {      \"die_1\": {        \"textures\": \"textures/blocks/die_1\"      },      \"die_2\": {        \"textures\": \"textures/blocks/die_2\"      },      \"die_3\": {        \"textures\": \"textures/blocks/die_3\"      },      \"die_4\": {        \"textures\": \"textures/blocks/die_4\"      },      \"die_5\": {        \"textures\": \"textures/blocks/die_5\"      },      \"die_6\": {        \"textures\": \"textures/blocks/die_6\"      },      \"die_red\": {        \"textures\": \"textures/blocks/die_red\"      }    }  }   Save the file.  In texture_data, the object with the label die_1 has created a friendly name we'll reference in other files. Cool!  Define textures and sounds with blocks.json  Block definitions are handled differently in the resource pack. Blocks are stored in a single JSON file that will contain definitions for each custom block.  Open the development_resource_packs folder. Open the custom_block_resource_pack folder. Inside the custom_block_resource_pack, create a text document and name it blocks.json. Open blocks.json in a text editor.  The blocks.json file has a similar set up to the manifest.json file and has requirements that need to be met in order for it to work correctly. Those requirements are:  A format version A namespaced name for our custom block (here it's demo:die) Textures for the custom block  The die block will use a custom texture for four of the sides, and a different texture for the top and bottom that you are going to bring over from the Vanilla Resource Pack. Real-life dice are designed so that the two opposite sides of the die add up to 7.  Copy the following text and paste it into your blocks.json file: JSON Copy {    \"format_version\": \"1.19.30\",    \"demo:die\": {      \"textures\": {        \"up\": \"die_1\",        \"down\": \"die_6\",        \"north\": \"die_3\",        \"south\": \"die_4\",        \"east\": \"die_2\",        \"west\": \"die_5\"      },      \"carried_textures\": \"die_red\",      \"sound\": \"stone\"       }  }  Save the file.  We're specifying the textures individually by face, and we're using the friendly name textures we assigned in terrain_textures.json. The textures field can be specified as a string, or as an object with the textures broken down into sub-textures. We define sub-textures here of up, down, and the cardinal directions to give each face a specific texture.  The carried_textures property allows you to specify the textures to use when the block is in your hand, hotbar, and inventory. We're giving that the die_red texture here as a string, but this could also be given an object to specify a texture for each face, too.  Finally, because this is a hard block, we're setting the sound to stone so that this block sounds like stone when you place it down or walk over it.  Test the block  With the die block defined in both the behavior pack and resource pack, you're ready to test it in-game.  Create a test world  The following are suggested settings for a test world, but feel free to tweak these as you see fit.  Flat world Show coordinates Cheats Always day Keep inventory No mob spawning No weather cycle Cheats enabled   Important  You will need to have a Minecraft world where cheats are enabled in order to add the block to your inventory using the /give command. You will also need to have both custom_block_resource_pack and custom_block_behavior_pack enabled in the world so you can get access to the die block.  Open the chat box. Type the following command: /give @s demo:die Troubleshooting If there's no custom block resource pack or behavior pack, do you have a manifest file? Does your file structure match the minecraft-samples packs? Have you created a world with cheats enabled? Are you using Minecraft: Bedrock Edition version 1.19.20 or later? If the demo:die doesn't appear in the game, is your behavior pack formatted correctly? If your textures don't load correctly, do your textures and terrain_texture.json file match the custom_block_resource_pack samples?  Now place your block anywhere you'd like. The die is red in hand and in the hotbar because of the carried_textures using the red die block. The sides will look like a colorful die when the block is placed, and walking on the block will use the stone sound.  Good luck!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/addcustomdieblock?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks Part 1: The Simplest Block 05/05/2025  Minecraft's behavior packs and resource packs allow you to create amazing custom content for the game. Custom blocks are an excellent way for creators to start adding interactive content. Through this tutorial, you will build a custom die block (don't be scared, that just means a singular dice!) that has different textures and can be placed in the world by a player.  In this tutorial you'll learn the following:  How to use JSON to define a new block. How to assign textures to a new block. Some of the behaviors and components that blocks can access. What .lang is and how it's used for in-game text. Prerequisites  It is recommended that the following be completed before beginning this tutorial:  This video is an excellent way to quickly get up to speed!  Getting Started with Add-On Development Introduction to Resource Packs Introduction to Behavior Packs  You'll also need to download the Vanilla resource pack.  Creating Custom Blocks with Resource and Behavior Packs  We even have a video for you to follow if that's your preference!  You'll be making changes in both a resource pack and a behavior pack to get custom looks and behavior for each custom block you will be creating. Here is the file structure we'll follow for this tutorial:  The behavior pack contains the <custom_block>.json file that holds all of the information about a block's behavior. It specifies components that give specific behaviors such as friction, flammability, destructibility, and more. Components can also control some visual elements such as geometry, materials, render methods, and lighting.   Note  If components are given in the behavior pack to control the visual properties of a block, they will override the visual properties specified for that block in the blocks.json file. That's why blocks.json becomes optional once you start relying on behavior packs more heavily.  In this tutorial, we'll be making a fairly simple custom block. We will be using blocks.json to specify the visual properties of the block, and won't be using any components. While it is recommended to complete this tutorial before moving forward, there is also a tutorial on using components called Advanced Custom Blocks.  Let's create a custom die block with six different-colored sides that becomes a different color in-hand. Small customizations like this can make a block feel more unique to players.  Behavior pack Create a behavior pack  We'll begin by creating a behavior pack for the custom block:  In File Explorer, navigate to the com.mojang folder.  Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.  Open the development_behavior_packs folder.  Create a folder and name it custom_block_behavior_pack.  Open the custom_block_behavior_pack folder, and create a text file.  Rename the text file manifest.json.  Open manifest.json in a text editor.  Copy the code below into the manifest.json file.  Get new UUIDs from UUIDgenerator.net.  JSON Copy {  \"format_version\": 2,   \"header\": {    \"description\": \"This is a behavior pack used to demo components!\",    \"name\": \"Demo Behavior Pack\",    \"uuid\": \"<UUID>\",    \"version\": [ 1, 0, 0 ],    \"min_engine_version\": [ 1, 19, 20 ]   },   \"modules\": [    {     \"description\": \"Demo Behavior Pack\",     \"type\": \"data\",     \"uuid\": \"<UUID>\",     \"version\": [ 1, 0, 0 ]    }   ],   \"dependencies\": [    {     \"uuid\": \"<Resource Pack UUID>\",     \"version\": [ 1, 0, 0 ]    }   ]  }   Now, let's create the custom block behavior JSON file in the behavior pack.  Inside the custom_block_behavior_pack folder, create a folder and name it blocks. Open the blocks folder. Inside the blocks folder, create a text document and name it die.json. Open die.json in a text editor. Create the behavior custom block json file  In the file, you will need to define what the block is, similar to the manifest.json file.  Copy and paste the following code into your die.json file: JSON Copy {    \"format_version\": \"1.19.30\",    \"minecraft:block\": {      \"description\": {        \"identifier\": \"demo:die\"      },      \"components\": {      }    }  }   Save the file.  Custom block files have several requirements for them to be functional:  format_version should be the latest, in case any components change in the future. minecraft:block is the block definition, which contains the \"description\" and \"components\" sections of a block. The description object requires an identifier with a namespace, separated by a colon. In this case, the namespace is \"demo\" and the identifier is \"die\". A components section contains the components that describe the block's behavior.  There are several components you may choose to use in custom blocks. To learn more, view the full list of custom block components in the reference documentation. For now, we'll leave the die block with only the identifier.  Resource Pack  Now that you've set up the custom block.json file in the behavior pack, it's time to include the resources Minecraft will need to create the block: Textures, names, and even a fun sound.  Create a resource pack  We will begin by creating a resource pack for the custom block:  In File Explorer, navigate to the com.mojang folder. Open the development_resource_packs folder. Create a new folder named custom_block_resource_pack. Inside the custom_block_resource_pack folder, create a manifest.json file. Open the manifest.json file in a text editor. Copy the code below into the manifest.json file. See the Introduction to Behavior Packs Tutorial to learn how to use UUIDs to create the dependency of this behavior pack on the resource pack, and get any new UUIDs from UUIDgenerator.net. JSON Copy {   \"format_version\": 2,   \"header\": {    \"description\": \"This is a resource pack used to demo components!\",    \"name\": \"Demo Resource Pack\",    \"uuid\": \"<UUID>\",    \"version\": [ 1, 0, 0 ],    \"min_engine_version\": [ 1, 19, 20 ]   },   \"modules\": [    {     \"description\": \"Demo Resource Pack\",     \"type\": \"resources\",     \"uuid\": \"<UUID>\",     \"version\": [ 1, 0, 0 ]    }   ]  }   Set the block name with .lang  Let's add the name of the block using a .lang file. '.lang' files are used to organize all custom text within an Add-On in a single location, and to localize creator content.  Inside the custom_block_resource_pack folder, create a folder and name it texts. Open the texts folder. Inside the texts folder, create a new text document and name it en_US.lang. Open en_US.lang in a text editor. Copy and paste the following into en_US.lang: tile.demo:die.name=Die Save and close the file.  This code sets the name of the block to Die in the game.  Save the custom block textures  The die block texture will need to be created and placed in the Resource Pack. When creating your own custom textures, make sure they are 16x16 for custom blocks not using custom geometries.  These were made in Paint and are 16x16 pixels. There are 7 images because it's a die block (6 sides) plus red for the in-hand texture.  The image that shows the 1 side should be named die_1, 2 should be named die_2, and so on. The in-hand image should be named die_red.   Note  The images above have been provided for the die block, but feel free to use different textures. If you do, be very careful about naming throughout the tutorial!  If you are using the resources provided:  Download the files to your computer. In custom_block_resource_pack, create a folder named textures. Inside the textures folder, create a folder named blocks. Place the die block .png files in the blocks folder. Add a friendly name in terrain_texture.json  The next step is to associate the texture names with a texture file path. This is done in a terrain_texture.json file.  In File Explorer, navigate to the custom_block_resource_pack folder and open the textures folder. Inside the textures folder, create a text document and name it terrain_texture.json. Open terrain_texture.json in a text editor. Copy and paste in the following code: JSON Copy {    \"resource_pack_name\": \"custom_block_resource_pack\",    \"texture_name\": \"atlas.terrain\",    \"padding\": 8,    \"num_mip_levels\": 4,    \"texture_data\": {      \"die_1\": {        \"textures\": \"textures/blocks/die_1\"      },      \"die_2\": {        \"textures\": \"textures/blocks/die_2\"      },      \"die_3\": {        \"textures\": \"textures/blocks/die_3\"      },      \"die_4\": {        \"textures\": \"textures/blocks/die_4\"      },      \"die_5\": {        \"textures\": \"textures/blocks/die_5\"      },      \"die_6\": {        \"textures\": \"textures/blocks/die_6\"      },      \"die_red\": {        \"textures\": \"textures/blocks/die_red\"      }    }  }   Save the file.  In texture_data, the object with the label die_1 has created a friendly name we'll reference in other files. Cool!  Define textures and sounds with blocks.json  Block definitions are handled differently in the resource pack. Blocks are stored in a single JSON file that will contain definitions for each custom block.  Open the development_resource_packs folder. Open the custom_block_resource_pack folder. Inside the custom_block_resource_pack, create a text document and name it blocks.json. Open blocks.json in a text editor.  The blocks.json file has a similar set up to the manifest.json file and has requirements that need to be met in order for it to work correctly. Those requirements are:  A format version A namespaced name for our custom block (here it's demo:die) Textures for the custom block  The die block will use a custom texture for four of the sides, and a different texture for the top and bottom that you are going to bring over from the Vanilla Resource Pack. Real-life dice are designed so that the two opposite sides of the die add up to 7.  Copy the following text and paste it into your blocks.json file: JSON Copy {    \"format_version\": \"1.19.30\",    \"demo:die\": {      \"textures\": {        \"up\": \"die_1\",        \"down\": \"die_6\",        \"north\": \"die_3\",        \"south\": \"die_4\",        \"east\": \"die_2\",        \"west\": \"die_5\"      },      \"carried_textures\": \"die_red\",      \"sound\": \"stone\"       }  }  Save the file.  We're specifying the textures individually by face, and we're using the friendly name textures we assigned in terrain_textures.json. The textures field can be specified as a string, or as an object with the textures broken down into sub-textures. We define sub-textures here of up, down, and the cardinal directions to give each face a specific texture.  The carried_textures property allows you to specify the textures to use when the block is in your hand, hotbar, and inventory. We're giving that the die_red texture here as a string, but this could also be given an object to specify a texture for each face, too.  Finally, because this is a hard block, we're setting the sound to stone so that this block sounds like stone when you place it down or walk over it.  Test the block  With the die block defined in both the behavior pack and resource pack, you're ready to test it in-game.  Create a test world  The following are suggested settings for a test world, but feel free to tweak these as you see fit.  Flat world Show coordinates Cheats Always day Keep inventory No mob spawning No weather cycle Cheats enabled   Important  You will need to have a Minecraft world where cheats are enabled in order to add the block to your inventory using the /give command. You will also need to have both custom_block_resource_pack and custom_block_behavior_pack enabled in the world so you can get access to the die block.  Open the chat box. Type the following command: /give @s demo:die Troubleshooting If there's no custom block resource pack or behavior pack, do you have a manifest file? Does your file structure match the minecraft-samples packs? Have you created a world with cheats enabled? Are you using Minecraft: Bedrock Edition version 1.19.20 or later? If the demo:die doesn't appear in the game, is your behavior pack formatted correctly? If your textures don't load correctly, do your textures and terrain_texture.json file match the custom_block_resource_pack samples?  Now place your block anywhere you'd like. The die is red in hand and in the hotbar because of the carried_textures using the red die block. The sides will look like a colorful die when the block is placed, and walking on the block will use the stone sound.  Good luck!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/advancedcustomblocks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks: Geometry and Material Instances 05/21/2025  In this tutorial, you will learn more about custom block components, including:  Using Blockbench to design custom geometries and textures. Adding block geometries that are different shapes/sizes than 16x16x16. Using the minecraft:geometry component to reference your custom geometry. Using the minecraft:material_instances component to set the texture(s) for your custom geometry.  If you haven't completed the How to Add a Simple Custom Block tutorial yet, it's recommended you do that before starting this one.  We've already created a cool die block that you can make with the fewest number of files and JSON, so let's explore the exciting possibilities that are offered by the behavior pack JSON components: geometry and material_instances!  Creating custom blocks with resource and behavior packs  For extra help, follow along with this video!  This tutorial builds from the Simple Custom Block lesson and uses the same file structure, with one major difference: for these blocks, we will be using custom geometry models, so we'll be adding a models folder to the custom_block_resource_pack. Here is the updated file structure we'll follow for this tutorial:  Sushi blocks  We're going to create custom blocks with geometry and material instances: sushi!  Let's use Blockbench  For this tutorial, we're going to be doing some work in Blockbench. Blockbench is a free entity-modeling application for creating entity models in Minecraft: Bedrock Edition. Additionally, users have the ability to create textures, and the ability to animate them for Bedrock Edition maps. Blockbench has external plugin support, enabling developers to create additional tools to use within the program. It also has the ability to export models into a standard OBJ format, Java Edition block model, and more.  We will use Blockbench in these tutorials to create custom geometries for the more advanced blocks we'll create for sushi, fish in a bubble, and a giant umbrella. If this is your first time using Blockbench, we recommend taking a look at the Entity Wizard tutorial.  Geometry in Blockbench  Each custom block has a different unit vector (UV) for the various textures of the sushi sides. The UV defines how the geometry maps to each texture. For this tutorial, we are sharing the texture for the sushi wrap.  As a bonus, the seaweed will be the same for all three rolls, so you can reuse the same geometries!  The textures for the individual rolls, however, will be different depending on the type of roll. Here is the salmon roll:  We highly recommend learning the ins and outs of Blockbench as you begin to create more complex and personalized custom entities. For this tutorial, however, we will be creating a blank file and exporting it to our PC, where we can copy our sushi block data.  Export the file from Blockbench  Navigate to File > Export > Export Bedrock Geometry to save the geometry file to your computer.  JSON Copy {    \"format_version\": \"1.12.0\",    \"minecraft:geometry\": [      {        \"description\": {          \"identifier\": \"geometry.sushi\",          \"texture_width\": 36,          \"texture_height\": 18,          \"visible_bounds_width\": 2,          \"visible_bounds_height\": 2.5,          \"visible_bounds_offset\": [0, 0.75, 0]        },        \"bones\": [          {            \"name\": \"bb_main\",            \"pivot\": [0, 0, 0],            \"cubes\": [              {\"origin\": [-6, 0, -3], \"size\": [12, 12, 6], \"uv\": [0, 0]}            ]          }        ]      }    ]  }    Now you can create textures in Blockbench, or create textures in a separate paint or photo editing application (assuring that it matches the size and UV of the geometry).  Resource pack Add the geometry  Let's start by adding files for the sushi blocks to the resource pack.  In File Explorer, navigate to the folder custom_block_resource_pack, located in the development_resource_packs folder. Inside the custom_block_resource_pack folder, create a folder and name it models. Open the models folder. Inside the models folder, create a folder and name it blocks. Open the blocks folder. Inside the blocks folder, copy the downloaded geometry files from Blockbench. Create custom block localization  Just like we did for the die block, we'll add custom block localization. In texts/en_US.lang, you'll add the following for the sushi blocks:  tile.demo:salmon_roll.name=Salmon Roll  tile.demo:tuna_roll.name=Tuna Roll  tile.demo:california_roll.name=California Roll  These lines set the name of the sushi blocks in the game. Make sure not to add extra spaces after the equal sign because they will display in Minecraft.  Add textures for blocks  Place the following images in the textures/blocks folder:  As always, feel free to create your own textures!  Add friendly names in terrain_texture.json  The next step is to associate the texture names with a texture file path. This is done in a terrain_texture.json file.  In File Explorer, navigate to the custom_block_resource_pack folder and open the textures folder. Open terrain_texture.json in a text editor. Copy and paste the following code into terrain_texture.json in the texture_data section: JSON Copy {    \"texture_data\": {      \"die_1\": {        \"textures\": \"textures/blocks/die_1\"      },     \"sushi_wrap\": {        \"textures\": \"textures/blocks/sushi_wrap\"      },      \"salmon_roll\": {        \"textures\": \"textures/blocks/salmon_roll\"      },      \"tuna_roll\": {       \"textures\": \"textures/blocks/tuna_roll\"      },      \"california_roll\": {       \"textures\": \"textures/blocks/california_roll\"      }    } }   Optional: include sounds in blocks.json  Adding a sound in blocks.json is optional, but you can include it here for fun.  Important! Because you'll be using advanced geometry and material instances, any rendering information will be overridden by the custom block file in the behavior pack. So we will only be adding the sound here. We'll give the sushi blocks the same sound as mud because they are squishy!  In the resource pack, navigate to blocks.json. Add the following sound information below the demo:die section. JSON Copy {    \"format_version\": \"1.19.30\",    \"demo:die\": {   },    \"demo:salmon_roll\": {      \"sound\": \"mud\"    },    \"demo:tuna_roll\": {      \"sound\": \"mud\"    },    \"demo:california_roll\": {      \"sound\": \"mud\"    } }   Behavior pack Create individual custom block files for each roll  Let's bring all those resource pieces together into one beautiful combination in the behavior pack individual custom block file.  Although the sushi blocks share the same geometry.sushi geometry, create separate files for each of these rolls so they become their own blocks that display their own unique textures.  In File Explorer, navigate to the folder custom_block_behavior_pack, located in the development_behavior_packs folder. Open the blocks folder and create a text document named salmon_roll.json. Double-click salmon_roll.json to open it in a text editor. Create the behavior custom block JSON file  In the file, you will need to define what each of the blocks is.  Copy and paste the following code into your salmon_roll.json file:  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:salmon_roll\"     },     \"components\": {       \"minecraft:geometry\": \"geometry.sushi\",       \"minecraft:material_instances\":{         \"north\": {            \"texture\": \"salmon_roll\"         },         \"south\": {            \"texture\": \"salmon_roll\"         },         \"*\": {           \"texture\": \"sushi_wrap\"         }       }     }   } }  Using custom block components  All of this has been a set up to the moment you've been waiting for: custom block components!  minecraft:geometry defines the model that will be used in the resource pack for this custom block. You will use the identifier inside the geo.json file that was created in Blockbench.  minecraft:material_instances has a ton of goodies. It's an object that defines the various textures (a single texture, or per-face) and allows you to specify some information about rendering and lighting. We'll talk more about the specific render methods and lighting options offered by this component later, in the Exploring the Material Instances Render and Lighting Options Tutorial.  Just like in blocks.json, we can define the various sides of the block that we want to use here. For now, we're going to define north and south for the salmon roll sides.  The rest of the sides are defined with *. This special key defines the default texture that will be used when a texture isn't given for a named side. If north and south weren't defined, the * key would give all the sides of our new block the sushi_wrap texture. You must specify a * key when you're defining material_instances.  Optional: Name custom instances of materials  There is another cool part of material_instances to show off: we can actually create defined variables within the material instances component. Let's see an example using salmon_roll:  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:salmon_roll\"     },     \"components\": {       \"minecraft:geometry\": \"geometry.sushi\",       \"minecraft:material_instances\": {         \"north\": \"sushi_side\",         \"south\": \"sushi_side\",         \"*\": {           \"texture\": \"sushi_wrap\"         },         \"sushi_side\": {           \"texture\": \"salmon_roll\"         }       }     }   } }   Here, we've defined sushi_side as having the salmon_roll texture.  Then, for north and south, we can use sushi_side as a string rather than a whole object specifying the texture as salmon_roll.  Now it's your turn to create the Tuna and California rolls. Feel free to copy this salmon_roll file to start from, making sure to change the identifier and the salmon_roll texture name to match the corresponding roll.  Test the block  Let's head back to the test world.  With the sushi blocks defined in both the behavior pack and resource pack, you can test them in-game.  Open up the chat dialogue box. Type the following command: /give @s demo:california_roll  Now you can place the sushi blocks all over! Note that the smaller geometry means they don't sit exactly side-by-side.  Make sure to test all three sushi blocks to truly appreciate how cute these new blocks really are!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/advancedcustomblocks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks: Geometry and Material Instances 05/21/2025  In this tutorial, you will learn more about custom block components, including:  Using Blockbench to design custom geometries and textures. Adding block geometries that are different shapes/sizes than 16x16x16. Using the minecraft:geometry component to reference your custom geometry. Using the minecraft:material_instances component to set the texture(s) for your custom geometry.  If you haven't completed the How to Add a Simple Custom Block tutorial yet, it's recommended you do that before starting this one.  We've already created a cool die block that you can make with the fewest number of files and JSON, so let's explore the exciting possibilities that are offered by the behavior pack JSON components: geometry and material_instances!  Creating custom blocks with resource and behavior packs  For extra help, follow along with this video!  This tutorial builds from the Simple Custom Block lesson and uses the same file structure, with one major difference: for these blocks, we will be using custom geometry models, so we'll be adding a models folder to the custom_block_resource_pack. Here is the updated file structure we'll follow for this tutorial:  Sushi blocks  We're going to create custom blocks with geometry and material instances: sushi!  Let's use Blockbench  For this tutorial, we're going to be doing some work in Blockbench. Blockbench is a free entity-modeling application for creating entity models in Minecraft: Bedrock Edition. Additionally, users have the ability to create textures, and the ability to animate them for Bedrock Edition maps. Blockbench has external plugin support, enabling developers to create additional tools to use within the program. It also has the ability to export models into a standard OBJ format, Java Edition block model, and more.  We will use Blockbench in these tutorials to create custom geometries for the more advanced blocks we'll create for sushi, fish in a bubble, and a giant umbrella. If this is your first time using Blockbench, we recommend taking a look at the Entity Wizard tutorial.  Geometry in Blockbench  Each custom block has a different unit vector (UV) for the various textures of the sushi sides. The UV defines how the geometry maps to each texture. For this tutorial, we are sharing the texture for the sushi wrap.  As a bonus, the seaweed will be the same for all three rolls, so you can reuse the same geometries!  The textures for the individual rolls, however, will be different depending on the type of roll. Here is the salmon roll:  We highly recommend learning the ins and outs of Blockbench as you begin to create more complex and personalized custom entities. For this tutorial, however, we will be creating a blank file and exporting it to our PC, where we can copy our sushi block data.  Export the file from Blockbench  Navigate to File > Export > Export Bedrock Geometry to save the geometry file to your computer.  JSON Copy {    \"format_version\": \"1.12.0\",    \"minecraft:geometry\": [      {        \"description\": {          \"identifier\": \"geometry.sushi\",          \"texture_width\": 36,          \"texture_height\": 18,          \"visible_bounds_width\": 2,          \"visible_bounds_height\": 2.5,          \"visible_bounds_offset\": [0, 0.75, 0]        },        \"bones\": [          {            \"name\": \"bb_main\",            \"pivot\": [0, 0, 0],            \"cubes\": [              {\"origin\": [-6, 0, -3], \"size\": [12, 12, 6], \"uv\": [0, 0]}            ]          }        ]      }    ]  }    Now you can create textures in Blockbench, or create textures in a separate paint or photo editing application (assuring that it matches the size and UV of the geometry).  Resource pack Add the geometry  Let's start by adding files for the sushi blocks to the resource pack.  In File Explorer, navigate to the folder custom_block_resource_pack, located in the development_resource_packs folder. Inside the custom_block_resource_pack folder, create a folder and name it models. Open the models folder. Inside the models folder, create a folder and name it blocks. Open the blocks folder. Inside the blocks folder, copy the downloaded geometry files from Blockbench. Create custom block localization  Just like we did for the die block, we'll add custom block localization. In texts/en_US.lang, you'll add the following for the sushi blocks:  tile.demo:salmon_roll.name=Salmon Roll  tile.demo:tuna_roll.name=Tuna Roll  tile.demo:california_roll.name=California Roll  These lines set the name of the sushi blocks in the game. Make sure not to add extra spaces after the equal sign because they will display in Minecraft.  Add textures for blocks  Place the following images in the textures/blocks folder:  As always, feel free to create your own textures!  Add friendly names in terrain_texture.json  The next step is to associate the texture names with a texture file path. This is done in a terrain_texture.json file.  In File Explorer, navigate to the custom_block_resource_pack folder and open the textures folder. Open terrain_texture.json in a text editor. Copy and paste the following code into terrain_texture.json in the texture_data section: JSON Copy {    \"texture_data\": {      \"die_1\": {        \"textures\": \"textures/blocks/die_1\"      },     \"sushi_wrap\": {        \"textures\": \"textures/blocks/sushi_wrap\"      },      \"salmon_roll\": {        \"textures\": \"textures/blocks/salmon_roll\"      },      \"tuna_roll\": {       \"textures\": \"textures/blocks/tuna_roll\"      },      \"california_roll\": {       \"textures\": \"textures/blocks/california_roll\"      }    } }   Optional: include sounds in blocks.json  Adding a sound in blocks.json is optional, but you can include it here for fun.  Important! Because you'll be using advanced geometry and material instances, any rendering information will be overridden by the custom block file in the behavior pack. So we will only be adding the sound here. We'll give the sushi blocks the same sound as mud because they are squishy!  In the resource pack, navigate to blocks.json. Add the following sound information below the demo:die section. JSON Copy {    \"format_version\": \"1.19.30\",    \"demo:die\": {   },    \"demo:salmon_roll\": {      \"sound\": \"mud\"    },    \"demo:tuna_roll\": {      \"sound\": \"mud\"    },    \"demo:california_roll\": {      \"sound\": \"mud\"    } }   Behavior pack Create individual custom block files for each roll  Let's bring all those resource pieces together into one beautiful combination in the behavior pack individual custom block file.  Although the sushi blocks share the same geometry.sushi geometry, create separate files for each of these rolls so they become their own blocks that display their own unique textures.  In File Explorer, navigate to the folder custom_block_behavior_pack, located in the development_behavior_packs folder. Open the blocks folder and create a text document named salmon_roll.json. Double-click salmon_roll.json to open it in a text editor. Create the behavior custom block JSON file  In the file, you will need to define what each of the blocks is.  Copy and paste the following code into your salmon_roll.json file:  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:salmon_roll\"     },     \"components\": {       \"minecraft:geometry\": \"geometry.sushi\",       \"minecraft:material_instances\":{         \"north\": {            \"texture\": \"salmon_roll\"         },         \"south\": {            \"texture\": \"salmon_roll\"         },         \"*\": {           \"texture\": \"sushi_wrap\"         }       }     }   } }  Using custom block components  All of this has been a set up to the moment you've been waiting for: custom block components!  minecraft:geometry defines the model that will be used in the resource pack for this custom block. You will use the identifier inside the geo.json file that was created in Blockbench.  minecraft:material_instances has a ton of goodies. It's an object that defines the various textures (a single texture, or per-face) and allows you to specify some information about rendering and lighting. We'll talk more about the specific render methods and lighting options offered by this component later, in the Exploring the Material Instances Render and Lighting Options Tutorial.  Just like in blocks.json, we can define the various sides of the block that we want to use here. For now, we're going to define north and south for the salmon roll sides.  The rest of the sides are defined with *. This special key defines the default texture that will be used when a texture isn't given for a named side. If north and south weren't defined, the * key would give all the sides of our new block the sushi_wrap texture. You must specify a * key when you're defining material_instances.  Optional: Name custom instances of materials  There is another cool part of material_instances to show off: we can actually create defined variables within the material instances component. Let's see an example using salmon_roll:  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:salmon_roll\"     },     \"components\": {       \"minecraft:geometry\": \"geometry.sushi\",       \"minecraft:material_instances\": {         \"north\": \"sushi_side\",         \"south\": \"sushi_side\",         \"*\": {           \"texture\": \"sushi_wrap\"         },         \"sushi_side\": {           \"texture\": \"salmon_roll\"         }       }     }   } }   Here, we've defined sushi_side as having the salmon_roll texture.  Then, for north and south, we can use sushi_side as a string rather than a whole object specifying the texture as salmon_roll.  Now it's your turn to create the Tuna and California rolls. Feel free to copy this salmon_roll file to start from, making sure to change the identifier and the salmon_roll texture name to match the corresponding roll.  Test the block  Let's head back to the test world.  With the sushi blocks defined in both the behavior pack and resource pack, you can test them in-game.  Open up the chat dialogue box. Type the following command: /give @s demo:california_roll  Now you can place the sushi blocks all over! Note that the smaller geometry means they don't sit exactly side-by-side.  Make sure to test all three sushi blocks to truly appreciate how cute these new blocks really are!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/addcustomitems?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Items 09/18/2024  It's possible to customize or create items in Minecraft, just like you can create custom blocks and entities.  This tutorial shows you how to create the structure and files needed for the add-on packs for different items. Different types of items require different files, depending on what Minecraft needs to know about the item. For example, things a player wears, like a crown, will require a model file, among other things.  It's important to remember that each of these files have to be stored in a folder with the correct name, in the exact location specified.  Prerequisites  It is recommended that the following be completed before beginning this tutorial:  Getting Started with Add-On Development Introduction to Resource Packs Introduction to Behavior Packs How to Add a Simple Custom Block Minecraft Item Wizard  Here is a link to the Vanilla Minecraft Add-on Packs in case you want to take a look at the pack structure there.  Minecraft Custom Items  Here are three items that do not currently exist in Vanilla Minecraft. They are listed here in order of complexity:  Goo Wrench Crown Custom Chestplate with Vanilla Armor Trim  Use the following sections to create add-on packs for each item, or to do one set of packs for two or more items.  Here is the general process from the Add-on pack tutorials:  Create Behavior Pack and Resource Pack folders. Create the folder and file structure for the item you want to create. Be sure to include the manifest.json files. Copy/paste the contents for the custom item files from the content in each section. Download and save the graphic files into the correct location. Load the packs into the development_behavior_pack and development_resource_pack folders in your com.mojang folder. Launch Minecraft: Bedrock Edition. Create a world with the behavior pack and resource packs activated. Choose either Creative Mode or Survival Mode with cheats toggled on. Go into your world and use the /give @s demo:<item> command to get your custom item.  You can also experiment with different item components and edit the graphic and model files in an application like Blockbench  Here is the template for each manifest.json file, which is also found in the Resource Pack and Behavior Pack tutorials.  Be sure to put your own UUIDs in there.  Behavior Pack/manifest.json  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Custom Item Behavior Pack\",     \"name\": \"Custom Item Behavior Pack\",     \"uuid\": \"<ADD YOUR OWN UUID>\",     \"version\": [1, 0, 1],     \"min_engine_version\": [1, 20, 30]   },   \"modules\": [     {       \"description\": \"Custom Item Behavior Pack\",       \"type\": \"data\",       \"uuid\": \"<ADD YOUR OWN UUID>\",       \"version\": [1, 0, 1]     }   ] }   Resource Pack/manifest.json  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Custom Item Resource Pack\",     \"name\": \"Custom Item Resource Pack\",     \"uuid\": \"<ADD YOUR OWN UUID>\",     \"version\": [1, 0, 1],     \"min_engine_version\": [1, 20, 30]   },   \"modules\": [     {       \"description\": \"Custom Item Resource Pack\",       \"type\": \"resources\",       \"uuid\": \"<ADD YOUR OWN UUID>\",       \"version\": [1, 0, 1]     }   ] }  Goo  Goo is the simplest custom item. You don't wear it or eat it. It's just a handful of weird goo. It's useful for making sure your add-on packs work and for experimenting with stack size and the display name.  Goo Behavior Pack  items goo.json manifest.json  Goo Behavior Pack/items/goo.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:item\": {     \"description\": {       \"identifier\": \"demo:goo\",       \"category\": \"Items\"     },     \"components\": {       \"minecraft:max_stack_size\": 16,       \"minecraft:icon\": {         \"texture\": \"demo:goo\"       },       \"minecraft:display_name\": {         \"value\": \"Weird Goo\"       }     }   } }  Goo Resource Pack Copy textures   items     goo.png   item_texture.json manifest.json   Goo Resource Pack/textures/item_texture.json  JSON Copy {   \"resource_pack_name\": \"Goo Resource Pack\",   \"texture_data\": {     \"demo:goo\": {       \"textures\": \"textures/items/goo\"     }   } }   Goo Resource Pack/textures/items  Here is a.png file to download and use for the goo texture:  Custom Goo Result  After you create the packs, go into Minecraft, and give yourself goo, it should look like this:  Wrench  An awesome giant wrench! This item has separate texture files for the version in your hotbar and the version you hold in your hand.  Wrench Behavior Pack Copy items   wrench.json manifest.json   Wrench Behavior Pack/items/wrench.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:item\": {     \"description\": {       \"identifier\": \"demo:wrench\",       \"category\": \"Items\"     },      \"components\": {       \"minecraft:max_stack_size\": 16,       \"minecraft:icon\": {         \"texture\": \"demo:wrench\"       },       \"minecraft:wearable\": {         \"dispensable\": true,         \"slot\": \"slot.weapon.offhand\"       }     }   } }  Wrench Resource Pack Copy attachables   wrench.player.json models   entity     wrench.geo.json textures   items     wrench.png     wrench_ico.png   item_texture.json manifest.json   Wrench Resource Pack/attachables/wrench.player.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:attachable\": {     \"description\": {       \"identifier\": \"demo:wrench\",       \"item\": { \"demo:wrench\": \"query.is_owner_identifier_any('minecraft:player')\" },       \"materials\": {         \"default\": \"entity\",         \"enchanted\": \"entity_alphatest_glint\"       },       \"textures\": {         \"default\": \"textures/items/wrench\",         \"enchanted\": \"textures/misc/enchanted_item_glint\"       },       \"geometry\": {         \"default\": \"geometry.wrench\"       },       \"animations\": {         \"hold_first_person\": \"animation.steve_head.hold_first_person\",         \"hold_third_person\": \"animation.steve_head.hold_third_person\"       },       \"scripts\": {         \"animate\": [           {             \"hold_first_person\": \"context.is_first_person == 1.0\"           },           {             \"hold_third_person\": \"context.is_first_person == 0.0\"           }         ]       },       \"render_controllers\": [\"controller.render.item_default\"]     }   } }   Wrench Resource Pack/models/entity/wrench.geo.json  JSON Copy {   \"format_version\": \"1.16.0\",   \"minecraft:geometry\": [     {       \"description\": {         \"identifier\": \"geometry.wrench\",         \"texture_width\": 32,         \"texture_height\": 32,         \"visible_bounds_width\": 3,         \"visible_bounds_height\": 4,         \"visible_bounds_offset\": [0, 1, 0]       },       \"bones\": [         {           \"name\": \"bb_main\",           \"pivot\": [0.1, 19, -6],           \"rotation\": [125, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-0.9, 9, -8], \"size\": [2, 16, 3], \"uv\": [0, 13]},             {\"origin\": [-0.9, 25, -11], \"size\": [2, 4, 9], \"uv\": [0, 0]},             {\"origin\": [-0.9, 29, -5], \"size\": [2, 2, 3], \"uv\": [13, 0]},             {\"origin\": [-0.9, 29, -11], \"size\": [2, 1, 3], \"uv\": [10, 13]},             {\"origin\": [-0.9, 30, -10], \"size\": [2, 1, 2], \"uv\": [10, 17]},             {\"origin\": [-0.9, 31, -5], \"size\": [2, 1, 3], \"uv\": [13, 5]},             {\"origin\": [-0.9, 32, -5], \"size\": [2, 1, 2], \"uv\": [0, 6]},             {\"origin\": [-0.9, 31, -9], \"size\": [2, 1, 1], \"uv\": [17, 19]},             {\"origin\": [-0.9, 33, -5], \"size\": [2, 1, 1], \"uv\": [16, 17]},             {\"origin\": [-0.9, 24, -5], \"size\": [2, 1, 2], \"uv\": [0, 3]},             {\"origin\": [-0.9, 24, -10], \"size\": [2, 1, 2], \"uv\": [0, 0]},             {\"origin\": [-0.9, 23, -5], \"size\": [2, 1, 1], \"uv\": [17, 13]},             {\"origin\": [-0.9, 23, -9], \"size\": [2, 1, 1], \"uv\": [7, 13]}           ]         }       ]     }   ] }   Wrench Resource Pack/textures/items  Here are the image files to use for the wrench icon and for the wrench itself.  Here is the wrench icon:  Here is the wrench texture:  Wrench Resource Pack/textures/item_texture.json  JSON Copy {   \"resource_pack_name\": \"Wrench Resource Pack\",   \"texture_data\": {     \"demo:wrench\": {       \"textures\": \"textures/items/wrench_ico\"     }   } }   After you create the packs, go into Minecraft, and give yourself a wrench, it should look like this:  Crown  This is a crown created by customizing a helmet.  Crown Behavior Pack Copy items   crown.json manifest.json   Crown Behavior Pack/items/crown.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:item\": {     \"description\": {       \"identifier\": \"demo:crown\",       \"category\": \"Items\"     },     \"components\": {       \"minecraft:max_stack_size\": 1,       \"minecraft:icon\": {         \"texture\": \"demo:crown\"       },       \"minecraft:wearable\": {         \"dispensable\": true,         \"slot\": \"slot.armor.head\"       }     }   } }  Crown Resource Pack Copy attachables   crown.player.json models   entity     crown.geo.json textures   items     crown_ico.png     crown_minecraft.png   item_texture.json manifest.json   Crown Resource Pack/attachables/crown.player.json  JSON Copy {   \"format_version\": \"1.19.80\",   \"minecraft:attachable\": {     \"description\": {       \"identifier\": \"demo:crown_hat.player\",       \"item\": { \"demo:crown\": \"query.is_owner_identifier_any('minecraft:player')\" },       \"materials\": {         \"default\": \"armor\",         \"enchanted\": \"armor_enchanted\"       },       \"textures\": {         \"default\": \"textures/items/crown_minecraft\",         \"enchanted\": \"textures/misc/enchanted_item_glint\"       },       \"geometry\": {         \"default\": \"geometry.crown\"       },       \"scripts\": {         \"parent_setup\": \"variable.helmet_layer_visible = 0.0;\"       },       \"render_controllers\": [\"controller.render.armor\"]     }   } }   Crown Resource Pack/models/entity/crown.geo.json  This file creates the custom shape of the crown that the texture will be mapped on to.  JSON Copy {   \"format_version\": \"1.16.0\",   \"minecraft:geometry\": [     {       \"description\": {         \"identifier\": \"geometry.crown\",         \"texture_width\": 32,         \"texture_height\": 32,         \"visible_bounds_width\": 2,         \"visible_bounds_height\": 3.5,         \"visible_bounds_offset\": [0, 1.25, 0]       },       \"bones\": [         {           \"name\": \"Crownbase\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-3, 31, -6.4], \"size\": [6, 3, 2], \"uv\": [1, 0]},             {\"origin\": [-5, 31, -6.4], \"size\": [6, 3, 2], \"pivot\": [-1, 31, -1.4], \"rotation\": [0, 90, 0], \"uv\": [0, 0]},             {\"origin\": [-3, 31, 1.6], \"size\": [6, 3, 2], \"pivot\": [1, 31, -1.4], \"rotation\": [0, 90, 0], \"uv\": [0, 0]},             {\"origin\": [-3, 31, 4.6], \"size\": [6, 3, 2], \"uv\": [1, 0]},             {\"origin\": [3, 31, -5.4], \"size\": [2, 3, 2], \"uv\": [24, 0]},             {\"origin\": [3, 31, 2.6], \"size\": [2, 3, 2], \"uv\": [22, 23]},             {               \"origin\": [-5, 31, -5.4],               \"size\": [2, 3, 2],               \"uv\": {                 \"north\": {\"uv\": [18, 22], \"uv_size\": [2, 3]},                 \"east\": {\"uv\": [16, 22], \"uv_size\": [2, 3]},                 \"south\": {\"uv\": [22, 22], \"uv_size\": [2, 3]},                 \"west\": {\"uv\": [20, 22], \"uv_size\": [2, 3]},                 \"up\": {\"uv\": [18, 20], \"uv_size\": [2, 2]},                 \"down\": {\"uv\": [20, 22], \"uv_size\": [2, -2]}               }             },             {\"origin\": [-5, 31, 2.6], \"size\": [2, 3, 2], \"uv\": [20, 10]}           ]         },         {           \"name\": \"crownprongs\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-5, 34, -5.4], \"size\": [2, 3, 2], \"uv\": [8, 20]},             {\"origin\": [3, 34, 2.6], \"size\": [2, 3, 2], \"uv\": [20, 5]},             {\"origin\": [3, 34, -5.4], \"size\": [2, 3, 2], \"uv\": [0, 20]},             {\"origin\": [-5, 34, 2.6], \"size\": [2, 3, 2], \"uv\": [16, 15]}           ]         },         {           \"name\": \"crownextraprongs\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-1, 34, -6.4], \"size\": [2, 3, 2], \"uv\": [8, 15]},             {\"origin\": [-6, 34, -1.4], \"size\": [2, 3, 2], \"uv\": [0, 15]},             {\"origin\": [-1, 34, 4.6], \"size\": [2, 3, 2], \"uv\": [12, 10]},             {\"origin\": [4, 34, -1.4], \"size\": [2, 3, 2], \"uv\": [12, 5]}           ]         },         {           \"name\": \"crownjewels\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-7, 32, -1.4], \"size\": [1, 1, 2], \"uv\": [6, 25]},             {\"origin\": [5, 32, -2.4], \"size\": [1, 1, 2], \"pivot\": [0, 31, -1.4], \"rotation\": [0, 90, 0], \"uv\": [0, 25]},             {\"origin\": [-6, 32, 0.6], \"size\": [1, 1, 2], \"pivot\": [0, 31, 1.6], \"rotation\": [0, 90, 0], \"uv\": [22, 18]},             {\"origin\": [6, 32, -1.4], \"size\": [1, 1, 2], \"uv\": [24, 15]}           ]         }       ]     }   ] }   Crown Resource Pack/textures/items  Here are the image files to download and use for the crown icon and the crown texture itself.  Here is the crown icon:  Here is the crown texture:  Crown Resource Pack/textures/item_texture.json  JSON Copy {   \"resource_pack_name\": \"crown_resource_pack\",   \"texture_data\": {     \"demo:crown\": {       \"textures\": \"textures/items/crown\"     }   } }  Custom Crown Result  After you create the packs, go into Minecraft, give yourself a crown, and put it on, you should look like this:  Custom Chestplate with Vanilla Armor Trim  If you create a custom chestplate, either by hand or through using the Minecraft Item Wizard, you can have it support all the Armor Trims available as of release 1.20.70. You can modify the trim patterns to better fit your custom armor too!  To use armor trim on your custom armor, you need to set your format versions on the item and attachable to a minimum of 1.20.60.  Custom Chestplate with Vanilla Armor Trim Behavior Pack Copy items   custom_chestplate.item.json manifest.json   Chestplate Behavior Pack/items/custom_chestplate.item.json  JSON Copy {  \"format_version\": \"1.20.60\",    \"minecraft:item\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"menu_category\": {          \"category\": \"equipment\",          \"group\": \"itemGroup.name.chestplate\"        }     },     \"components\": {        \"minecraft:max_stack_size\": 1,        \"minecraft:icon\": {          \"textures\": {            \"default\": \"custom_chestplate\" }        },        \"minecraft:wearable\": {          \"protection\": 10,          \"slot\": \"slot.armor.chest\"        },        \"minecraft:durability\": {          \"damage_chance\": {            \"min\": 10,            \"max\": 50        },          \"max_durability\": 1560        },        \"minecraft:repairable\": {          \"repair_items\": [            {              \"items\": [\"pink_dye\"],              \"repair_amount\": 390            }          ]        },        \"minecraft:tags\": {          \"tags\": [            \"minecraft:is_armor\",            \"minecraft:trimmable_armors\"          ]        }      }    }  }   Chestplate Resource Pack  Copy attachables   custom_chestplate.attachable.json models   entity     custom_chestplate.geo.json textures   items     custom_chestplate_ico.png     custom_chestplate.png   item_texture.json manifest.json   Chestplate Resource Pack/attachables/custom_chestplate.attachable.json  This file defines which geometry will appear for the chestplate, as well as the armor trim palette that will be used and any adjusted trim patterns.  JSON Copy {   \"format_version\": \"1.20.60\",    \"minecraft:attachable\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"render_controllers\": [\"controller.render.armor\"],        \"materials\": {          \"default\": \"entity_alphatest\",          \"enchanted\": \"entity_alphatest_glint\"        },        \"textures\": {          \"default\": \"textures/entity/attachable/custom_chestplate\",         \"enchanted\": \"textures/misc/enchanted_item_glint\",          \"wild_trim\": \"textures/models/armor/custom_wild\",          \"iron_palette\": \"textures/trims/color_palettes/diamond_darker\"       },        \"geometry\": {          \"default\": \"geometry.custom_chestplate\"       }     }   } }   You can add any of the existing vanilla armor trim patterns to the textures section to supply adjusted trim textures to your new armor.  Chestplate Resource Pack/models/entity/custom_chestplate.geo.json  This file creates the custom shape of the chestplate that the texture and armor trim will be mapped on to.  JSON Copy {   \"format_version\": \"1.16.0\",    \"minecraft:geometry\": [      {        \"description\": {          \"identifier\": \"geometry.custom_chestplate\",          \"texture_width\": 32,          \"texture_height\": 32,          \"visible_bounds_width\": 3,          \"visible_bounds_height\": 2.5,          \"visible_bounds_offset\": [0, 0.75, 0]        },        \"bones\": [          {            \"name\": \"body\",            \"pivot\": [0, 14, 0]          },          {            \"name\": \"chestplate\",            \"parent\": \"body\",            \"pivot\": [0, 0, 0],            \"binding\": \"'body'\",            \"cubes\": [              {\"origin\": [-4, 2, -2], \"size\": [8, 12, 4], \"inflate\": 1.01, \"uv\": [0, 0]}            ]          },          {            \"name\": \"arm_right\",            \"pivot\": [-5, 12, 0]          },         {            \"name\": \"arm_plate_right\",            \"parent\": \"arm_right\",            \"pivot\": [-5, 12, 0],            \"binding\": \"'rightarm'\",            \"cubes\": [              {\"origin\": [-8, 2, -2], \"size\": [4, 12, 4], \"inflate\": 1, \"uv\": [0, 16]}            ]          },          {            \"name\": \"arm_left\",            \"pivot\": [5, 12, 0]          },          {            \"name\": \"arm_plate_left\",            \"parent\": \"arm_left\",            \"pivot\": [5, 12, 0],            \"binding\": \"'leftarm'\",            \"cubes\": [              {\"origin\": [4, 2, -2], \"size\": [4, 12, 4], \"inflate\": 1, \"uv\": [0, 16], \"mirror\": true}            ]          }        ]      }    ]  }  Chestplate Resource Pack/textures/items  Here are the image files to download and use for the custom chestplate icon and the geometry's texture itself.  Here is the chestplate icon:  Here is the chestplate texture:  Here is the modified \"wild\" trim pattern:  Chestplate Resource Pack/textures/item_texture.json  JSON Copy {     \"texture_data\": {         \"custom_chestplate\": {             \"textures\": \"textures/items/custom_chestplate.png\"         }     } }  Custom Chestplate Result  After you create the packs, go into Minecraft, give yourself the custom chestplate, and put it on. You should look like this:  Give yourself the wild armor trim template and combine your chestplate with the wild template at a smithing table, and put it back on, you should now look like this:  If your chestplate instead looks like this...  ... then check the paths to your textures in the item_texture.json and custom_chestplate.attachable.json files. If there are any spelling errors or textures in incorrect folders, the geometry will display the \"missing texture pattern\" on your armor.  Dyeable Custom Items  Custom items can now be dyed in cauldrons. To use the dyeable component the format version on the item and the attachable needs to be 1.21.30 or higher.  This section of the tutorial assumes that you have successfully completed the previous section: Custom Chestplate with Vanilla Armor Trim.  Start by creating a copy of your Custom Chestplate with Vanilla Armor Trim add-on packs.  Dyable Custom Chestplate Behavior Pack  Chestplate Behavior Pack/textures/item_texture.json  Inside the behavior pack, open textures/item_texture.json and do this:  Edit the format version to be 1.21.30.  Edit minecraft:icon:  JSON Copy \"minecraft:icon\": {   \"textures\": {     \"default\": \"custom_chestplate_icon\",     \"dyed\": \"custom_chestplate_icon_gray\"     } },  Add minecraft:dyeable. JSON Copy \"minecraft:dyeable\": {   \"default_color\":  \"#175882\" }   ... So that the final version of item_texture.json looks like this:  JSON Copy {  \"format_version\": \"1.21.30\",    \"minecraft:item\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"menu_category\": {          \"category\": \"equipment\",          \"group\": \"itemGroup.name.chestplate\"        }     },     \"components\": {        \"minecraft:max_stack_size\": 1,        \"minecraft:icon\": {         \"textures\": {           \"default\": \"custom_chestplate_icon\",           \"dyed\": \"custom_chestplate_icon_gray\"         }       },       \"minecraft:wearable\": {         \"protection\": 10,          \"slot\": \"slot.armor.chest\"        },        \"minecraft:durability\": {          \"damage_chance\": {            \"min\": 10,            \"max\": 50        },          \"max_durability\": 1560        },        \"minecraft:repairable\": {          \"repair_items\": [            {              \"items\": [\"pink_dye\"],              \"repair_amount\": 390            }          ]        },        \"minecraft:tags\": {          \"tags\": [            \"minecraft:is_armor\",            \"minecraft:trimmable_armors\"          ]        },       \"minecraft:dyeable\": {         \"default_color\":  \"#175882\"       }     }    }  }   If you do not want a default color you can leave the \"default_color\" off and the texture will be the same as if you did not have the component until it is dyed.  For the icon to be dyed correctly. you need to provide a grayscale .tga version of your icon image. To do this, make a copy of the .png file, change the extension to .tga, and then change the configuration to grayscale.  Hint: You can use the icon graphics from the previous section.  Dyeable Custom Chestplate Resource Pack:  Copy  attachables    custom_chestplate.attachable.json  models    entity      custom_chestplate.geo.json  render_controllers (NEW)    custom_chestplate.render_controllers.json (NEW)  textures    items      custom_chestplate_ico.png      custom_chestplate.png      custom_chestplate_grayscale.tga      custom_chestplate_icon_grayscale.tga    item_texture.json  manifest.json   You edit Pack/attachables/custom_chestplate.attachable.json like this...  Edit the format version to be 1.21.30.  Edit \"render_controllers\" like this...  JSON Copy \"render_controllers\": [ \"controller.render.custom_chestplate\" ],  Edit materials to be: JSON Copy \"materials\": {   \"default\": \"armor\",   \"dyed\": \"entity_alphatest_change_color\" },  Edit textures to be: JSON Copy \"textures\": {   \"default\": \"textures/items/custom_chestplate.png\",   \"dyed\": \"textures/items/custom_chestplate_grayscale.tga\" },  Add scripts: JSON Copy \"scripts\": {   \"pre_animation\": [     \"variable.is_dyed = query.armor_color_slot(1, 0) != 0.0 || query.armor_color_slot(1, 1) != 0.0 || query.armor_color_slot(1, 2) != 0.0 || query.armor_color_slot(1, 3) != 0.0;\"   ] }   So that the final version of custom_chestplate.attachable.json looks like this:  JSON Copy {   \"format_version\": \"1.20.60\",    \"minecraft:attachable\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"render_controllers\": [\"controller.render.armor\"],        \"materials\": {          \"default\": \"armor\",         \"dyed\": \"entity_alphatest_change_color\"       },        \"textures\": {          \"default\": \"textures/items/custom_chestplate.png\",         \"dyed\": \"textures/items/custom_chestplate_grayscale.tga\"       },        \"geometry\": {          \"default\": \"geometry.custom_chestplate\"       },       \"scripts\": {         \"pre_animation\": [           \"variable.is_dyed = query.armor_color_slot(1, 0) != 0.0 || query.armor_color_slot(1, 1) != 0.0 || query.armor_color_slot(1, 2) != 0.0 || query.armor_color_slot(1, 3) != 0.0;\"         ]       }     }   } }  custom_chestplate.render_controllers.json  In the resource pack, add the render_controllers directory and put a new file in there named: custom_chestplate.render_controllers.json.  Copy and paste this content in there:  JSON Copy {   \"format_version\": \"1.8.0\",   \"render_controllers\": {     \"controller.render.custom_chestplate\": {       \"geometry\": \"Geometry.default\",       \"materials\": [ { \"*\": \"variable.is_dyed ? Material.dyed : Material.default\" } ],       \"textures\": [         \"variable.is_dyed ? Texture.dyed : Texture.default\"       ]     }   } }   Chestplate Resource Pack/items/item_texture  JSON Copy {   \"texture_data\": {     \"custom_chestplate\": {       \"textures\": \"textures/items/custom_chestplate.png\"     },     \"custom_chestplate_icon_gray\": {       \"textures\": \"textures/items/custom_chestplate_icon_grayscale.tga\"     }   } }   After you have edited and saved all of the files, you should be able to dye your custom chestplate in a cauldron full of dye and it will look like this:  To learn more about the dyeable item component, take a look at the minecraft:dyeable reference page.  Next Steps  After you create the custom item packs and get them to work, you could take a look at the item components and try adding some of these to your own custom items.  Or, you could go through the Custom Item Wizard and compare the add-on packs created by the Wizard to the ones you created on your own.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/addcustomitems?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Items 09/18/2024  It's possible to customize or create items in Minecraft, just like you can create custom blocks and entities.  This tutorial shows you how to create the structure and files needed for the add-on packs for different items. Different types of items require different files, depending on what Minecraft needs to know about the item. For example, things a player wears, like a crown, will require a model file, among other things.  It's important to remember that each of these files have to be stored in a folder with the correct name, in the exact location specified.  Prerequisites  It is recommended that the following be completed before beginning this tutorial:  Getting Started with Add-On Development Introduction to Resource Packs Introduction to Behavior Packs How to Add a Simple Custom Block Minecraft Item Wizard  Here is a link to the Vanilla Minecraft Add-on Packs in case you want to take a look at the pack structure there.  Minecraft Custom Items  Here are three items that do not currently exist in Vanilla Minecraft. They are listed here in order of complexity:  Goo Wrench Crown Custom Chestplate with Vanilla Armor Trim  Use the following sections to create add-on packs for each item, or to do one set of packs for two or more items.  Here is the general process from the Add-on pack tutorials:  Create Behavior Pack and Resource Pack folders. Create the folder and file structure for the item you want to create. Be sure to include the manifest.json files. Copy/paste the contents for the custom item files from the content in each section. Download and save the graphic files into the correct location. Load the packs into the development_behavior_pack and development_resource_pack folders in your com.mojang folder. Launch Minecraft: Bedrock Edition. Create a world with the behavior pack and resource packs activated. Choose either Creative Mode or Survival Mode with cheats toggled on. Go into your world and use the /give @s demo:<item> command to get your custom item.  You can also experiment with different item components and edit the graphic and model files in an application like Blockbench  Here is the template for each manifest.json file, which is also found in the Resource Pack and Behavior Pack tutorials.  Be sure to put your own UUIDs in there.  Behavior Pack/manifest.json  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Custom Item Behavior Pack\",     \"name\": \"Custom Item Behavior Pack\",     \"uuid\": \"<ADD YOUR OWN UUID>\",     \"version\": [1, 0, 1],     \"min_engine_version\": [1, 20, 30]   },   \"modules\": [     {       \"description\": \"Custom Item Behavior Pack\",       \"type\": \"data\",       \"uuid\": \"<ADD YOUR OWN UUID>\",       \"version\": [1, 0, 1]     }   ] }   Resource Pack/manifest.json  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Custom Item Resource Pack\",     \"name\": \"Custom Item Resource Pack\",     \"uuid\": \"<ADD YOUR OWN UUID>\",     \"version\": [1, 0, 1],     \"min_engine_version\": [1, 20, 30]   },   \"modules\": [     {       \"description\": \"Custom Item Resource Pack\",       \"type\": \"resources\",       \"uuid\": \"<ADD YOUR OWN UUID>\",       \"version\": [1, 0, 1]     }   ] }  Goo  Goo is the simplest custom item. You don't wear it or eat it. It's just a handful of weird goo. It's useful for making sure your add-on packs work and for experimenting with stack size and the display name.  Goo Behavior Pack  items goo.json manifest.json  Goo Behavior Pack/items/goo.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:item\": {     \"description\": {       \"identifier\": \"demo:goo\",       \"category\": \"Items\"     },     \"components\": {       \"minecraft:max_stack_size\": 16,       \"minecraft:icon\": {         \"texture\": \"demo:goo\"       },       \"minecraft:display_name\": {         \"value\": \"Weird Goo\"       }     }   } }  Goo Resource Pack Copy textures   items     goo.png   item_texture.json manifest.json   Goo Resource Pack/textures/item_texture.json  JSON Copy {   \"resource_pack_name\": \"Goo Resource Pack\",   \"texture_data\": {     \"demo:goo\": {       \"textures\": \"textures/items/goo\"     }   } }   Goo Resource Pack/textures/items  Here is a.png file to download and use for the goo texture:  Custom Goo Result  After you create the packs, go into Minecraft, and give yourself goo, it should look like this:  Wrench  An awesome giant wrench! This item has separate texture files for the version in your hotbar and the version you hold in your hand.  Wrench Behavior Pack Copy items   wrench.json manifest.json   Wrench Behavior Pack/items/wrench.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:item\": {     \"description\": {       \"identifier\": \"demo:wrench\",       \"category\": \"Items\"     },      \"components\": {       \"minecraft:max_stack_size\": 16,       \"minecraft:icon\": {         \"texture\": \"demo:wrench\"       },       \"minecraft:wearable\": {         \"dispensable\": true,         \"slot\": \"slot.weapon.offhand\"       }     }   } }  Wrench Resource Pack Copy attachables   wrench.player.json models   entity     wrench.geo.json textures   items     wrench.png     wrench_ico.png   item_texture.json manifest.json   Wrench Resource Pack/attachables/wrench.player.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:attachable\": {     \"description\": {       \"identifier\": \"demo:wrench\",       \"item\": { \"demo:wrench\": \"query.is_owner_identifier_any('minecraft:player')\" },       \"materials\": {         \"default\": \"entity\",         \"enchanted\": \"entity_alphatest_glint\"       },       \"textures\": {         \"default\": \"textures/items/wrench\",         \"enchanted\": \"textures/misc/enchanted_item_glint\"       },       \"geometry\": {         \"default\": \"geometry.wrench\"       },       \"animations\": {         \"hold_first_person\": \"animation.steve_head.hold_first_person\",         \"hold_third_person\": \"animation.steve_head.hold_third_person\"       },       \"scripts\": {         \"animate\": [           {             \"hold_first_person\": \"context.is_first_person == 1.0\"           },           {             \"hold_third_person\": \"context.is_first_person == 0.0\"           }         ]       },       \"render_controllers\": [\"controller.render.item_default\"]     }   } }   Wrench Resource Pack/models/entity/wrench.geo.json  JSON Copy {   \"format_version\": \"1.16.0\",   \"minecraft:geometry\": [     {       \"description\": {         \"identifier\": \"geometry.wrench\",         \"texture_width\": 32,         \"texture_height\": 32,         \"visible_bounds_width\": 3,         \"visible_bounds_height\": 4,         \"visible_bounds_offset\": [0, 1, 0]       },       \"bones\": [         {           \"name\": \"bb_main\",           \"pivot\": [0.1, 19, -6],           \"rotation\": [125, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-0.9, 9, -8], \"size\": [2, 16, 3], \"uv\": [0, 13]},             {\"origin\": [-0.9, 25, -11], \"size\": [2, 4, 9], \"uv\": [0, 0]},             {\"origin\": [-0.9, 29, -5], \"size\": [2, 2, 3], \"uv\": [13, 0]},             {\"origin\": [-0.9, 29, -11], \"size\": [2, 1, 3], \"uv\": [10, 13]},             {\"origin\": [-0.9, 30, -10], \"size\": [2, 1, 2], \"uv\": [10, 17]},             {\"origin\": [-0.9, 31, -5], \"size\": [2, 1, 3], \"uv\": [13, 5]},             {\"origin\": [-0.9, 32, -5], \"size\": [2, 1, 2], \"uv\": [0, 6]},             {\"origin\": [-0.9, 31, -9], \"size\": [2, 1, 1], \"uv\": [17, 19]},             {\"origin\": [-0.9, 33, -5], \"size\": [2, 1, 1], \"uv\": [16, 17]},             {\"origin\": [-0.9, 24, -5], \"size\": [2, 1, 2], \"uv\": [0, 3]},             {\"origin\": [-0.9, 24, -10], \"size\": [2, 1, 2], \"uv\": [0, 0]},             {\"origin\": [-0.9, 23, -5], \"size\": [2, 1, 1], \"uv\": [17, 13]},             {\"origin\": [-0.9, 23, -9], \"size\": [2, 1, 1], \"uv\": [7, 13]}           ]         }       ]     }   ] }   Wrench Resource Pack/textures/items  Here are the image files to use for the wrench icon and for the wrench itself.  Here is the wrench icon:  Here is the wrench texture:  Wrench Resource Pack/textures/item_texture.json  JSON Copy {   \"resource_pack_name\": \"Wrench Resource Pack\",   \"texture_data\": {     \"demo:wrench\": {       \"textures\": \"textures/items/wrench_ico\"     }   } }   After you create the packs, go into Minecraft, and give yourself a wrench, it should look like this:  Crown  This is a crown created by customizing a helmet.  Crown Behavior Pack Copy items   crown.json manifest.json   Crown Behavior Pack/items/crown.json  JSON Copy {   \"format_version\": \"1.20.30\",   \"minecraft:item\": {     \"description\": {       \"identifier\": \"demo:crown\",       \"category\": \"Items\"     },     \"components\": {       \"minecraft:max_stack_size\": 1,       \"minecraft:icon\": {         \"texture\": \"demo:crown\"       },       \"minecraft:wearable\": {         \"dispensable\": true,         \"slot\": \"slot.armor.head\"       }     }   } }  Crown Resource Pack Copy attachables   crown.player.json models   entity     crown.geo.json textures   items     crown_ico.png     crown_minecraft.png   item_texture.json manifest.json   Crown Resource Pack/attachables/crown.player.json  JSON Copy {   \"format_version\": \"1.19.80\",   \"minecraft:attachable\": {     \"description\": {       \"identifier\": \"demo:crown_hat.player\",       \"item\": { \"demo:crown\": \"query.is_owner_identifier_any('minecraft:player')\" },       \"materials\": {         \"default\": \"armor\",         \"enchanted\": \"armor_enchanted\"       },       \"textures\": {         \"default\": \"textures/items/crown_minecraft\",         \"enchanted\": \"textures/misc/enchanted_item_glint\"       },       \"geometry\": {         \"default\": \"geometry.crown\"       },       \"scripts\": {         \"parent_setup\": \"variable.helmet_layer_visible = 0.0;\"       },       \"render_controllers\": [\"controller.render.armor\"]     }   } }   Crown Resource Pack/models/entity/crown.geo.json  This file creates the custom shape of the crown that the texture will be mapped on to.  JSON Copy {   \"format_version\": \"1.16.0\",   \"minecraft:geometry\": [     {       \"description\": {         \"identifier\": \"geometry.crown\",         \"texture_width\": 32,         \"texture_height\": 32,         \"visible_bounds_width\": 2,         \"visible_bounds_height\": 3.5,         \"visible_bounds_offset\": [0, 1.25, 0]       },       \"bones\": [         {           \"name\": \"Crownbase\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-3, 31, -6.4], \"size\": [6, 3, 2], \"uv\": [1, 0]},             {\"origin\": [-5, 31, -6.4], \"size\": [6, 3, 2], \"pivot\": [-1, 31, -1.4], \"rotation\": [0, 90, 0], \"uv\": [0, 0]},             {\"origin\": [-3, 31, 1.6], \"size\": [6, 3, 2], \"pivot\": [1, 31, -1.4], \"rotation\": [0, 90, 0], \"uv\": [0, 0]},             {\"origin\": [-3, 31, 4.6], \"size\": [6, 3, 2], \"uv\": [1, 0]},             {\"origin\": [3, 31, -5.4], \"size\": [2, 3, 2], \"uv\": [24, 0]},             {\"origin\": [3, 31, 2.6], \"size\": [2, 3, 2], \"uv\": [22, 23]},             {               \"origin\": [-5, 31, -5.4],               \"size\": [2, 3, 2],               \"uv\": {                 \"north\": {\"uv\": [18, 22], \"uv_size\": [2, 3]},                 \"east\": {\"uv\": [16, 22], \"uv_size\": [2, 3]},                 \"south\": {\"uv\": [22, 22], \"uv_size\": [2, 3]},                 \"west\": {\"uv\": [20, 22], \"uv_size\": [2, 3]},                 \"up\": {\"uv\": [18, 20], \"uv_size\": [2, 2]},                 \"down\": {\"uv\": [20, 22], \"uv_size\": [2, -2]}               }             },             {\"origin\": [-5, 31, 2.6], \"size\": [2, 3, 2], \"uv\": [20, 10]}           ]         },         {           \"name\": \"crownprongs\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-5, 34, -5.4], \"size\": [2, 3, 2], \"uv\": [8, 20]},             {\"origin\": [3, 34, 2.6], \"size\": [2, 3, 2], \"uv\": [20, 5]},             {\"origin\": [3, 34, -5.4], \"size\": [2, 3, 2], \"uv\": [0, 20]},             {\"origin\": [-5, 34, 2.6], \"size\": [2, 3, 2], \"uv\": [16, 15]}           ]         },         {           \"name\": \"crownextraprongs\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-1, 34, -6.4], \"size\": [2, 3, 2], \"uv\": [8, 15]},             {\"origin\": [-6, 34, -1.4], \"size\": [2, 3, 2], \"uv\": [0, 15]},             {\"origin\": [-1, 34, 4.6], \"size\": [2, 3, 2], \"uv\": [12, 10]},             {\"origin\": [4, 34, -1.4], \"size\": [2, 3, 2], \"uv\": [12, 5]}           ]         },         {           \"name\": \"crownjewels\",           \"pivot\": [0, 0, 0],           \"binding\": \"q.item_slot_to_bone_name(context.item_slot)\",           \"cubes\": [             {\"origin\": [-7, 32, -1.4], \"size\": [1, 1, 2], \"uv\": [6, 25]},             {\"origin\": [5, 32, -2.4], \"size\": [1, 1, 2], \"pivot\": [0, 31, -1.4], \"rotation\": [0, 90, 0], \"uv\": [0, 25]},             {\"origin\": [-6, 32, 0.6], \"size\": [1, 1, 2], \"pivot\": [0, 31, 1.6], \"rotation\": [0, 90, 0], \"uv\": [22, 18]},             {\"origin\": [6, 32, -1.4], \"size\": [1, 1, 2], \"uv\": [24, 15]}           ]         }       ]     }   ] }   Crown Resource Pack/textures/items  Here are the image files to download and use for the crown icon and the crown texture itself.  Here is the crown icon:  Here is the crown texture:  Crown Resource Pack/textures/item_texture.json  JSON Copy {   \"resource_pack_name\": \"crown_resource_pack\",   \"texture_data\": {     \"demo:crown\": {       \"textures\": \"textures/items/crown\"     }   } }  Custom Crown Result  After you create the packs, go into Minecraft, give yourself a crown, and put it on, you should look like this:  Custom Chestplate with Vanilla Armor Trim  If you create a custom chestplate, either by hand or through using the Minecraft Item Wizard, you can have it support all the Armor Trims available as of release 1.20.70. You can modify the trim patterns to better fit your custom armor too!  To use armor trim on your custom armor, you need to set your format versions on the item and attachable to a minimum of 1.20.60.  Custom Chestplate with Vanilla Armor Trim Behavior Pack Copy items   custom_chestplate.item.json manifest.json   Chestplate Behavior Pack/items/custom_chestplate.item.json  JSON Copy {  \"format_version\": \"1.20.60\",    \"minecraft:item\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"menu_category\": {          \"category\": \"equipment\",          \"group\": \"itemGroup.name.chestplate\"        }     },     \"components\": {        \"minecraft:max_stack_size\": 1,        \"minecraft:icon\": {          \"textures\": {            \"default\": \"custom_chestplate\" }        },        \"minecraft:wearable\": {          \"protection\": 10,          \"slot\": \"slot.armor.chest\"        },        \"minecraft:durability\": {          \"damage_chance\": {            \"min\": 10,            \"max\": 50        },          \"max_durability\": 1560        },        \"minecraft:repairable\": {          \"repair_items\": [            {              \"items\": [\"pink_dye\"],              \"repair_amount\": 390            }          ]        },        \"minecraft:tags\": {          \"tags\": [            \"minecraft:is_armor\",            \"minecraft:trimmable_armors\"          ]        }      }    }  }   Chestplate Resource Pack  Copy attachables   custom_chestplate.attachable.json models   entity     custom_chestplate.geo.json textures   items     custom_chestplate_ico.png     custom_chestplate.png   item_texture.json manifest.json   Chestplate Resource Pack/attachables/custom_chestplate.attachable.json  This file defines which geometry will appear for the chestplate, as well as the armor trim palette that will be used and any adjusted trim patterns.  JSON Copy {   \"format_version\": \"1.20.60\",    \"minecraft:attachable\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"render_controllers\": [\"controller.render.armor\"],        \"materials\": {          \"default\": \"entity_alphatest\",          \"enchanted\": \"entity_alphatest_glint\"        },        \"textures\": {          \"default\": \"textures/entity/attachable/custom_chestplate\",         \"enchanted\": \"textures/misc/enchanted_item_glint\",          \"wild_trim\": \"textures/models/armor/custom_wild\",          \"iron_palette\": \"textures/trims/color_palettes/diamond_darker\"       },        \"geometry\": {          \"default\": \"geometry.custom_chestplate\"       }     }   } }   You can add any of the existing vanilla armor trim patterns to the textures section to supply adjusted trim textures to your new armor.  Chestplate Resource Pack/models/entity/custom_chestplate.geo.json  This file creates the custom shape of the chestplate that the texture and armor trim will be mapped on to.  JSON Copy {   \"format_version\": \"1.16.0\",    \"minecraft:geometry\": [      {        \"description\": {          \"identifier\": \"geometry.custom_chestplate\",          \"texture_width\": 32,          \"texture_height\": 32,          \"visible_bounds_width\": 3,          \"visible_bounds_height\": 2.5,          \"visible_bounds_offset\": [0, 0.75, 0]        },        \"bones\": [          {            \"name\": \"body\",            \"pivot\": [0, 14, 0]          },          {            \"name\": \"chestplate\",            \"parent\": \"body\",            \"pivot\": [0, 0, 0],            \"binding\": \"'body'\",            \"cubes\": [              {\"origin\": [-4, 2, -2], \"size\": [8, 12, 4], \"inflate\": 1.01, \"uv\": [0, 0]}            ]          },          {            \"name\": \"arm_right\",            \"pivot\": [-5, 12, 0]          },         {            \"name\": \"arm_plate_right\",            \"parent\": \"arm_right\",            \"pivot\": [-5, 12, 0],            \"binding\": \"'rightarm'\",            \"cubes\": [              {\"origin\": [-8, 2, -2], \"size\": [4, 12, 4], \"inflate\": 1, \"uv\": [0, 16]}            ]          },          {            \"name\": \"arm_left\",            \"pivot\": [5, 12, 0]          },          {            \"name\": \"arm_plate_left\",            \"parent\": \"arm_left\",            \"pivot\": [5, 12, 0],            \"binding\": \"'leftarm'\",            \"cubes\": [              {\"origin\": [4, 2, -2], \"size\": [4, 12, 4], \"inflate\": 1, \"uv\": [0, 16], \"mirror\": true}            ]          }        ]      }    ]  }  Chestplate Resource Pack/textures/items  Here are the image files to download and use for the custom chestplate icon and the geometry's texture itself.  Here is the chestplate icon:  Here is the chestplate texture:  Here is the modified \"wild\" trim pattern:  Chestplate Resource Pack/textures/item_texture.json  JSON Copy {     \"texture_data\": {         \"custom_chestplate\": {             \"textures\": \"textures/items/custom_chestplate.png\"         }     } }  Custom Chestplate Result  After you create the packs, go into Minecraft, give yourself the custom chestplate, and put it on. You should look like this:  Give yourself the wild armor trim template and combine your chestplate with the wild template at a smithing table, and put it back on, you should now look like this:  If your chestplate instead looks like this...  ... then check the paths to your textures in the item_texture.json and custom_chestplate.attachable.json files. If there are any spelling errors or textures in incorrect folders, the geometry will display the \"missing texture pattern\" on your armor.  Dyeable Custom Items  Custom items can now be dyed in cauldrons. To use the dyeable component the format version on the item and the attachable needs to be 1.21.30 or higher.  This section of the tutorial assumes that you have successfully completed the previous section: Custom Chestplate with Vanilla Armor Trim.  Start by creating a copy of your Custom Chestplate with Vanilla Armor Trim add-on packs.  Dyable Custom Chestplate Behavior Pack  Chestplate Behavior Pack/textures/item_texture.json  Inside the behavior pack, open textures/item_texture.json and do this:  Edit the format version to be 1.21.30.  Edit minecraft:icon:  JSON Copy \"minecraft:icon\": {   \"textures\": {     \"default\": \"custom_chestplate_icon\",     \"dyed\": \"custom_chestplate_icon_gray\"     } },  Add minecraft:dyeable. JSON Copy \"minecraft:dyeable\": {   \"default_color\":  \"#175882\" }   ... So that the final version of item_texture.json looks like this:  JSON Copy {  \"format_version\": \"1.21.30\",    \"minecraft:item\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"menu_category\": {          \"category\": \"equipment\",          \"group\": \"itemGroup.name.chestplate\"        }     },     \"components\": {        \"minecraft:max_stack_size\": 1,        \"minecraft:icon\": {         \"textures\": {           \"default\": \"custom_chestplate_icon\",           \"dyed\": \"custom_chestplate_icon_gray\"         }       },       \"minecraft:wearable\": {         \"protection\": 10,          \"slot\": \"slot.armor.chest\"        },        \"minecraft:durability\": {          \"damage_chance\": {            \"min\": 10,            \"max\": 50        },          \"max_durability\": 1560        },        \"minecraft:repairable\": {          \"repair_items\": [            {              \"items\": [\"pink_dye\"],              \"repair_amount\": 390            }          ]        },        \"minecraft:tags\": {          \"tags\": [            \"minecraft:is_armor\",            \"minecraft:trimmable_armors\"          ]        },       \"minecraft:dyeable\": {         \"default_color\":  \"#175882\"       }     }    }  }   If you do not want a default color you can leave the \"default_color\" off and the texture will be the same as if you did not have the component until it is dyed.  For the icon to be dyed correctly. you need to provide a grayscale .tga version of your icon image. To do this, make a copy of the .png file, change the extension to .tga, and then change the configuration to grayscale.  Hint: You can use the icon graphics from the previous section.  Dyeable Custom Chestplate Resource Pack:  Copy  attachables    custom_chestplate.attachable.json  models    entity      custom_chestplate.geo.json  render_controllers (NEW)    custom_chestplate.render_controllers.json (NEW)  textures    items      custom_chestplate_ico.png      custom_chestplate.png      custom_chestplate_grayscale.tga      custom_chestplate_icon_grayscale.tga    item_texture.json  manifest.json   You edit Pack/attachables/custom_chestplate.attachable.json like this...  Edit the format version to be 1.21.30.  Edit \"render_controllers\" like this...  JSON Copy \"render_controllers\": [ \"controller.render.custom_chestplate\" ],  Edit materials to be: JSON Copy \"materials\": {   \"default\": \"armor\",   \"dyed\": \"entity_alphatest_change_color\" },  Edit textures to be: JSON Copy \"textures\": {   \"default\": \"textures/items/custom_chestplate.png\",   \"dyed\": \"textures/items/custom_chestplate_grayscale.tga\" },  Add scripts: JSON Copy \"scripts\": {   \"pre_animation\": [     \"variable.is_dyed = query.armor_color_slot(1, 0) != 0.0 || query.armor_color_slot(1, 1) != 0.0 || query.armor_color_slot(1, 2) != 0.0 || query.armor_color_slot(1, 3) != 0.0;\"   ] }   So that the final version of custom_chestplate.attachable.json looks like this:  JSON Copy {   \"format_version\": \"1.20.60\",    \"minecraft:attachable\": {      \"description\": {        \"identifier\": \"demo:custom_chestplate\",        \"render_controllers\": [\"controller.render.armor\"],        \"materials\": {          \"default\": \"armor\",         \"dyed\": \"entity_alphatest_change_color\"       },        \"textures\": {          \"default\": \"textures/items/custom_chestplate.png\",         \"dyed\": \"textures/items/custom_chestplate_grayscale.tga\"       },        \"geometry\": {          \"default\": \"geometry.custom_chestplate\"       },       \"scripts\": {         \"pre_animation\": [           \"variable.is_dyed = query.armor_color_slot(1, 0) != 0.0 || query.armor_color_slot(1, 1) != 0.0 || query.armor_color_slot(1, 2) != 0.0 || query.armor_color_slot(1, 3) != 0.0;\"         ]       }     }   } }  custom_chestplate.render_controllers.json  In the resource pack, add the render_controllers directory and put a new file in there named: custom_chestplate.render_controllers.json.  Copy and paste this content in there:  JSON Copy {   \"format_version\": \"1.8.0\",   \"render_controllers\": {     \"controller.render.custom_chestplate\": {       \"geometry\": \"Geometry.default\",       \"materials\": [ { \"*\": \"variable.is_dyed ? Material.dyed : Material.default\" } ],       \"textures\": [         \"variable.is_dyed ? Texture.dyed : Texture.default\"       ]     }   } }   Chestplate Resource Pack/items/item_texture  JSON Copy {   \"texture_data\": {     \"custom_chestplate\": {       \"textures\": \"textures/items/custom_chestplate.png\"     },     \"custom_chestplate_icon_gray\": {       \"textures\": \"textures/items/custom_chestplate_icon_grayscale.tga\"     }   } }   After you have edited and saved all of the files, you should be able to dye your custom chestplate in a cauldron full of dye and it will look like this:  To learn more about the dyeable item component, take a look at the minecraft:dyeable reference page.  Next Steps  After you create the custom item packs and get them to work, you could take a look at the item components and try adding some of these to your own custom items.  Or, you could go through the Custom Item Wizard and compare the add-on packs created by the Wizard to the ones you created on your own.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/skinpack?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Skin Packs 04/24/2024  It takes only a few files to create a custom player skin in Minecraft.  These are the usual ones found in most add-on packs:  en_US.lang - This file is lives in the texts folder and the name might be different, depending on your language preferences manifest.json  And these are the files specific to a skin pack:  <skin_graphic>.png - The image that will be mapped into the player. There are some of tools out there to help with this, but for now, we are just going to use a basic graphic-editing program like Paint.net. skins.json - JSON file containing the metadata about the skins in your skin pack  If you put all these files together and make sure everything is complete and correct, then you will have created your own custom skin.  As always, there are lots and lots ... and lots... of tools and resources out in the world about skin packs made by creators like you. This guide is intended to give you an overview of the basics so that you will have a point of reference to learn more.  In this tutorial, you will learn:  That it's possible to change your skin in Minecraft: Bedrock Edition. How to customize a very simple template. Sample Skin Pack  There is a sample skin pack available at the Microsoft samples GitHub. It may be used to understand the structure of skin packs and to check your work after the tutorial.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Getting Started with Add-On Development Building the Skin Pack  For Minecraft to find and use your skin pack files, you have to set up the folders and files in a particular structure. This tutorial will guide you through creating the most basic folder and file structure of a pack that can be imported and used in Minecraft.  Start by creating a folder and naming it something like My_SKIN_Pack. Then, add the following files:  manifest.json  Create a text file and name it manifest.json.  Paste this content in there and put in the UUIDs.  JSON Copy {   \"format_version\": 2,   \"header\": {       \"name\": \"Tutorial Skin Pack\",       \"uuid\": \"<FIRST GENERATED UUID>\",       \"version\": [1, 0, 0]   },   \"modules\": [     {       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\",       \"version\": [1, 0, 0]     }   ] }  Save and close the file. texts/en_US.lang  Create a folder and name it texts.  Create a text file in there and name it for your preferred language, such as en_US.lang.  Paste in this text:  Copy skin.sample.skin_example=Sample Skin skinpack.sample=Tutorial Skin Pack skinpack.sample.by=YourNameHere  Save the file. <skin_example>.png  Download this file to use as an example.  skins.json  Create a text file named skins.json and paste this text in there:  JSON Copy {   \"skins\": [     {       \"localization_name\": \"Sample Skin\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_example.png\",       \"type\": \"free\"     }   ],   \"serialize_name\": \"sample\",   \"localization_name\": \"sample\" }   The serialize_name and localization_name values are used in the .lang file in the paths starting with skin. or skinpack.  Deploying the Skin Pack  To use your new skin pack, create a .zip file of the contents and save it with the .mcpack extension.  Double-click the .mcpack to open it. Minecraft will launch and import the files automatically into the skin_packs folder inside your com.mojang directory.  You should see messages stating that the import has started and that the skin pack was imported successfully.  After Minecraft loads, click the Dressing Room button.  If you get messages asking you to make a choice between Character Creator or Classic Skin, choose Classic Skin.  Choose the little, green Featured Skins button with the clothes hanger on it, select your skin, then click Equip.  You have a new look!  Troubleshooting  You can always download the sample skinpack and compare the contents with your files.  If Minecraft doesn't recognize your skin, then go to the main Minecraft Settings page, find the General tab, and make sure \"Only Allow Trusted Skins\" is toggled off.  What's Next?  Now that you know more about how skin packs work, maybe you should learn more about how the other add-on packs work.  Comprehensive Add-on Pack Contents  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/skinpack?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Skin Packs 04/24/2024  It takes only a few files to create a custom player skin in Minecraft.  These are the usual ones found in most add-on packs:  en_US.lang - This file is lives in the texts folder and the name might be different, depending on your language preferences manifest.json  And these are the files specific to a skin pack:  <skin_graphic>.png - The image that will be mapped into the player. There are some of tools out there to help with this, but for now, we are just going to use a basic graphic-editing program like Paint.net. skins.json - JSON file containing the metadata about the skins in your skin pack  If you put all these files together and make sure everything is complete and correct, then you will have created your own custom skin.  As always, there are lots and lots ... and lots... of tools and resources out in the world about skin packs made by creators like you. This guide is intended to give you an overview of the basics so that you will have a point of reference to learn more.  In this tutorial, you will learn:  That it's possible to change your skin in Minecraft: Bedrock Edition. How to customize a very simple template. Sample Skin Pack  There is a sample skin pack available at the Microsoft samples GitHub. It may be used to understand the structure of skin packs and to check your work after the tutorial.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Getting Started with Add-On Development Building the Skin Pack  For Minecraft to find and use your skin pack files, you have to set up the folders and files in a particular structure. This tutorial will guide you through creating the most basic folder and file structure of a pack that can be imported and used in Minecraft.  Start by creating a folder and naming it something like My_SKIN_Pack. Then, add the following files:  manifest.json  Create a text file and name it manifest.json.  Paste this content in there and put in the UUIDs.  JSON Copy {   \"format_version\": 2,   \"header\": {       \"name\": \"Tutorial Skin Pack\",       \"uuid\": \"<FIRST GENERATED UUID>\",       \"version\": [1, 0, 0]   },   \"modules\": [     {       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\",       \"version\": [1, 0, 0]     }   ] }  Save and close the file. texts/en_US.lang  Create a folder and name it texts.  Create a text file in there and name it for your preferred language, such as en_US.lang.  Paste in this text:  Copy skin.sample.skin_example=Sample Skin skinpack.sample=Tutorial Skin Pack skinpack.sample.by=YourNameHere  Save the file. <skin_example>.png  Download this file to use as an example.  skins.json  Create a text file named skins.json and paste this text in there:  JSON Copy {   \"skins\": [     {       \"localization_name\": \"Sample Skin\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_example.png\",       \"type\": \"free\"     }   ],   \"serialize_name\": \"sample\",   \"localization_name\": \"sample\" }   The serialize_name and localization_name values are used in the .lang file in the paths starting with skin. or skinpack.  Deploying the Skin Pack  To use your new skin pack, create a .zip file of the contents and save it with the .mcpack extension.  Double-click the .mcpack to open it. Minecraft will launch and import the files automatically into the skin_packs folder inside your com.mojang directory.  You should see messages stating that the import has started and that the skin pack was imported successfully.  After Minecraft loads, click the Dressing Room button.  If you get messages asking you to make a choice between Character Creator or Classic Skin, choose Classic Skin.  Choose the little, green Featured Skins button with the clothes hanger on it, select your skin, then click Equip.  You have a new look!  Troubleshooting  You can always download the sample skinpack and compare the contents with your files.  If Minecraft doesn't recognize your skin, then go to the main Minecraft Settings page, find the General tab, and make sure \"Only Allow Trusted Skins\" is toggled off.  What's Next?  Now that you know more about how skin packs work, maybe you should learn more about how the other add-on packs work.  Comprehensive Add-on Pack Contents  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/creatorcamp?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Bedrock Creator Camp 05/08/2025  Howdy, campers! We recently held a two-day live event that covered everything you need to know about building on Minecraft: Bedrock Edition. Wasn't able to make it to the live stream? No problem! You can watch the stream on the Minecraft Creator Channel on YouTube.  Creator Camp is split into two days: a tutorial day, featuring all of the introductory information you'll need to get started, including an overview of tools, plus a set of technical tutorials. On creator day, you can hear from the experts who are building content on Minecraft Bedrock Edition as well as the Minecraft Creator team on the roadmap and major themes of how the platform and tools are evolving. Plus Q&A and Roundtables!  Tutorial Day  Creator Camp Day 1 on YouTube  Tutorial Day will feature overviews and how to get started in creating with Minecraft Bedrock Edition. Whether you're just getting started or have more in-depth questions, come learn the fundamentals of how to build with Minecraft!  Topics:  The Minecraft Bedrock Landscape Entities: Create your first entity Using Minecraft Editor Working with Custom Blocks World Generation Features Items, Custom Components, and Scripting Creator Day  Creator Camp Day 2 on YouTube  See more about the roadmap for Minecraft Bedrock Edition - along with interviews and sessions from Creators from the Minecraft Marketplace.  Topics  Bedrock Roadmap for Creators Razzleberries: From Cute to Hit Oreville Studios: Actions & Stuff Roadmap for Entities, Items, and Blocks Jigarbov: Add-On Ecosystems Roadmap for Biomes and more JWolf Creations Minecraft Creator Team Q&A Live Creator Roundtable Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/creatorcamp?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Bedrock Creator Camp 05/08/2025  Howdy, campers! We recently held a two-day live event that covered everything you need to know about building on Minecraft: Bedrock Edition. Wasn't able to make it to the live stream? No problem! You can watch the stream on the Minecraft Creator Channel on YouTube.  Creator Camp is split into two days: a tutorial day, featuring all of the introductory information you'll need to get started, including an overview of tools, plus a set of technical tutorials. On creator day, you can hear from the experts who are building content on Minecraft Bedrock Edition as well as the Minecraft Creator team on the roadmap and major themes of how the platform and tools are evolving. Plus Q&A and Roundtables!  Tutorial Day  Creator Camp Day 1 on YouTube  Tutorial Day will feature overviews and how to get started in creating with Minecraft Bedrock Edition. Whether you're just getting started or have more in-depth questions, come learn the fundamentals of how to build with Minecraft!  Topics:  The Minecraft Bedrock Landscape Entities: Create your first entity Using Minecraft Editor Working with Custom Blocks World Generation Features Items, Custom Components, and Scripting Creator Day  Creator Camp Day 2 on YouTube  See more about the roadmap for Minecraft Bedrock Edition - along with interviews and sessions from Creators from the Minecraft Marketplace.  Topics  Bedrock Roadmap for Creators Razzleberries: From Cute to Hit Oreville Studios: Actions & Stuff Roadmap for Entities, Items, and Blocks Jigarbov: Add-On Ecosystems Roadmap for Biomes and more JWolf Creations Minecraft Creator Team Q&A Live Creator Roundtable Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/comprehensivepackcontents?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Comprehensive List of Add-on Pack Contents 02/12/2025  Have you ever wondered what files and folders the most comprehensive behavior, resource, and skin packs would contain? If so, this list is for you.  Minecraft Bedrock Edition can only use add-on pack file contents if the file is the correct type (like .json, .png, .fsb), and if it is stored in a folder with a particular name, and if that folder is in the correct location.  Behavior packs and resource packs can vary wildly depending on what the creator who made them wants to create. It can also be a design choice to group entities or items in separate folders, rather than storing their .json files all together.  For example, if the creator does not want to use functions, then there is no function section and no .mcfunction files. But if they do want to use a function, then this list helps by showing that the function folder goes in the behavior pack, that the folder must be named function (rather than \"functions\"), and that only .mcfunction files can go in that folder.  Some features need a folder to contain the resources and a related file like sounds.json.  The only required file in either type of pack is manifest.json.  Wherever possible, the sections are linked to related tutorials, overviews, or reference documents.  Comprehensive Behavior Pack  Here is an introduction to behavior packs.  animation_controllers <entity_name> <entity_name_animation_controller>.json <entity_controller>.json animations <entity_name> <entity_name_animations>.json <entity_name_animations>.json blocks <block_name>.json cameras presets <identifier>.json entities <entity_name> <entity_name_animation_controller>.json <entity_name>.json features <feature>.json feature_rules <feature_rule>.json [dialogue] <scene_dialogue> <scene>.json manifest.json functions <entity_name> <entity_name_function>.mcfunction tick.json item_catalog crafting_item_catalog.json items <item_name>.json loot_tables entities <entity_name>.json recipes <entity_recipe>.json spawn_rules <entity_spawn_rules>.json structures <structure_name>.mcstructure texts languages.json en_US.lang <language>.lang trading <villager_trades>.json manifest.json (required) pack_icon.png Comprehensive Resource Pack  Here is an introduction to resource packs.  animation_controllers <entity_animation_controllers>.json animations <entity.animation>.json attachables <attachable_entity_name>.json block_culling <block_culling>.json entity <entity_name> <entity_name>.json <entity_name>.json fogs <location_fog_setting>.json items <item_name>.json materials <entity>.material models <entity>.geo.json particles <item_name>.json render_controllers <entity_render_controllers>.json default.render_controllers.json sounds <location_type> <location1> <location*>.ogg <location2> <location*> <sound*>.fsb texts <language> font glyph_*.png en_US.lang textures <item_category> <item_name> <item_name>.png <item_name>.png blocks <custom_block>.png terrain_texture.json flipbook_textures.json ui <graphic>.png <graphic>.jpg <file>.json biomes_client.json - deprecated, see client biomes blocks.json manifest.json (required) pack_icon.png sounds.json Comprehensive Skin Pack  Here is an introduction to skin packs.  texts languages.json en_US.lang <skin_graphic>.png geometry.json manifest.json (required) skins.json Common Files manifest.json  This is the most important file in the pack. Without it, Minecraft will not know what to do with the rest of the content. Different packs' manifest files look similar, but there are some very important differences.  Take a look at these examples and notice the \"type: \" line in the \"modules\" section, if there is one.  behavior_pack/manifest.json  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Pack description\",     \"name\": \"My Behavior Pack\",     \"uuid\": \"<FIRST GENERATED UUID>\",     \"version\": [1, 0, 0],     \"min_engine_version\": [1, 16, 0]   },   \"modules\":     [       {         \"description\": \"Pack description\",           \"type\": \"data\",           \"uuid\": \"<SECOND GENERATED UUID>\",           \"version\": [1, 0, 0]       }     ] }   resource_pack.manifest.json  JSON Copy {  \"format_version\": 2,  \"header\": {    \"description\": \"Resource pack description\",    \"name\": \"My Resource Pack\",    \"uuid\": \"<FIRST GENERATED UUID>\",    \"version\": [1, 0, 0],    \"min_engine_version\": [1, 16, 0]   },  \"modules\": [    {      \"description\": \"Resource pack description\",      \"type\": \"resources\",      \"uuid\": \"<SECOND GENERATED UUID>\",      \"version\": [1, 0, 0]    }  ] }   skin_pack/manifest.json  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 1 }   world_template/manifest.json  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"world_template\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 2 }   dialogue/manifest.json taken from the NPC Dialogue page.  JSON Copy {   \"format_version\":\"1.17\",   \"minecraft:npc_dialogue\":{     \"scenes\":[      {         \"scene_tag\":\"ducky_intro\",         \"npc_name\":\"Ducky\",         \"text\":\"Hello new friend\",         \"on_open_commands\":[              \"/clear @p\"         ],         \"on_close_commands\":[             \"/say Farewell! \"         ],          \"buttons\":[             {               \"name\":\"Take Gold?\",               \"commands\":[                   \"/give @initiator gold_ingot\"                 ]             },             {                 \"name\":\"Wish Luck\",               \"commands\":[                  \"/say Good luck!\"                 ]              }         ]       }     ]   } }  .../texts/languages.json  This file tells Minecraft what languages your skin pack supports. Only English (en_US.lang) is required. If you want to support other languages you can make other xx_YY.lang files and then edit the languages.json file to tell the game you support them.  The following locales/languages are currently supported:  \"en_US\" \"de_DE\" \"ru_RU\" \"zh_CN\" \"fr_FR\" \"it_IT\" \"pt_BR\" \"fr_CA\" \"zh_TW\" \"es_MX\" \"es_ES\" \"pt_PT\" \"en_GB\" \"ko_KR\" \"ja_JP\" \"nl_NL\" \"bg_BG\" \"cs_CZ\" \"da_DK\" \"el_GR\" \"fi_FI\" \"hu_HU\" \"id_ID\" \"nb_NO\" \"pl_PL\" \"sk_SK\" \"sv_SE\" \"tr_TR\" \"uk_UA\" Template languages.json JSON Copy [   \"en_US\" ]  Sample Packs  To see examples of typical resource and behavior packs, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  What's Next?  Here are some more advanced add-on pack content information:  ScriptingGettingStarted  Creating New Entity Types  Entity JSON Documentation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/comprehensivepackcontents?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Comprehensive List of Add-on Pack Contents 02/12/2025  Have you ever wondered what files and folders the most comprehensive behavior, resource, and skin packs would contain? If so, this list is for you.  Minecraft Bedrock Edition can only use add-on pack file contents if the file is the correct type (like .json, .png, .fsb), and if it is stored in a folder with a particular name, and if that folder is in the correct location.  Behavior packs and resource packs can vary wildly depending on what the creator who made them wants to create. It can also be a design choice to group entities or items in separate folders, rather than storing their .json files all together.  For example, if the creator does not want to use functions, then there is no function section and no .mcfunction files. But if they do want to use a function, then this list helps by showing that the function folder goes in the behavior pack, that the folder must be named function (rather than \"functions\"), and that only .mcfunction files can go in that folder.  Some features need a folder to contain the resources and a related file like sounds.json.  The only required file in either type of pack is manifest.json.  Wherever possible, the sections are linked to related tutorials, overviews, or reference documents.  Comprehensive Behavior Pack  Here is an introduction to behavior packs.  animation_controllers <entity_name> <entity_name_animation_controller>.json <entity_controller>.json animations <entity_name> <entity_name_animations>.json <entity_name_animations>.json blocks <block_name>.json cameras presets <identifier>.json entities <entity_name> <entity_name_animation_controller>.json <entity_name>.json features <feature>.json feature_rules <feature_rule>.json [dialogue] <scene_dialogue> <scene>.json manifest.json functions <entity_name> <entity_name_function>.mcfunction tick.json item_catalog crafting_item_catalog.json items <item_name>.json loot_tables entities <entity_name>.json recipes <entity_recipe>.json spawn_rules <entity_spawn_rules>.json structures <structure_name>.mcstructure texts languages.json en_US.lang <language>.lang trading <villager_trades>.json manifest.json (required) pack_icon.png Comprehensive Resource Pack  Here is an introduction to resource packs.  animation_controllers <entity_animation_controllers>.json animations <entity.animation>.json attachables <attachable_entity_name>.json block_culling <block_culling>.json entity <entity_name> <entity_name>.json <entity_name>.json fogs <location_fog_setting>.json items <item_name>.json materials <entity>.material models <entity>.geo.json particles <item_name>.json render_controllers <entity_render_controllers>.json default.render_controllers.json sounds <location_type> <location1> <location*>.ogg <location2> <location*> <sound*>.fsb texts <language> font glyph_*.png en_US.lang textures <item_category> <item_name> <item_name>.png <item_name>.png blocks <custom_block>.png terrain_texture.json flipbook_textures.json ui <graphic>.png <graphic>.jpg <file>.json biomes_client.json - deprecated, see client biomes blocks.json manifest.json (required) pack_icon.png sounds.json Comprehensive Skin Pack  Here is an introduction to skin packs.  texts languages.json en_US.lang <skin_graphic>.png geometry.json manifest.json (required) skins.json Common Files manifest.json  This is the most important file in the pack. Without it, Minecraft will not know what to do with the rest of the content. Different packs' manifest files look similar, but there are some very important differences.  Take a look at these examples and notice the \"type: \" line in the \"modules\" section, if there is one.  behavior_pack/manifest.json  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Pack description\",     \"name\": \"My Behavior Pack\",     \"uuid\": \"<FIRST GENERATED UUID>\",     \"version\": [1, 0, 0],     \"min_engine_version\": [1, 16, 0]   },   \"modules\":     [       {         \"description\": \"Pack description\",           \"type\": \"data\",           \"uuid\": \"<SECOND GENERATED UUID>\",           \"version\": [1, 0, 0]       }     ] }   resource_pack.manifest.json  JSON Copy {  \"format_version\": 2,  \"header\": {    \"description\": \"Resource pack description\",    \"name\": \"My Resource Pack\",    \"uuid\": \"<FIRST GENERATED UUID>\",    \"version\": [1, 0, 0],    \"min_engine_version\": [1, 16, 0]   },  \"modules\": [    {      \"description\": \"Resource pack description\",      \"type\": \"resources\",      \"uuid\": \"<SECOND GENERATED UUID>\",      \"version\": [1, 0, 0]    }  ] }   skin_pack/manifest.json  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 1 }   world_template/manifest.json  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"world_template\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 2 }   dialogue/manifest.json taken from the NPC Dialogue page.  JSON Copy {   \"format_version\":\"1.17\",   \"minecraft:npc_dialogue\":{     \"scenes\":[      {         \"scene_tag\":\"ducky_intro\",         \"npc_name\":\"Ducky\",         \"text\":\"Hello new friend\",         \"on_open_commands\":[              \"/clear @p\"         ],         \"on_close_commands\":[             \"/say Farewell! \"         ],          \"buttons\":[             {               \"name\":\"Take Gold?\",               \"commands\":[                   \"/give @initiator gold_ingot\"                 ]             },             {                 \"name\":\"Wish Luck\",               \"commands\":[                  \"/say Good luck!\"                 ]              }         ]       }     ]   } }  .../texts/languages.json  This file tells Minecraft what languages your skin pack supports. Only English (en_US.lang) is required. If you want to support other languages you can make other xx_YY.lang files and then edit the languages.json file to tell the game you support them.  The following locales/languages are currently supported:  \"en_US\" \"de_DE\" \"ru_RU\" \"zh_CN\" \"fr_FR\" \"it_IT\" \"pt_BR\" \"fr_CA\" \"zh_TW\" \"es_MX\" \"es_ES\" \"pt_PT\" \"en_GB\" \"ko_KR\" \"ja_JP\" \"nl_NL\" \"bg_BG\" \"cs_CZ\" \"da_DK\" \"el_GR\" \"fi_FI\" \"hu_HU\" \"id_ID\" \"nb_NO\" \"pl_PL\" \"sk_SK\" \"sv_SE\" \"tr_TR\" \"uk_UA\" Template languages.json JSON Copy [   \"en_US\" ]  Sample Packs  To see examples of typical resource and behavior packs, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  What's Next?  Here are some more advanced add-on pack content information:  ScriptingGettingStarted  Creating New Entity Types  Entity JSON Documentation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/differencesbetweenbedrockandjava?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Differences Between Minecraft: Bedrock Edition and Minecraft: Java Edition 05/21/2025  We love all forms of Minecraft equally, but loving them equally doesn't mean they're identical. As a creator, it's important to know as much as you can about the differences between the flavors of Minecraft. So, we're going to review some of the major differences between Minecraft: Java Edition and Minecraft: Bedrock Edition, and what they may mean for you as a creator.  A brief history of Minecraft  Minecraft: Java Edition is the current iteration of the original version, released in 2009 (simply as \"Minecraft\"). Minecraft: Bedrock Edition started as Minecraft: Pocket Edition with an alpha release in 2011, and remained in alpha until its full release in 2016. In 2017, with version 1.2.0, Pocket Edition officially became Minecraft: Bedrock Edition, unifying the various non-Java releases across platforms. Currently, both versions are active and have broad, passionate audiences. For clarity, we'll refer to the versions as \"Java\" and \"Bedrock\" respectively.  World format  A major difference between Java and Bedrock is the world format. Bedrock uses the LevelDB format for world storage, while Java uses the Anvil format. Due to this, most third-party tools created for editing a world will only work in the version for which it was created.  The two versions also use a fairly different block format. Java has flattened its block format using a unique string for individual blocks, and stores the state of that block separately. Similarly, Bedrock uses a string-based system with block states, while some blocks are grouped together by data value. Because of this, blocks are named differently between the versions. For example, granite is defined as stone 1 in Bedrock, while in Java it's referred to as granite.  Commands and redstone  Bedrock and Java have different structures and implementation of commands. Bedrock's command structure is similar to the system used in versions of Java up to 1.13. It also uses a component-based system for commands instead of raw JSON strings. Instead of using JSON strings to customize entities, you can summon an entity with an event to fire and name it in a single command.  There are also differences per version in the way that redstone works, and while the majority of redstone circuits work well between versions, more complex circuits may not work as well in Bedrock. This is because Bedrock doesn't support quasi-connectivity, while Java does. Systems that use mechanics such as Block Update Detector (BUD) switches won't work the same way in Bedrock. Pistons require one tick to retract, and won't leave blocks behind if given a one-tick pulse. Additionally, the way updates happen is slightly different.  Resource packs  The idea behind resource packs is the same in both editions: change how various aspects of the game look. The capabilities and layout of resource packs are very different depending on the version, however. To get into the details of how things work in Bedrock, take a look at our Introduction to Resource Packs (as an added bonus, you'll learn how to change the look of grass blocks in your world!).  Behavior packs  Bedrock's behavior packs are equivalent to Java's data packs. While they share some similarities, the differences are significant. For example:  To animate textures, Bedrock uses a single file called flipbook_textures.json, while Java uses individual .mcmeta files for each texture. Java can create custom fonts and GLSL shaders, while Bedrock cannot. Bedrock can create custom particles and fogs, while Java cannot. Controls  Currently, both versions of Minecraft support mouse and keyboard controls, but only Bedrock has controller support. Additionally, depending on the hardware used to access Bedrock, there is a significant chance that users may be using touch controls. This becomes an important consideration when determining which type of content to create for each version.  Crossplay  Java is currently available on Windows, Mac, and Linux PCs, meaning that any content you create will be played by users on a computer. Bedrock is available for Windows PCs, consoles, and mobile devices. This means that players in the same world may be having vastly different experiences depending upon the devices they are using. For additional guidance on designing your content for users on varied devices, check out Designing Gameplay for Various Devices.  Next steps  If you're entering the world of Bedrock creation, your next stop should be our add-on concept articles. Here are some excellent follow-up articles for your review:  Getting Started with Add-Ons Comprehensive List of Add-On Pack Contents  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/differencesbetweenbedrockandjava?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Differences Between Minecraft: Bedrock Edition and Minecraft: Java Edition 05/21/2025  We love all forms of Minecraft equally, but loving them equally doesn't mean they're identical. As a creator, it's important to know as much as you can about the differences between the flavors of Minecraft. So, we're going to review some of the major differences between Minecraft: Java Edition and Minecraft: Bedrock Edition, and what they may mean for you as a creator.  A brief history of Minecraft  Minecraft: Java Edition is the current iteration of the original version, released in 2009 (simply as \"Minecraft\"). Minecraft: Bedrock Edition started as Minecraft: Pocket Edition with an alpha release in 2011, and remained in alpha until its full release in 2016. In 2017, with version 1.2.0, Pocket Edition officially became Minecraft: Bedrock Edition, unifying the various non-Java releases across platforms. Currently, both versions are active and have broad, passionate audiences. For clarity, we'll refer to the versions as \"Java\" and \"Bedrock\" respectively.  World format  A major difference between Java and Bedrock is the world format. Bedrock uses the LevelDB format for world storage, while Java uses the Anvil format. Due to this, most third-party tools created for editing a world will only work in the version for which it was created.  The two versions also use a fairly different block format. Java has flattened its block format using a unique string for individual blocks, and stores the state of that block separately. Similarly, Bedrock uses a string-based system with block states, while some blocks are grouped together by data value. Because of this, blocks are named differently between the versions. For example, granite is defined as stone 1 in Bedrock, while in Java it's referred to as granite.  Commands and redstone  Bedrock and Java have different structures and implementation of commands. Bedrock's command structure is similar to the system used in versions of Java up to 1.13. It also uses a component-based system for commands instead of raw JSON strings. Instead of using JSON strings to customize entities, you can summon an entity with an event to fire and name it in a single command.  There are also differences per version in the way that redstone works, and while the majority of redstone circuits work well between versions, more complex circuits may not work as well in Bedrock. This is because Bedrock doesn't support quasi-connectivity, while Java does. Systems that use mechanics such as Block Update Detector (BUD) switches won't work the same way in Bedrock. Pistons require one tick to retract, and won't leave blocks behind if given a one-tick pulse. Additionally, the way updates happen is slightly different.  Resource packs  The idea behind resource packs is the same in both editions: change how various aspects of the game look. The capabilities and layout of resource packs are very different depending on the version, however. To get into the details of how things work in Bedrock, take a look at our Introduction to Resource Packs (as an added bonus, you'll learn how to change the look of grass blocks in your world!).  Behavior packs  Bedrock's behavior packs are equivalent to Java's data packs. While they share some similarities, the differences are significant. For example:  To animate textures, Bedrock uses a single file called flipbook_textures.json, while Java uses individual .mcmeta files for each texture. Java can create custom fonts and GLSL shaders, while Bedrock cannot. Bedrock can create custom particles and fogs, while Java cannot. Controls  Currently, both versions of Minecraft support mouse and keyboard controls, but only Bedrock has controller support. Additionally, depending on the hardware used to access Bedrock, there is a significant chance that users may be using touch controls. This becomes an important consideration when determining which type of content to create for each version.  Crossplay  Java is currently available on Windows, Mac, and Linux PCs, meaning that any content you create will be played by users on a computer. Bedrock is available for Windows PCs, consoles, and mobile devices. This means that players in the same world may be having vastly different experiences depending upon the devices they are using. For additional guidance on designing your content for users on varied devices, check out Designing Gameplay for Various Devices.  Next steps  If you're entering the world of Bedrock creation, your next stop should be our add-on concept articles. Here are some excellent follow-up articles for your review:  Getting Started with Add-Ons Comprehensive List of Add-On Pack Contents  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/moreinfosources?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn More Sources of Information about Minecraft: Bedrock Edition 05/21/2025  Where possible, we aim to make the documentation here as comprehensive as we can get it - but the breadth of Minecraft possibilities can't be contained on just one website!  First, we have a YouTube channel! Check out the Minecraft Creator Channel for a growing library of tutorial videos that accompany some of the articles you see here on this site.  Here are many other handy references and sources of information that you can use when building Minecraft solutions.  Bedrock samples GitHub repository  The github.com/mojang/bedrock-samples repository is a set of example definitions and assets adapted from the vanilla experience of Minecraft.  Importantly, there are two \"branches\" in the repository: a \"main\" branch which represents the latest major release of content (e.g., 1.20.80) and a \"preview\" branch that represents the latest usually-weekly preview build of Minecraft (e.g., 1.21.20.21-preview). Information in the preview branch contains the latest cutting edge platform features, but be cautious as some advanced capabilities may be modified or removed before making it into \"main\" versions of Minecraft. Under the Releases page, you can see downloadable versions of the source of this repo. Be sure to understand the License Agreement of this repository.  The bedrock-samples GitHub repository is divided into several subfolders:  Sample packs  The samples you see in the behavior_pack and resource_pack are derived from some in-game samples. Keep in mind that sometimes these samples are not comprehensive across all of what \"vanilla gameplay\" encompasses, or across all of the platform capabilities (for example, they don't demonstrate how you can build script-powered gameplay experiences.. but you can)! Nevertheless, we'd strongly recommend downloading the bedrock-samples packs to use as \"sample references\" you can search through in a tool like Visual Studio Code to find an uncommonly used property on an item JSON component, for example.  Sample metadata  Where possible, we try to publish more and more lists of \"Minecraft things\" within the metadata folder. The various folders whose name ends in _modules contain metadata such as canonical lists of \"default Minecraft mobs\" or a listing of available Minecraft commands. Typically these files are more useful for tooling authors or creators that build very comprehensive add-ons or hosted experiences. Keep in mind that the schema of these various JSON files may change over time, so if you build tools that parse them, they would likely need to be updated, from time to time.  Sample documentation  The HTML files contained in the documentation folder are replicated and organized into the Reference section of this site. However, if you need information on a brand new JSON definition in Minecraft Preview (but hasn't been integrated into this site) it may first show up in the preview HTML documentation.  Changes over time  Because the repository is hosted on GitHub, you can use GitHub site features to view historical and change items for Minecraft. For example, the preview commits page will show you, week over week, what's new from a file perspective in Minecraft Preview. You can also see a summary of what's new for Minecraft from the Minecraft Beta Changelog notes.  Network protocol documentation   Important  The Minecraft protocol is not a formally supported API. The Minecraft Protocol changes from one release to the next—sometimes quite significantly—with no guarantee of backwards compatibility or support. Use at your own risk!  Like many games, Minecraft is an engine split into two parts: there is a \"Minecraft Server\" where all of the game logic and world state definitions are hosted, and where management of players in the world happens, and a \"Minecraft Client\" that connects to the server, displays all of the graphics, plays sounds, and handles player inputs. This is true whether you're playing a game on a hosted server, or if you're playing a single player game on your phone. The Minecraft Client speaks to the Minecraft Server via a \"protocol\"—a pipeline of messages that conform to one of hundreds of types of \"packet formats\". For example, when a player types in a \"slash command\" in their client, it results in a Command Request packet being sent from client to server so that the server can process and run the command.  Documentation on the Minecraft Protocol formats is available from a GitHub repository at https://github.com/Mojang/bedrock-protocol-docs/. Implementing the Protocol in your own software and tools is not supported. In addition to being extremely difficult, it's very likely to break every time a new version of Minecraft is released. New capabilities may also be introduced that are hard to replicate in an unofficial implementation. The documentation exists to give you a look at how the client/server internals of Minecraft: Bedrock Edition work at a more fundamental level.  Other sample repos  There are other sample repositories officially hosted by Mojang:  minecraft-samples  The minecraft-samples repository shows a number of samples discussed in this documentation demonstrating a number of different capabilities of Minecraft. You can see example custom entities, items, and mobs as well as some basic \"starters\" for creating your own projects.  minecraft-scripting-samples  The minecraft-scripting-samples repository is just like the minecraft-samples repo, but more focused on using script in various forms. It also includes a couple of starters if you wish to create a script-focused project.  minecraft-gametests  The minecraft-gametests repository represents a handful of samples for building GameTests, which are intended to be simple ways to build tests for Minecraft content.  Community  One of the best things about Minecraft is that there is a large, passionate community of creators who build all kinds of things—and create sites, write docs, record podcasts, and create videos of their progress. They also discuss and ask questions on forums such as Discord or Reddit. Often, the best way to find information is to search on your favorite search engine or video website for just about any topic, and chances are, someone has probably tried it and talked about it.   Important  This section contains links to external community-run sites and forums. Use at your own discretion.  Within Discord, you can visit channels such as #bedrock-mechanics on the Official Minecraft Discord at https://discord.gg/minecraft.  You can see some great community-run sites via bedrock.dev and the Minecraft wiki (minecraft.wiki) amongst many others.  There is also an amazing Discord community focused on building Add-Ons for Bedrock at bedrock.dev.  Tools  Of course, every creator can level up by using tools for creating their own Minecraft games and experiences. In addition to Mojang-driven tools such as the Bedrock Editor or the Visual Studio Code Debugger, we recommend you check out the commonly used tools article for more recommendations on Minecraft tools from the community.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/moreinfosources?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn More Sources of Information about Minecraft: Bedrock Edition 05/21/2025  Where possible, we aim to make the documentation here as comprehensive as we can get it - but the breadth of Minecraft possibilities can't be contained on just one website!  First, we have a YouTube channel! Check out the Minecraft Creator Channel for a growing library of tutorial videos that accompany some of the articles you see here on this site.  Here are many other handy references and sources of information that you can use when building Minecraft solutions.  Bedrock samples GitHub repository  The github.com/mojang/bedrock-samples repository is a set of example definitions and assets adapted from the vanilla experience of Minecraft.  Importantly, there are two \"branches\" in the repository: a \"main\" branch which represents the latest major release of content (e.g., 1.20.80) and a \"preview\" branch that represents the latest usually-weekly preview build of Minecraft (e.g., 1.21.20.21-preview). Information in the preview branch contains the latest cutting edge platform features, but be cautious as some advanced capabilities may be modified or removed before making it into \"main\" versions of Minecraft. Under the Releases page, you can see downloadable versions of the source of this repo. Be sure to understand the License Agreement of this repository.  The bedrock-samples GitHub repository is divided into several subfolders:  Sample packs  The samples you see in the behavior_pack and resource_pack are derived from some in-game samples. Keep in mind that sometimes these samples are not comprehensive across all of what \"vanilla gameplay\" encompasses, or across all of the platform capabilities (for example, they don't demonstrate how you can build script-powered gameplay experiences.. but you can)! Nevertheless, we'd strongly recommend downloading the bedrock-samples packs to use as \"sample references\" you can search through in a tool like Visual Studio Code to find an uncommonly used property on an item JSON component, for example.  Sample metadata  Where possible, we try to publish more and more lists of \"Minecraft things\" within the metadata folder. The various folders whose name ends in _modules contain metadata such as canonical lists of \"default Minecraft mobs\" or a listing of available Minecraft commands. Typically these files are more useful for tooling authors or creators that build very comprehensive add-ons or hosted experiences. Keep in mind that the schema of these various JSON files may change over time, so if you build tools that parse them, they would likely need to be updated, from time to time.  Sample documentation  The HTML files contained in the documentation folder are replicated and organized into the Reference section of this site. However, if you need information on a brand new JSON definition in Minecraft Preview (but hasn't been integrated into this site) it may first show up in the preview HTML documentation.  Changes over time  Because the repository is hosted on GitHub, you can use GitHub site features to view historical and change items for Minecraft. For example, the preview commits page will show you, week over week, what's new from a file perspective in Minecraft Preview. You can also see a summary of what's new for Minecraft from the Minecraft Beta Changelog notes.  Network protocol documentation   Important  The Minecraft protocol is not a formally supported API. The Minecraft Protocol changes from one release to the next—sometimes quite significantly—with no guarantee of backwards compatibility or support. Use at your own risk!  Like many games, Minecraft is an engine split into two parts: there is a \"Minecraft Server\" where all of the game logic and world state definitions are hosted, and where management of players in the world happens, and a \"Minecraft Client\" that connects to the server, displays all of the graphics, plays sounds, and handles player inputs. This is true whether you're playing a game on a hosted server, or if you're playing a single player game on your phone. The Minecraft Client speaks to the Minecraft Server via a \"protocol\"—a pipeline of messages that conform to one of hundreds of types of \"packet formats\". For example, when a player types in a \"slash command\" in their client, it results in a Command Request packet being sent from client to server so that the server can process and run the command.  Documentation on the Minecraft Protocol formats is available from a GitHub repository at https://github.com/Mojang/bedrock-protocol-docs/. Implementing the Protocol in your own software and tools is not supported. In addition to being extremely difficult, it's very likely to break every time a new version of Minecraft is released. New capabilities may also be introduced that are hard to replicate in an unofficial implementation. The documentation exists to give you a look at how the client/server internals of Minecraft: Bedrock Edition work at a more fundamental level.  Other sample repos  There are other sample repositories officially hosted by Mojang:  minecraft-samples  The minecraft-samples repository shows a number of samples discussed in this documentation demonstrating a number of different capabilities of Minecraft. You can see example custom entities, items, and mobs as well as some basic \"starters\" for creating your own projects.  minecraft-scripting-samples  The minecraft-scripting-samples repository is just like the minecraft-samples repo, but more focused on using script in various forms. It also includes a couple of starters if you wish to create a script-focused project.  minecraft-gametests  The minecraft-gametests repository represents a handful of samples for building GameTests, which are intended to be simple ways to build tests for Minecraft content.  Community  One of the best things about Minecraft is that there is a large, passionate community of creators who build all kinds of things—and create sites, write docs, record podcasts, and create videos of their progress. They also discuss and ask questions on forums such as Discord or Reddit. Often, the best way to find information is to search on your favorite search engine or video website for just about any topic, and chances are, someone has probably tried it and talked about it.   Important  This section contains links to external community-run sites and forums. Use at your own discretion.  Within Discord, you can visit channels such as #bedrock-mechanics on the Official Minecraft Discord at https://discord.gg/minecraft.  You can see some great community-run sites via bedrock.dev and the Minecraft wiki (minecraft.wiki) amongst many others.  There is also an amazing Discord community focused on building Add-Ons for Bedrock at bedrock.dev.  Tools  Of course, every creator can level up by using tools for creating their own Minecraft games and experiences. In addition to Mojang-driven tools such as the Bedrock Editor or the Visual Studio Code Debugger, we recommend you check out the commonly used tools article for more recommendations on Minecraft tools from the community.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftfileextensions?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Minecraft File Extensions 11/15/2023  A file extension is the series of letters after the period in a name of a computer file. File extensions specify the program or programs the file is associated with. In Minecraft: Bedrock Edition, many extensions begin with '.mc,' as detailed below.  .mcaddon  A zip file that contains .mcpack or .mcworld files to modify Minecraft (Bedrock Edition); generally used to distribute add-ons to other users.  .mcmeta  A custom resource pack configuration file.  .mcpack  A zipped resource or behavior pack that modifies Minecraft: Bedrock Edition, typically used to transfer resources between users.  .mcproject  Minecraft Bedrock Editor's filetype. Files of this type only open in Editor and are capable of containing Editor extensions.  .mcworld files can be imported into Editor, at which point they are converted to an .mcproject. When an .mcproject is exported as an .mcworld, Editor extensions are removed. .mcstructure  Contains a Minecraft structure such as a building or natural feature, saved using the Structure Block tool; can be shared between players, allowing the sharing of each other's structures.  .mctemplate  A zip archive containing the template of a world used in Minecraft.  .mcworld  A zip archive that contains all the files needed to load a Minecraft: Bedrock Edition or Minecraft Education world, for example .dat and .txt files.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftfileextensions?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Minecraft File Extensions 11/15/2023  A file extension is the series of letters after the period in a name of a computer file. File extensions specify the program or programs the file is associated with. In Minecraft: Bedrock Edition, many extensions begin with '.mc,' as detailed below.  .mcaddon  A zip file that contains .mcpack or .mcworld files to modify Minecraft (Bedrock Edition); generally used to distribute add-ons to other users.  .mcmeta  A custom resource pack configuration file.  .mcpack  A zipped resource or behavior pack that modifies Minecraft: Bedrock Edition, typically used to transfer resources between users.  .mcproject  Minecraft Bedrock Editor's filetype. Files of this type only open in Editor and are capable of containing Editor extensions.  .mcworld files can be imported into Editor, at which point they are converted to an .mcproject. When an .mcproject is exported as an .mcworld, Editor extensions are removed. .mcstructure  Contains a Minecraft structure such as a building or natural feature, saved using the Structure Block tool; can be shared between players, allowing the sharing of each other's structures.  .mctemplate  A zip archive containing the template of a world used in Minecraft.  .mcworld  A zip archive that contains all the files needed to load a Minecraft: Bedrock Edition or Minecraft Education world, for example .dat and .txt files.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/experimentalfeaturestoggle?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Experimental Features in Minecraft: Bedrock Edition 05/21/2025   Note  To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs version on the sidebar, or switch using this link.  With each retail version of Minecraft: Bedrock Edition, there are a few features that are currently in an experimental state. Experimental Features can be toggled on for creators who are interested in testing the latest features offered in the preview, and retail versions of Minecraft.   Note  The Experiments toggle list is subject to frequent changes and could have entirely different options from the ones in your own version of Minecraft. Also, the screen shots shown here might look different.  Available experimental features  There are two sets of experimental features available, depending on whether you are using a retail version of Minecraft or the latest version of Minecraft Preview.  Retail  These are the currently available Experimental toggles in the 1.21.80 retail build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing Drop 2 2025\tExperience flying with the Happy Ghast, coming in the second game drop of 2025 Locator Bar\tShow the direction of other players in multiplayer  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Custom Components V2\tEnables custom components V2 for scripting (V2.0.0-beta and higher) and JSON (V1.21.80 and higher) APIs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder Preview  These are the currently available Experimental toggles in the 1.21.90.23 preview build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes actor properties and adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Render Dragon Features for Creators\tEnable the deferred rendering pipeline. Requires a PBR-enables resource pack and compatible hardware. Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder How do I activate an experimental features toggle for my world?  You can activate an experimental toggle for any of your new or existing worlds.   Warning  Activating experimental features that are still under development means that your world might crash, break, or not work with future updates.  If you're planning to build content that you want to share with the community, it would be best to do it in a non-experimental world.  Toggle experimental features in a new world  If you are building a new world from scratch to test experimental features, you can toggle which features you want enabled in the Game Settings.  Under Game settings, navigate down to Experiments and select a toggle to enable the feature.  When you get the popup asking if you're sure, select Turn on Experiments anyway.  Toggle experimental features in an existing world  If you want to add experimental features to an existing world, open that world's game settings and activate the toggles just like you would for a new world.   Note  A copy of your world will be generated automatically after you activate an experimental feature toggle. You can also manually create copies of your world as an extra precaution, in case something goes wrong.  After you select Activate Experiments, a copy of your existing world will be created. The copy will have the same name as the original world with \"Copy of...\" added in front of it.  Verify the world has experimental features enabled  After you've created a world that has an experimental feature toggle enabled, your world will get a tag next to the game mode in your Worlds list that says Experimental.  Another way to identify if your world is using experimental toggles is to visit the settings for your world. In the Game world settings, scroll down to the Experiments section to see which experiments are enabled.   Important  Worlds that use experimental features cannot be restored to a non-experimental state.  What's next?  If you like experimenting and testing things in Minecraft, you could learn more about the GameTest Framework.  Introduction to the GameTest Framework  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/experimentalfeaturestoggle?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Experimental Features in Minecraft: Bedrock Edition 05/21/2025   Note  To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs version on the sidebar, or switch using this link.  With each retail version of Minecraft: Bedrock Edition, there are a few features that are currently in an experimental state. Experimental Features can be toggled on for creators who are interested in testing the latest features offered in the preview, and retail versions of Minecraft.   Note  The Experiments toggle list is subject to frequent changes and could have entirely different options from the ones in your own version of Minecraft. Also, the screen shots shown here might look different.  Available experimental features  There are two sets of experimental features available, depending on whether you are using a retail version of Minecraft or the latest version of Minecraft Preview.  Retail  These are the currently available Experimental toggles in the 1.21.80 retail build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing Drop 2 2025\tExperience flying with the Happy Ghast, coming in the second game drop of 2025 Locator Bar\tShow the direction of other players in multiplayer  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Custom Components V2\tEnables custom components V2 for scripting (V2.0.0-beta and higher) and JSON (V1.21.80 and higher) APIs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder Preview  These are the currently available Experimental toggles in the 1.21.90.23 preview build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes actor properties and adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Render Dragon Features for Creators\tEnable the deferred rendering pipeline. Requires a PBR-enables resource pack and compatible hardware. Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder How do I activate an experimental features toggle for my world?  You can activate an experimental toggle for any of your new or existing worlds.   Warning  Activating experimental features that are still under development means that your world might crash, break, or not work with future updates.  If you're planning to build content that you want to share with the community, it would be best to do it in a non-experimental world.  Toggle experimental features in a new world  If you are building a new world from scratch to test experimental features, you can toggle which features you want enabled in the Game Settings.  Under Game settings, navigate down to Experiments and select a toggle to enable the feature.  When you get the popup asking if you're sure, select Turn on Experiments anyway.  Toggle experimental features in an existing world  If you want to add experimental features to an existing world, open that world's game settings and activate the toggles just like you would for a new world.   Note  A copy of your world will be generated automatically after you activate an experimental feature toggle. You can also manually create copies of your world as an extra precaution, in case something goes wrong.  After you select Activate Experiments, a copy of your existing world will be created. The copy will have the same name as the original world with \"Copy of...\" added in front of it.  Verify the world has experimental features enabled  After you've created a world that has an experimental feature toggle enabled, your world will get a tag next to the game mode in your Worlds list that says Experimental.  Another way to identify if your world is using experimental toggles is to visit the settings for your world. In the Game world settings, scroll down to the Experiments section to see which experiments are enabled.   Important  Worlds that use experimental features cannot be restored to a non-experimental state.  What's next?  If you like experimenting and testing things in Minecraft, you could learn more about the GameTest Framework.  Introduction to the GameTest Framework  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/experimentalfeaturestoggle?view=minecraft-bedrock-experimental&preserve-view=true", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Experimental Features in Minecraft: Bedrock Edition 05/21/2025   Note  To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs version on the sidebar, or switch using this link.  With each retail version of Minecraft: Bedrock Edition, there are a few features that are currently in an experimental state. Experimental Features can be toggled on for creators who are interested in testing the latest features offered in the preview, and retail versions of Minecraft.   Note  The Experiments toggle list is subject to frequent changes and could have entirely different options from the ones in your own version of Minecraft. Also, the screen shots shown here might look different.  Available experimental features  There are two sets of experimental features available, depending on whether you are using a retail version of Minecraft or the latest version of Minecraft Preview.  Retail  These are the currently available Experimental toggles in the 1.21.80 retail build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing Drop 2 2025\tExperience flying with the Happy Ghast, coming in the second game drop of 2025 Locator Bar\tShow the direction of other players in multiplayer  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Custom Components V2\tEnables custom components V2 for scripting (V2.0.0-beta and higher) and JSON (V1.21.80 and higher) APIs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder Preview  These are the currently available Experimental toggles in the 1.21.90.23 preview build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes actor properties and adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Render Dragon Features for Creators\tEnable the deferred rendering pipeline. Requires a PBR-enables resource pack and compatible hardware. Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder How do I activate an experimental features toggle for my world?  You can activate an experimental toggle for any of your new or existing worlds.   Warning  Activating experimental features that are still under development means that your world might crash, break, or not work with future updates.  If you're planning to build content that you want to share with the community, it would be best to do it in a non-experimental world.  Toggle experimental features in a new world  If you are building a new world from scratch to test experimental features, you can toggle which features you want enabled in the Game Settings.  Under Game settings, navigate down to Experiments and select a toggle to enable the feature.  When you get the popup asking if you're sure, select Turn on Experiments anyway.  Toggle experimental features in an existing world  If you want to add experimental features to an existing world, open that world's game settings and activate the toggles just like you would for a new world.   Note  A copy of your world will be generated automatically after you activate an experimental feature toggle. You can also manually create copies of your world as an extra precaution, in case something goes wrong.  After you select Activate Experiments, a copy of your existing world will be created. The copy will have the same name as the original world with \"Copy of...\" added in front of it.  Verify the world has experimental features enabled  After you've created a world that has an experimental feature toggle enabled, your world will get a tag next to the game mode in your Worlds list that says Experimental.  Another way to identify if your world is using experimental toggles is to visit the settings for your world. In the Game world settings, scroll down to the Experiments section to see which experiments are enabled.   Important  Worlds that use experimental features cannot be restored to a non-experimental state.  What's next?  If you like experimenting and testing things in Minecraft, you could learn more about the GameTest Framework.  Introduction to the GameTest Framework  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gametestgettingstarted?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to the GameTest Framework 06/20/2024  GameTest Framework is a toolset available to creators to build and test any new content created by you. Within the world of Minecraft: Bedrock Edition, you can express infinite forms of gameplay and variability in your content. With all these creative possibilities, sometimes you may need additional tools to help validate that your experiences are running just as you expect it, and assist you as you customize aspects of the broader Minecraft environment.  What happens if you change the behavior of Villagers? Or introduce a new Mob? Small changes can have unexpectedly big impacts that can be really hard to anticipate. With the GameTest Framework - a system for establishing sets of tests - you can track and repeat to ensure everything works the way you intend.  With these tests, you can express and document your expectations for how things should work - both for your content and games, and for the Minecraft world. You'll be able to save time by using GameTests to take the place of repeatedly needing to manually play through conditions just to validate that all is working as expected.  Submitting and using GameTests can be a great way to establish and communicate the expected behavior you are looking for. As you build more complex worlds and adventures, use the GameTest Framework as a tool to validate facets of your content.  Requirements  To get started, you'll want to begin with understanding how a behavior pack works within Minecraft. To read more about creating behavior packs, see this topic:  Introduction To Behavior Packs What's a GameTest?  A GameTest is a miniature environment along with a set of starting conditions, such as a set of mobs or items. After that environment plays out in the Minecraft world for a period of time, a GameTest has conditional code that evaluates whether expected conditions were met. If a test passes, you will receive confirmation that everything is working as expected. When a test fails, you can observe and diagnose why it may have failed.  Let's examine a potential use case for a GameTest. Let's say that we want to validate that a minecart can make its way around curves and over a complex track when Redstone triggers it. We can build a GameTest for this case by building out a track, placing a minecart at the start of the track, and then power the track with a block of Redstone. We can then validate that the minecart reaches the end of its track within a reasonable time-frame. Minecraft includes a growing set of GameTests that test various basic situations in the Minecraft world. However, you can build your own GameTests to validate any changes you introduce.  Running tests within game  To run tests within a game, you'll want to create a new world or start with a copy of your existing adventure and experience.  Within this GameTest world, you'll want to ensure that cheats are enabled and that the Beta APIs experiment is turned on. If you've created GameTest Framework tests within behavior packs, you'll want to add those behavior packs in your world. You can see an example set of gametests available at https://github.com/microsoft/minecraft-gametests. You'll want to download this pack of gametests, copy them into your developer_behavior_packs folder in Minecraft, and then create a world that uses this behavior pack.   Important  You'll also likely want to specify some additional changes in your environment:  Selecting a Creative game mode Selecting a Flat world You will want to retain Normal difficulty (mobs work differently compared to Peaceful worlds)  Once the world is loaded, use the /gametest command to run tests.  To run the default set of tests, use /gametest runset.  What's Next?  Building sets of GameTests requires building out your GameTests via a behavior pack, and writing some simple JavaScript code. When building out your own tests, you will likely want to start a new test behavior pack that is just focused on adding additional GameTests.  Build your first GameTest  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gametestgettingstarted?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to the GameTest Framework 06/20/2024  GameTest Framework is a toolset available to creators to build and test any new content created by you. Within the world of Minecraft: Bedrock Edition, you can express infinite forms of gameplay and variability in your content. With all these creative possibilities, sometimes you may need additional tools to help validate that your experiences are running just as you expect it, and assist you as you customize aspects of the broader Minecraft environment.  What happens if you change the behavior of Villagers? Or introduce a new Mob? Small changes can have unexpectedly big impacts that can be really hard to anticipate. With the GameTest Framework - a system for establishing sets of tests - you can track and repeat to ensure everything works the way you intend.  With these tests, you can express and document your expectations for how things should work - both for your content and games, and for the Minecraft world. You'll be able to save time by using GameTests to take the place of repeatedly needing to manually play through conditions just to validate that all is working as expected.  Submitting and using GameTests can be a great way to establish and communicate the expected behavior you are looking for. As you build more complex worlds and adventures, use the GameTest Framework as a tool to validate facets of your content.  Requirements  To get started, you'll want to begin with understanding how a behavior pack works within Minecraft. To read more about creating behavior packs, see this topic:  Introduction To Behavior Packs What's a GameTest?  A GameTest is a miniature environment along with a set of starting conditions, such as a set of mobs or items. After that environment plays out in the Minecraft world for a period of time, a GameTest has conditional code that evaluates whether expected conditions were met. If a test passes, you will receive confirmation that everything is working as expected. When a test fails, you can observe and diagnose why it may have failed.  Let's examine a potential use case for a GameTest. Let's say that we want to validate that a minecart can make its way around curves and over a complex track when Redstone triggers it. We can build a GameTest for this case by building out a track, placing a minecart at the start of the track, and then power the track with a block of Redstone. We can then validate that the minecart reaches the end of its track within a reasonable time-frame. Minecraft includes a growing set of GameTests that test various basic situations in the Minecraft world. However, you can build your own GameTests to validate any changes you introduce.  Running tests within game  To run tests within a game, you'll want to create a new world or start with a copy of your existing adventure and experience.  Within this GameTest world, you'll want to ensure that cheats are enabled and that the Beta APIs experiment is turned on. If you've created GameTest Framework tests within behavior packs, you'll want to add those behavior packs in your world. You can see an example set of gametests available at https://github.com/microsoft/minecraft-gametests. You'll want to download this pack of gametests, copy them into your developer_behavior_packs folder in Minecraft, and then create a world that uses this behavior pack.   Important  You'll also likely want to specify some additional changes in your environment:  Selecting a Creative game mode Selecting a Flat world You will want to retain Normal difficulty (mobs work differently compared to Peaceful worlds)  Once the world is loaded, use the /gametest command to run tests.  To run the default set of tests, use /gametest runset.  What's Next?  Building sets of GameTests requires building out your GameTests via a behavior pack, and writing some simple JavaScript code. When building out your own tests, you will likely want to start a new test behavior pack that is just focused on adding additional GameTests.  Build your first GameTest  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commonlyusedtools?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Commonly Used Tools 06/27/2024  There are a wide variety of tools that have been created for the purpose of increasing the efficiency of Minecraft content creation. Tools can help with a variety of things from creating skins, to crafting beautiful custom worlds. This article will explore some of the most commonly used tools currently available and some of their uses.   Important  These tools are provided by external, third-party contributors and are not Mojang/Microsoft offerings. Users should use at their own discretion.  Creating maps  Map creation is one of the largest and most time-consuming components of content creation. That being said, there are a significant number of map creation tools available to make this process significantly more efficient.  Chunker  Chunker is a Java-based tool for Minecraft: Bedrock Edition worlds. It's specifically useful for converting worlds between Minecraft: Java Edition and Bedrock Edition, as well as easily configuring world settings. Conversion includes level settings, chunk data (such as blocks and biomes), dimensions, and more. To learn more about using Chunker, you can begin with the Chunker Overview guide, which goes over the steps needed to do simple conversions and leads to more advanced features of the tool.  Amulet  Amulet is a utility tool designed to edit Minecraft maps. It can come in handy for world development, having helpful abilities such as replacing blocks in a selected area and the ability to create and remove chunks within a world. There's also a massive variety of community-made custom plugins referred to as \"operations\" that allow creators to perform a wide variety of tasks. Included below is a list of operations that can be useful for map creation:  Abrightmore's Amulet operations PREMIEREHELL's Amulet operations StealthyExpert's Amulet operations 5uso's Amulet operations Image Map  Image Map is a small application for both Bedrock Edition and Java Edition that can convert images to Minecraft maps. This can be used to add custom banners and art inside of Minecraft worlds.  Server Based Tools  Many commonly used tools are designed to be used on Java Edition servers utilizing a server software known as Spigot, which is based on the Craftbukkit API. The following tools are plugins that work on servers running this software.  Fast Async WorldEdit (FAWE)  WorldEdit is an in-game Minecraft map editor for Java Edition. It allows creators to perform a wide range of build-related commands, as well as utilize brushes that help sculpt Minecraft worlds. Some notable features include the ability to copy and paste selected areas, as well as rotate selected areas to face a different direction. This is especially useful when creating large builds with lots of repeating patterns. Linked here is the Fast Async WorldEdit project, a spinoff that includes some big performance boosts from the original WorldEdit, as well as some useful features for creative builders.  Voxel Sniper Flattened  Voxel Sniper Flattened is another in-game Minecraft map editor for Java Edition. It allows creators to edit any block in sight using an arrow (for replacing blocks) and gunpowder (for adding blocks). It contains a wide array of brushes that can be used for anything from precise block placements to large terraforming jobs. This plugin is a continuation of the original VoxelSniper.  goBrush  goBrush is a server plugin for Java Edition that adds in-game tools designed for custom terrain editing by using heightmap brushes instead of geometric shapes like tools such as WorldEdit and Voxel Sniper Flattened.  goPaint  goPaint is a server plugin for Java Edition that allows creators to efficiently \"paint\" blocks with a variety of brush shapes.  Creating Models and Visuals Blockbench  Blockbench is a free entity-modeling application for creating working Bedrock Edition entity models, as well as creating textures and the ability to animate them for Bedrock Edition maps. Blockbench has external plugin support, enabling developers to create additional tools to use within the program. It also has the ability to export models into a standard OBJ format, Java Edition block model, and more.  Snowstorm  Snowstorm is a small application for Bedrock Edition created by the developer of Blockbench that can be used to create custom particle effects that are usable in-game. To get started with Snowstorm, visit a tutorial on building particle effects with Snowstorm.  Project and JSON Definition Editing Blockception VSCode Extension  An extension that provides support for files such as .mcfunction, .json and .lang. This extension adds features like completion, validations, formatters, diagnostics, cheat-sheets, code-actions, generation of files, and development tools to help develop Minecraft: Bedrock Edition Addons or Minecraft Education. It's recommended that you use the Dark+ theme for the best color highlighting.  bridge.  bridge. is a light-weight, dedicated editor for Minecraft Add-Ons that makes it easy to get started with Add-Ons and later scales with your growing needs. It requires zero setup and provides you with an instantly bootable development environment with syntax highlighting, code completions and file diagnostics all designed to make developing Minecraft Add-Ons more convenient. To read more, please refer to bridge.'s getting started guide or learn more about why you should use bridge.  bridge. is open source and freely available to all Add-On creators on desktop and mobile platforms.  Minecraft Creator Tools  Minecraft Creator Tools is both a website and an NPM-based command line tool that you can use to start or extend your Minecraft projects. It also includes validators to help find and point out potential issues in the project.  Minecraft Creator Tools is also open source and available on GitHub.  NPC DialogueDesigner  DialogueDesigner is a Web application for Bedrock Edition created by the developer of Blockbench and Snowstorm that can be used to create NPC dialogues, as shown in this handy tutorial: NPC DialogueDesigner.  Creating Skins and Resource Packs  Skin and resource pack creation can be done primarily within any image-editing software, but there are also a few helpful applications that can make this process easier.  Blockbench  Blockbench has a skin editor that allows skins to be edited in 3D (or 2D) with Blockbench's advanced paint tools such as mirror painting and color palettes. It has presets to create entity textures for resource packs as well.  Skins can be packaged for the Marketplace using the Skin Pack Packager plugin in Blockbench.  PMCSkin3D  PMCSkin3D is a web-based dedicated skin editor from PlanetMinecraft. It has a 3D and 2D as well as split-screen mode and advanced brush options. There is also a lite edition with simplified tools.  Aseprite  Aseprite is a purchasable art application designed with pixel-art in mind. It contains many tools that can help make skin and resource pack creation easier. Aseprite also has significant documentation and tutorials to help artists of all skill levels use the application effectively.  McSkin3d  McSkin3D is software designed entirely with skin creation in mind. It has many features such as a built-in skin viewer that can be directly painted on and a split view showing both the skin in 3D alongside its 2D texture.  LookatMySkin  LookatMySkin is a skin previewer that allows you to edit a skin in your program of choice and instantly see it previewed on a 3D player model. It has a variety of features, such as limb posing, zoom, and adjustable background color. This can also be useful for taking screenshots of skins or quickly checking skins for oddities when posed in different ways.  What's Next?  While there are many more tools that exist and are constantly being created to make Minecraft content creation easier, this is a great place to start. Creators should check back here often for newly added content and take advantage of all the available tools at their disposal.  Some of these tools allow you to modify NBT data. Learning about NBT and especially learning what not to do when editing it will save you from a world of trouble.  Editing NBT safely  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commonlyusedtools?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Commonly Used Tools 06/27/2024  There are a wide variety of tools that have been created for the purpose of increasing the efficiency of Minecraft content creation. Tools can help with a variety of things from creating skins, to crafting beautiful custom worlds. This article will explore some of the most commonly used tools currently available and some of their uses.   Important  These tools are provided by external, third-party contributors and are not Mojang/Microsoft offerings. Users should use at their own discretion.  Creating maps  Map creation is one of the largest and most time-consuming components of content creation. That being said, there are a significant number of map creation tools available to make this process significantly more efficient.  Chunker  Chunker is a Java-based tool for Minecraft: Bedrock Edition worlds. It's specifically useful for converting worlds between Minecraft: Java Edition and Bedrock Edition, as well as easily configuring world settings. Conversion includes level settings, chunk data (such as blocks and biomes), dimensions, and more. To learn more about using Chunker, you can begin with the Chunker Overview guide, which goes over the steps needed to do simple conversions and leads to more advanced features of the tool.  Amulet  Amulet is a utility tool designed to edit Minecraft maps. It can come in handy for world development, having helpful abilities such as replacing blocks in a selected area and the ability to create and remove chunks within a world. There's also a massive variety of community-made custom plugins referred to as \"operations\" that allow creators to perform a wide variety of tasks. Included below is a list of operations that can be useful for map creation:  Abrightmore's Amulet operations PREMIEREHELL's Amulet operations StealthyExpert's Amulet operations 5uso's Amulet operations Image Map  Image Map is a small application for both Bedrock Edition and Java Edition that can convert images to Minecraft maps. This can be used to add custom banners and art inside of Minecraft worlds.  Server Based Tools  Many commonly used tools are designed to be used on Java Edition servers utilizing a server software known as Spigot, which is based on the Craftbukkit API. The following tools are plugins that work on servers running this software.  Fast Async WorldEdit (FAWE)  WorldEdit is an in-game Minecraft map editor for Java Edition. It allows creators to perform a wide range of build-related commands, as well as utilize brushes that help sculpt Minecraft worlds. Some notable features include the ability to copy and paste selected areas, as well as rotate selected areas to face a different direction. This is especially useful when creating large builds with lots of repeating patterns. Linked here is the Fast Async WorldEdit project, a spinoff that includes some big performance boosts from the original WorldEdit, as well as some useful features for creative builders.  Voxel Sniper Flattened  Voxel Sniper Flattened is another in-game Minecraft map editor for Java Edition. It allows creators to edit any block in sight using an arrow (for replacing blocks) and gunpowder (for adding blocks). It contains a wide array of brushes that can be used for anything from precise block placements to large terraforming jobs. This plugin is a continuation of the original VoxelSniper.  goBrush  goBrush is a server plugin for Java Edition that adds in-game tools designed for custom terrain editing by using heightmap brushes instead of geometric shapes like tools such as WorldEdit and Voxel Sniper Flattened.  goPaint  goPaint is a server plugin for Java Edition that allows creators to efficiently \"paint\" blocks with a variety of brush shapes.  Creating Models and Visuals Blockbench  Blockbench is a free entity-modeling application for creating working Bedrock Edition entity models, as well as creating textures and the ability to animate them for Bedrock Edition maps. Blockbench has external plugin support, enabling developers to create additional tools to use within the program. It also has the ability to export models into a standard OBJ format, Java Edition block model, and more.  Snowstorm  Snowstorm is a small application for Bedrock Edition created by the developer of Blockbench that can be used to create custom particle effects that are usable in-game. To get started with Snowstorm, visit a tutorial on building particle effects with Snowstorm.  Project and JSON Definition Editing Blockception VSCode Extension  An extension that provides support for files such as .mcfunction, .json and .lang. This extension adds features like completion, validations, formatters, diagnostics, cheat-sheets, code-actions, generation of files, and development tools to help develop Minecraft: Bedrock Edition Addons or Minecraft Education. It's recommended that you use the Dark+ theme for the best color highlighting.  bridge.  bridge. is a light-weight, dedicated editor for Minecraft Add-Ons that makes it easy to get started with Add-Ons and later scales with your growing needs. It requires zero setup and provides you with an instantly bootable development environment with syntax highlighting, code completions and file diagnostics all designed to make developing Minecraft Add-Ons more convenient. To read more, please refer to bridge.'s getting started guide or learn more about why you should use bridge.  bridge. is open source and freely available to all Add-On creators on desktop and mobile platforms.  Minecraft Creator Tools  Minecraft Creator Tools is both a website and an NPM-based command line tool that you can use to start or extend your Minecraft projects. It also includes validators to help find and point out potential issues in the project.  Minecraft Creator Tools is also open source and available on GitHub.  NPC DialogueDesigner  DialogueDesigner is a Web application for Bedrock Edition created by the developer of Blockbench and Snowstorm that can be used to create NPC dialogues, as shown in this handy tutorial: NPC DialogueDesigner.  Creating Skins and Resource Packs  Skin and resource pack creation can be done primarily within any image-editing software, but there are also a few helpful applications that can make this process easier.  Blockbench  Blockbench has a skin editor that allows skins to be edited in 3D (or 2D) with Blockbench's advanced paint tools such as mirror painting and color palettes. It has presets to create entity textures for resource packs as well.  Skins can be packaged for the Marketplace using the Skin Pack Packager plugin in Blockbench.  PMCSkin3D  PMCSkin3D is a web-based dedicated skin editor from PlanetMinecraft. It has a 3D and 2D as well as split-screen mode and advanced brush options. There is also a lite edition with simplified tools.  Aseprite  Aseprite is a purchasable art application designed with pixel-art in mind. It contains many tools that can help make skin and resource pack creation easier. Aseprite also has significant documentation and tutorials to help artists of all skill levels use the application effectively.  McSkin3d  McSkin3D is software designed entirely with skin creation in mind. It has many features such as a built-in skin viewer that can be directly painted on and a split view showing both the skin in 3D alongside its 2D texture.  LookatMySkin  LookatMySkin is a skin previewer that allows you to edit a skin in your program of choice and instantly see it previewed on a 3D player model. It has a variety of features, such as limb posing, zoom, and adjustable background color. This can also be useful for taking screenshots of skins or quickly checking skins for oddities when posed in different ways.  What's Next?  While there are many more tools that exist and are constantly being created to make Minecraft content creation easier, this is a great place to start. Creators should check back here often for newly added content and take advantage of all the available tools at their disposal.  Some of these tools allow you to modify NBT data. Learning about NBT and especially learning what not to do when editing it will save you from a world of trouble.  Editing NBT safely  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptinglibraries?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Open-Source Scripting Libraries 02/16/2024  Mojang provides a number of open-source scripting libraries, which allow you to see all of the changes and behind-the-scenes code. Some libraries can be used in your Minecraft projects, while others are helper tools and build scripts. Additionally, since the libraries are open-source you can contribute fixes and even submit your own libraries! For more information, please be sure to look at our Contributing Guide. Now that you're familiar with the concept, let's take a look at the libraries:  Math  The math library contains a set of utility functions and a wrapper class for common Vector operations. Two patterns are supported; a more computational approach operating on the Vector3 interface with no mutation, and a separate wrapper object-oriented approach following a \"builder\" pattern. The choice of pattern is based on your preference; behind the scenes, the same helpers are used.  Core Build Tasks  The core build tasks library contains common build tasks used in the minecraft-scripting-libraries build, but can be used in other repositories as well. If a task is used by the 'just' build infrastructure in multiple packages, it is moved into this package to reduce duplication.   Note  This subdirectory only runs the 'build' step - specifically, 'tsc' - since this package itself defines build tasks and must be kept lightweight.  Linting  The linting library contains best practices for authoring Minecraft script. Rules may include suggestions, such as \"Use this API instead of this command!\", or errors against anti-patterns to avoid pitfalls.  To author a new rule, add a file under 'src/rules' named after the rule. Rules are authored via the 'ESLintUtils' rule creator; more information on rule creation can be found here.  Once you have a new rule, update 'src/index.ts' and add it to the exported 'rules' key in the module exports and update the default 'eslint' configuration as to whether the new rule is an error or a warning.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptinglibraries?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Open-Source Scripting Libraries 02/16/2024  Mojang provides a number of open-source scripting libraries, which allow you to see all of the changes and behind-the-scenes code. Some libraries can be used in your Minecraft projects, while others are helper tools and build scripts. Additionally, since the libraries are open-source you can contribute fixes and even submit your own libraries! For more information, please be sure to look at our Contributing Guide. Now that you're familiar with the concept, let's take a look at the libraries:  Math  The math library contains a set of utility functions and a wrapper class for common Vector operations. Two patterns are supported; a more computational approach operating on the Vector3 interface with no mutation, and a separate wrapper object-oriented approach following a \"builder\" pattern. The choice of pattern is based on your preference; behind the scenes, the same helpers are used.  Core Build Tasks  The core build tasks library contains common build tasks used in the minecraft-scripting-libraries build, but can be used in other repositories as well. If a task is used by the 'just' build infrastructure in multiple packages, it is moved into this package to reduce duplication.   Note  This subdirectory only runs the 'build' step - specifically, 'tsc' - since this package itself defines build tasks and must be kept lightweight.  Linting  The linting library contains best practices for authoring Minecraft script. Rules may include suggestions, such as \"Use this API instead of this command!\", or errors against anti-patterns to avoid pitfalls.  To author a new rule, add a file under 'src/rules' named after the rule. Rules are authored via the 'ESLintUtils' rule creator; more information on rule creation can be found here.  Once you have a new rule, update 'src/index.ts' and add it to the exported 'rules' key in the module exports and update the default 'eslint' configuration as to whether the new rule is an error or a warning.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/snowstormoverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Snowstorm - Overview 06/27/2024  Every experience you build in Minecraft gets better when there are particles and effects to accentuate the action. Minecraft: Bedrock Edition supports a concept of particles - lightweight visual items that you can design - as well as particle emitters - logic for determining when particles are created. You can add these particles to your resource packs and then use them in experiences with the particle command and as a part of your JSON definitions.  One tool for visually editing the particle files that underlie these is Snowstorm - an app by JannisX11, who also created Blockbench.  You can access Snowstorm as a web appliation via https://snowstorm.app or as a Visual Studio Code plugin. A Quick Setup tab within Snowstorm makes it easy to get started with various pre-set motions and appearances.   Important  Snowstorm is provided by external, third-party contributors and is not a Mojang/Microsoft offering. Users should use at their own discretion.  To see how you can use Snowstorm to build particle effects, visit this tutorial.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/snowstormoverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Snowstorm - Overview 06/27/2024  Every experience you build in Minecraft gets better when there are particles and effects to accentuate the action. Minecraft: Bedrock Edition supports a concept of particles - lightweight visual items that you can design - as well as particle emitters - logic for determining when particles are created. You can add these particles to your resource packs and then use them in experiences with the particle command and as a part of your JSON definitions.  One tool for visually editing the particle files that underlie these is Snowstorm - an app by JannisX11, who also created Blockbench.  You can access Snowstorm as a web appliation via https://snowstorm.app or as a Visual Studio Code plugin. A Quick Setup tab within Snowstorm makes it easy to get started with various pre-set motions and appearances.   Important  Snowstorm is provided by external, third-party contributors and is not a Mojang/Microsoft offering. Users should use at their own discretion.  To see how you can use Snowstorm to build particle effects, visit this tutorial.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/mctoolsoverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Minecraft Creator Tools (mctools.dev) - Overview 10/04/2024  Minecraft Creator Tools is produced by Mojang as an open source toolset that can improve your productivity as a creator. It comes in two forms: a website, located at https://mctools.dev, and a command line tool that you can install via nodejs tools.  https://mctools.dev website  The creator tools site is the easiest way to get started - simply navigate to https://mctools.dev. On the home page, you'll see a number of new project starters, code samples, and start-from-mob starters. From the website, and in Google Chrome and Microsoft Edge browsers, Minecraft Creator Tools can also open folders on your device and work directly against them.  Once you've started your project, you'll see an editor that shows top-level files that you can edit, including TypeScript, JSON files, and more. You can test certain facets of your creations by downloading .MCWorld and .MCProject files, which when run will open inside of Minecraft and import your custom code.   Important  mctools.dev stores your projects and edits within the storage confines of your browser. Sometimes, this storage can get cleared by your browser. For any projects you'd like to keep, ensure that you regularly backup and download projects.  Command Line Tools  Command line tools let you access the power of creator tools from a command line. You can also integrate this into broader processes or project-level tasks.  Command line tools are available via the @minecraft/creator-tools page on NPM. To install via NPM, install nodejs tools and then run npm i @minecraft/creator-tools from a command line. See the NPM page for more documentation and sample command lines.  Minecraft Creator Tools - what it does New Project Starters  Start and extend your Minecraft projects from a growing set of GitHub-hosted sources of samples and content. Start on the MC Tools website and select from the gallery of projects. Add new items from the set of Minecraft samples. With command line tools, use the create command to start a new project, and add to add additional elements.  Project Editor  Minecraft Creator Tools includes editors for various files including JavaScript and JSON: editing JavaScript or TypeScript, the Project Editor includes a modern editor with autocomplete and built-in support for Minecraft types, plus a rich array of code snippets.  Accessibility Support  Where possible, additional capabilities are provided to help make Minecraft Creator Tools accessible to all users. This section discusses using some of these tools and features.  Tab Trapping  By default, pressing Tab in the JavaScript/JSON editor inserts the Tab character and does not navigate to the next focusable element on the page. You can toggle the trapping of Tab with Ctrl+M on Windows and Linux and with Ctrl+Shift+M on OSX, and subsequent Tab keys will move focus out of the editor.  Validation and Analytics  Minecraft Creator Tools includes a suite of tests and analytics that can be used to build reports across projects. It can output reports as an HTML file, in addition to being displayed within the site. Validation/analytics is available on both the website and the NPM command line tools.  To use the validator, use \"Choose file\" in the Validate/Inspect Tool to select a zip file from your local device that contains project files. This can be any typical zip of a Minecraft project: an MCAddon file, an MCPack file, or a ZIP file where you have behavior packs under behavior_packs and resource packs under resource_packs. Note that these ZIP files are temporarily stored and locally processed within your browser.  Validation results are displayed in the \"Inspector\" section of the application. Note that there are different suites of tests that you can use. You can also opt to download the results in comma-separated-value (CSV) format or web page (HTML) format.  What's Next?  MCTools.dev is one of many tools you can use to work on facets of your project. See the other major Minecraft tools listed here.  CommonlyUsedTools  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/mctoolsoverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Minecraft Creator Tools (mctools.dev) - Overview 10/04/2024  Minecraft Creator Tools is produced by Mojang as an open source toolset that can improve your productivity as a creator. It comes in two forms: a website, located at https://mctools.dev, and a command line tool that you can install via nodejs tools.  https://mctools.dev website  The creator tools site is the easiest way to get started - simply navigate to https://mctools.dev. On the home page, you'll see a number of new project starters, code samples, and start-from-mob starters. From the website, and in Google Chrome and Microsoft Edge browsers, Minecraft Creator Tools can also open folders on your device and work directly against them.  Once you've started your project, you'll see an editor that shows top-level files that you can edit, including TypeScript, JSON files, and more. You can test certain facets of your creations by downloading .MCWorld and .MCProject files, which when run will open inside of Minecraft and import your custom code.   Important  mctools.dev stores your projects and edits within the storage confines of your browser. Sometimes, this storage can get cleared by your browser. For any projects you'd like to keep, ensure that you regularly backup and download projects.  Command Line Tools  Command line tools let you access the power of creator tools from a command line. You can also integrate this into broader processes or project-level tasks.  Command line tools are available via the @minecraft/creator-tools page on NPM. To install via NPM, install nodejs tools and then run npm i @minecraft/creator-tools from a command line. See the NPM page for more documentation and sample command lines.  Minecraft Creator Tools - what it does New Project Starters  Start and extend your Minecraft projects from a growing set of GitHub-hosted sources of samples and content. Start on the MC Tools website and select from the gallery of projects. Add new items from the set of Minecraft samples. With command line tools, use the create command to start a new project, and add to add additional elements.  Project Editor  Minecraft Creator Tools includes editors for various files including JavaScript and JSON: editing JavaScript or TypeScript, the Project Editor includes a modern editor with autocomplete and built-in support for Minecraft types, plus a rich array of code snippets.  Accessibility Support  Where possible, additional capabilities are provided to help make Minecraft Creator Tools accessible to all users. This section discusses using some of these tools and features.  Tab Trapping  By default, pressing Tab in the JavaScript/JSON editor inserts the Tab character and does not navigate to the next focusable element on the page. You can toggle the trapping of Tab with Ctrl+M on Windows and Linux and with Ctrl+Shift+M on OSX, and subsequent Tab keys will move focus out of the editor.  Validation and Analytics  Minecraft Creator Tools includes a suite of tests and analytics that can be used to build reports across projects. It can output reports as an HTML file, in addition to being displayed within the site. Validation/analytics is available on both the website and the NPM command line tools.  To use the validator, use \"Choose file\" in the Validate/Inspect Tool to select a zip file from your local device that contains project files. This can be any typical zip of a Minecraft project: an MCAddon file, an MCPack file, or a ZIP file where you have behavior packs under behavior_packs and resource packs under resource_packs. Note that these ZIP files are temporarily stored and locally processed within your browser.  Validation results are displayed in the \"Inspector\" section of the application. Note that there are different suites of tests that you can use. You can also opt to download the results in comma-separated-value (CSV) format or web page (HTML) format.  What's Next?  MCTools.dev is one of many tools you can use to work on facets of your project. See the other major Minecraft tools listed here.  CommonlyUsedTools  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftentitywizard?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with the Minecraft Entity Wizard 05/07/2025  If you're new to Minecraft add-on development, creating your first working behavior pack and custom entity can take a lot of time and research. The Minecraft Entity Wizard for Blockbench aims to make it as easy as possible to create a custom entity and to add it to your world. From there, you can build on your entity, change the model, or add your own behavior.  Building a grizzly bear with the Minecraft Entity Wizard  Blockbench is a 3D modeling program with native support for many Minecraft 3D model formats. Once you've created your basic entity in the Entity Wizard, you can continue to use Blockbench to modify the model, and you can edit the behavior in an external program (more on that later).  As a starting point, the Entity Wizard offers most of Minecraft's vanilla mobs as presets. For example, if you want to create a shark, you can choose the dolphin preset. There are also stripped down \"basic\" presets that you can use if you're a more experienced add-on creator and want to create entity behavior from scratch.  In this tutorial, you'll learn the following:  How to add the Minecraft Entity Wizard plugin to Blockbench. The steps to create a custom entity with the Wizard. How to export the entity to use within Minecraft: Bedrock Edition. Requirements  It's recommended that the following be completed before beginning this tutorial.  Getting Started with Add-On Development Introduction to Blockbench  You'll also need to either have Blockbench installed or have access to the Blockbench web app.   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Getting started  Once you've downloaded and installed Blockbench, you can directly install the Entity Wizard from within the program.   Tip  If you do not want to install the app, or you are using a mobile device like a tablet, you can also use the plugin in the Blockbench web app. Most parts of the program work the same in the web app, but saving files requires a few extra steps.  Adding the Minecraft Entity Wizard In Blockbench, go to File > Plugins..., switch to the Available tab, and enter \"Minecraft Entity Wizard\" into the search bar (or scroll until you find it in the list). Find the Entity Wizard plugin and click Install. After it's installed, close the Plugins dialog. The Wizard  You'll find the Minecraft Entity Wizard in the left sidebar of the start screen, under Loaders. Now that the plugin is installed, you can use the Minecraft Entity Wizard to start creating your entity.  Click the yellow banner on the start screen to open the wizard, or navigate to Filter and select Create Bedrock Entity. Click the Let's Go-button.  The wizard will guide you through the steps required to create your custom entity. To navigate the wizard, use the Back and Next buttons at the bottom of the screen.   Caution  You can also close the dialog and select Keep to keep your current state and inputs. However, closing Blockbench entirely will discard your input.  Name  The Display Name is the name that the entity will later be called in Minecraft. It will appear in the spawn egg name, in chat, and in other places in the interface. This name also supports translations into different languages.   Note  The Identifier is the internal name used within Minecraft that is commonly used in commands and other places to identify this type of entity.  Appearance  Select the appearance of your entity from a list of presets. The appearance includes model, texture, animations, and sounds. At a later step, you will be able to edit and modify this model in Blockbench.   Note  If you currently have a model opened inside Blockbench, you may also pick this model as your starting point.  Behavior  The behavior tab determines how your custom entity behaves and interacts with the world.   Warning  It is recommended for beginners to use the behavior from the same mob as the appearance, to avoid conflicts.  Appearance and behavior often work hand in hand. As an example, if you mix the appearance of a wolf with the behavior of a sheep (a sheep in wolf's clothing), you will quickly notice that the wolf in Minecraft does not come with a grazing animation, so it will look like the grass below them just pops off.  Spawn egg  The spawn egg tab allows you to set the spawn egg that is the item used to spawn the custom entity.  There are three ways to define the spawn egg:  Colors: Use the two-color pickers to select the background and foreground colors on the default spawn egg icon. Custom Texture: Select a custom texture for your spawn egg icon. You can create the texture in a regular image editor, such as Paint.NET or Photoshop. The image should be a PNG file, ideally with a resolution of 16 by 16 pixels and a transparent background. None: Do not generate a spawn egg at all. If you select this option, you will not find a spawn egg in the creative inventory, instead you can summon the entity using commands. Exporting  You have now entered all the information that is necessary to create the entity. The Next Steps tab allows you to select an export method to create a resource and behavior pack to load the entity into your world.  In the Blockbench desktop app, there are three ways to save your pack:  Export Packs: Create a new pack with your custom entity. Integrate into Pack: Integrate your new custom entity into an existing add-on. Export as MCAddon: Generate a .mcadd-on file and save it to your computer. You can open this file to load your add-on into Minecraft, or share this file with friends. If you select this option, you will not be able to directly edit your model in Blockbench after exporting the add-on.   Tip  In the web app, the only option available to export your pack is MCAddon.   Important  The Integrate into Pack option is only available if you have a behavior pack and a resource pack already imported in Minecraft. Upon launching Blockbench for the first time, you may not see all available export options. To quickly enable this, you can use the following steps.  Create an entity. Export to .mcaddon. double-click the .mcaddon to import it. If Minecraft is open when import has started you will need to relaunch it. If it was closed it will launch as part of the export process. Minecraft recognizes the pack exists. create another entity. After this, the third option will be accessible.  Depending on the export option you have selected, you may need to enter some information about the Add-On that the wizard is about to create.  Depending on the export option you selected, you may need to enter some information about the add-on you're creating.  Pack Name: This name will be used both for the generated file, as well as for the name in the pack menu in Minecraft.  Pack Icon: You can upload an image as an icon to represent your pack in the pack menu. The image should be a PNG file; the recommended resolution is 64 by 64 pixels. The icon is optional.  Installing the pack  To enable your packs for the first time, you need to add the behavior pack to your Minecraft world. Open the world settings and locate the Behavior Packs section. Find your new pack and activate it. Activating the behavior pack automatically activates the connected resource pack. This means that you now have the full add-on installed into your world.   Tip  You can view a detailed step-by-step walkthrough on how to enable tutorial in the Behavior Pack tutorial.  Enter the world and follow the instructions in the wizard to spawn your custom entity. Usually, you can do this by getting a spawn egg from the creative inventory and using it.   Note  Alternatively, if you have exported your add-on as a .mcaddon file, you can open this file in order to automatically add the packs into Minecraft.  Modifying your entity Model and animations  Since you are already in Blockbench, you can continue to use the program to edit the model, textures and animations. To do that, press the blue button in the bottom right called Edit Model.   Caution  This option is not available if you have exported your add-on as an .mcaddon file.  You can learn how to model and animate in this tutorial playlist: ArtsByKev Blockbench Tutorials  More information on Blockbench can be found on the Blockbench Wiki.  Editing behavior  If you want to edit the behavior and other aspects of your entity, you need to use a code editor. The wizard will present you with an option to open the packs in Visual Studio Code, a code editor that is popular for add-on development for Minecraft: Bedrock Edition. You can learn how to set up Visual Studio Code for add-on development under this link.  Custom entity behavior is a huge topic, and this article won't attempt to touch on it. Instead, here are some helpful resources to help you get started:  Introduction To Behavior Packs  To view all of the available behaviors and AI Goal Components that an entity can use, you can go to the Entity JSON Reference Documentation.  Entity JSON Documentation  What's next?  If you'd like to see another tutorial on using Blockbench with the Minecraft Entity Wizard, you can watch it on the Minecraft Creator Channel.  Tutorial Video  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftentitywizard?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with the Minecraft Entity Wizard 05/07/2025  If you're new to Minecraft add-on development, creating your first working behavior pack and custom entity can take a lot of time and research. The Minecraft Entity Wizard for Blockbench aims to make it as easy as possible to create a custom entity and to add it to your world. From there, you can build on your entity, change the model, or add your own behavior.  Building a grizzly bear with the Minecraft Entity Wizard  Blockbench is a 3D modeling program with native support for many Minecraft 3D model formats. Once you've created your basic entity in the Entity Wizard, you can continue to use Blockbench to modify the model, and you can edit the behavior in an external program (more on that later).  As a starting point, the Entity Wizard offers most of Minecraft's vanilla mobs as presets. For example, if you want to create a shark, you can choose the dolphin preset. There are also stripped down \"basic\" presets that you can use if you're a more experienced add-on creator and want to create entity behavior from scratch.  In this tutorial, you'll learn the following:  How to add the Minecraft Entity Wizard plugin to Blockbench. The steps to create a custom entity with the Wizard. How to export the entity to use within Minecraft: Bedrock Edition. Requirements  It's recommended that the following be completed before beginning this tutorial.  Getting Started with Add-On Development Introduction to Blockbench  You'll also need to either have Blockbench installed or have access to the Blockbench web app.   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Getting started  Once you've downloaded and installed Blockbench, you can directly install the Entity Wizard from within the program.   Tip  If you do not want to install the app, or you are using a mobile device like a tablet, you can also use the plugin in the Blockbench web app. Most parts of the program work the same in the web app, but saving files requires a few extra steps.  Adding the Minecraft Entity Wizard In Blockbench, go to File > Plugins..., switch to the Available tab, and enter \"Minecraft Entity Wizard\" into the search bar (or scroll until you find it in the list). Find the Entity Wizard plugin and click Install. After it's installed, close the Plugins dialog. The Wizard  You'll find the Minecraft Entity Wizard in the left sidebar of the start screen, under Loaders. Now that the plugin is installed, you can use the Minecraft Entity Wizard to start creating your entity.  Click the yellow banner on the start screen to open the wizard, or navigate to Filter and select Create Bedrock Entity. Click the Let's Go-button.  The wizard will guide you through the steps required to create your custom entity. To navigate the wizard, use the Back and Next buttons at the bottom of the screen.   Caution  You can also close the dialog and select Keep to keep your current state and inputs. However, closing Blockbench entirely will discard your input.  Name  The Display Name is the name that the entity will later be called in Minecraft. It will appear in the spawn egg name, in chat, and in other places in the interface. This name also supports translations into different languages.   Note  The Identifier is the internal name used within Minecraft that is commonly used in commands and other places to identify this type of entity.  Appearance  Select the appearance of your entity from a list of presets. The appearance includes model, texture, animations, and sounds. At a later step, you will be able to edit and modify this model in Blockbench.   Note  If you currently have a model opened inside Blockbench, you may also pick this model as your starting point.  Behavior  The behavior tab determines how your custom entity behaves and interacts with the world.   Warning  It is recommended for beginners to use the behavior from the same mob as the appearance, to avoid conflicts.  Appearance and behavior often work hand in hand. As an example, if you mix the appearance of a wolf with the behavior of a sheep (a sheep in wolf's clothing), you will quickly notice that the wolf in Minecraft does not come with a grazing animation, so it will look like the grass below them just pops off.  Spawn egg  The spawn egg tab allows you to set the spawn egg that is the item used to spawn the custom entity.  There are three ways to define the spawn egg:  Colors: Use the two-color pickers to select the background and foreground colors on the default spawn egg icon. Custom Texture: Select a custom texture for your spawn egg icon. You can create the texture in a regular image editor, such as Paint.NET or Photoshop. The image should be a PNG file, ideally with a resolution of 16 by 16 pixels and a transparent background. None: Do not generate a spawn egg at all. If you select this option, you will not find a spawn egg in the creative inventory, instead you can summon the entity using commands. Exporting  You have now entered all the information that is necessary to create the entity. The Next Steps tab allows you to select an export method to create a resource and behavior pack to load the entity into your world.  In the Blockbench desktop app, there are three ways to save your pack:  Export Packs: Create a new pack with your custom entity. Integrate into Pack: Integrate your new custom entity into an existing add-on. Export as MCAddon: Generate a .mcadd-on file and save it to your computer. You can open this file to load your add-on into Minecraft, or share this file with friends. If you select this option, you will not be able to directly edit your model in Blockbench after exporting the add-on.   Tip  In the web app, the only option available to export your pack is MCAddon.   Important  The Integrate into Pack option is only available if you have a behavior pack and a resource pack already imported in Minecraft. Upon launching Blockbench for the first time, you may not see all available export options. To quickly enable this, you can use the following steps.  Create an entity. Export to .mcaddon. double-click the .mcaddon to import it. If Minecraft is open when import has started you will need to relaunch it. If it was closed it will launch as part of the export process. Minecraft recognizes the pack exists. create another entity. After this, the third option will be accessible.  Depending on the export option you have selected, you may need to enter some information about the Add-On that the wizard is about to create.  Depending on the export option you selected, you may need to enter some information about the add-on you're creating.  Pack Name: This name will be used both for the generated file, as well as for the name in the pack menu in Minecraft.  Pack Icon: You can upload an image as an icon to represent your pack in the pack menu. The image should be a PNG file; the recommended resolution is 64 by 64 pixels. The icon is optional.  Installing the pack  To enable your packs for the first time, you need to add the behavior pack to your Minecraft world. Open the world settings and locate the Behavior Packs section. Find your new pack and activate it. Activating the behavior pack automatically activates the connected resource pack. This means that you now have the full add-on installed into your world.   Tip  You can view a detailed step-by-step walkthrough on how to enable tutorial in the Behavior Pack tutorial.  Enter the world and follow the instructions in the wizard to spawn your custom entity. Usually, you can do this by getting a spawn egg from the creative inventory and using it.   Note  Alternatively, if you have exported your add-on as a .mcaddon file, you can open this file in order to automatically add the packs into Minecraft.  Modifying your entity Model and animations  Since you are already in Blockbench, you can continue to use the program to edit the model, textures and animations. To do that, press the blue button in the bottom right called Edit Model.   Caution  This option is not available if you have exported your add-on as an .mcaddon file.  You can learn how to model and animate in this tutorial playlist: ArtsByKev Blockbench Tutorials  More information on Blockbench can be found on the Blockbench Wiki.  Editing behavior  If you want to edit the behavior and other aspects of your entity, you need to use a code editor. The wizard will present you with an option to open the packs in Visual Studio Code, a code editor that is popular for add-on development for Minecraft: Bedrock Edition. You can learn how to set up Visual Studio Code for add-on development under this link.  Custom entity behavior is a huge topic, and this article won't attempt to touch on it. Instead, here are some helpful resources to help you get started:  Introduction To Behavior Packs  To view all of the available behaviors and AI Goal Components that an entity can use, you can go to the Entity JSON Reference Documentation.  Entity JSON Documentation  What's next?  If you'd like to see another tutorial on using Blockbench with the Minecraft Entity Wizard, you can watch it on the Minecraft Creator Channel.  Tutorial Video  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/blockbench?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Blockbench 11/22/2024  What is Minecraft built out of? Well, blocks and entities and items. But behind every block or entity you might see, there is a model that provides the visual shape, and a set of textures that drape over the parts of the model model that provide the colors and features. Additionally, for entities and items, a set of animations provide the movement and gestures of the mob.  As you create new builds in Minecraft, you're going to want to provide textured models and animations. One of the best tools to create these with is Blockbench, a free and open source low-poly model editor created by Jannis Petersen. You can get started with Blockbench by visiting blockbench.net   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Blockbench Fundamentals  Blockbench is available both as a web application - you can use it in a web browser - as well as a downloadable application for Windows, Linux, or macOS.  The Blockbench web application and Blockbench downloadable app provide equivalent editing functionality, but the downloadable application makes it easier to work with files on your device. On Windows, you can directly save your work in the Minecraft folder to make it easier to test out your creations.  Whether you use a downloadable application or the web application, Blockbench has a plug-in system that makes it easy to add additional functionality to tailor it to your workflow. In particular, there is a set of wizard plugins that make starting a new Minecraft project easier:  Minecraft Entity Wizard provides a jumpstart for creating a new entity/mob based on an example from vanilla Minecraft Minecraft Item Wizard provides starters for creating a new Minecraft item Minecraft Block Wizard provides a base for creating a new block  Each of these articles contains more information on creating an entitiy, item, or block respectively.  Blockbench Concepts  As you begin to edit in Blockbench, familiarize yourself with the different aspects of the screen.  Edit Paint Animate Modes  In the upper right hand corner of the screen, you'll see Edit/Paint/Animate tabs. This lets you select the editing mode of Blockbench. In Edit mode, you can add, update, and remove the various cubes that make up the shape of the model. In Paint mode, you can edit the colors of the various pixels of the textures of your model. In Animate mode, you can adjust the animation of various sections. If you are editing a block (which in Minecraft does not support animations) you may not see an Animate tab.  As a general rule, you'll probably want to try to edit your models in these three phases: edit your cubes, then paint them, then animate it. In other words, don't paint or animate your model until you are pretty happy with the overall cube structure of your model - because significantly shifting the shape of your cubes can cause the need to rework some of your painting.  Outliner and Cube Structure  In the lower right hand corner of the Blockbench application, you will see the Outliner which lists all of the cubes in the model. Cubes are grouped into a broader tree-style hierarchy. These named groupings of cubes (referred to in Minecraft as a \"bone\") can sometimes have a special meaning and syntax - for example, the group/bone named \"head\" is automatically rotated on some mobs to provide \"look at\" behavior. These groups/bones are also the foundation for animation (you animate a group/bone, not an individual cube). For these reasons, it's a good practice to organize and name your bones and cubes as you work.  UV texture mapping  In the upper left hand corner of the Blockbench window, you'll see the UV section. UVs refer to a texture image that provides the color information for a pixel on the model. If you visualize your model as a wrapped gift in a box, think of the UV as the wrapping paper (but: flattened out). In Edit mode, you can adjust the location of where an individual cube is pulling its colors -- in the example above, you can see the head cube is selected and it is pulling the six faces from the upper left of the UV texture. In the Paint mode, you can use brushes, fills, and shapes to change the colors of the model - either directly on the model itself, or within the UV window.  Next steps: more videos and docs  One of the best ways to understand Blockbench is just to dive in! We'd recommend using the Minecraft Entity Wizard to start with a model based on an existing Minecraft mob. If you'd like to see a tutorial on using Blockbench with the Minecraft Entity Wizard, you can watch it on the Minecraft Creator Channel.  Tutorial Video  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/blockbench?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Blockbench 11/22/2024  What is Minecraft built out of? Well, blocks and entities and items. But behind every block or entity you might see, there is a model that provides the visual shape, and a set of textures that drape over the parts of the model model that provide the colors and features. Additionally, for entities and items, a set of animations provide the movement and gestures of the mob.  As you create new builds in Minecraft, you're going to want to provide textured models and animations. One of the best tools to create these with is Blockbench, a free and open source low-poly model editor created by Jannis Petersen. You can get started with Blockbench by visiting blockbench.net   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Blockbench Fundamentals  Blockbench is available both as a web application - you can use it in a web browser - as well as a downloadable application for Windows, Linux, or macOS.  The Blockbench web application and Blockbench downloadable app provide equivalent editing functionality, but the downloadable application makes it easier to work with files on your device. On Windows, you can directly save your work in the Minecraft folder to make it easier to test out your creations.  Whether you use a downloadable application or the web application, Blockbench has a plug-in system that makes it easy to add additional functionality to tailor it to your workflow. In particular, there is a set of wizard plugins that make starting a new Minecraft project easier:  Minecraft Entity Wizard provides a jumpstart for creating a new entity/mob based on an example from vanilla Minecraft Minecraft Item Wizard provides starters for creating a new Minecraft item Minecraft Block Wizard provides a base for creating a new block  Each of these articles contains more information on creating an entitiy, item, or block respectively.  Blockbench Concepts  As you begin to edit in Blockbench, familiarize yourself with the different aspects of the screen.  Edit Paint Animate Modes  In the upper right hand corner of the screen, you'll see Edit/Paint/Animate tabs. This lets you select the editing mode of Blockbench. In Edit mode, you can add, update, and remove the various cubes that make up the shape of the model. In Paint mode, you can edit the colors of the various pixels of the textures of your model. In Animate mode, you can adjust the animation of various sections. If you are editing a block (which in Minecraft does not support animations) you may not see an Animate tab.  As a general rule, you'll probably want to try to edit your models in these three phases: edit your cubes, then paint them, then animate it. In other words, don't paint or animate your model until you are pretty happy with the overall cube structure of your model - because significantly shifting the shape of your cubes can cause the need to rework some of your painting.  Outliner and Cube Structure  In the lower right hand corner of the Blockbench application, you will see the Outliner which lists all of the cubes in the model. Cubes are grouped into a broader tree-style hierarchy. These named groupings of cubes (referred to in Minecraft as a \"bone\") can sometimes have a special meaning and syntax - for example, the group/bone named \"head\" is automatically rotated on some mobs to provide \"look at\" behavior. These groups/bones are also the foundation for animation (you animate a group/bone, not an individual cube). For these reasons, it's a good practice to organize and name your bones and cubes as you work.  UV texture mapping  In the upper left hand corner of the Blockbench window, you'll see the UV section. UVs refer to a texture image that provides the color information for a pixel on the model. If you visualize your model as a wrapped gift in a box, think of the UV as the wrapping paper (but: flattened out). In Edit mode, you can adjust the location of where an individual cube is pulling its colors -- in the example above, you can see the head cube is selected and it is pulling the six faces from the upper left of the UV texture. In the Paint mode, you can use brushes, fills, and shapes to change the colors of the model - either directly on the model itself, or within the UV window.  Next steps: more videos and docs  One of the best ways to understand Blockbench is just to dive in! We'd recommend using the Minecraft Entity Wizard to start with a model based on an existing Minecraft mob. If you'd like to see a tutorial on using Blockbench with the Minecraft Entity Wizard, you can watch it on the Minecraft Creator Channel.  Tutorial Video  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftitemwizard?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with the Minecraft Item Wizard 04/21/2025  The Minecraft Item Wizard is a plugin for Blockbench. It allows you to add a custom item to Minecraft without any coding experience or knowledge of the addon system. It does this by generating an addon on your computer, which you can add to your world.  After you have created a custom item with the Wizard, you can use Blockbench to design a custom 3D model for it.  The plugin works similarly to the Minecraft Entity Wizard and the Minecraft Block Wizard.  Demonstration: How to Make a Custom Item  This video shows how to make a custom item with Minecraft Item Wizard.  In this tutorial, you will learn how to:  Add the Minecraft Item Wizard plugin to Blockbench Create a custom item with the Wizard Export the item for use within Minecraft: Bedrock Edition Requirements  To get started, you need the following:  An installation of Blockbench Minecraft Bedrock Edition A Windows computer (or an Android device)   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Getting Started  The first step is to install the Item Wizard plugin.  In Blockbench, go to File > Plugins..., switch to the Available tab, and enter \"Minecraft Item Wizard\" into the search bar. Find the Item Wizard plugin and select Install. Close the Plugins dialog. After it has installed, you will find the Minecraft Item Wizard in the left sidebar of your start screen. Select it, then press Create an Item!  Next time you want to use it, you can open the Item Wizard from the menu via Tools > Minecraft Item Wizard or from the center of the start screen.  Tutorial: Making a Glass Sword  This tutorial starts with something familiar, but nonexistant in vanilla Minecraft: a sword made of glass!  Preset  On the first page of the Item Wizard, you can select a preset item to use as starting point for your own custom item.  Select the Sword preset item and click Next. Naming  This is where we enter the meta data for the item. The required fields are Display Name, Identifier, and Creative Category. Stack Size is also on this page, but it is not required.  Display Name: The item's name that will be displayed in the inventory and in other places within the interface.  To keep things simple, let's name it Glass Sword.  Identifier: The identifier of the item will be used internally, like with the /give command. The identifier needs to start with a namespace such as your own name or the name of your project or addon packs. All items that Minecraft comes with by default have the namespace minecraft:, so you can't use that one. That namespace is reserved for vanilla Minecraft entities.  Enter an identifier like this: myname:glass_sword.  Stack Size: How many items can fit in one stack.  To keep this sword like other swords in Minecraft, Stack Size should be set to 1.  Creative Category: Select the tab of the creative inventory where you want your item to appear. You can also select a sub-group to add your item to in one of the foldable groups within an inventory tab.  Swords are Equipment (by default) so let's leave it there and select Swords as the sub-group.  Click Next.  Functionality  Different preset items have different Functionality settings.  This is the page for the Sword preset, with some options already selected for you.  Melee Attack: Use the weapon to attack mobs.  Yes. Because we want to use this like any other sword, Melee Attack should be checked.  Damage: If the item can be used to damage mobs, set that level here.  For the glass sword, set the Damage level all the way up to 20.  Break Blocks: Check this box if the item is intended to be used to break specific blocks.  Wearable: Check this box if the item is intended to be worn by the player.  Leave Break Blocks and Wearable unchecked.  Durability: Item loses some durability every time it is used, until it breaks.  To make our glass sword act like a sword made out of fragile glass, let's set the durability to 3.  Repair Item: If you want to be able to repair your sword, this is where you set which material should be used.  Click the drop-down menu and enter \"glass\" in the search field. Select \"Glass.\"   Note  If you want to make your item repairable with more than one material, you can add items in the repair_items section of the glass_sword.item.json file in the behavior pack like this:  JSON Copy \"minecraft:repairable\": {  \"repair_items\": [    {      \"items\": [\"glass\", \"sand\"],        \"repair_amount\": 3    }  ] }   Repair Amount: Set the precentage of how much one unit of material will repair your item.  Let's encourage players to re-use glass by setting this to 100%.  Food: Allow players to eat the item.  Furnace Fuel: Check this if you want to be able to burn the item in a furnace like wood or coal.  Place Entity: Check this if you want to be able to place an entity on the ground.  Leave Food, Furnace Fuel, and Place Entity unchecked.  Click Next.  Design  On this page, you have the Handheld Item Model option and the option to add an Icon Glint.  Handheld Item Model: Do you want to create a handheld model for your item, or just use the 2D icon? In the inventory and on the ground it will use the icon either way.  Select Icon + 3D Model.  Icon Glint: Select this option if you want to display the 2D icon with a shimmery glint, like it's enchanted.  Leave Icon Glint unchecked so you can see the model you create without any enchantments on it.  Click Next.  Export  We're almost there!  You can choose Export to Folder, to export the packs directly into the development pack folders of your Minecraft installation, or Export as MCAddon to generate an MCAddon file that you can install in one click or send to your friends.  Choose Export to Folder.  Pack Name: (Required) The name of the packs you are exporting. This name will be used both for the generated file, as well as for the name in the pack menu in Minecraft.  Enter a Pack Name. You can use the identifier from the Naming screen.  Pack Author(s): You can enter your name as the author of the pack. To enter multiple names, separate them with a comma.  Pack Icon: You can upload an image as an icon to represent your pack in the pack menu. The image should be a .png file and the recommended resolution is 64 by 64 pixels.  Enter author names and give your pack an icon if you want to.  Click Next.  Next Steps  Blockbench creates your packs and saves them in your com.mojang folder, in the development_behavior_packs and development_resource_packs, respectively.  You should see an \"Export Successful\" message from Blockbench.  Click Next. Editing the 3D Model  Because you are already in Blockbench, you can continue to use the program to edit the model and texture.   Caution  This option is not available if you have exported your addon as an .mcaddon file.  You can learn how to create a model in this tutorial playlist: ArtsByKev Blockbench Tutorials  More information on Blockbench can be found on the Blockbench Wiki.  Starting with the familiar sword model...  ... let's give it rainbow colors, like a prism!  Go to File > Save Model. Editing the 2D Icon  Starting with the sword icon...  ... let's make it look more like the glass sword model!  Go to File > Save Model. Installing the pack  To enable your packs for the first time, you need to add the behavior pack to your Minecraft world. Open the world settings and locate the behavior packs section. Find your new pack and activate it. Activating the behavior pack will also automatically activate the connected resource pack. This means that you now have the full addon installed into your world.   Tip  You can view a detailed step-by-step walkthrough on how to enable tutorial in the Behavior Pack tutorial.  Enter the world and locate the custom item in your creative inventory. Alternatively, if you didn't choose to add your item to a creative inventory tab, you can get it using the /give command.   Note  Alternatively, if you have exported your addon as a .mcaddon file, you can open this file in order to automatically add the packs into Minecraft.  Let's Try it Out!  Launch Minecraft and go a Survival world with cheats toggled on.  Give yourself a sword. You will need to enter the whole name, like \"myname:glass_sword\".  /give @s myname:glass_sword  Try it out! Remember, we made it high damage and low durability.   Note  Using items in creative mode does not consume durability, so make sure you are in survival mode to test this.  Try repairing it, too!  What's Next?  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftitemwizard?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with the Minecraft Item Wizard 04/21/2025  The Minecraft Item Wizard is a plugin for Blockbench. It allows you to add a custom item to Minecraft without any coding experience or knowledge of the addon system. It does this by generating an addon on your computer, which you can add to your world.  After you have created a custom item with the Wizard, you can use Blockbench to design a custom 3D model for it.  The plugin works similarly to the Minecraft Entity Wizard and the Minecraft Block Wizard.  Demonstration: How to Make a Custom Item  This video shows how to make a custom item with Minecraft Item Wizard.  In this tutorial, you will learn how to:  Add the Minecraft Item Wizard plugin to Blockbench Create a custom item with the Wizard Export the item for use within Minecraft: Bedrock Edition Requirements  To get started, you need the following:  An installation of Blockbench Minecraft Bedrock Edition A Windows computer (or an Android device)   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Getting Started  The first step is to install the Item Wizard plugin.  In Blockbench, go to File > Plugins..., switch to the Available tab, and enter \"Minecraft Item Wizard\" into the search bar. Find the Item Wizard plugin and select Install. Close the Plugins dialog. After it has installed, you will find the Minecraft Item Wizard in the left sidebar of your start screen. Select it, then press Create an Item!  Next time you want to use it, you can open the Item Wizard from the menu via Tools > Minecraft Item Wizard or from the center of the start screen.  Tutorial: Making a Glass Sword  This tutorial starts with something familiar, but nonexistant in vanilla Minecraft: a sword made of glass!  Preset  On the first page of the Item Wizard, you can select a preset item to use as starting point for your own custom item.  Select the Sword preset item and click Next. Naming  This is where we enter the meta data for the item. The required fields are Display Name, Identifier, and Creative Category. Stack Size is also on this page, but it is not required.  Display Name: The item's name that will be displayed in the inventory and in other places within the interface.  To keep things simple, let's name it Glass Sword.  Identifier: The identifier of the item will be used internally, like with the /give command. The identifier needs to start with a namespace such as your own name or the name of your project or addon packs. All items that Minecraft comes with by default have the namespace minecraft:, so you can't use that one. That namespace is reserved for vanilla Minecraft entities.  Enter an identifier like this: myname:glass_sword.  Stack Size: How many items can fit in one stack.  To keep this sword like other swords in Minecraft, Stack Size should be set to 1.  Creative Category: Select the tab of the creative inventory where you want your item to appear. You can also select a sub-group to add your item to in one of the foldable groups within an inventory tab.  Swords are Equipment (by default) so let's leave it there and select Swords as the sub-group.  Click Next.  Functionality  Different preset items have different Functionality settings.  This is the page for the Sword preset, with some options already selected for you.  Melee Attack: Use the weapon to attack mobs.  Yes. Because we want to use this like any other sword, Melee Attack should be checked.  Damage: If the item can be used to damage mobs, set that level here.  For the glass sword, set the Damage level all the way up to 20.  Break Blocks: Check this box if the item is intended to be used to break specific blocks.  Wearable: Check this box if the item is intended to be worn by the player.  Leave Break Blocks and Wearable unchecked.  Durability: Item loses some durability every time it is used, until it breaks.  To make our glass sword act like a sword made out of fragile glass, let's set the durability to 3.  Repair Item: If you want to be able to repair your sword, this is where you set which material should be used.  Click the drop-down menu and enter \"glass\" in the search field. Select \"Glass.\"   Note  If you want to make your item repairable with more than one material, you can add items in the repair_items section of the glass_sword.item.json file in the behavior pack like this:  JSON Copy \"minecraft:repairable\": {  \"repair_items\": [    {      \"items\": [\"glass\", \"sand\"],        \"repair_amount\": 3    }  ] }   Repair Amount: Set the precentage of how much one unit of material will repair your item.  Let's encourage players to re-use glass by setting this to 100%.  Food: Allow players to eat the item.  Furnace Fuel: Check this if you want to be able to burn the item in a furnace like wood or coal.  Place Entity: Check this if you want to be able to place an entity on the ground.  Leave Food, Furnace Fuel, and Place Entity unchecked.  Click Next.  Design  On this page, you have the Handheld Item Model option and the option to add an Icon Glint.  Handheld Item Model: Do you want to create a handheld model for your item, or just use the 2D icon? In the inventory and on the ground it will use the icon either way.  Select Icon + 3D Model.  Icon Glint: Select this option if you want to display the 2D icon with a shimmery glint, like it's enchanted.  Leave Icon Glint unchecked so you can see the model you create without any enchantments on it.  Click Next.  Export  We're almost there!  You can choose Export to Folder, to export the packs directly into the development pack folders of your Minecraft installation, or Export as MCAddon to generate an MCAddon file that you can install in one click or send to your friends.  Choose Export to Folder.  Pack Name: (Required) The name of the packs you are exporting. This name will be used both for the generated file, as well as for the name in the pack menu in Minecraft.  Enter a Pack Name. You can use the identifier from the Naming screen.  Pack Author(s): You can enter your name as the author of the pack. To enter multiple names, separate them with a comma.  Pack Icon: You can upload an image as an icon to represent your pack in the pack menu. The image should be a .png file and the recommended resolution is 64 by 64 pixels.  Enter author names and give your pack an icon if you want to.  Click Next.  Next Steps  Blockbench creates your packs and saves them in your com.mojang folder, in the development_behavior_packs and development_resource_packs, respectively.  You should see an \"Export Successful\" message from Blockbench.  Click Next. Editing the 3D Model  Because you are already in Blockbench, you can continue to use the program to edit the model and texture.   Caution  This option is not available if you have exported your addon as an .mcaddon file.  You can learn how to create a model in this tutorial playlist: ArtsByKev Blockbench Tutorials  More information on Blockbench can be found on the Blockbench Wiki.  Starting with the familiar sword model...  ... let's give it rainbow colors, like a prism!  Go to File > Save Model. Editing the 2D Icon  Starting with the sword icon...  ... let's make it look more like the glass sword model!  Go to File > Save Model. Installing the pack  To enable your packs for the first time, you need to add the behavior pack to your Minecraft world. Open the world settings and locate the behavior packs section. Find your new pack and activate it. Activating the behavior pack will also automatically activate the connected resource pack. This means that you now have the full addon installed into your world.   Tip  You can view a detailed step-by-step walkthrough on how to enable tutorial in the Behavior Pack tutorial.  Enter the world and locate the custom item in your creative inventory. Alternatively, if you didn't choose to add your item to a creative inventory tab, you can get it using the /give command.   Note  Alternatively, if you have exported your addon as a .mcaddon file, you can open this file in order to automatically add the packs into Minecraft.  Let's Try it Out!  Launch Minecraft and go a Survival world with cheats toggled on.  Give yourself a sword. You will need to enter the whole name, like \"myname:glass_sword\".  /give @s myname:glass_sword  Try it out! Remember, we made it high damage and low durability.   Note  Using items in creative mode does not consume durability, so make sure you are in survival mode to test this.  Try repairing it, too!  What's Next?  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftblockwizard?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with the Minecraft Block Wizard 05/07/2025  The Minecraft Block Wizard, a plugin for Blockbench, lets you add a custom block to Minecraft without any coding experience. It makes it easy as possible to generate the block and add it to your world. After you've created your custom block, you can use Blockbench to customize it. The plugin works similarly to the Minecraft Entity Wizard, which lets you create custom entities.  Demonstration: how to make a custom block  This video shows how to make a custom block with Minecraft Block Wizard.  In this tutorial, you'll learn the following:  How to add the Minecraft Block Wizard plugin to Blockbench. The steps to create a custom block with the Wizard. How to export the block for use within Minecraft: Bedrock Edition. Requirements  To get started, you need the following:  An installation of Blockbench Minecraft Bedrock Edition A Windows computer (or an Android device)   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Getting started  The first step is to install the Block Wizard plugin.  In Blockbench, go to File > Plugins..., switch to the Available tab, and enter \"Minecraft Block Wizard\" into the search bar (or scroll until you find it in the list). Find the Block Wizard plugin and click Install. After it's installed, close the Plugins dialog. You'll find the Minecraft Block Wizard in the left sidebar of the start screen, under Loaders. Select it, then click Create a Block!  Next time you want to use it, you can open the Block Wizard from the menu via Tools > Minecraft Block Wizard.  Metadata  On the first page of the Block Wizard, enter the metadata for the block. This includes the name, ID, and creative inventory category. The name and ID fields are required.  Name: The name of your block will be displayed in the inventory and in other places in the interface.  Identifier: The ID of the block will be used internally, for example in commands. The identifier needs to start with a namespace, a short identifier of your or your project. This is useful to distinguish your own block from blocks with the same purpose, but from another add-on, if you are using multiple add-ons in your world. All blocks that Minecraft comes with by default have the namespace minecraft:. That namespace is reserved for vanilla blocks. Your ID may look like this: my_add-on:my_block.  Creative Category: Select the tab of the creative inventory that your block will appear in. You can also select a sub-group to add your block to one of the foldable groups within an inventory tab. If you select None, your block will not appear in the creative inventory and you will only be able to get it by using commands.  Preset  On this page, you can select a preset to base your block on. The preset will pre-configure all your options to be like a specific Minecraft block, but you can also change all options individually later.  Properties  On this page you can set the basic properties of your block.  Mineable: Enable this to allow players to mine the block in survival mode. When enabled, you can also set the destroy time, which is the time it takes to destroy the block, in seconds. Right next to that, you can see a little animation that previews how fast the block can be mined. Different mining speeds for different tools such as pick axes are not available at the moment.  Explodable: When enabled, the block can be destroyed by explosions. You can also define the explosion resistance. The higher you set the resistance, the closer the block can be to an explosion without getting destroyed.  Friction: The friction value determines how much the player's feet will stick to the ground when walking on the custom block. Lower friction values will make the block slippery, like ice. The default value of 0.6 will feel normal. Higher friction values will reduce the walk speed on the block.  Flammable: When enabled, the block can catch fire and burn.  Fire Catch Chance: The chance that the block will catch on fire when it's next to an open fire. For reference, the value for normal wood is 5. Higher chances will make the block catch on fire faster.  Fire Destroy Chance: The chance that fire on the block will destroy the block itself. For reference, the value for normal wood is 20. Higher values increase the likelihood of the block being destroyed by fire. If you set the value to 0, the fire on the block will burn forever.  Design  On this page, you can change multiple properties related to the design and sound of the block.  Use current model: This option appears when you already have a bedrock block model currently opened in Blockbench. You can enable the checkbox to export the current model, instead of using the model of the preset block that you selected.  Light Emission: This slider turns your block into a light source. The brightest possible value is 15, which is the equivalent of glow stone.  Light Dampening: Sets how much the block dampens the light that passes through it. A mostly transparent block like a button has a value of 0. A solid block like stone has a value of 15, and blocks all light from coming through. Blocks that let some light through, such as leaves, are somewhere in between.  Transparency: This option determines how transparent textures are rendered:  Allow Transparency (Alpha Test): This option lets you use either fully opaque or fully transparent pixels. The option is great for models like plants. Allow Translucency (Blend): This option lets you use fully transparent, fully opaque, or partially transparent pixels. Partially transparent pixels can be good for see-through materials like water or slime. However, the material has a slightly larger impact on performance and sometimes causes unexpected visual glitches, so only use this option when necessary. No Transparency (Opaque): With this option, the texture will be rendered as opaque. Transparent pixels will look black instead. This option is good for models with solid elements, like rocks and chairs.  Map Color: Pick the color that your block will have when displayed on a map in Minecraft. This is the map that can be crafted from paper and a compass.  Sound: Select the sound preset for your block. This will affect all sounds that can be produced when interacting with the block, including the sounds for placing, walking over, or mining the block. For most blocks it should be enough to select a preset of a vanilla block. If you have experience with sound design, you can also implement your own sounds later on.  Export  You have now entered all the information that is necessary to create the block. The Export page allows you to select an export method to create a resource and behavior pack to load the block into your world.  In the Blockbench desktop app, there are three ways to save your pack:  Export Packs: Create a new pack with your custom block. Integrate into Pack: Integrate your new custom block into an existing add-on. Export as MCAddon: Generate a .mcaddon file and save it to your computer. You can open this file to load your add-on into Minecraft, or share this file with friends. If you select this option, you will not be able to directly edit your model in Blockbench after exporting the add-on.   Tip  In the web app, the only option available to export your pack is MCAddon.  Depending on the export option you selected, you may need to enter some information about the add-on you're creating.  Pack Name: This name will be used both for the generated file, as well as for the name in the pack menu in Minecraft.  Pack Icon: You can upload an image as an icon to represent your pack in the pack menu. The image should be a PNG file; the recommended resolution is 64 by 64 pixels. The icon is optional.  Installing the pack  To enable your packs for the first time, you need to add the behavior pack to your Minecraft world. Open the world settings and locate the Behavior Packs section. Find your new pack and activate it. Activating the behavior pack automatically activates the connected resource pack. This means that you now have the full add-on installed into your world.   Tip  You can view a detailed step-by-step walkthrough on how to enable your pack in the Behavior Pack tutorial.  Enter the world and locate the custom block in your creative inventory. Alternatively, if you didn't choose to add your block to a creative inventory tab, you can get it using the /setblock and /give commands.   Note  Alternatively, if you have exported your add-on as a .mcaddon file, you can open this file in order to automatically add the packs into Minecraft.  Modifying your block Model editing  Because you are already in Blockbench, you can continue to use the program to edit the model and texture. To do that, press the Edit Model button in the bottom right.   Caution  This option is not available if you have exported your add-on as an .mcadd-on file.  You can learn how to create a model in this tutorial playlist: ArtsByKev Blockbench Tutorials  More information on Blockbench can be found on the Blockbench Wiki.  Size restrictions  Unlike entity models, block models are restricted to a certain size.  The model can be up to 30 pixels long, wide, and tall. A regular Minecraft block measures 16 by 16 by 16 pixels. From that center block, you can expand by 14 pixels on each of the 3 axes. The 14 pixels can be all towards one side, split evenly between the two sides (7 on each), or anything in between.  Blockbench will automatically restrict you from placing cubes outside of these size restrictions. The restrictions in Blockbench can be disabled in the settings (Deactivate Size Limit) if you prefer to model without them. But make sure to re-enable the restrictions before exporting, otherwise Minecraft won't load the model.  Texture  Block preset models are generated with a simple texture that is applied to all 6 sides of the element. Drawing on one side will also affect the other sides. When you start to design a more complex model, you will quickly find that the texture is no longer enough for the model.  To solve this, press Ctrl + A to select all elements of your model, then click the Create Texture button at the top of the Textures panel in the left sidebar. Confirm the dialog to generate a texture. You can switch to Paint mode by clicking \"Paint\" in the top right corner of the program, and then use the paint tools to texture your model. After you add new elements, you can automatically include them in your texture by clicking Append Elements to Template in the Textures panel. When saving your new texture, don't forget to overwrite the old texture file in your resource pack so that Minecraft knows where to look for it. What's next?  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftblockwizard?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with the Minecraft Block Wizard 05/07/2025  The Minecraft Block Wizard, a plugin for Blockbench, lets you add a custom block to Minecraft without any coding experience. It makes it easy as possible to generate the block and add it to your world. After you've created your custom block, you can use Blockbench to customize it. The plugin works similarly to the Minecraft Entity Wizard, which lets you create custom entities.  Demonstration: how to make a custom block  This video shows how to make a custom block with Minecraft Block Wizard.  In this tutorial, you'll learn the following:  How to add the Minecraft Block Wizard plugin to Blockbench. The steps to create a custom block with the Wizard. How to export the block for use within Minecraft: Bedrock Edition. Requirements  To get started, you need the following:  An installation of Blockbench Minecraft Bedrock Edition A Windows computer (or an Android device)   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering.  Getting started  The first step is to install the Block Wizard plugin.  In Blockbench, go to File > Plugins..., switch to the Available tab, and enter \"Minecraft Block Wizard\" into the search bar (or scroll until you find it in the list). Find the Block Wizard plugin and click Install. After it's installed, close the Plugins dialog. You'll find the Minecraft Block Wizard in the left sidebar of the start screen, under Loaders. Select it, then click Create a Block!  Next time you want to use it, you can open the Block Wizard from the menu via Tools > Minecraft Block Wizard.  Metadata  On the first page of the Block Wizard, enter the metadata for the block. This includes the name, ID, and creative inventory category. The name and ID fields are required.  Name: The name of your block will be displayed in the inventory and in other places in the interface.  Identifier: The ID of the block will be used internally, for example in commands. The identifier needs to start with a namespace, a short identifier of your or your project. This is useful to distinguish your own block from blocks with the same purpose, but from another add-on, if you are using multiple add-ons in your world. All blocks that Minecraft comes with by default have the namespace minecraft:. That namespace is reserved for vanilla blocks. Your ID may look like this: my_add-on:my_block.  Creative Category: Select the tab of the creative inventory that your block will appear in. You can also select a sub-group to add your block to one of the foldable groups within an inventory tab. If you select None, your block will not appear in the creative inventory and you will only be able to get it by using commands.  Preset  On this page, you can select a preset to base your block on. The preset will pre-configure all your options to be like a specific Minecraft block, but you can also change all options individually later.  Properties  On this page you can set the basic properties of your block.  Mineable: Enable this to allow players to mine the block in survival mode. When enabled, you can also set the destroy time, which is the time it takes to destroy the block, in seconds. Right next to that, you can see a little animation that previews how fast the block can be mined. Different mining speeds for different tools such as pick axes are not available at the moment.  Explodable: When enabled, the block can be destroyed by explosions. You can also define the explosion resistance. The higher you set the resistance, the closer the block can be to an explosion without getting destroyed.  Friction: The friction value determines how much the player's feet will stick to the ground when walking on the custom block. Lower friction values will make the block slippery, like ice. The default value of 0.6 will feel normal. Higher friction values will reduce the walk speed on the block.  Flammable: When enabled, the block can catch fire and burn.  Fire Catch Chance: The chance that the block will catch on fire when it's next to an open fire. For reference, the value for normal wood is 5. Higher chances will make the block catch on fire faster.  Fire Destroy Chance: The chance that fire on the block will destroy the block itself. For reference, the value for normal wood is 20. Higher values increase the likelihood of the block being destroyed by fire. If you set the value to 0, the fire on the block will burn forever.  Design  On this page, you can change multiple properties related to the design and sound of the block.  Use current model: This option appears when you already have a bedrock block model currently opened in Blockbench. You can enable the checkbox to export the current model, instead of using the model of the preset block that you selected.  Light Emission: This slider turns your block into a light source. The brightest possible value is 15, which is the equivalent of glow stone.  Light Dampening: Sets how much the block dampens the light that passes through it. A mostly transparent block like a button has a value of 0. A solid block like stone has a value of 15, and blocks all light from coming through. Blocks that let some light through, such as leaves, are somewhere in between.  Transparency: This option determines how transparent textures are rendered:  Allow Transparency (Alpha Test): This option lets you use either fully opaque or fully transparent pixels. The option is great for models like plants. Allow Translucency (Blend): This option lets you use fully transparent, fully opaque, or partially transparent pixels. Partially transparent pixels can be good for see-through materials like water or slime. However, the material has a slightly larger impact on performance and sometimes causes unexpected visual glitches, so only use this option when necessary. No Transparency (Opaque): With this option, the texture will be rendered as opaque. Transparent pixels will look black instead. This option is good for models with solid elements, like rocks and chairs.  Map Color: Pick the color that your block will have when displayed on a map in Minecraft. This is the map that can be crafted from paper and a compass.  Sound: Select the sound preset for your block. This will affect all sounds that can be produced when interacting with the block, including the sounds for placing, walking over, or mining the block. For most blocks it should be enough to select a preset of a vanilla block. If you have experience with sound design, you can also implement your own sounds later on.  Export  You have now entered all the information that is necessary to create the block. The Export page allows you to select an export method to create a resource and behavior pack to load the block into your world.  In the Blockbench desktop app, there are three ways to save your pack:  Export Packs: Create a new pack with your custom block. Integrate into Pack: Integrate your new custom block into an existing add-on. Export as MCAddon: Generate a .mcaddon file and save it to your computer. You can open this file to load your add-on into Minecraft, or share this file with friends. If you select this option, you will not be able to directly edit your model in Blockbench after exporting the add-on.   Tip  In the web app, the only option available to export your pack is MCAddon.  Depending on the export option you selected, you may need to enter some information about the add-on you're creating.  Pack Name: This name will be used both for the generated file, as well as for the name in the pack menu in Minecraft.  Pack Icon: You can upload an image as an icon to represent your pack in the pack menu. The image should be a PNG file; the recommended resolution is 64 by 64 pixels. The icon is optional.  Installing the pack  To enable your packs for the first time, you need to add the behavior pack to your Minecraft world. Open the world settings and locate the Behavior Packs section. Find your new pack and activate it. Activating the behavior pack automatically activates the connected resource pack. This means that you now have the full add-on installed into your world.   Tip  You can view a detailed step-by-step walkthrough on how to enable your pack in the Behavior Pack tutorial.  Enter the world and locate the custom block in your creative inventory. Alternatively, if you didn't choose to add your block to a creative inventory tab, you can get it using the /setblock and /give commands.   Note  Alternatively, if you have exported your add-on as a .mcaddon file, you can open this file in order to automatically add the packs into Minecraft.  Modifying your block Model editing  Because you are already in Blockbench, you can continue to use the program to edit the model and texture. To do that, press the Edit Model button in the bottom right.   Caution  This option is not available if you have exported your add-on as an .mcadd-on file.  You can learn how to create a model in this tutorial playlist: ArtsByKev Blockbench Tutorials  More information on Blockbench can be found on the Blockbench Wiki.  Size restrictions  Unlike entity models, block models are restricted to a certain size.  The model can be up to 30 pixels long, wide, and tall. A regular Minecraft block measures 16 by 16 by 16 pixels. From that center block, you can expand by 14 pixels on each of the 3 axes. The 14 pixels can be all towards one side, split evenly between the two sides (7 on each), or anything in between.  Blockbench will automatically restrict you from placing cubes outside of these size restrictions. The restrictions in Blockbench can be disabled in the settings (Deactivate Size Limit) if you prefer to model without them. But make sure to re-enable the restrictions before exporting, otherwise Minecraft won't load the model.  Texture  Block preset models are generated with a simple texture that is applied to all 6 sides of the element. Drawing on one side will also affect the other sides. When you start to design a more complex model, you will quickly find that the texture is no longer enough for the model.  To solve this, press Ctrl + A to select all elements of your model, then click the Create Texture button at the top of the Textures panel in the left sidebar. Confirm the dialog to generate a texture. You can switch to Paint mode by clicking \"Paint\" in the top right corner of the program, and then use the paint tools to texture your model. After you add new elements, you can automatically include them in your texture by clicking Append Elements to Template in the Textures panel. When saving your new texture, don't forget to overwrite the old texture file in your resource pack so that Minecraft knows where to look for it. What's next?  Want to learn more about building with Blockbench? The Blockbench Wiki has step by step guides and reference documentation for modeling, texturing, and animating any custom creation you can imagine.  Blockbench Wiki  The Blockbench Quick Start guide can help lead you to the specific document that you're looking for and is a great way to discover relevant external guides and videos.  Blockbench Quick Start  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/particleeffects?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Particle Effects 09/21/2023  From firework rockets leaving smoke behind to bubbles coming out of a fish's mouth, particles are a great way to add special effects to content within Minecraft: Bedrock Edition.  In this tutorial you will learn:  How to create custom particle effects in Minecraft: Bedrock Edition. How to make a new particle effect.  You'll also use Snowstorm - a community tool that will make editing particle effects much easier!  Requirements  It is recommended that the following be completed before beginning this tutorial:  Introduction to Resource Packs Introduction  Particles can greatly enhance the visual experience of a map or add-on, for effects such as exhaust smoke or magic spells. Particles can be used for ambiance effects like falling leaves, or even to place simple 2D graphics in your world.  Naming and Location  Bedrock uses a custom JSON format for particle effects. Files are stored in the particles folder of a resource pack. Similar to models and entities, particles are referenced by their identifier, so the file can be saved in any subfolder inside the particles folder without having to reference it.  The particle identifier is specified at the top of the JSON file, and consists of a namespace and name, such as sample:colored_smoke.  JSON Copy     \"description\": {     \"identifier\": \"sample:colored_smoke\",     },  Units  All values in particle effects use meters (blocks) and seconds as units. Velocity is stated as meters per second (m/s) and acceleration is meters per second squared (m/s²). Rotations use degrees for both rotations and trigonometric functions.  Snowstorm  We'll be using Snowstorm to create the particle effects in this guide. Snowstorm can be used as a web app or as an extension for VSCode. It allows users to preview the particle effect live while changing parameters. The web app is useful for beginners, while the VSCode extension offers a faster process for working with multiple particle effects.  Interface  Snowstorm includes a 3D preview section, sidebar organized by section tab buttons, a menu bar, and an expression bar below the menu.  Across the tabs and into the sidebar, you'll see the parameters and settings that make up a particle.  The first tab is the \"Quick Setup\" tab, which allows you to select from a set of pre-set motions, timings, and physics configurations.  Within the sidebar, many of the fields support Molang, which means static numbers can be added, but for more control over the value, mathematical expressions that use Molang can be used. Hovering over a field will cause a description of the field to appear.  If you end up with a complex Molang expression, it can be edited in the expression bar below the menu.  The menu bar is where files can be imported and exported in the web app, examples can be loaded, and references can be reviewed.  Below the expression bar is the preview screen. To navigate in the 3D space, use the left and right mouse button, as well as the mouse wheel; the buttons below can be used to start or pause the preview. Finally, in the bottom right corner is the FPS and the current number of particles in the scene.  Import and Export  In the web app, files have to be imported and exported via the File menu. To see the markup for the file, switch to the Code tab in the top right corner of the window.  If using custom textures, they must be loaded individually in the Textures section of the sidebar.  If using the VSCode extension, create a new file named <name>.particle.json in the particles folder, and VSCode will open it with the Snowstorm editor automatically. Clicking Open Code in the top right corner will preview the generated code in a new tab, and the code can be edited here directly as well.  Creating a Particle Effect  In this guide, we'll create a colored smoke effect step-by-step.   Note  The Quick Setup tab in Snowstorm provides an easy way to get started with custom particle effects, but in this tutorial we'll take a more leisurely tour through various Snowstorm settings areas.  To begin, open Snowstorm and locate the meta section in the sidebar. Type in the identifier of the particle effect – we'll use sample:colored_smoke.  Emitter  Next, we'll change the emitter. The emitter is the centerpiece of the particle effect and is responsible for spawning particles. To start, we need to open the Rate section and define how many particles are spawned. Leave the mode setting at Steady, which means that the emitter will constantly spawn particles, set the rate to 30, and the maximum to 100. This means that the emitter will spawn 30 particles per second over its lifetime as long as no more than 100 particles from this emitter exist in the world.  Now that the rate is set, it's time to define the emitter lifetime. We want to only play this particle effect once, but if you need a constant emitter, you can do so by setting it to looping. For this effect, set the Active Time to 2, which means that the emitter will spawn particles for two seconds.  By default, particles will spawn at a single point at the center of the emitter. This is fine for our particle effect, so no changes are required in the Shape section.  Particle Size  All particles are a 2D plane with a texture applied to it. In the size settings, the width and height of this plane can be defined, where each value is the radius. This means that setting the size to 1 by 1 would make it 2 by 2 blocks. We will use 0.25 by 0.25 in this example.  Particle motion and physics  The next step is to define how the particles move. In the Motion section, leave the Direction mode set to Outwards. For point emitters, this means the particles will spread to all directions equally.  Now that the particle has an initial direction, let's change the speed. In the Motion section, set the Speed to math.random(2, 4). This is a simple math expression that will output a random decimal from 2 to 4. The speed is calculated when the particle is spawned, so now each of our particles will have a random start speed.  Acceleration defines forces that act on the particle after it's spawned. For example, to simulate gravity on Earth, you would set the middle value (Y axis) to -9.8. For our smoke we'll use 0, 3, 0 as the acceleration to show a slow upwards movement.  The acceleration will make the particle exponentially faster. To make them slow down eventually and keep them in one space, we will add air drag, which will gently slow the acceleration when the particle reaches its terminal speed. We'll set this to 2.  To give the air drag more variation, we will randomize this value using a built-in variable. Each particle and each emitter will automatically have 4 random variables assigned that won't change over its lifetime. The variables contain a random number from 0 to 1. To achieve a random air drag value from 2 to 3, we'll set the value to 2 + variable.particle_random_1.  Particle Lifetime  Next, we will define how long the particles exist in the world. To get a slow fade-out effect, we'll randomize this number. Since the Max Age is only evaluated when the particle spawns, we can achieve this by setting the value to math.random(1, 3).  Texture  It is possible to create your own particle texture and save it in the textures folder of the resource pack. For simplicity, we'll use the default Minecraft particle sprite. To reference this texture, type textures/particle/particles into the Path field of the Texture section. The texture will be loaded automatically and show in game even if it's not in your current texture pack, since it will default to the vanilla version of the texture.  The particle texture we will use is the largest smoke particle. To animate the texture to gradually move to smaller smoke particle sizes, set the UV Mode to Animated.  The whole texture map, which includes textures for all particles, has a resolution of 128 x 128 pixels, where most individual pieces on the sprite have a dimension of 8 x 8 pixels. These values scale up by a factor of 2, so the Texture Size is actually 16 x 16 pixels and the remaining options will be based on that size.  The starting pixel of the largest smoke particle is 56 pixels horizontally, scaled up by a factor of 2 to 112. Since textures are 16 by 16 in this context, dividing 112 by 16 results in 7, which is the value of the UV Start field. Alternatively, you can count the number of textures that appear before the texture you want to start with (there are 7 textures that appear before the largest smoke particle). However, counting textures by hand may be difficult depending on the amount of empty space.  Since the animation involves moving to smaller smoke textures, the UV Step will be set to -1 by 0. This means it will go left by 16 pixels horizontally (based on the texture size) to the previous texture and not change vertically. We'll set Max Frame to 7, as the animation will have eight frames since there are 8 textures. The first frame of the animation is counted as \"frame 0\", so the last frame is frame 7.  In this case, we want to equally spread all frames across the lifetime of the particle. So, we'll leave the FPS field blank, leave Loop unchecked, and select Stretch To Lifetime. Now, we have a working animated texture.  Color  Now, it's time to apply random colors to the particles. The base texture is white, which is a great starting point for tinting particles.  We'll use a range of different colors, and each particle will pick a random value. First, open the Color & Light section and select the Gradient mode. For our effect, let's configure a nice, simple rainbow. You can add a color point using the + icon, move it around, and change the color of each point.  The default color range is between 0 and 1. That means that we can use a built-in random variable to pick a random color by entering variable.particle_random_2 into the Interpolant field. Now, each particle will spawn in a random color from the gradient.  The end result should look similar to this in Snowstorm:  Using the Particle Effect in Game  There are three main ways to play particle effects in-game:  Commands  This is the simplest way to test an effect. Use the /particle command to summon a particle emitter into the world.   Note  Because particle effects are entirely client-side and commands are run server-side, the server is not aware of particle effects. This means an error message will not appear if you try to play a particle effect that doesn't exist.  Here is an example command: The three tildes at the end of the command indicate the position, in this case the exact position where the command was executed, so the feet position of the player or the center of the command block running the command.  JSON Copy /particle sample:colored_smoke ~ ~ ~  Animations  Particles can also be played in entity animations, which is a two-step process. The first step is to link the particle effect in the client entity file and give it a short name. Then, use the short name in an animation.  Add this to the client entity file inside the description object:  JSON Copy \"particle_effects\": {     \"smoke\": \"sample:colored_smoke\" }   Particle effect keyframes can be added to an animation in Blockbench. Click the Animate Effects button above the timeline and add a keyframe to the Particle channel, then enter the short name (as defined in the client entity file) into the Effect input of the keyframe panel.  You can specify a locator in the entity file where the particle effect will appear, and can also assign a variable in the Script input that can be used inside the particle effect.  Example:  JSON Copy variable.custom_size = 3.14;  Animation Controllers  Particle effects can be played by animation controllers. To do this, first add the particle effect to the client entity file as explained previously. Next, add one or more particle effects to a specific state of the animation controller, as shown in this example:  JSON Copy \"particle_effects\": [     {         \"effect\": \"smoke\"     } ]  What's Next?  Congratulations, you've made it to the end of the (p)article! You've learned how to create a custom particle effect, configure the emitter, change the physics, use an animated texture, and how to color it.  Creating particle effects is all about trial and error, combining different settings, and using Molang expressions to power parameters. To learn more, check out the example particles and look through the configurations to learn how different values and expressions can be used to create effects. Finally, and most importantly, play around with all parameters, have fun, and see what you can come up with.  Particle JSON Documentation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/particleeffects?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Particle Effects 09/21/2023  From firework rockets leaving smoke behind to bubbles coming out of a fish's mouth, particles are a great way to add special effects to content within Minecraft: Bedrock Edition.  In this tutorial you will learn:  How to create custom particle effects in Minecraft: Bedrock Edition. How to make a new particle effect.  You'll also use Snowstorm - a community tool that will make editing particle effects much easier!  Requirements  It is recommended that the following be completed before beginning this tutorial:  Introduction to Resource Packs Introduction  Particles can greatly enhance the visual experience of a map or add-on, for effects such as exhaust smoke or magic spells. Particles can be used for ambiance effects like falling leaves, or even to place simple 2D graphics in your world.  Naming and Location  Bedrock uses a custom JSON format for particle effects. Files are stored in the particles folder of a resource pack. Similar to models and entities, particles are referenced by their identifier, so the file can be saved in any subfolder inside the particles folder without having to reference it.  The particle identifier is specified at the top of the JSON file, and consists of a namespace and name, such as sample:colored_smoke.  JSON Copy     \"description\": {     \"identifier\": \"sample:colored_smoke\",     },  Units  All values in particle effects use meters (blocks) and seconds as units. Velocity is stated as meters per second (m/s) and acceleration is meters per second squared (m/s²). Rotations use degrees for both rotations and trigonometric functions.  Snowstorm  We'll be using Snowstorm to create the particle effects in this guide. Snowstorm can be used as a web app or as an extension for VSCode. It allows users to preview the particle effect live while changing parameters. The web app is useful for beginners, while the VSCode extension offers a faster process for working with multiple particle effects.  Interface  Snowstorm includes a 3D preview section, sidebar organized by section tab buttons, a menu bar, and an expression bar below the menu.  Across the tabs and into the sidebar, you'll see the parameters and settings that make up a particle.  The first tab is the \"Quick Setup\" tab, which allows you to select from a set of pre-set motions, timings, and physics configurations.  Within the sidebar, many of the fields support Molang, which means static numbers can be added, but for more control over the value, mathematical expressions that use Molang can be used. Hovering over a field will cause a description of the field to appear.  If you end up with a complex Molang expression, it can be edited in the expression bar below the menu.  The menu bar is where files can be imported and exported in the web app, examples can be loaded, and references can be reviewed.  Below the expression bar is the preview screen. To navigate in the 3D space, use the left and right mouse button, as well as the mouse wheel; the buttons below can be used to start or pause the preview. Finally, in the bottom right corner is the FPS and the current number of particles in the scene.  Import and Export  In the web app, files have to be imported and exported via the File menu. To see the markup for the file, switch to the Code tab in the top right corner of the window.  If using custom textures, they must be loaded individually in the Textures section of the sidebar.  If using the VSCode extension, create a new file named <name>.particle.json in the particles folder, and VSCode will open it with the Snowstorm editor automatically. Clicking Open Code in the top right corner will preview the generated code in a new tab, and the code can be edited here directly as well.  Creating a Particle Effect  In this guide, we'll create a colored smoke effect step-by-step.   Note  The Quick Setup tab in Snowstorm provides an easy way to get started with custom particle effects, but in this tutorial we'll take a more leisurely tour through various Snowstorm settings areas.  To begin, open Snowstorm and locate the meta section in the sidebar. Type in the identifier of the particle effect – we'll use sample:colored_smoke.  Emitter  Next, we'll change the emitter. The emitter is the centerpiece of the particle effect and is responsible for spawning particles. To start, we need to open the Rate section and define how many particles are spawned. Leave the mode setting at Steady, which means that the emitter will constantly spawn particles, set the rate to 30, and the maximum to 100. This means that the emitter will spawn 30 particles per second over its lifetime as long as no more than 100 particles from this emitter exist in the world.  Now that the rate is set, it's time to define the emitter lifetime. We want to only play this particle effect once, but if you need a constant emitter, you can do so by setting it to looping. For this effect, set the Active Time to 2, which means that the emitter will spawn particles for two seconds.  By default, particles will spawn at a single point at the center of the emitter. This is fine for our particle effect, so no changes are required in the Shape section.  Particle Size  All particles are a 2D plane with a texture applied to it. In the size settings, the width and height of this plane can be defined, where each value is the radius. This means that setting the size to 1 by 1 would make it 2 by 2 blocks. We will use 0.25 by 0.25 in this example.  Particle motion and physics  The next step is to define how the particles move. In the Motion section, leave the Direction mode set to Outwards. For point emitters, this means the particles will spread to all directions equally.  Now that the particle has an initial direction, let's change the speed. In the Motion section, set the Speed to math.random(2, 4). This is a simple math expression that will output a random decimal from 2 to 4. The speed is calculated when the particle is spawned, so now each of our particles will have a random start speed.  Acceleration defines forces that act on the particle after it's spawned. For example, to simulate gravity on Earth, you would set the middle value (Y axis) to -9.8. For our smoke we'll use 0, 3, 0 as the acceleration to show a slow upwards movement.  The acceleration will make the particle exponentially faster. To make them slow down eventually and keep them in one space, we will add air drag, which will gently slow the acceleration when the particle reaches its terminal speed. We'll set this to 2.  To give the air drag more variation, we will randomize this value using a built-in variable. Each particle and each emitter will automatically have 4 random variables assigned that won't change over its lifetime. The variables contain a random number from 0 to 1. To achieve a random air drag value from 2 to 3, we'll set the value to 2 + variable.particle_random_1.  Particle Lifetime  Next, we will define how long the particles exist in the world. To get a slow fade-out effect, we'll randomize this number. Since the Max Age is only evaluated when the particle spawns, we can achieve this by setting the value to math.random(1, 3).  Texture  It is possible to create your own particle texture and save it in the textures folder of the resource pack. For simplicity, we'll use the default Minecraft particle sprite. To reference this texture, type textures/particle/particles into the Path field of the Texture section. The texture will be loaded automatically and show in game even if it's not in your current texture pack, since it will default to the vanilla version of the texture.  The particle texture we will use is the largest smoke particle. To animate the texture to gradually move to smaller smoke particle sizes, set the UV Mode to Animated.  The whole texture map, which includes textures for all particles, has a resolution of 128 x 128 pixels, where most individual pieces on the sprite have a dimension of 8 x 8 pixels. These values scale up by a factor of 2, so the Texture Size is actually 16 x 16 pixels and the remaining options will be based on that size.  The starting pixel of the largest smoke particle is 56 pixels horizontally, scaled up by a factor of 2 to 112. Since textures are 16 by 16 in this context, dividing 112 by 16 results in 7, which is the value of the UV Start field. Alternatively, you can count the number of textures that appear before the texture you want to start with (there are 7 textures that appear before the largest smoke particle). However, counting textures by hand may be difficult depending on the amount of empty space.  Since the animation involves moving to smaller smoke textures, the UV Step will be set to -1 by 0. This means it will go left by 16 pixels horizontally (based on the texture size) to the previous texture and not change vertically. We'll set Max Frame to 7, as the animation will have eight frames since there are 8 textures. The first frame of the animation is counted as \"frame 0\", so the last frame is frame 7.  In this case, we want to equally spread all frames across the lifetime of the particle. So, we'll leave the FPS field blank, leave Loop unchecked, and select Stretch To Lifetime. Now, we have a working animated texture.  Color  Now, it's time to apply random colors to the particles. The base texture is white, which is a great starting point for tinting particles.  We'll use a range of different colors, and each particle will pick a random value. First, open the Color & Light section and select the Gradient mode. For our effect, let's configure a nice, simple rainbow. You can add a color point using the + icon, move it around, and change the color of each point.  The default color range is between 0 and 1. That means that we can use a built-in random variable to pick a random color by entering variable.particle_random_2 into the Interpolant field. Now, each particle will spawn in a random color from the gradient.  The end result should look similar to this in Snowstorm:  Using the Particle Effect in Game  There are three main ways to play particle effects in-game:  Commands  This is the simplest way to test an effect. Use the /particle command to summon a particle emitter into the world.   Note  Because particle effects are entirely client-side and commands are run server-side, the server is not aware of particle effects. This means an error message will not appear if you try to play a particle effect that doesn't exist.  Here is an example command: The three tildes at the end of the command indicate the position, in this case the exact position where the command was executed, so the feet position of the player or the center of the command block running the command.  JSON Copy /particle sample:colored_smoke ~ ~ ~  Animations  Particles can also be played in entity animations, which is a two-step process. The first step is to link the particle effect in the client entity file and give it a short name. Then, use the short name in an animation.  Add this to the client entity file inside the description object:  JSON Copy \"particle_effects\": {     \"smoke\": \"sample:colored_smoke\" }   Particle effect keyframes can be added to an animation in Blockbench. Click the Animate Effects button above the timeline and add a keyframe to the Particle channel, then enter the short name (as defined in the client entity file) into the Effect input of the keyframe panel.  You can specify a locator in the entity file where the particle effect will appear, and can also assign a variable in the Script input that can be used inside the particle effect.  Example:  JSON Copy variable.custom_size = 3.14;  Animation Controllers  Particle effects can be played by animation controllers. To do this, first add the particle effect to the client entity file as explained previously. Next, add one or more particle effects to a specific state of the animation controller, as shown in this example:  JSON Copy \"particle_effects\": [     {         \"effect\": \"smoke\"     } ]  What's Next?  Congratulations, you've made it to the end of the (p)article! You've learned how to create a custom particle effect, configure the emitter, change the physics, use an animated texture, and how to color it.  Creating particle effects is all about trial and error, combining different settings, and using Molang expressions to power parameters. To learn more, check out the example particles and look through the configurations to learn how different values and expressions can be used to create effects. Finally, and most importantly, play around with all parameters, have fun, and see what you can come up with.  Particle JSON Documentation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoentityproperties?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Entity Properties 09/20/2023  Entity Properties are data fields defined in the Behavior Pack for any type of Minecraft entity. Any Entity Property defined on a particular minecraft:entity will have separate values for that Property tracked for every instance of the entity type. Entity Property values are always persisted through saving and loading. Entity Properties can be of four different types – int, float, enum, and bool, and can be optionally sent to game clients where they can be read by Resource Packs to affect how entities render or animate.  One Property Definition but Multiple Values  When a single Entity Property is defined on a single type of entity, every instance of that entity type will have that property. Additionally, every instance will keep track of its own separate value for that property.  Example Properties  Here are some example Entity Properties on an imaginary truck entity that someone might want to implement. These properties will describe the number of open windows, the amount of fuel in the gas tank, whether the truck is running, and what setting the gear shift is in.  JSON Copy \"example:num_open_windows\": {      \"type\": \"int\",      \"range\": [0, 4],      \"default\": 0  }    Here, example:num_open_windows is an integer property that starts with a default value of zero and can range as low as 0 and as high as 4. Note the \"example:\" in the name; Entity Property names must have a namespace prefix, similar to other named concepts in our game.  Replace \"example\" with your studio name or something else, anything other than \"minecraft\" because that namespace is reserved for official content.  JSON Copy \"example:remaining_fuel\": {      \"type\": \"float\",      \"range\": [0.0, 30.0],      \"default\": \"math.random(20, 25)\"  }   Here, \"example:remaining_fuel\" is a floating point property that starts with a default value determined by a Molang expression; in this case, a random value from 20 to 25. Because this is a \"float\", it can hold decimal values like 0.5.  JSON Copy \"example:engine_on\": {      \"type\": \"bool\",      \"default\": false  }    Here, \"example:engine_on\" is a bool property that starts off as false. Entity Properties with type bool don't have a range, because they can only be true or false.  JSON Copy \"example:gearshift\": {      \"type\": \"enum\",      \"values\": [\"park\", \"reverse\", \"neutral\", \"drive\"],      \"default\": \"park\",      \"client_sync\": true  }    Finally, we have an example of an enum property. Here, \"example:gearshift\" is an enum property that starts off with a value of \"park\", though it could also have several other values according to the \"values\" array. This example also includes a line setting \"client_sync\" to true, which means that this should be sent to clients, where it will be available to the content in the Resource Pack so it can influence how the entity renders and animates.  Why Use Entity Properties?  Entity Properties allow high-level states about Minecraft entities to be defined for specific types of entities, without those values being confused as intended for some other purpose. They also allow a flexible way to affect behavior, rendering, and animation of an entity in a way that is much easier to author and understand.  Without Entity Properties, a content creator making a car for a city scenario might want to animate its windshield wipers based on some interaction that turns the wipers on and off. Because there's no \"minecraft:windshield_wipers\" component, the content creator might figure out that they can add a \"minecraft:is_baby\" component to indicate that the wipers are on, and set up animations to play when \"query.is_baby\" detects that condition in the Resource Pack.  As this content gets developed further, the list of associations like \"for example:car, is_baby means my wipers are on\" can get more and more confusing, and, with each feature, the creator needs to find another component to use in a clever way. This also has a drawback that being a baby may have some built-in consequence in the Minecraft engine which is not desired or expected.  By using Entity Properties, the same content creator can instead use their own property definitions like \"example:car_wipers_on\" to track the state of their entities without the above drawbacks.  How are Entity Properties Changed?  As Entity Properties represent the high-level state of an entity, their property values are changed via entity events – the same system through which component groups are currently added or removed to entity instances.  JSON Copy \"events\": {   \"example:first\": {     \"add\": { \"component_groups\": [ \"example:some_group\" ] },     \"set_property\": {       \"example:my_property\": 4     }   },    \"example:second\": {     \"set_property\": {       \"example:another\": \"query.property('example:another') + 1\"     }    },    \"example:third\": {     \"set_property\": {        \"example:my_bool\": false,       \"example:my_enum\": \"park\"     }   } }   Here are several examples of how Entity Properties can be modified by entity events. The first sets a property \"example:my_property\" to 4 while also adding a component group, which is a common thing for events to do already. The second event shows that a Molang expression can be used to do more complicated logic. For example, here it sets \"example:another\" to 1 more than the current value of that property. The third event shows that multiple properties can be modified by a single \"set_property\" definition.  Property Value Changes and Property Ranges  An important thing to keep in mind about the \"range\" of Entity Properties of type int or float is that the value will always stay within the values listed in the \"range\" of the property definition. For example, if you have a range of \"[0, 10]\" and set the value to 25, whether directly or through a Molang expression, the value will be limited to 10 without any warning or error being sent.  When New Values are Calculated versus When they are Applied  Because entity events can be triggered by entity behaviors, players, command blocks, or other sources, it's not always safe for entity events to apply their changes right away. Instead, the effects of events are calculated and are applied the next time the entity ticks on the Behavior Pack/server side of the game. This means the effects of an event can take place during the current tick, or in the next tick, depending on a variety of factors. This also means that if two events are received by an entity in the same tick, the second event won't necessarily \"see\" the effect of the first event, as it hasn't been applied yet.  Entity Properties follow this pattern as well. When a \"set_property\" section in an event handler runs, it will immediately calculate the new values (often by evaluating a Molang expression) for any specified property value changes. Those values will be queued with any other property changes or add/remove of component groups, then later all of the changes will take place.  A Note on Large Integer Entity Property Values  When using a \"set_property\" expression to change an Entity Property of type \"int\", floating point-related math errors can be encountered if the values are very high or very low.  For example:  JSON Copy    \"set_property\": {       \"example:my_int\": \"query.property('example:my_int') + 1\"     }   Here a Molang expression is defined that is used to increment the \"example:my_int\" property. Since Molang expressions are evaluated as float values, this logic will fail when the value exceeds about 16.7 million.  Because of this, it's recommended to keep Entity Properties of type \"int\" between -1 million and +1 million, and if you need to exceed that value range, test your content carefully.  How Are Entity Properties Read?  Entity Properties can be read by two systems to affect how the game behaves: Molang and Filters.  Reading Properties with Molang  Molang has two main queries to consider related to Entity Properties - \"query.property\" and \"query.has_property\".  \"query.property\" takes one argument – the full name of a property – and will return the value of that property, or will send a content error message and return 0 if no property with that name is found.  For example, \"(query.property('example:fuel') > 5) ? query.property('example.fuel') : 1\" will return the value of the \"example:fuel\" property if it is over 5, otherwise it will return 1.  \"query.has_property\" takes one argument – the full name of a property – and will return 1 if that property exists, otherwise it will return 0. This query is useful to avoid errors in situations where the entity being inspected might not have a property with that name.  Reading Properties with Filters  Entity Properties can be read by filters in Behavior Pack JSON files. This is useful for checking whether part of or all of an entity event should have an effect, or for controlling when various components take the appropriate action.  There are five types of filters – one for each type of Entity Property, and one to check for the existence of a property. Here is an example of each type of filter:  \"test\":\"int_property\", \"subject\":\"self\", \"domain\":\"test:myint\", \"value\":4, \"operator\":\">\"  \"test\":\"bool_property\", \"subject\":\"self\", \"domain\":\"test:mybool\", \"value\":true, \"operator\":\"==\"  \"test\":\"float_property\", \"subject\":\"self\", \"domain\":\"test:myfloat\", \"value\":4.5, \"operator\":\">\"  \"test\":\"enum_property\", \"subject\":\"self\", \"domain\":\"test:myenum\", \"value\":\"blue\", \"operator\":\"!=\"  \"test\":\"has_property\", \"subject\":\"self\", \"value\":\"test:propertyname\", \"operator\":\"==\"  Like other filters, these have the usual parameters - test, subject, value, and operator. The type-specific tests also take a \"domain\" parameter.  Filter 1 passes if an Entity Property of type int and name \"test:myint\" exists on the entity with a value greater than 4. Filter 2 checks for a bool property named \"test:mybool\" with a true value. Filter 3 checks for a float value that is greater than 4.5. And filter 4 checks for an enum value not equal to the \"blue\" enum entry.  The last example filter uses the \"has_property\" test, which passes if it finds a property with the specified name.  All of these filters assume a \"subject\" of \"self\" if that is not specified.  The \"bool_property\" filter will assume \"value\" is true if not specified, while other filters require a value.  The \"has_property\" filter will assume \"operator\" is \"==\", while other filters require something to be specified. Using \"!=\" for \"has_property\" will check for a property not existing with that name.  Limitations of Entity Properties  Because Entity Properties are a new and potentially powerful system, some limitations have been implemented to maintain game stability and performance. Going past these limitations should cause a content error with a useful error message and prevent the property or properties from loading.  Number of Entity Properties per Entity Type  Each type of entity is limited to 32 Entity Properties. Within that, there's no further limit on which types are used or how many of them have the \"client_sync\" property set to true.  Enum Property Restrictions  Properties of type \"enum\" have several limitations. Each enum is limited to a maximum of 16 entries. Each entry has a minimum length of 1 and a maximum length of 32 characters. The first character of an enum entry must be alphabetical and the remaining characters can be alphabetical, numeric, or the underscore character.  Default Value Restrictions  Default values for Entity Properties can be authored in two ways – either as a direct value, or as a Molang expression. If authored as a direct value (such as 5 for an int property), the value must be the correct type for the property and must be within the defined range.  Molang expressions can be used for default values as well. In this case, the expression is evaluated then the result is cast to the appropriate type and clamped to be within the defined range. An error can still occur if a numeric result is returned from the expression for an enum property (which expects a string result), or if a non-numeric result is returned for an int, float, or bool property.  Molang expressions for default values cannot assign or read Molang variables, as the entity hasn't been constructed yet. Lastly, the only query that is available in a default value's Molang expression is \"query.had_component_group\", which is used for reading the state of previously saved entity data whose entity definition has been updated to use Entity Properties. See Entity Properties and Changes to Entity Definitions later in this article for more information.  Property Change Restrictions  When Entity Properties are modified with the \"set_property\" section of an event handler, either a direct value or a Molang expression can be specified for the new value.  Molang expressions for property changes cannot assign Molang variables but can read them. They can use the \"query.property\" or \"query.has_property\" queries to read other property values, but can't currently use other queries. This restriction has to do with the fact that events can be called from a variety of places including other entities, command blocks, or manually typed \"/event\" commands, so it's not always predictable what state the game will be in when a query is executing. Alternatives to this restriction include using filters within the event handler to detect a situation or using an animation in the Behavior Pack that sets a Molang variable, which can then be read by the \"set_property\" Molang expression.  Entity Properties and Changes to Entity Definitions  It's possible to define an entity, create worlds where instances of that entity are saved, then modify the definition of the entity. To help avoid entities that are loaded from older data but newer definitions, this section is meant to explain what happens in several related scenarios.  Added or removed properties  If an entity is loaded and there is a new Entity Property defined for which there is no previously saved data, a value will be added to the entity based on the property's default value. If an entity has a value for an Entity Property that is no longer in the entity definition, that value will be discarded.  Renamed Properties  All Entity Property data is saved according to the full name of each property. If a property is renamed in the entity definition, that will be handled the same way as if the property was removed and then a new property was added. The effect being that the data would be discarded, and new values would be generated according to the property's default value.  Changed Types  If a value for an Entity Property is loaded, and the type of that property doesn't match the type of the loaded data, the value will be discarded and a new value will be generated from the property's default value.  Changed Range  If a numeric (int or float) property value is loaded and is outside of the range defined for that Entity Property, the value will be clamped to be within that range. For example, a saved value of 120 that is loaded for an integer property with range \"[0, 100]\" will become 100, without any error or warning being sent.  Changed Enum Values  Enum values are saved in their string form, rather than the index they happen to have in the values array. Because of this, rearranging the order of entries in an enum property's values array will have no effect. If an enum entry is removed, any property values saved with that entry will be reset according to the property's default value.  Loading Old Data with an Upgraded Entity Property-Enabled Entity  Sometimes a creator may want to upgrade how part of an entity works to use the Entity Properties feature, where existing saved data for that entity already exists. For example, a \"sample:truck\" might be authored to indicate that the headlights are turned on by using the \"minecraft:is_baby\" component:  JSON Copy \"component_groups\": {   \"example:headlights\": {     \"minecraft:is_baby\": { }   } }  \"events\": {   \"example:turn_on_headlights\": {       \"add\": { \"component_groups\": [ \"example:headlights\" ]     } }   This sort of thing technically works, but it uses the concept of \"is_baby\" in an odd way and can get very confusing to keep track of what the different components are cleverly used for. Instead, this sort of thing could be implemented with Entity Properties, for example:  JSON Copy \"description\": {   \"properties\": {     \"example:headlights_on\": {       \"type\": \"bool\",       \"default\": false     }   } }  \"events\": {   \"example:turn_on_headlights\": {       \"set_property\": { \"example:headlights_on\": true }     } }   With this change, the \"example:headlights\" component group has been removed, and instead of making the game think the entity is a baby, it now sets a new \"example:headlights_on\" property to true.  This conversion would work, with the drawback that if any previously saved entities has the \"example:headlights\" component group active, they will lose that state when they load, meaning that some \"sample:truck\" entities will have their headlights turned back off.  To solve situations like this, the Molang query \"query.had_component_group\" has been added for use in the default value expression for Entity Properties.  The default value can be changed to this expression instead:  \"default\": \"query.had_component_group('example:headlights')\"  What this will do is set the value of the \"example:headlights_on\" property to true if the entity is being loaded from previously saved data that had a component group named \"example:headlights\" active. If there's no data being loaded, or the loaded data didn't have that component group active, the query will return 0, making the \"example:headlights_on\" property value false.  A mechanism like this is used in the \"minecraft:bee\" to allow bees to not lose track of their \"has_nectar\" state in the event that the bee was saved with nectar in an older version, then loaded with the new version of the bee's definition that uses an Entity Property.  Real Minecraft Example: The Bee's minecraft:has_nectar Property  To provide a real example of a working Entity Property, the part of the Minecraft bee that tracks whether it has nectar will be converted to use this new feature. Here is an explanation of those changes.  Property Definition  First, a new Entity Property will be added to the \"minecraft:bee\"'s \"description\" section:  JSON Copy   \"properties\": {     \"minecraft:has_nectar\": {        \"type\": \"bool\",        \"client_sync\": true,        \"default\": \"query.had_component_group('has_nectar')\"      }    }   This causes every bee in the game to have a per-bee true or false value named \"minecraft:has_nectar\". Like with all Entity Properties it will be persisted when the world saves and loads. Because \"client_sync\" is set to true, these values will also be sent to the client side of the game where Resource Pack files can read them for things like rendering and animation.  The default value expression here causes the value to initialize to true if the bee is being loaded from previously saved data where the entity had an active component group named \"has_nectar\". This is only necessary to avoid old bees forgetting their has_nectar state – if having nectar was a new aspect of bees, or if there was no existing save data that needed to be gracefully upgraded, the default value could just be \"false\" instead to start all bees without nectar.  Component Replacement  Next, the bee's behavior JSON file (the same file where the property is defined) will be updated to set the property instead of using the old \"minecraft:is_charged\" component.  This line from the \"has_nectar\" component group will be removed:  \"minecraft:is_charged\": {},  Any events that \"add\" the \"has_nectar\" component group will have this section added to set the property to true:  JSON Copy       \"set_property\": {          \"minecraft:has_nectar\": true        }    And any events that \"remove\" the \"has_nectar\" component group will have this section added to set the property to false:  JSON Copy       \"set_property\": {          \"minecraft:has_nectar\": false        }   Filter Replacement  There are a few filters in the file that check for the \"minecraft:is_charged\" component, or the lack of such a component. These filters will be updated to instead check the value of the new Entity Property.  This filter checks for the \"minecraft:is_charged\" component:  JSON Copy     \"filters\": {        \"test\": \"has_component\",        \"value\": \"minecraft:is_charged\"      },    This will be replaced with a \"bool_property\" filter as follows:  JSON Copy     \"filters\": {        \"test\": \"bool_property\",        \"domain\": \"minecraft:has_nectar\"      },    Note that this filter assumes a \"value\" of true and an \"operator\" of \"==\", so those don't have to be specified.  There are a few similar filters that use an \"operator\" of \"!=\" to check that the component is not there. In those cases, the same replacement will be made, leaving the \"operator\" as-is, which will end up with this filter:  JSON Copy     \"filters\": {        \"test\": \"bool_property\",        \"operator\": \"!=\",        \"domain\": \"minecraft:has_nectar\"      },     This filter will allow the appropriate behavior when the \"minecraft:has_nectar\" bool property is not equal to true.  Animation Controller Update  In the Resource Pack, the bee's animation controller has a \"dripping\" animation state that is active when the Molang expression \"query.is_powered\" returns 1, and another transition out of that state when the opposite of that expression returns 1:  JSON Copy         \"default\": {            \"transitions\": [              { \"dripping\": \"query.is_powered\" }            ]          },          \"dripping\": {  ...           \"transitions\": [              { \"default\": \"!query.is_powered\" }            ]          }    The Molang query \"is_powered\" returns true when the \"minecraft:is_charged\" component is active on an entity. Converting to use the new Entity Property is straightforward, just replacing that query with a \"query.property\" call that specifies the property name:  JSON Copy         \"default\": {            \"transitions\": [              { \"dripping\": \"query.property('minecraft:has_nectar')\" }            ]          },  ...         \"dripping\": {            \"transitions\": [              { \"default\": \"!query.property('minecraft:has_nectar')\" }            ]          }   Render Controller Update  The bee's render controller (also in the Resource Pack) has this line which chooses a texture during rendering based on whether the bee has nectar and some other logic:  \"textures\": [ \"array.skins[query.is_powered + query.is_angry * 2]\" ]  Like the above animation transition change, this will be updated to instead read the new Entity Property.  \"textures\": [ \"array.skins[query.property('minecraft:has_nectar') + query.is_angry * 2]\" ]  Conclusion  This concludes the explanation of what Entity Properties are, while giving some context about their value and an example of how this will be used with the game's bee entity.  Entity Properties allow for a much simpler way to author entity state, especially for properties that are intended to persist across sessions and to sync to clients where they can affect how an entity appears. We look forward to what our community comes up with using this new feature!  What's Next?  In this guide we have added a complete custom entity to the game. If you used the existing model files instead of creating your own, now might be a good time to learn about Blockbench. Or, you can read more about entity behavior for the server.  Entity Modeling and Animation Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoentityproperties?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Entity Properties 09/20/2023  Entity Properties are data fields defined in the Behavior Pack for any type of Minecraft entity. Any Entity Property defined on a particular minecraft:entity will have separate values for that Property tracked for every instance of the entity type. Entity Property values are always persisted through saving and loading. Entity Properties can be of four different types – int, float, enum, and bool, and can be optionally sent to game clients where they can be read by Resource Packs to affect how entities render or animate.  One Property Definition but Multiple Values  When a single Entity Property is defined on a single type of entity, every instance of that entity type will have that property. Additionally, every instance will keep track of its own separate value for that property.  Example Properties  Here are some example Entity Properties on an imaginary truck entity that someone might want to implement. These properties will describe the number of open windows, the amount of fuel in the gas tank, whether the truck is running, and what setting the gear shift is in.  JSON Copy \"example:num_open_windows\": {      \"type\": \"int\",      \"range\": [0, 4],      \"default\": 0  }    Here, example:num_open_windows is an integer property that starts with a default value of zero and can range as low as 0 and as high as 4. Note the \"example:\" in the name; Entity Property names must have a namespace prefix, similar to other named concepts in our game.  Replace \"example\" with your studio name or something else, anything other than \"minecraft\" because that namespace is reserved for official content.  JSON Copy \"example:remaining_fuel\": {      \"type\": \"float\",      \"range\": [0.0, 30.0],      \"default\": \"math.random(20, 25)\"  }   Here, \"example:remaining_fuel\" is a floating point property that starts with a default value determined by a Molang expression; in this case, a random value from 20 to 25. Because this is a \"float\", it can hold decimal values like 0.5.  JSON Copy \"example:engine_on\": {      \"type\": \"bool\",      \"default\": false  }    Here, \"example:engine_on\" is a bool property that starts off as false. Entity Properties with type bool don't have a range, because they can only be true or false.  JSON Copy \"example:gearshift\": {      \"type\": \"enum\",      \"values\": [\"park\", \"reverse\", \"neutral\", \"drive\"],      \"default\": \"park\",      \"client_sync\": true  }    Finally, we have an example of an enum property. Here, \"example:gearshift\" is an enum property that starts off with a value of \"park\", though it could also have several other values according to the \"values\" array. This example also includes a line setting \"client_sync\" to true, which means that this should be sent to clients, where it will be available to the content in the Resource Pack so it can influence how the entity renders and animates.  Why Use Entity Properties?  Entity Properties allow high-level states about Minecraft entities to be defined for specific types of entities, without those values being confused as intended for some other purpose. They also allow a flexible way to affect behavior, rendering, and animation of an entity in a way that is much easier to author and understand.  Without Entity Properties, a content creator making a car for a city scenario might want to animate its windshield wipers based on some interaction that turns the wipers on and off. Because there's no \"minecraft:windshield_wipers\" component, the content creator might figure out that they can add a \"minecraft:is_baby\" component to indicate that the wipers are on, and set up animations to play when \"query.is_baby\" detects that condition in the Resource Pack.  As this content gets developed further, the list of associations like \"for example:car, is_baby means my wipers are on\" can get more and more confusing, and, with each feature, the creator needs to find another component to use in a clever way. This also has a drawback that being a baby may have some built-in consequence in the Minecraft engine which is not desired or expected.  By using Entity Properties, the same content creator can instead use their own property definitions like \"example:car_wipers_on\" to track the state of their entities without the above drawbacks.  How are Entity Properties Changed?  As Entity Properties represent the high-level state of an entity, their property values are changed via entity events – the same system through which component groups are currently added or removed to entity instances.  JSON Copy \"events\": {   \"example:first\": {     \"add\": { \"component_groups\": [ \"example:some_group\" ] },     \"set_property\": {       \"example:my_property\": 4     }   },    \"example:second\": {     \"set_property\": {       \"example:another\": \"query.property('example:another') + 1\"     }    },    \"example:third\": {     \"set_property\": {        \"example:my_bool\": false,       \"example:my_enum\": \"park\"     }   } }   Here are several examples of how Entity Properties can be modified by entity events. The first sets a property \"example:my_property\" to 4 while also adding a component group, which is a common thing for events to do already. The second event shows that a Molang expression can be used to do more complicated logic. For example, here it sets \"example:another\" to 1 more than the current value of that property. The third event shows that multiple properties can be modified by a single \"set_property\" definition.  Property Value Changes and Property Ranges  An important thing to keep in mind about the \"range\" of Entity Properties of type int or float is that the value will always stay within the values listed in the \"range\" of the property definition. For example, if you have a range of \"[0, 10]\" and set the value to 25, whether directly or through a Molang expression, the value will be limited to 10 without any warning or error being sent.  When New Values are Calculated versus When they are Applied  Because entity events can be triggered by entity behaviors, players, command blocks, or other sources, it's not always safe for entity events to apply their changes right away. Instead, the effects of events are calculated and are applied the next time the entity ticks on the Behavior Pack/server side of the game. This means the effects of an event can take place during the current tick, or in the next tick, depending on a variety of factors. This also means that if two events are received by an entity in the same tick, the second event won't necessarily \"see\" the effect of the first event, as it hasn't been applied yet.  Entity Properties follow this pattern as well. When a \"set_property\" section in an event handler runs, it will immediately calculate the new values (often by evaluating a Molang expression) for any specified property value changes. Those values will be queued with any other property changes or add/remove of component groups, then later all of the changes will take place.  A Note on Large Integer Entity Property Values  When using a \"set_property\" expression to change an Entity Property of type \"int\", floating point-related math errors can be encountered if the values are very high or very low.  For example:  JSON Copy    \"set_property\": {       \"example:my_int\": \"query.property('example:my_int') + 1\"     }   Here a Molang expression is defined that is used to increment the \"example:my_int\" property. Since Molang expressions are evaluated as float values, this logic will fail when the value exceeds about 16.7 million.  Because of this, it's recommended to keep Entity Properties of type \"int\" between -1 million and +1 million, and if you need to exceed that value range, test your content carefully.  How Are Entity Properties Read?  Entity Properties can be read by two systems to affect how the game behaves: Molang and Filters.  Reading Properties with Molang  Molang has two main queries to consider related to Entity Properties - \"query.property\" and \"query.has_property\".  \"query.property\" takes one argument – the full name of a property – and will return the value of that property, or will send a content error message and return 0 if no property with that name is found.  For example, \"(query.property('example:fuel') > 5) ? query.property('example.fuel') : 1\" will return the value of the \"example:fuel\" property if it is over 5, otherwise it will return 1.  \"query.has_property\" takes one argument – the full name of a property – and will return 1 if that property exists, otherwise it will return 0. This query is useful to avoid errors in situations where the entity being inspected might not have a property with that name.  Reading Properties with Filters  Entity Properties can be read by filters in Behavior Pack JSON files. This is useful for checking whether part of or all of an entity event should have an effect, or for controlling when various components take the appropriate action.  There are five types of filters – one for each type of Entity Property, and one to check for the existence of a property. Here is an example of each type of filter:  \"test\":\"int_property\", \"subject\":\"self\", \"domain\":\"test:myint\", \"value\":4, \"operator\":\">\"  \"test\":\"bool_property\", \"subject\":\"self\", \"domain\":\"test:mybool\", \"value\":true, \"operator\":\"==\"  \"test\":\"float_property\", \"subject\":\"self\", \"domain\":\"test:myfloat\", \"value\":4.5, \"operator\":\">\"  \"test\":\"enum_property\", \"subject\":\"self\", \"domain\":\"test:myenum\", \"value\":\"blue\", \"operator\":\"!=\"  \"test\":\"has_property\", \"subject\":\"self\", \"value\":\"test:propertyname\", \"operator\":\"==\"  Like other filters, these have the usual parameters - test, subject, value, and operator. The type-specific tests also take a \"domain\" parameter.  Filter 1 passes if an Entity Property of type int and name \"test:myint\" exists on the entity with a value greater than 4. Filter 2 checks for a bool property named \"test:mybool\" with a true value. Filter 3 checks for a float value that is greater than 4.5. And filter 4 checks for an enum value not equal to the \"blue\" enum entry.  The last example filter uses the \"has_property\" test, which passes if it finds a property with the specified name.  All of these filters assume a \"subject\" of \"self\" if that is not specified.  The \"bool_property\" filter will assume \"value\" is true if not specified, while other filters require a value.  The \"has_property\" filter will assume \"operator\" is \"==\", while other filters require something to be specified. Using \"!=\" for \"has_property\" will check for a property not existing with that name.  Limitations of Entity Properties  Because Entity Properties are a new and potentially powerful system, some limitations have been implemented to maintain game stability and performance. Going past these limitations should cause a content error with a useful error message and prevent the property or properties from loading.  Number of Entity Properties per Entity Type  Each type of entity is limited to 32 Entity Properties. Within that, there's no further limit on which types are used or how many of them have the \"client_sync\" property set to true.  Enum Property Restrictions  Properties of type \"enum\" have several limitations. Each enum is limited to a maximum of 16 entries. Each entry has a minimum length of 1 and a maximum length of 32 characters. The first character of an enum entry must be alphabetical and the remaining characters can be alphabetical, numeric, or the underscore character.  Default Value Restrictions  Default values for Entity Properties can be authored in two ways – either as a direct value, or as a Molang expression. If authored as a direct value (such as 5 for an int property), the value must be the correct type for the property and must be within the defined range.  Molang expressions can be used for default values as well. In this case, the expression is evaluated then the result is cast to the appropriate type and clamped to be within the defined range. An error can still occur if a numeric result is returned from the expression for an enum property (which expects a string result), or if a non-numeric result is returned for an int, float, or bool property.  Molang expressions for default values cannot assign or read Molang variables, as the entity hasn't been constructed yet. Lastly, the only query that is available in a default value's Molang expression is \"query.had_component_group\", which is used for reading the state of previously saved entity data whose entity definition has been updated to use Entity Properties. See Entity Properties and Changes to Entity Definitions later in this article for more information.  Property Change Restrictions  When Entity Properties are modified with the \"set_property\" section of an event handler, either a direct value or a Molang expression can be specified for the new value.  Molang expressions for property changes cannot assign Molang variables but can read them. They can use the \"query.property\" or \"query.has_property\" queries to read other property values, but can't currently use other queries. This restriction has to do with the fact that events can be called from a variety of places including other entities, command blocks, or manually typed \"/event\" commands, so it's not always predictable what state the game will be in when a query is executing. Alternatives to this restriction include using filters within the event handler to detect a situation or using an animation in the Behavior Pack that sets a Molang variable, which can then be read by the \"set_property\" Molang expression.  Entity Properties and Changes to Entity Definitions  It's possible to define an entity, create worlds where instances of that entity are saved, then modify the definition of the entity. To help avoid entities that are loaded from older data but newer definitions, this section is meant to explain what happens in several related scenarios.  Added or removed properties  If an entity is loaded and there is a new Entity Property defined for which there is no previously saved data, a value will be added to the entity based on the property's default value. If an entity has a value for an Entity Property that is no longer in the entity definition, that value will be discarded.  Renamed Properties  All Entity Property data is saved according to the full name of each property. If a property is renamed in the entity definition, that will be handled the same way as if the property was removed and then a new property was added. The effect being that the data would be discarded, and new values would be generated according to the property's default value.  Changed Types  If a value for an Entity Property is loaded, and the type of that property doesn't match the type of the loaded data, the value will be discarded and a new value will be generated from the property's default value.  Changed Range  If a numeric (int or float) property value is loaded and is outside of the range defined for that Entity Property, the value will be clamped to be within that range. For example, a saved value of 120 that is loaded for an integer property with range \"[0, 100]\" will become 100, without any error or warning being sent.  Changed Enum Values  Enum values are saved in their string form, rather than the index they happen to have in the values array. Because of this, rearranging the order of entries in an enum property's values array will have no effect. If an enum entry is removed, any property values saved with that entry will be reset according to the property's default value.  Loading Old Data with an Upgraded Entity Property-Enabled Entity  Sometimes a creator may want to upgrade how part of an entity works to use the Entity Properties feature, where existing saved data for that entity already exists. For example, a \"sample:truck\" might be authored to indicate that the headlights are turned on by using the \"minecraft:is_baby\" component:  JSON Copy \"component_groups\": {   \"example:headlights\": {     \"minecraft:is_baby\": { }   } }  \"events\": {   \"example:turn_on_headlights\": {       \"add\": { \"component_groups\": [ \"example:headlights\" ]     } }   This sort of thing technically works, but it uses the concept of \"is_baby\" in an odd way and can get very confusing to keep track of what the different components are cleverly used for. Instead, this sort of thing could be implemented with Entity Properties, for example:  JSON Copy \"description\": {   \"properties\": {     \"example:headlights_on\": {       \"type\": \"bool\",       \"default\": false     }   } }  \"events\": {   \"example:turn_on_headlights\": {       \"set_property\": { \"example:headlights_on\": true }     } }   With this change, the \"example:headlights\" component group has been removed, and instead of making the game think the entity is a baby, it now sets a new \"example:headlights_on\" property to true.  This conversion would work, with the drawback that if any previously saved entities has the \"example:headlights\" component group active, they will lose that state when they load, meaning that some \"sample:truck\" entities will have their headlights turned back off.  To solve situations like this, the Molang query \"query.had_component_group\" has been added for use in the default value expression for Entity Properties.  The default value can be changed to this expression instead:  \"default\": \"query.had_component_group('example:headlights')\"  What this will do is set the value of the \"example:headlights_on\" property to true if the entity is being loaded from previously saved data that had a component group named \"example:headlights\" active. If there's no data being loaded, or the loaded data didn't have that component group active, the query will return 0, making the \"example:headlights_on\" property value false.  A mechanism like this is used in the \"minecraft:bee\" to allow bees to not lose track of their \"has_nectar\" state in the event that the bee was saved with nectar in an older version, then loaded with the new version of the bee's definition that uses an Entity Property.  Real Minecraft Example: The Bee's minecraft:has_nectar Property  To provide a real example of a working Entity Property, the part of the Minecraft bee that tracks whether it has nectar will be converted to use this new feature. Here is an explanation of those changes.  Property Definition  First, a new Entity Property will be added to the \"minecraft:bee\"'s \"description\" section:  JSON Copy   \"properties\": {     \"minecraft:has_nectar\": {        \"type\": \"bool\",        \"client_sync\": true,        \"default\": \"query.had_component_group('has_nectar')\"      }    }   This causes every bee in the game to have a per-bee true or false value named \"minecraft:has_nectar\". Like with all Entity Properties it will be persisted when the world saves and loads. Because \"client_sync\" is set to true, these values will also be sent to the client side of the game where Resource Pack files can read them for things like rendering and animation.  The default value expression here causes the value to initialize to true if the bee is being loaded from previously saved data where the entity had an active component group named \"has_nectar\". This is only necessary to avoid old bees forgetting their has_nectar state – if having nectar was a new aspect of bees, or if there was no existing save data that needed to be gracefully upgraded, the default value could just be \"false\" instead to start all bees without nectar.  Component Replacement  Next, the bee's behavior JSON file (the same file where the property is defined) will be updated to set the property instead of using the old \"minecraft:is_charged\" component.  This line from the \"has_nectar\" component group will be removed:  \"minecraft:is_charged\": {},  Any events that \"add\" the \"has_nectar\" component group will have this section added to set the property to true:  JSON Copy       \"set_property\": {          \"minecraft:has_nectar\": true        }    And any events that \"remove\" the \"has_nectar\" component group will have this section added to set the property to false:  JSON Copy       \"set_property\": {          \"minecraft:has_nectar\": false        }   Filter Replacement  There are a few filters in the file that check for the \"minecraft:is_charged\" component, or the lack of such a component. These filters will be updated to instead check the value of the new Entity Property.  This filter checks for the \"minecraft:is_charged\" component:  JSON Copy     \"filters\": {        \"test\": \"has_component\",        \"value\": \"minecraft:is_charged\"      },    This will be replaced with a \"bool_property\" filter as follows:  JSON Copy     \"filters\": {        \"test\": \"bool_property\",        \"domain\": \"minecraft:has_nectar\"      },    Note that this filter assumes a \"value\" of true and an \"operator\" of \"==\", so those don't have to be specified.  There are a few similar filters that use an \"operator\" of \"!=\" to check that the component is not there. In those cases, the same replacement will be made, leaving the \"operator\" as-is, which will end up with this filter:  JSON Copy     \"filters\": {        \"test\": \"bool_property\",        \"operator\": \"!=\",        \"domain\": \"minecraft:has_nectar\"      },     This filter will allow the appropriate behavior when the \"minecraft:has_nectar\" bool property is not equal to true.  Animation Controller Update  In the Resource Pack, the bee's animation controller has a \"dripping\" animation state that is active when the Molang expression \"query.is_powered\" returns 1, and another transition out of that state when the opposite of that expression returns 1:  JSON Copy         \"default\": {            \"transitions\": [              { \"dripping\": \"query.is_powered\" }            ]          },          \"dripping\": {  ...           \"transitions\": [              { \"default\": \"!query.is_powered\" }            ]          }    The Molang query \"is_powered\" returns true when the \"minecraft:is_charged\" component is active on an entity. Converting to use the new Entity Property is straightforward, just replacing that query with a \"query.property\" call that specifies the property name:  JSON Copy         \"default\": {            \"transitions\": [              { \"dripping\": \"query.property('minecraft:has_nectar')\" }            ]          },  ...         \"dripping\": {            \"transitions\": [              { \"default\": \"!query.property('minecraft:has_nectar')\" }            ]          }   Render Controller Update  The bee's render controller (also in the Resource Pack) has this line which chooses a texture during rendering based on whether the bee has nectar and some other logic:  \"textures\": [ \"array.skins[query.is_powered + query.is_angry * 2]\" ]  Like the above animation transition change, this will be updated to instead read the new Entity Property.  \"textures\": [ \"array.skins[query.property('minecraft:has_nectar') + query.is_angry * 2]\" ]  Conclusion  This concludes the explanation of what Entity Properties are, while giving some context about their value and an example of how this will be used with the game's bee entity.  Entity Properties allow for a much simpler way to author entity state, especially for properties that are intended to persist across sessions and to sync to clients where they can affect how an entity appears. We look forward to what our community comes up with using this new feature!  What's Next?  In this guide we have added a complete custom entity to the game. If you used the existing model files instead of creating your own, now might be a good time to learn about Blockbench. Or, you can read more about entity behavior for the server.  Entity Modeling and Animation Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entitybehaviorintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Behavior Introduction 09/20/2023  In this tutorial you will learn the following:  How to create and use behavior files to change an entity's behavior. How to use components to expand an entity's behavior. How to use events to modify active components based on some condition. Requirements  It's recommended that the following be completed before beginning this tutorial.  Creating New Entity Types Introduction  Entity JSON files in Minecraft: Bedrock Edition customize how an entity behaves and interacts with the world. They're a part of behavior packs, but behavior packs can contain more functionality including functions, loot tables, and more.  Entity JSON files were first introduced along with add-ons as a way to customize how Vanilla entities behave.  Entity JSON file structure includes:  Metadata such as the identifier, spawning and summoning settings. Components that define active behavior such as visibility, family, health, and collision box behavior. These behaviors are applied to the entity immediately. Component groups are not applied but may be evoked by events. They apply additional Minecraft behavior, including behaviors like aging and herd behavior. Events which allow custom behavior to run based on the Minecraft event system. We will discuss events more in the Entity Events article.  Components were created to be small units of reusable behaviors to be used by creators to customize entities. For example, the tameable component can make entities like ocelots and wolves tameable.  There are two ways in which entity JSON files can be used:  Modifying Vanilla entities. This should only be used for small adjustments to the Vanilla game, not for additional content. Creating custom entities. Entity JSON files serve as the base for custom entities. Format Overview  Entity JSON files are saved in the entities folder of your behavior pack. The game loads all files in that folder so you can use subfolders to manage your entities. The files use the extension .json. This extension is used by a lot of files within add-ons, so if you want to avoid confusion, you can use the extended extension .behavior.json for entity JSON files specifically.  The files are written in JSON and the basic structure looks like this:  JSON Copy {     \"format_version\":\"1.19.20\",     \"minecraft:entity\":{         \"description\":{             \"identifier\":\"sample:example\",             \"is_spawnable\":true,             \"is_summonable\":true         },         \"components\":{                      },         \"component_groups\":{                      },         \"events\":{                      }     } }   Inside the description tag, a few basic properties define how the game registers the entity:  Expand table Parameter Name\tType\tDescription identifier\tString\tIdentifier of the entity. If this is a custom entity in an add-on, you should use a custom unique namespace as seen in the example. runtime_identifier\tString\tIdentifier that's used internally by the game. This can be used to inherit custom mechanics from Vanilla entities that are not yet available as a component. Only one runtime identifier may be specified per entity. Only use this if it is really necessary. If a Vanilla entity's mechanics are turned into components, you may lose functionality if you are relying on those mechanics through a runtime identifier. is_spawnable\tBoolean\tIf true, a spawn egg for the entity is added to the creative inventory. is_summonable\tBoolean\tIf true, the entity can be summoned using the /summon command. animations\tObject\tA list of behavior animations or behavior animation controllers. These aren't used for visible model animations. These can be used to run commands or events on the entity. scripts\tObject\tScripts work similarly to how they work in client entity files, and they can be used to play behavior animations. spawn_category\tString\tCurrently not fully implemented, so we recommend that creators do not set a value for this property. This property is optional. Available values include monster, creature, ambient, axolotls, underground_water_creature, water_creature, water_ambient and misc. If you do set this property, we recommend a value of misc. Components Basics  A full list of available components can be found in the Component List documentation.  A good way to learn about a component and see how it's used in practice is to look at the entity JSON files of default Minecraft entities. You can always find the latest default behavior pack at this URL: https://aka.ms/behaviorpacktemplate.   Note  The way a component works can sometimes change between versions. Learn more about versions in the manifest reference documentation. You're encouraged to always use the latest version of the component as it's been refined and can include fixes.  Essential Components Expand table Component Name\tOptions\tDescription minecraft:physics\thas_collision has_gravity\tYou'll need this component on 99% of custom entities. It allows the entity to stay on the ground and react to interaction and punches in a way that you would expect. minecraft:scale\tvalue\tSets the relative size of the entity. minecraft:type_family\tfamily\tSets a list of type families that the entity is in. Type families can be tested by other entities. For example, to test which mobs they are hostile towards. See Introduction to Entity Families minecraft:movement\tvalue\tSets the movement speed of the entity. 0.25 is the regular speed of most animals in Minecraft. minecraft:movement.basic\tSee documentation\tAllows the entity to move around on the ground. minecraft:navigation.walk\tSee documentation\tAllows the entity to navigate through the world by walking. There are other types of navigation as well, like hovering. minecraft:is_baby minecraft:is_ignited minecraft:is_saddled minecraft:is_sheared minecraft:is_tamed minecraft:is_illager_captain\tvalue\tThese components don't do anything on their own, but they can be queried in animations, animation controllers, or render controllers, allowing you to control animations and other visuals from the entity behavior. minecraft:variant minecraft:mark_variant minecraft:skin_id\tvalue\tThese components work like the ones above, but instead of only storing an on/off state, they can store an integer value. Priorities  The option priority can be used on all AI goal behavior components. 0 is the highest priority and the default priority of all behavior components. The higher the number, the lower the priority. If the entity is busy doing a low priority behavior and a high priority behavior comes up, the entity will immediately switch to the higher priority behavior.  In the following example, the hurt_by_target component has a higher priority. If the entity gets attacked while strolling, it will immediately target the attacker.  JSON Copy \"minecraft:behavior.random_stroll\":{     \"priority\":4 }, \"minecraft:behavior.hurt_by_target\":{     \"priority\":1 }   Components are properties or mechanics that you can add to your entity. There are two ways to add components: 1. Directly to the component tag or 2. In a component group.  Components added to the base component tag are always active unless removed or replaced through a component group in an event. Component groups are sets of one or more components each that aren't active by default but can be enabled or disabled through events. For instance, this can be used to create a variation of the entity, such as a baby cow. Adding Component Groups  These groups must be defined in the component_groups section of the file. As entities can only have one component of each type active, any components in a group that is being added will replace previously added components.  Additionally, adding a component group that is already active will cause those components to be re-initialized. For some types of components like minecraft:is_baby, re-initializing an already active component has no effect, but for other component types the associated logic will start over.  For example, an already-added minecraft:timer that is added again will start its timing logic over.  Component Groups Example  In this example, a component group is defined which can cause the entity to become a baby variation. The components defined in the main component section are always active, while the components in the baby component group are only active when that group is added by the sample:add_baby event.  JSON Copy {     \"format_version\":\"1.19.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\":\"sample:example\",             \"is_spawnable\":true,             \"is_summonable\":true         },         \"components\":{             \"minecraft:physics\": {             }         },         \"component_groups\": {             \"sample:baby\":{                 \"minecraft:behavior.follow_parent\": {                                      },                 \"minecraft:is_baby\": {                                      }             }         },         \"events\": {             \"sample:add_baby\": {                   \"add\": {                  \"component_groups\": {                      [\"baby\"]                 }             }         }       }     } }   All Minecraft components use the minecraft: namespace, which you can use when referring to a built in Minecraft behavior. Custom behaviors need to use a different namespace.  Almost all components are defined as a JSON object. Most components have options that can be specified inside this object, but some components work without options, as shown in the previous example.  Removing Components  When a component group is removed from an entity, the effect of the components will be removed as well. This won't cause any problems in most cases. But in some cases, it's important to consider that components overwrite each other. Therefore, removing a component won't make it go back to the previous state of that component, and it won't use the same component from another component group or the base components. Instead, the component will be removed completely and reset to its default values.  Here's an example: Let's say you have an entity with a scale of 2 defined in the base components tag. You add a baby component group with a scale component that sets the scale to 1.5. This will correctly update the scale to 1.5. Now, you remove that component group again. Instead of going back to 2, the scale will now be reset to 1. This happens because removing the component group will also remove the scale component entirely.  There are a few components where this is important to consider:  Components that change a value of the entity like minecraft:scale, minecraft:collision_box, or minecraft:variant. List components like minecraft:interact, minecraft:environment_sensor, or minecraft:damage_sensor. Any other components that you might want to have different states of like minecraft:rideable which has different seat counts or positions.  In order to avoid this behavior, you need to add a new component group with the updated state of the component. In the case of the scale example, this can be as easy as having two different component groups for the different states that you can switch between.  JSON Copy \"components\":{     \"minecraft:scale\":{         \"value\":2     } }, \"component_groups\":{     \"baby\":{         \"minecraft:scale\":{             \"value\":1.5         }     },     \"adult\":{         \"minecraft:scale\":{             \"value\":2         }     } }, \"events\":{     \"set_baby\":{         \"remove\":{             \"component_groups\":[                 \"adult\"              ]         },         \"add\":{             \"component_groups\":[                 \"baby\"             ]         }     },     \"set_adult\":{         \"remove\":{             \"component_groups\":[                 \"baby\"             ]         },         \"add\":{             \"component_groups\":[                 \"adult\"             ]         }     } }  Use Entity Components  If you ever get stuck or want a better understanding on how a component works, checking the Vanilla entity JSON files will allow you to see working examples. Deconstructing a Vanilla entity and applying it to a different entity is a great way to get started.  Here are a few ideas:  Take the minecraft:teleport component from an Endermen and apply it to a creeper. Make a zombie rideable by the player. Make baby creepers. What's Next?  The component system allows you to customize what your entity does and how it interacts with the world. If you want to learn more about entity events and using them to add more component groups with more customized behavior, see the Entity Events documentation.  Entity Events  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entitybehaviorintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Behavior Introduction 09/20/2023  In this tutorial you will learn the following:  How to create and use behavior files to change an entity's behavior. How to use components to expand an entity's behavior. How to use events to modify active components based on some condition. Requirements  It's recommended that the following be completed before beginning this tutorial.  Creating New Entity Types Introduction  Entity JSON files in Minecraft: Bedrock Edition customize how an entity behaves and interacts with the world. They're a part of behavior packs, but behavior packs can contain more functionality including functions, loot tables, and more.  Entity JSON files were first introduced along with add-ons as a way to customize how Vanilla entities behave.  Entity JSON file structure includes:  Metadata such as the identifier, spawning and summoning settings. Components that define active behavior such as visibility, family, health, and collision box behavior. These behaviors are applied to the entity immediately. Component groups are not applied but may be evoked by events. They apply additional Minecraft behavior, including behaviors like aging and herd behavior. Events which allow custom behavior to run based on the Minecraft event system. We will discuss events more in the Entity Events article.  Components were created to be small units of reusable behaviors to be used by creators to customize entities. For example, the tameable component can make entities like ocelots and wolves tameable.  There are two ways in which entity JSON files can be used:  Modifying Vanilla entities. This should only be used for small adjustments to the Vanilla game, not for additional content. Creating custom entities. Entity JSON files serve as the base for custom entities. Format Overview  Entity JSON files are saved in the entities folder of your behavior pack. The game loads all files in that folder so you can use subfolders to manage your entities. The files use the extension .json. This extension is used by a lot of files within add-ons, so if you want to avoid confusion, you can use the extended extension .behavior.json for entity JSON files specifically.  The files are written in JSON and the basic structure looks like this:  JSON Copy {     \"format_version\":\"1.19.20\",     \"minecraft:entity\":{         \"description\":{             \"identifier\":\"sample:example\",             \"is_spawnable\":true,             \"is_summonable\":true         },         \"components\":{                      },         \"component_groups\":{                      },         \"events\":{                      }     } }   Inside the description tag, a few basic properties define how the game registers the entity:  Expand table Parameter Name\tType\tDescription identifier\tString\tIdentifier of the entity. If this is a custom entity in an add-on, you should use a custom unique namespace as seen in the example. runtime_identifier\tString\tIdentifier that's used internally by the game. This can be used to inherit custom mechanics from Vanilla entities that are not yet available as a component. Only one runtime identifier may be specified per entity. Only use this if it is really necessary. If a Vanilla entity's mechanics are turned into components, you may lose functionality if you are relying on those mechanics through a runtime identifier. is_spawnable\tBoolean\tIf true, a spawn egg for the entity is added to the creative inventory. is_summonable\tBoolean\tIf true, the entity can be summoned using the /summon command. animations\tObject\tA list of behavior animations or behavior animation controllers. These aren't used for visible model animations. These can be used to run commands or events on the entity. scripts\tObject\tScripts work similarly to how they work in client entity files, and they can be used to play behavior animations. spawn_category\tString\tCurrently not fully implemented, so we recommend that creators do not set a value for this property. This property is optional. Available values include monster, creature, ambient, axolotls, underground_water_creature, water_creature, water_ambient and misc. If you do set this property, we recommend a value of misc. Components Basics  A full list of available components can be found in the Component List documentation.  A good way to learn about a component and see how it's used in practice is to look at the entity JSON files of default Minecraft entities. You can always find the latest default behavior pack at this URL: https://aka.ms/behaviorpacktemplate.   Note  The way a component works can sometimes change between versions. Learn more about versions in the manifest reference documentation. You're encouraged to always use the latest version of the component as it's been refined and can include fixes.  Essential Components Expand table Component Name\tOptions\tDescription minecraft:physics\thas_collision has_gravity\tYou'll need this component on 99% of custom entities. It allows the entity to stay on the ground and react to interaction and punches in a way that you would expect. minecraft:scale\tvalue\tSets the relative size of the entity. minecraft:type_family\tfamily\tSets a list of type families that the entity is in. Type families can be tested by other entities. For example, to test which mobs they are hostile towards. See Introduction to Entity Families minecraft:movement\tvalue\tSets the movement speed of the entity. 0.25 is the regular speed of most animals in Minecraft. minecraft:movement.basic\tSee documentation\tAllows the entity to move around on the ground. minecraft:navigation.walk\tSee documentation\tAllows the entity to navigate through the world by walking. There are other types of navigation as well, like hovering. minecraft:is_baby minecraft:is_ignited minecraft:is_saddled minecraft:is_sheared minecraft:is_tamed minecraft:is_illager_captain\tvalue\tThese components don't do anything on their own, but they can be queried in animations, animation controllers, or render controllers, allowing you to control animations and other visuals from the entity behavior. minecraft:variant minecraft:mark_variant minecraft:skin_id\tvalue\tThese components work like the ones above, but instead of only storing an on/off state, they can store an integer value. Priorities  The option priority can be used on all AI goal behavior components. 0 is the highest priority and the default priority of all behavior components. The higher the number, the lower the priority. If the entity is busy doing a low priority behavior and a high priority behavior comes up, the entity will immediately switch to the higher priority behavior.  In the following example, the hurt_by_target component has a higher priority. If the entity gets attacked while strolling, it will immediately target the attacker.  JSON Copy \"minecraft:behavior.random_stroll\":{     \"priority\":4 }, \"minecraft:behavior.hurt_by_target\":{     \"priority\":1 }   Components are properties or mechanics that you can add to your entity. There are two ways to add components: 1. Directly to the component tag or 2. In a component group.  Components added to the base component tag are always active unless removed or replaced through a component group in an event. Component groups are sets of one or more components each that aren't active by default but can be enabled or disabled through events. For instance, this can be used to create a variation of the entity, such as a baby cow. Adding Component Groups  These groups must be defined in the component_groups section of the file. As entities can only have one component of each type active, any components in a group that is being added will replace previously added components.  Additionally, adding a component group that is already active will cause those components to be re-initialized. For some types of components like minecraft:is_baby, re-initializing an already active component has no effect, but for other component types the associated logic will start over.  For example, an already-added minecraft:timer that is added again will start its timing logic over.  Component Groups Example  In this example, a component group is defined which can cause the entity to become a baby variation. The components defined in the main component section are always active, while the components in the baby component group are only active when that group is added by the sample:add_baby event.  JSON Copy {     \"format_version\":\"1.19.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\":\"sample:example\",             \"is_spawnable\":true,             \"is_summonable\":true         },         \"components\":{             \"minecraft:physics\": {             }         },         \"component_groups\": {             \"sample:baby\":{                 \"minecraft:behavior.follow_parent\": {                                      },                 \"minecraft:is_baby\": {                                      }             }         },         \"events\": {             \"sample:add_baby\": {                   \"add\": {                  \"component_groups\": {                      [\"baby\"]                 }             }         }       }     } }   All Minecraft components use the minecraft: namespace, which you can use when referring to a built in Minecraft behavior. Custom behaviors need to use a different namespace.  Almost all components are defined as a JSON object. Most components have options that can be specified inside this object, but some components work without options, as shown in the previous example.  Removing Components  When a component group is removed from an entity, the effect of the components will be removed as well. This won't cause any problems in most cases. But in some cases, it's important to consider that components overwrite each other. Therefore, removing a component won't make it go back to the previous state of that component, and it won't use the same component from another component group or the base components. Instead, the component will be removed completely and reset to its default values.  Here's an example: Let's say you have an entity with a scale of 2 defined in the base components tag. You add a baby component group with a scale component that sets the scale to 1.5. This will correctly update the scale to 1.5. Now, you remove that component group again. Instead of going back to 2, the scale will now be reset to 1. This happens because removing the component group will also remove the scale component entirely.  There are a few components where this is important to consider:  Components that change a value of the entity like minecraft:scale, minecraft:collision_box, or minecraft:variant. List components like minecraft:interact, minecraft:environment_sensor, or minecraft:damage_sensor. Any other components that you might want to have different states of like minecraft:rideable which has different seat counts or positions.  In order to avoid this behavior, you need to add a new component group with the updated state of the component. In the case of the scale example, this can be as easy as having two different component groups for the different states that you can switch between.  JSON Copy \"components\":{     \"minecraft:scale\":{         \"value\":2     } }, \"component_groups\":{     \"baby\":{         \"minecraft:scale\":{             \"value\":1.5         }     },     \"adult\":{         \"minecraft:scale\":{             \"value\":2         }     } }, \"events\":{     \"set_baby\":{         \"remove\":{             \"component_groups\":[                 \"adult\"              ]         },         \"add\":{             \"component_groups\":[                 \"baby\"             ]         }     },     \"set_adult\":{         \"remove\":{             \"component_groups\":[                 \"baby\"             ]         },         \"add\":{             \"component_groups\":[                 \"adult\"             ]         }     } }  Use Entity Components  If you ever get stuck or want a better understanding on how a component works, checking the Vanilla entity JSON files will allow you to see working examples. Deconstructing a Vanilla entity and applying it to a different entity is a great way to get started.  Here are a few ideas:  Take the minecraft:teleport component from an Endermen and apply it to a creeper. Make a zombie rideable by the player. Make baby creepers. What's Next?  The component system allows you to customize what your entity does and how it interacts with the world. If you want to learn more about entity events and using them to add more component groups with more customized behavior, see the Entity Events documentation.  Entity Events  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entitybehaviorcomponents?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Behavior (AI) Components 01/09/2025  Entity behavior components are one of the specific ways we can use components to get entities to behave a certain way. Behavior components determine how entities decide how to act in the game by controlling how they move, interact with objects or other entities, or respond to certain events. Here are some key points to keep in mind:  Behavior components are defined in .json files as part of a behavior pack. Behavior components start with minecraft:behavior.. Minecraft Bedrock edition includes many built-in behavior components. For a full list, see Entity Documentation - AI Goal Component List. Many behavior components accept parameters to fine-tune an entity's actions or responses to events, such as speed_multiplier or target_distance. Behavior Components Structure  As part of a behavior pack, behavior components are defined within an entity's .json file inside the behavior pack folder. Here is an example of the structure of a behavior pack:  Behavior Priority  Behavior components are evaluated independently, which means that different behaviors might be evaluated simultaneously. This can either help to create a seamless behavior, where two harmonious actions are performed at the same time, or it can cause two incompatible behaviors to compete. In the case where incompatible behaviors compete, you may see errors or notice that your entity's behaviors don't work in the way you expect.  To resolve this issue, it's important to know that behavior components work on a priority system. Behavior components with a lower priority value are executed first - so a component with a priority of 1 would execute before a component with a priority of 2. Behavior components also resolve on the same priority, meaning that, even if a component with a higher priority value meets the conditions for execution, the component with the lower priority value would resolve first before the next component is allowed to start. This helps to create a sequence of behaviors and seamless switching between behaviors.  Adding Custom Behavior  For a complete tutorial on adding custom behavior, check out the Create an Angry Cow: An Introduction To Behavior Packs (from scratch) guide. This will help you get an understanding of how to add components to an entity's .json file, where to add the code, and how to test and deploy your behavior pack. Pay close attention to the final angry cow components list to make sure you see how priority will affect the custom entity's behavior:  JSON Copy             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             }   See how minecraft:behavior.nearest_attackable_target has a lower priority value than the minecraft:behavior.melee_attack component? That's because we want to target only attackable entities that are not cows. If we didn't have the priorities set the way we do, then the cow may attack indiscriminantly or might try attacking things that don't take damage, causing it to get stuck in a loop.  Essential Behavior Components  Now that you know how to add behavior components and design custom behavior, let's take a look at some of the most important behavior components in Minecraft. While Minecraft does not have \"required\" components, there are some - like minecraft:movement, minecraft:health, and minecraft:interact that are essential to an entity's ability to have a meaningful impact on your world. Behavior components are similar. There are no requirements for behavior components, but there are definitely some behaviors that are extremely common and give entities a \"baseline\" ability to interact with the world, with other entities, and with players. Here's a list of some of the most common entity behaviors:  Expand table Behavior\tPurpose\tCommon Users minecraft:behavior.look_at_player\tMakes the entity look at a player.\tPassive mobs, neutral mobs minecraft:behavior.random_stroll\tMakes an entity wander around in a random path.\tPassive mobs minecraft:behavior.nearest_attackable_target\tTargets the nearest entity to attack.\tHostile mobs minecraft:behavior.attack\tDefines how the entity attacks its target.\tHostile mobs minecraft:behavior.hurt_by_target\tMakes the entity retaliate when it is hurt.\tPassive mobs, hostile mobs minecraft:behavior.breed\tEnables breeding for an entity.\tPassive mobs minecraft:behavior.follow_owner\tMakes an entity follow its owner.\tTamed mobs minecraft:behavior.sit\tMakes an entity sit on command.\tTamed mobs Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entitybehaviorcomponents?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Behavior (AI) Components 01/09/2025  Entity behavior components are one of the specific ways we can use components to get entities to behave a certain way. Behavior components determine how entities decide how to act in the game by controlling how they move, interact with objects or other entities, or respond to certain events. Here are some key points to keep in mind:  Behavior components are defined in .json files as part of a behavior pack. Behavior components start with minecraft:behavior.. Minecraft Bedrock edition includes many built-in behavior components. For a full list, see Entity Documentation - AI Goal Component List. Many behavior components accept parameters to fine-tune an entity's actions or responses to events, such as speed_multiplier or target_distance. Behavior Components Structure  As part of a behavior pack, behavior components are defined within an entity's .json file inside the behavior pack folder. Here is an example of the structure of a behavior pack:  Behavior Priority  Behavior components are evaluated independently, which means that different behaviors might be evaluated simultaneously. This can either help to create a seamless behavior, where two harmonious actions are performed at the same time, or it can cause two incompatible behaviors to compete. In the case where incompatible behaviors compete, you may see errors or notice that your entity's behaviors don't work in the way you expect.  To resolve this issue, it's important to know that behavior components work on a priority system. Behavior components with a lower priority value are executed first - so a component with a priority of 1 would execute before a component with a priority of 2. Behavior components also resolve on the same priority, meaning that, even if a component with a higher priority value meets the conditions for execution, the component with the lower priority value would resolve first before the next component is allowed to start. This helps to create a sequence of behaviors and seamless switching between behaviors.  Adding Custom Behavior  For a complete tutorial on adding custom behavior, check out the Create an Angry Cow: An Introduction To Behavior Packs (from scratch) guide. This will help you get an understanding of how to add components to an entity's .json file, where to add the code, and how to test and deploy your behavior pack. Pay close attention to the final angry cow components list to make sure you see how priority will affect the custom entity's behavior:  JSON Copy             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             }   See how minecraft:behavior.nearest_attackable_target has a lower priority value than the minecraft:behavior.melee_attack component? That's because we want to target only attackable entities that are not cows. If we didn't have the priorities set the way we do, then the cow may attack indiscriminantly or might try attacking things that don't take damage, causing it to get stuck in a loop.  Essential Behavior Components  Now that you know how to add behavior components and design custom behavior, let's take a look at some of the most important behavior components in Minecraft. While Minecraft does not have \"required\" components, there are some - like minecraft:movement, minecraft:health, and minecraft:interact that are essential to an entity's ability to have a meaningful impact on your world. Behavior components are similar. There are no requirements for behavior components, but there are definitely some behaviors that are extremely common and give entities a \"baseline\" ability to interact with the world, with other entities, and with players. Here's a list of some of the most common entity behaviors:  Expand table Behavior\tPurpose\tCommon Users minecraft:behavior.look_at_player\tMakes the entity look at a player.\tPassive mobs, neutral mobs minecraft:behavior.random_stroll\tMakes an entity wander around in a random path.\tPassive mobs minecraft:behavior.nearest_attackable_target\tTargets the nearest entity to attack.\tHostile mobs minecraft:behavior.attack\tDefines how the entity attacks its target.\tHostile mobs minecraft:behavior.hurt_by_target\tMakes the entity retaliate when it is hurt.\tPassive mobs, hostile mobs minecraft:behavior.breed\tEnables breeding for an entity.\tPassive mobs minecraft:behavior.follow_owner\tMakes an entity follow its owner.\tTamed mobs minecraft:behavior.sit\tMakes an entity sit on command.\tTamed mobs Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entityevents?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Events 09/20/2023  In this article you will learn more about events, including sequential events, randomized events, and how event spawning behavior works. This article will cover:  How to use events to modify active components based on some condition. How to use sequential and randomized events for more exciting behavior. Advanced entity events topics including execution and spawn events. Requirements  It's recommended that the following be completed before reviewing this article:  Creating New Entity Types Entity Behavior Introduction Events Overview  Events are used to add and remove component groups from an entity. In this example, an old component group is removed while two new ones are added:  JSON Copy \"events\":{     \"sample:example_event\":{         \"remove\":{             \"component_groups\":[                 \"sample:group_a\"             ]         },         \"add\":{             \"component_groups\":[                 \"sample:group_b\",                 \"sample:group_c\"             ]         }     } }  What causes entity events to run?  Events can be called from several locations:  Active components on the entity behavior JSON For example, the minecraft:ageable component on baby mobs has a grow_up property whose event is run on the same entity. For the Minecraft cow, this event is called minecraft:ageable_grow_up, and that event adds the minecraft:cow_adult component group after removing the minecraft:cow_baby component group. Other events on the entity behavior JSON An event can run another event. For example, the Minecraft sheep's minecraft:entity_spawned event has a randomize section that specifies a trigger to run either the spawn_adult or spawn_baby event. Behavior pack animation events Animations in Behavior Packs can run events from their timelines by using a string like @s example:event_name Behavior JSON from other entities Events are typically run from the owning entity, but in some cases the events can be run from other entities. One example is the wololo spell, which is something the Evoker can do to turn a nearby sheep from blue to red. This is done by the Evoker's minecraft:behavior.send_event behavior, which sends the wololo event to the other nearby Sheep entity. Built-in code behavior While most events are run by discoverable things in the games's JSON files, there are a few that are called directly from the Minecraft game code. One example is the minecraft:hive_full event, which is fired by beehives to any bee that tries but fails to enter the hive due to lack of available space. The /event command The /event command runs the specified event on any targeted entities that have an event with the same name defined. These can come from any of the places that can run commands – players typing them manually, Command Blocks, behavior pack animations, functions, or Scripting. The/summoncommand The/summoncommand can take a spawn event argument. When the desired entity is created, the specified spawn event is run instead of any other assumed spawn event, like minecraft:entity_spawned. The What are Spawn Events? section on this page has more information. Built-in Events  A few events are built into Minecraft and run if the entity is spawned under certain conditions.  Expand table Event Name\tEssential components minecraft:entity_born\tRuns when the entity is spawned by breeding. minecraft:entity_spawned\tRuns whenever the entity spawns. Note that it won't run if you manually /summon it. minecraft:entity_transformed\tRuns when another entity transforms into this entity. minecraft:on_prime\tRuns when the entity is primed and ready to explode. What are Spawn Events?  The /summon command and a few entity components can take a spawnEvent argument. Spawn events have been described in several places as any of the events that can be found in an entity's behavior definition, but this isn't entirely accurate.  The Minecraft engine has a concept of a desired spawn event when an entity is created. When an entity is created from a spawn egg for example, the minecraft:entity_spawned event is run as the spawn event. When an entity is created, for example from two cows breeding, the spawn event is minecraft:entity_born.  Other examples of less common spawn events are:  minecraft:entity_transformed which is often used by a minecraft:transformation component. minecraft:from_wandering_trader which is a spawn event on the llama that is used when the Wandering Trader spawns to create its appropriately decorated llamas.  The spawn event that is used when creating an entity, whether the event is specified or automatically selected, is run on the entity as it is being created. You can think of it as a constructor in programming language terms. The entity starts with the default-included components list, as specified in its behavior JSON file. Then it also gets the effects of its spawn event, which will probably add one or more component_groups, possibly based on some random selection.  Using the minecraft:cow as an example, it has both a minecraft:entity_spawned and minecraft:entity_born event. minecraft:entity_spawned has a 95% chance of calling the minecraft:spawn_adult event (which adds the minecraft:cow_adult component group), and a 5% chance of adding the minecraft:cow_baby component group. The minecraft:entity_born event simply always adds the minecraft:cow_baby component group.  In this case, all of those events can be considered spawn events, because they're meant to be called for various reasons as part of initialization of a new minecraft:cow entity. They either end up with the cow having adult or baby-related components such as the interaction to get a bucket of milk using an empty bucket, or the ability to grow into an adult after being fed enough wheat.  This overall system of events, some of which are meant as spawn events, works well enough in the standard game of Minecraft, but strange things can happen if events are used in unexpected ways.  Strange Entity States Are Possible  For example, what happens if you use the command /summon minecraft:cow ~ ~ ~ missing_event? The cow has no event named missing_event, so it will use that as its spawn event instead of minecraft:entity_spawned. The result will be a cow that isn't a baby but also isn't interactable to get a bucket of milk.  A similarly strange situation can happen when using the /event command to run a spawn event on an already-created entity. If you use that command to run minecraft:entity_born on an adult cow, you can end up with a cow that can be interacted with for milk, but otherwise mostly behaves like a baby.  The side-effects of using events in unexpected ways will vary based on the nuances of how any particular entity is authored. Sometimes the entity won't misbehave, but other times it might lack the ability to move, or have a very wrong scale, or any number of unexpected traits.   Note  While these strange conditions of entities can be very entertaining, because they're unexpected they also aren't intentionally supported. It's possible the specific behaviors of these odd states will change from one game version to the next, as other intentional behavior is adjusted for new features or bug fixing.  Randomizers  If you want to randomize which component group gets added to the entity, you can use the randomize function. You specify an array of objects, each of which can add and remove component groups. The game will randomly pick and run one of these objects.  Optionally, you can add a weight option to the options to change the probability of each option. All weights can be combined count to add up to 100%. In the following example, the entity will spawn as a baby with a 20% (1 to 5) chance, while in the other cases, no component group is added:  JSON Copy \"events\":{     \"minecraft:entity_spawned\":{         \"randomize\":[             {                 \"weight\":40             },             {                 \"weight\":10,                 \"add\":{                     \"component_groups\":[                         \"baby\"                     ]                 }             }         ]     } }  Sequences  The sequence node is an array node that will execute all entries in order. Sometimes you need to run multiple event instances one after the other in the same event. Sequences are structured similarly to randomizers, but each item in the list is executed in order.  For example, you might want to randomize two aspects of the entity, like the color and mark pattern. In this case, you can use a sequence.  Sequences and randomizers can be nested indefinitely.  In this example, the group initial will be added when the entity is spawned. After that, the baby component will be randomized like in the previous section.  JSON Copy \"events\":{     \"minecraft:entity_spawned\":{         \"sequence\":[             {                 \"add\":{                     \"component_groups\":[                         \"initial\"                     ]                 }             },             {                 \"randomize\":[                     {                         \"weight\":40                     },                     {                         \"weight\":10,                         \"add\":{                             \"component_groups\":[                                 \"baby\"                             ]                         }                     }                 ]             }         ]     } }  Filters  Filters condition an event or a part of an event by testing for a specific property on the current entity, the interacting entity, or the world. Filters can be used in any event, but you can also use them directly in some components.  An event consists of up to five parameters. The parameters test and value are required — the others are optional:  Expand table Test Type\tThe property to test for test\tThe test that will be run. value\tThe value to test for. This can be a string when testing for strings, a number when testing for numeric values, or a boolean. subject\tThe entity that the test runs on. By default this is self, but it can also target the other entity involved in an interaction. operator\tThe way in which the value is compared. This defaults to equals but can also test for smaller or greater values (on numeric values) or for inequality. domain\tThis is only used by a few tests to provide additional context, such as the inventory slot to test in for the has_equipment test.   Note  A full list of the filters, and how these parameters interact with them, can be found in the Entities filter list.  A minimal example of a filter inside an event could look like the sample below. The component group can only be added if the entity has the tag event_allowed.  JSON Copy \"events\":{     \"sample:example_event\":{         \"filters\":{             \"test\":\"has_tag\",             \"value\":\"event_allowed\"         },         \"add\":{             \"component_groups\":[                 \"baby\"             ]         }     } }    Note  A format_version of 1.19.20 or higher is required to use a filter at the root of an event. If a lower format_version is specified, filters will only be respected by the game if they are underneath sequence or randomize nodes.  To use multiple filters, you can group them using the lists all_of, any_of, or none_of which will only succeed if all of the filters inside, any one of the filters inside, or none of the filters inside succeeded. These lists can be nested indefinitely.  In the following example, we're adding a second condition to the filter. The event will only run if the entity has the tag from the previous example and is less than 10 blocks away from the nearest player.  JSON Copy \"events\":{     \"sample:example_event\":{         \"filters\":{             \"all_of\":[                 {                     \"test\":\"has_tag\",                     \"value\":\"event_allowed\"                 },                 {                     \"test\":\"distance_to_nearest_player\",                     \"operator\":\"<\",                     \"value\":10                 }             ]         },         \"add\":{             \"component_groups\":[                 \"baby\"             ]         }     } }  Event Execution Order  When an event is received, the effects of that event are determined immediately, but those changes are not applied to the entity until the entity ticks on the server side of the game. This means filters in later entries in a sequence array won't see changes from earlier in that array.  It also means that when one entity sends an event to another entity, it could take effect on the same game tick or on the next tick, depending on whether the target entity has already been updated.  Here is an example of this nuance. An entity type has a component group defined that contains a minecraft:is_baby component. That entity type also has an event that adds this component group, then immediately calls another event that tests for that component. The test for that component would not see the component because it doesn`t exist on the entity instance yet, its addition is still pending.  JSON Copy \"component_groups\":{     \"example:be_baby\":{         \"minecraft:is_baby\":{}         }     },     \"example:another_group\":{         \"minecraft:scale\":{             \"value\":0.5         }     }, \"events\":{     \"example:become_baby\":{         \"add\":{             \"component_groups\":[                 \"example:be_baby\"             ]         },         \"trigger\":\"example:scale_check\"     },     \"example:scale_check\":{         \"sequence\":[             {                 \"filters\":{                     \"test\":\"has_component\",                     \"value\":\"minecraft:is_baby\"                     ]                 },                 \"add\"{                     \"component_groups\":[                         \"example:another_group\"                     ]                 }             }         }     }   Imagine an entity with the above JSON does not have any component groups added yet, and it receives an example:become_baby event.  The event will immediately queue the example:be_baby component group for addition, then right away call its example:scale_check event. The example:scale_check event is handled, which checks its has_component filter to see if the example:another_group component group should be added. Because the example:be_baby component group's addition is still pending, the entity does not yet have a minecraft:is_baby component, so the example:scale_check event ends up doing nothing. The next time the entity updates (which happens every server tick, 20 times a second), the example:be_baby component group is added, which adds the minecraft:is_baby component. After that, receiving the example:scale_check event would cause the event's filter logic to allow adding the example:another_group component group. What's Next?  The entity events system allows for component groups and custom functionality to be included in both existing Vanilla entities and new, custom entities. If you want to learn more about designing how your entity looks and moves, check out the entity modeling and animation tutorial.  Entity Modeling and Animation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entityevents?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Events 09/20/2023  In this article you will learn more about events, including sequential events, randomized events, and how event spawning behavior works. This article will cover:  How to use events to modify active components based on some condition. How to use sequential and randomized events for more exciting behavior. Advanced entity events topics including execution and spawn events. Requirements  It's recommended that the following be completed before reviewing this article:  Creating New Entity Types Entity Behavior Introduction Events Overview  Events are used to add and remove component groups from an entity. In this example, an old component group is removed while two new ones are added:  JSON Copy \"events\":{     \"sample:example_event\":{         \"remove\":{             \"component_groups\":[                 \"sample:group_a\"             ]         },         \"add\":{             \"component_groups\":[                 \"sample:group_b\",                 \"sample:group_c\"             ]         }     } }  What causes entity events to run?  Events can be called from several locations:  Active components on the entity behavior JSON For example, the minecraft:ageable component on baby mobs has a grow_up property whose event is run on the same entity. For the Minecraft cow, this event is called minecraft:ageable_grow_up, and that event adds the minecraft:cow_adult component group after removing the minecraft:cow_baby component group. Other events on the entity behavior JSON An event can run another event. For example, the Minecraft sheep's minecraft:entity_spawned event has a randomize section that specifies a trigger to run either the spawn_adult or spawn_baby event. Behavior pack animation events Animations in Behavior Packs can run events from their timelines by using a string like @s example:event_name Behavior JSON from other entities Events are typically run from the owning entity, but in some cases the events can be run from other entities. One example is the wololo spell, which is something the Evoker can do to turn a nearby sheep from blue to red. This is done by the Evoker's minecraft:behavior.send_event behavior, which sends the wololo event to the other nearby Sheep entity. Built-in code behavior While most events are run by discoverable things in the games's JSON files, there are a few that are called directly from the Minecraft game code. One example is the minecraft:hive_full event, which is fired by beehives to any bee that tries but fails to enter the hive due to lack of available space. The /event command The /event command runs the specified event on any targeted entities that have an event with the same name defined. These can come from any of the places that can run commands – players typing them manually, Command Blocks, behavior pack animations, functions, or Scripting. The/summoncommand The/summoncommand can take a spawn event argument. When the desired entity is created, the specified spawn event is run instead of any other assumed spawn event, like minecraft:entity_spawned. The What are Spawn Events? section on this page has more information. Built-in Events  A few events are built into Minecraft and run if the entity is spawned under certain conditions.  Expand table Event Name\tEssential components minecraft:entity_born\tRuns when the entity is spawned by breeding. minecraft:entity_spawned\tRuns whenever the entity spawns. Note that it won't run if you manually /summon it. minecraft:entity_transformed\tRuns when another entity transforms into this entity. minecraft:on_prime\tRuns when the entity is primed and ready to explode. What are Spawn Events?  The /summon command and a few entity components can take a spawnEvent argument. Spawn events have been described in several places as any of the events that can be found in an entity's behavior definition, but this isn't entirely accurate.  The Minecraft engine has a concept of a desired spawn event when an entity is created. When an entity is created from a spawn egg for example, the minecraft:entity_spawned event is run as the spawn event. When an entity is created, for example from two cows breeding, the spawn event is minecraft:entity_born.  Other examples of less common spawn events are:  minecraft:entity_transformed which is often used by a minecraft:transformation component. minecraft:from_wandering_trader which is a spawn event on the llama that is used when the Wandering Trader spawns to create its appropriately decorated llamas.  The spawn event that is used when creating an entity, whether the event is specified or automatically selected, is run on the entity as it is being created. You can think of it as a constructor in programming language terms. The entity starts with the default-included components list, as specified in its behavior JSON file. Then it also gets the effects of its spawn event, which will probably add one or more component_groups, possibly based on some random selection.  Using the minecraft:cow as an example, it has both a minecraft:entity_spawned and minecraft:entity_born event. minecraft:entity_spawned has a 95% chance of calling the minecraft:spawn_adult event (which adds the minecraft:cow_adult component group), and a 5% chance of adding the minecraft:cow_baby component group. The minecraft:entity_born event simply always adds the minecraft:cow_baby component group.  In this case, all of those events can be considered spawn events, because they're meant to be called for various reasons as part of initialization of a new minecraft:cow entity. They either end up with the cow having adult or baby-related components such as the interaction to get a bucket of milk using an empty bucket, or the ability to grow into an adult after being fed enough wheat.  This overall system of events, some of which are meant as spawn events, works well enough in the standard game of Minecraft, but strange things can happen if events are used in unexpected ways.  Strange Entity States Are Possible  For example, what happens if you use the command /summon minecraft:cow ~ ~ ~ missing_event? The cow has no event named missing_event, so it will use that as its spawn event instead of minecraft:entity_spawned. The result will be a cow that isn't a baby but also isn't interactable to get a bucket of milk.  A similarly strange situation can happen when using the /event command to run a spawn event on an already-created entity. If you use that command to run minecraft:entity_born on an adult cow, you can end up with a cow that can be interacted with for milk, but otherwise mostly behaves like a baby.  The side-effects of using events in unexpected ways will vary based on the nuances of how any particular entity is authored. Sometimes the entity won't misbehave, but other times it might lack the ability to move, or have a very wrong scale, or any number of unexpected traits.   Note  While these strange conditions of entities can be very entertaining, because they're unexpected they also aren't intentionally supported. It's possible the specific behaviors of these odd states will change from one game version to the next, as other intentional behavior is adjusted for new features or bug fixing.  Randomizers  If you want to randomize which component group gets added to the entity, you can use the randomize function. You specify an array of objects, each of which can add and remove component groups. The game will randomly pick and run one of these objects.  Optionally, you can add a weight option to the options to change the probability of each option. All weights can be combined count to add up to 100%. In the following example, the entity will spawn as a baby with a 20% (1 to 5) chance, while in the other cases, no component group is added:  JSON Copy \"events\":{     \"minecraft:entity_spawned\":{         \"randomize\":[             {                 \"weight\":40             },             {                 \"weight\":10,                 \"add\":{                     \"component_groups\":[                         \"baby\"                     ]                 }             }         ]     } }  Sequences  The sequence node is an array node that will execute all entries in order. Sometimes you need to run multiple event instances one after the other in the same event. Sequences are structured similarly to randomizers, but each item in the list is executed in order.  For example, you might want to randomize two aspects of the entity, like the color and mark pattern. In this case, you can use a sequence.  Sequences and randomizers can be nested indefinitely.  In this example, the group initial will be added when the entity is spawned. After that, the baby component will be randomized like in the previous section.  JSON Copy \"events\":{     \"minecraft:entity_spawned\":{         \"sequence\":[             {                 \"add\":{                     \"component_groups\":[                         \"initial\"                     ]                 }             },             {                 \"randomize\":[                     {                         \"weight\":40                     },                     {                         \"weight\":10,                         \"add\":{                             \"component_groups\":[                                 \"baby\"                             ]                         }                     }                 ]             }         ]     } }  Filters  Filters condition an event or a part of an event by testing for a specific property on the current entity, the interacting entity, or the world. Filters can be used in any event, but you can also use them directly in some components.  An event consists of up to five parameters. The parameters test and value are required — the others are optional:  Expand table Test Type\tThe property to test for test\tThe test that will be run. value\tThe value to test for. This can be a string when testing for strings, a number when testing for numeric values, or a boolean. subject\tThe entity that the test runs on. By default this is self, but it can also target the other entity involved in an interaction. operator\tThe way in which the value is compared. This defaults to equals but can also test for smaller or greater values (on numeric values) or for inequality. domain\tThis is only used by a few tests to provide additional context, such as the inventory slot to test in for the has_equipment test.   Note  A full list of the filters, and how these parameters interact with them, can be found in the Entities filter list.  A minimal example of a filter inside an event could look like the sample below. The component group can only be added if the entity has the tag event_allowed.  JSON Copy \"events\":{     \"sample:example_event\":{         \"filters\":{             \"test\":\"has_tag\",             \"value\":\"event_allowed\"         },         \"add\":{             \"component_groups\":[                 \"baby\"             ]         }     } }    Note  A format_version of 1.19.20 or higher is required to use a filter at the root of an event. If a lower format_version is specified, filters will only be respected by the game if they are underneath sequence or randomize nodes.  To use multiple filters, you can group them using the lists all_of, any_of, or none_of which will only succeed if all of the filters inside, any one of the filters inside, or none of the filters inside succeeded. These lists can be nested indefinitely.  In the following example, we're adding a second condition to the filter. The event will only run if the entity has the tag from the previous example and is less than 10 blocks away from the nearest player.  JSON Copy \"events\":{     \"sample:example_event\":{         \"filters\":{             \"all_of\":[                 {                     \"test\":\"has_tag\",                     \"value\":\"event_allowed\"                 },                 {                     \"test\":\"distance_to_nearest_player\",                     \"operator\":\"<\",                     \"value\":10                 }             ]         },         \"add\":{             \"component_groups\":[                 \"baby\"             ]         }     } }  Event Execution Order  When an event is received, the effects of that event are determined immediately, but those changes are not applied to the entity until the entity ticks on the server side of the game. This means filters in later entries in a sequence array won't see changes from earlier in that array.  It also means that when one entity sends an event to another entity, it could take effect on the same game tick or on the next tick, depending on whether the target entity has already been updated.  Here is an example of this nuance. An entity type has a component group defined that contains a minecraft:is_baby component. That entity type also has an event that adds this component group, then immediately calls another event that tests for that component. The test for that component would not see the component because it doesn`t exist on the entity instance yet, its addition is still pending.  JSON Copy \"component_groups\":{     \"example:be_baby\":{         \"minecraft:is_baby\":{}         }     },     \"example:another_group\":{         \"minecraft:scale\":{             \"value\":0.5         }     }, \"events\":{     \"example:become_baby\":{         \"add\":{             \"component_groups\":[                 \"example:be_baby\"             ]         },         \"trigger\":\"example:scale_check\"     },     \"example:scale_check\":{         \"sequence\":[             {                 \"filters\":{                     \"test\":\"has_component\",                     \"value\":\"minecraft:is_baby\"                     ]                 },                 \"add\"{                     \"component_groups\":[                         \"example:another_group\"                     ]                 }             }         }     }   Imagine an entity with the above JSON does not have any component groups added yet, and it receives an example:become_baby event.  The event will immediately queue the example:be_baby component group for addition, then right away call its example:scale_check event. The example:scale_check event is handled, which checks its has_component filter to see if the example:another_group component group should be added. Because the example:be_baby component group's addition is still pending, the entity does not yet have a minecraft:is_baby component, so the example:scale_check event ends up doing nothing. The next time the entity updates (which happens every server tick, 20 times a second), the example:be_baby component group is added, which adds the minecraft:is_baby component. After that, receiving the example:scale_check event would cause the event's filter logic to allow adding the example:another_group component group. What's Next?  The entity events system allows for component groups and custom functionality to be included in both existing Vanilla entities and new, custom entities. If you want to learn more about designing how your entity looks and moves, check out the entity modeling and animation tutorial.  Entity Modeling and Animation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/makerseriesmakingthegoblinchef?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating a Goblin Chef 05/06/2025  This tutorial is meant to be an inside look at how professional Minecraft creators make something cool from beginning to end. Instead of teaching the basics of creation tools, this tutorial assumes some base knowledge of creating in Minecraft and lets us spend more time talking about creative decisions like color choice or finding the right proportions. The goal is to give you direct insight into how pros think while they are creating, and hopefully you can learn some tips and tricks along the way.  These videos feature Mojang 3D artist Peter Sheff, as he walks you through the creation of a custom Goblin Chef entity. Here, we will take you from the early concept phase of the Chef all the way to it being ready to be placed inside of Minecraft. There are three parts to the tutorial: Part 1 is modeling, part 2 is texturing, and part 3 is animating. These videos are 10-15 minutes each, so feel free to watch each part separately.  Part 1: Modeling  In this video, Peter starts with the fundamentals of creating a new entity. The initial focus is using the 3D shape tools in Blockbench to focus on getting the 3D form of the Goblin Chef just right.  Part 2: Texturing  Now that the basic shape of the chef has been determined, it's time to apply a set of colors and textures to our new friend. Here, Peter focuses on the process of designing your UV textures including tips, tricks, and shortcuts for using various tools within Blockbench.  Part 3: Animating  In the animating section, you'll see how Peter animates the basic parts of the Goblin Chef, adding natural animations to the head, arms, and legs to create a walk cycle. You can see how to adjust the motion of various parts by adding keyframes in the Timeline tool of Blockbench.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/makerseriesmakingthegoblinchef?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating a Goblin Chef 05/06/2025  This tutorial is meant to be an inside look at how professional Minecraft creators make something cool from beginning to end. Instead of teaching the basics of creation tools, this tutorial assumes some base knowledge of creating in Minecraft and lets us spend more time talking about creative decisions like color choice or finding the right proportions. The goal is to give you direct insight into how pros think while they are creating, and hopefully you can learn some tips and tricks along the way.  These videos feature Mojang 3D artist Peter Sheff, as he walks you through the creation of a custom Goblin Chef entity. Here, we will take you from the early concept phase of the Chef all the way to it being ready to be placed inside of Minecraft. There are three parts to the tutorial: Part 1 is modeling, part 2 is texturing, and part 3 is animating. These videos are 10-15 minutes each, so feel free to watch each part separately.  Part 1: Modeling  In this video, Peter starts with the fundamentals of creating a new entity. The initial focus is using the 3D shape tools in Blockbench to focus on getting the 3D form of the Goblin Chef just right.  Part 2: Texturing  Now that the basic shape of the chef has been determined, it's time to apply a set of colors and textures to our new friend. Here, Peter focuses on the process of designing your UV textures including tips, tricks, and shortcuts for using various tools within Blockbench.  Part 3: Animating  In the animating section, you'll see how Peter animates the basic parts of the Goblin Chef, adding natural animations to the head, arms, and legs to create a walk cycle. You can see how to adjust the motion of various parts by adding keyframes in the Timeline tool of Blockbench.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createanimatedblocktexture?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create an Animated Block Texture 05/21/2025  In this tutorial, you'll learn how to create custom block texture animations using a resource pack. You do not need any third-party animation applications.  Flipbook animation is an illusion made by displaying multiple images one at a time in the same spot so that the viewer perceives motion. It's called a \"flipbook\" because animators can get a thick book of drawing paper and make little drawings in the corner and then hold the book just right to make the pages flip by so quickly that it looks like their drawings are moving.  Each page's graphic is called a \"frame,\" and the illusion can be affected by how quickly each frame is replaced by the next one and whether the changes between each frame are blended together to create a smoother appearance.  One difference between Minecraft flipbook animation and paper flipbook animation is that rather than using individual pages/graphic files for each frame, Minecraft animation frames are stored as one long strip. Each frame is a 16 by 16-pixel square. The animation code inside the Minecraft game assigns each square a number and then displays each one starting at the top with frame 0.  By default, each of the six faces of a Minecraft block show the same frame of animation at the same time. The process to put a different animation on different faces of the block will be covered later.  Prerequisites  Before you begin this tutorial, you should do the following:  Create a resource pack using the Creating a Resource Pack tutorial, or download the sample pack collection and keep it handy on your computer. Download and expand the latest Vanilla Minecraft packs. The code and graphics needed for these tutorials will be provided along the way, but it's a good idea to have the sample pack as a reference. A Flipbook animation resource pack  This is the basic structure and content for the animation pack we are creating:  resource_pack textures blocks <block_name>.png flipbook_texture.json manifest.json  Open the resource pack from the Vanilla Minecraft sample packs.  Open the textures folder, then open the blocks folder. This is where the .png graphics files for blocks live.  Open the flipbook_texture.json file and take a look at the contents. There is a large list of different flipbook textures. Notice how different textures have different properties.  Here are some examples:  sculk  JSON Copy   {     \"flipbook_texture\": \"textures/blocks/sculk\",     \"atlas_tile\": \"sculk\",     \"ticks_per_frame\": 20   }   bubble column  JSON Copy  {     \"flipbook_texture\": \"textures/blocks/bubble_column_inner_b\",     \"atlas_index\": 1,     \"atlas_tile_variant\": 1,     \"atlas_tile\": \"bubble_column_mid\",     \"ticks_per_frame\": 1,     \"frames\": [ 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],     \"blend_frames\": false   }   respawn anchor top  JSON Copy {     \"flipbook_texture\": \"textures/blocks/respawn_anchor_top\",     \"atlas_tile\": \"respawn_anchor_top\",     \"atlas_index\": 2,     \"atlas_tile_variant\": 2,     \"frames\": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ]   }   Flipbook Texture Properties  Expand table Name\tDescription flipbook_texture\tPath to the graphic file for one or more faces of a block atlas_index\tIndex of the first frame to display when beginning the animation. If a problem occurs, then only this frame will be displayed. atlas_tile\tName of the graphic that will be shown on the block if there is a problem with the animation. atlas_tile_variant\tAn alternate graphic to display as the atlas tile. ticks_per_frame\tHow many ticks (1/20th of one second) of game time should pass before the next frame is displayed. frames\tAn array of frame numbers, used to show what order to display the frames. Prepare an animation resource pack  Start with the finished \"green dirt block\" resource pack that you can either create with the resource pack tutorial or download from Minecraft pack samples.  Rename the pack's folder animation_resource_pack.  Make sure there are new UUIDs in the manifest.json file.  (Optional) Change the name and descriptions to reflect the pack's use for animation.  Okay. Now we're ready to animate!  Edit an already animated block  To get familiar with how block textures are animated, we're going to start with one that is already animated, make some changes to it, and then observe the changes.  Inside the animation_resource_pack, open the textures folder.  Add a text file and name it flipbook_texture.json.  Add this content, then save and close the file.  JSON Copy [   {     \"flipbook_texture\": \"textures/blocks/sculk\",     \"atlas_tile\": \"sculk\",     \"frames\": [ 0, 1, 2, 3],     \"ticks_per_frame\": 20   } ]   Open the blocks folder.  Download this sculk.png file and place it in the blocks folder of your animation_resource_pack.  Open sculk.png in a graphics program like Paint.net.  Edit each frame of the sculk graphic so it looks a little different.  Here is an already edited graphic file, if you would prefer to use it to replace the original one.  When you put it in your resource pack, you will need to rename it from sculk_EDITED.png to sculk.png.  After you have the edited sculk.png file in place, deploy the resource pack to Minecraft and place a sculk block. It should look something like this:  Now that we have a better idea how flipbook animated textures work on an already animated block, let's see if we can animated a block that is NOT already animated.  Add animation to a non-animated block: lapis lazuli ore  Let's build on the existing animation pack by replacing the contents of your animation resource pack's flipbook_texture.json file with this:  JSON Copy [   {     \"flipbook_texture\": \"textures/blocks/sculk\",     \"atlas_tile\": \"sculk\",     \"frames\": [ 0, 1, 2, 3],     \"ticks_per_frame\": 20   },   {     \"flipbook_texture\": \"textures/blocks/lapis_ore\",     \"atlas_tile\": \"lapis_ore\",     \"frames\": [ 0, 1, 2, 3, 4, 5],     \"ticks_per_frame\": 10   } ]   In the lapis ore section, the \"frames\": [ 0, 1, 2, 3, 4, 5] line of the code says that we will be adding 5 frames to the existing lapis_ore.png file.  The \"ticks_per_frame\": 10 line means that the lapis animation will have a faster frame rate than the one for sculk.  The original Vanilla lapis ore texture file, lapis_ore.png, looks like this:  The original file is 16 by 16 pixels. If we want to have a 6-frame animation like it says in the flipbook_texture.json file code (and we do), we need to open the graphic file and change the canvas size to be 96 pixels tall.  Like this:  Now that the canvas can accommodate a total of 6 frames, add 5 more frames worth of graphics to the file. Here is one way to do it:  Put the edited graphic file in the textures/blocks folder of your animation pack, make sure the name is changed from lapis_ore_EDITED.png to lapis_ore.png, and you're ready to go take a look at your animated block in Minecraft.  Animate the custom die block  After completing the Advanced Custom Blocks tutorial you will have a red block in your hotbar and hand that, when placed, looks like a die block.  In this next example, we're going to animate the block in the player's hand to scroll through the pattern of dots.  Due to how textures are mapped onto blocks in the hotbar, all three visible sides of the die block will have the same pattern as the numbers shift from one through six.  You can download the completed sample Custom Die block resource pack and behavior pack. You will need both the behavior pack and the resource pack for it to work.  Navigate to resource pack > textures, add a flipbook_texture.json file, and insert this code:  JSON Copy [   {     \"flipbook_texture\": \"textures/blocks/die_red\",     \"atlas_tile\": \"die_red\",     \"frames\": [ 0, 1, 2, 3, 4, 5 ],     \"ticks_per_frame\": 20,     \"blend_frames\": false   } ]   Then, replace the die_red.png graphic in the textures/blocks folder with this one:  In a creative world with the behavior pack and resource pack activated, give yourself a demo:die and notice that the red block is now animated.  A Multi-faceted Animation: the Command Block  For the purpose of this discussion, we are talking only about the basic \"Vanilla\" command black, not the ones with conditional or chain or mipmap in their names. They are all animated the same way. I'm mentioning this so that if you go digging for the code in the flipbook_texture.json file or for the graphics in the blocks folder of the Vanilla sample pack, you'll know to look for the ones whose names match the names on the \"flipbook_texture\": line of the code.  If you take a really close look at a command block, you'll notice that the front, back, and sides of the block have different shapes with animated blinking dots on them.  The front of the block has a circle shape and the four sides have an arrow shape:  The back of the block has a square shape:  The frames are mapped onto the command block with this code:  JSON Copy {   \"flipbook_texture\": \"textures/blocks/command_block_front\",   \"atlas_tile\": \"command_block_front\",   \"ticks_per_frame\": 10 }, {   \"flipbook_texture\": \"textures/blocks/command_block_back\",   \"atlas_tile\": \"command_block_back\",   \"ticks_per_frame\": 10 }, {   \"flipbook_texture\": \"textures/blocks/command_block_side\",   \"atlas_tile\": \"command_block_side\",   \"ticks_per_frame\": 10 }   Here are some edited command block texture graphics.  command_block_front  command_block_back  command_block_side  This is the final result:  Next Steps  Now that you know how to animate block textures, take a look at this page about Add-on Pack Contents to see what else you could do to customize your own Minecraft world!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createanimatedblocktexture?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create an Animated Block Texture 05/21/2025  In this tutorial, you'll learn how to create custom block texture animations using a resource pack. You do not need any third-party animation applications.  Flipbook animation is an illusion made by displaying multiple images one at a time in the same spot so that the viewer perceives motion. It's called a \"flipbook\" because animators can get a thick book of drawing paper and make little drawings in the corner and then hold the book just right to make the pages flip by so quickly that it looks like their drawings are moving.  Each page's graphic is called a \"frame,\" and the illusion can be affected by how quickly each frame is replaced by the next one and whether the changes between each frame are blended together to create a smoother appearance.  One difference between Minecraft flipbook animation and paper flipbook animation is that rather than using individual pages/graphic files for each frame, Minecraft animation frames are stored as one long strip. Each frame is a 16 by 16-pixel square. The animation code inside the Minecraft game assigns each square a number and then displays each one starting at the top with frame 0.  By default, each of the six faces of a Minecraft block show the same frame of animation at the same time. The process to put a different animation on different faces of the block will be covered later.  Prerequisites  Before you begin this tutorial, you should do the following:  Create a resource pack using the Creating a Resource Pack tutorial, or download the sample pack collection and keep it handy on your computer. Download and expand the latest Vanilla Minecraft packs. The code and graphics needed for these tutorials will be provided along the way, but it's a good idea to have the sample pack as a reference. A Flipbook animation resource pack  This is the basic structure and content for the animation pack we are creating:  resource_pack textures blocks <block_name>.png flipbook_texture.json manifest.json  Open the resource pack from the Vanilla Minecraft sample packs.  Open the textures folder, then open the blocks folder. This is where the .png graphics files for blocks live.  Open the flipbook_texture.json file and take a look at the contents. There is a large list of different flipbook textures. Notice how different textures have different properties.  Here are some examples:  sculk  JSON Copy   {     \"flipbook_texture\": \"textures/blocks/sculk\",     \"atlas_tile\": \"sculk\",     \"ticks_per_frame\": 20   }   bubble column  JSON Copy  {     \"flipbook_texture\": \"textures/blocks/bubble_column_inner_b\",     \"atlas_index\": 1,     \"atlas_tile_variant\": 1,     \"atlas_tile\": \"bubble_column_mid\",     \"ticks_per_frame\": 1,     \"frames\": [ 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],     \"blend_frames\": false   }   respawn anchor top  JSON Copy {     \"flipbook_texture\": \"textures/blocks/respawn_anchor_top\",     \"atlas_tile\": \"respawn_anchor_top\",     \"atlas_index\": 2,     \"atlas_tile_variant\": 2,     \"frames\": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ]   }   Flipbook Texture Properties  Expand table Name\tDescription flipbook_texture\tPath to the graphic file for one or more faces of a block atlas_index\tIndex of the first frame to display when beginning the animation. If a problem occurs, then only this frame will be displayed. atlas_tile\tName of the graphic that will be shown on the block if there is a problem with the animation. atlas_tile_variant\tAn alternate graphic to display as the atlas tile. ticks_per_frame\tHow many ticks (1/20th of one second) of game time should pass before the next frame is displayed. frames\tAn array of frame numbers, used to show what order to display the frames. Prepare an animation resource pack  Start with the finished \"green dirt block\" resource pack that you can either create with the resource pack tutorial or download from Minecraft pack samples.  Rename the pack's folder animation_resource_pack.  Make sure there are new UUIDs in the manifest.json file.  (Optional) Change the name and descriptions to reflect the pack's use for animation.  Okay. Now we're ready to animate!  Edit an already animated block  To get familiar with how block textures are animated, we're going to start with one that is already animated, make some changes to it, and then observe the changes.  Inside the animation_resource_pack, open the textures folder.  Add a text file and name it flipbook_texture.json.  Add this content, then save and close the file.  JSON Copy [   {     \"flipbook_texture\": \"textures/blocks/sculk\",     \"atlas_tile\": \"sculk\",     \"frames\": [ 0, 1, 2, 3],     \"ticks_per_frame\": 20   } ]   Open the blocks folder.  Download this sculk.png file and place it in the blocks folder of your animation_resource_pack.  Open sculk.png in a graphics program like Paint.net.  Edit each frame of the sculk graphic so it looks a little different.  Here is an already edited graphic file, if you would prefer to use it to replace the original one.  When you put it in your resource pack, you will need to rename it from sculk_EDITED.png to sculk.png.  After you have the edited sculk.png file in place, deploy the resource pack to Minecraft and place a sculk block. It should look something like this:  Now that we have a better idea how flipbook animated textures work on an already animated block, let's see if we can animated a block that is NOT already animated.  Add animation to a non-animated block: lapis lazuli ore  Let's build on the existing animation pack by replacing the contents of your animation resource pack's flipbook_texture.json file with this:  JSON Copy [   {     \"flipbook_texture\": \"textures/blocks/sculk\",     \"atlas_tile\": \"sculk\",     \"frames\": [ 0, 1, 2, 3],     \"ticks_per_frame\": 20   },   {     \"flipbook_texture\": \"textures/blocks/lapis_ore\",     \"atlas_tile\": \"lapis_ore\",     \"frames\": [ 0, 1, 2, 3, 4, 5],     \"ticks_per_frame\": 10   } ]   In the lapis ore section, the \"frames\": [ 0, 1, 2, 3, 4, 5] line of the code says that we will be adding 5 frames to the existing lapis_ore.png file.  The \"ticks_per_frame\": 10 line means that the lapis animation will have a faster frame rate than the one for sculk.  The original Vanilla lapis ore texture file, lapis_ore.png, looks like this:  The original file is 16 by 16 pixels. If we want to have a 6-frame animation like it says in the flipbook_texture.json file code (and we do), we need to open the graphic file and change the canvas size to be 96 pixels tall.  Like this:  Now that the canvas can accommodate a total of 6 frames, add 5 more frames worth of graphics to the file. Here is one way to do it:  Put the edited graphic file in the textures/blocks folder of your animation pack, make sure the name is changed from lapis_ore_EDITED.png to lapis_ore.png, and you're ready to go take a look at your animated block in Minecraft.  Animate the custom die block  After completing the Advanced Custom Blocks tutorial you will have a red block in your hotbar and hand that, when placed, looks like a die block.  In this next example, we're going to animate the block in the player's hand to scroll through the pattern of dots.  Due to how textures are mapped onto blocks in the hotbar, all three visible sides of the die block will have the same pattern as the numbers shift from one through six.  You can download the completed sample Custom Die block resource pack and behavior pack. You will need both the behavior pack and the resource pack for it to work.  Navigate to resource pack > textures, add a flipbook_texture.json file, and insert this code:  JSON Copy [   {     \"flipbook_texture\": \"textures/blocks/die_red\",     \"atlas_tile\": \"die_red\",     \"frames\": [ 0, 1, 2, 3, 4, 5 ],     \"ticks_per_frame\": 20,     \"blend_frames\": false   } ]   Then, replace the die_red.png graphic in the textures/blocks folder with this one:  In a creative world with the behavior pack and resource pack activated, give yourself a demo:die and notice that the red block is now animated.  A Multi-faceted Animation: the Command Block  For the purpose of this discussion, we are talking only about the basic \"Vanilla\" command black, not the ones with conditional or chain or mipmap in their names. They are all animated the same way. I'm mentioning this so that if you go digging for the code in the flipbook_texture.json file or for the graphics in the blocks folder of the Vanilla sample pack, you'll know to look for the ones whose names match the names on the \"flipbook_texture\": line of the code.  If you take a really close look at a command block, you'll notice that the front, back, and sides of the block have different shapes with animated blinking dots on them.  The front of the block has a circle shape and the four sides have an arrow shape:  The back of the block has a square shape:  The frames are mapped onto the command block with this code:  JSON Copy {   \"flipbook_texture\": \"textures/blocks/command_block_front\",   \"atlas_tile\": \"command_block_front\",   \"ticks_per_frame\": 10 }, {   \"flipbook_texture\": \"textures/blocks/command_block_back\",   \"atlas_tile\": \"command_block_back\",   \"ticks_per_frame\": 10 }, {   \"flipbook_texture\": \"textures/blocks/command_block_side\",   \"atlas_tile\": \"command_block_side\",   \"ticks_per_frame\": 10 }   Here are some edited command block texture graphics.  command_block_front  command_block_back  command_block_side  This is the final result:  Next Steps  Now that you know how to animate block textures, take a look at this page about Add-on Pack Contents to see what else you could do to customize your own Minecraft world!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createloottable?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating a Loot Table 05/05/2025  Loot tables are excellent tools, and creating your own is a big step on your journey as a creator! Following along with the instructions and examples here will help you to learn the process of creating a loot table and get you one step closer to creating the Minecraft world of your dreams.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Loot Tables Loot and Trade Table Functions Loot Overloads Introduction to Behavior Packs Basic loot table  To begin, let's create something fairly simple: A loot table that returns a single diamond when it's called.  JSON Copy {     \"pools\": [         {             \"rolls\": 1,             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\"                 }             ]         }     ] }   As you can see, we defined a single pool that rolls one time and contains a single diamond on every roll. If you combined this with the minecraft:loot component inside an entity's behavior file, the entity would drop that diamond on death.  Now, let's get a little more complicated. What if you wanted to choose from two items? What if we wanted to return a diamond or a piece of coal?  That would be achieved by adding a second value to the entries object.  JSON Copy {     \"pools\": [         {             \"rolls\": 1,             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\"                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\"                 }             ]         }     ] }   What you'll notice here is a diamond is just as likely to drop as a piece of coal. All entries have a weight assigned to them. If you don't specify the weight it will default to 1 giving all entries an equal chance of being rolled. In order to adjust that, we'll need to define the weight value ourselves.  JSON Copy {     \"pools\": [         {             \"rolls\": 1,             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\",                     \"weight\": 1                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\",                     \"weight\": 7                 }             ]         }     ] }   The best way to understand how weight affects the roll is to imagine the example doesn't have two entries, it has eight: Seven chances for coal and one chance for diamond. This means it's seven times more likely for the roll to result in coal instead of a diamond.  Additionally, you can randomize the number of times a set of entries are rolled. The rolls key can be set with a min and max value that the game will choose within randomly.  JSON Copy {     \"pools\": [         {             \"rolls\": {                 \"min\": 1,                 \"max\": 3             },             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\",                     \"weight\": 1                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\",                     \"weight\": 7                 }             ]         }     ] }   In this example, the game will roll the entries one to three times, resulting in a minimum of one item and a maximum of three every time this loot table is called.  Here's another example using a loot table as one of the entries. This will cause the game to call the other loot table and return whatever that results in.  JSON Copy {     \"pools\": [         {             \"rolls\": {                 \"min\": 1,                 \"max\": 3             },             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\",                     \"weight\": 1                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\",                     \"weight\": 7                 },                 {                     \"type\": \"loot_table\",                     \"name\": \"loot_tables/custom/some_loot_table\",                     \"weight\": 1                 }             ]         }     ] }    Important  Be aware that a loot table cannot refer to itself in any way! If a roll results in a recursive loot table, nothing will be returned.  And there you have it! At this point you should be familiar with loot tables, conditions, functions, and overloads. Add to that the examples of loot tables found here, and you now possess all the tools necessary to begin creating your own loot and trade tables for your custom experience!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createloottable?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Creating a Loot Table 05/05/2025  Loot tables are excellent tools, and creating your own is a big step on your journey as a creator! Following along with the instructions and examples here will help you to learn the process of creating a loot table and get you one step closer to creating the Minecraft world of your dreams.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Loot Tables Loot and Trade Table Functions Loot Overloads Introduction to Behavior Packs Basic loot table  To begin, let's create something fairly simple: A loot table that returns a single diamond when it's called.  JSON Copy {     \"pools\": [         {             \"rolls\": 1,             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\"                 }             ]         }     ] }   As you can see, we defined a single pool that rolls one time and contains a single diamond on every roll. If you combined this with the minecraft:loot component inside an entity's behavior file, the entity would drop that diamond on death.  Now, let's get a little more complicated. What if you wanted to choose from two items? What if we wanted to return a diamond or a piece of coal?  That would be achieved by adding a second value to the entries object.  JSON Copy {     \"pools\": [         {             \"rolls\": 1,             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\"                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\"                 }             ]         }     ] }   What you'll notice here is a diamond is just as likely to drop as a piece of coal. All entries have a weight assigned to them. If you don't specify the weight it will default to 1 giving all entries an equal chance of being rolled. In order to adjust that, we'll need to define the weight value ourselves.  JSON Copy {     \"pools\": [         {             \"rolls\": 1,             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\",                     \"weight\": 1                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\",                     \"weight\": 7                 }             ]         }     ] }   The best way to understand how weight affects the roll is to imagine the example doesn't have two entries, it has eight: Seven chances for coal and one chance for diamond. This means it's seven times more likely for the roll to result in coal instead of a diamond.  Additionally, you can randomize the number of times a set of entries are rolled. The rolls key can be set with a min and max value that the game will choose within randomly.  JSON Copy {     \"pools\": [         {             \"rolls\": {                 \"min\": 1,                 \"max\": 3             },             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\",                     \"weight\": 1                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\",                     \"weight\": 7                 }             ]         }     ] }   In this example, the game will roll the entries one to three times, resulting in a minimum of one item and a maximum of three every time this loot table is called.  Here's another example using a loot table as one of the entries. This will cause the game to call the other loot table and return whatever that results in.  JSON Copy {     \"pools\": [         {             \"rolls\": {                 \"min\": 1,                 \"max\": 3             },             \"entries\": [                 {                     \"type\": \"item\",                     \"name\": \"minecraft:diamond\",                     \"weight\": 1                 },                 {                     \"type\": \"item\",                     \"name\": \"minecraft:coal\",                     \"weight\": 7                 },                 {                     \"type\": \"loot_table\",                     \"name\": \"loot_tables/custom/some_loot_table\",                     \"weight\": 1                 }             ]         }     ] }    Important  Be aware that a loot table cannot refer to itself in any way! If a roll results in a recursive loot table, nothing will be returned.  And there you have it! At this point you should be familiar with loot tables, conditions, functions, and overloads. Add to that the examples of loot tables found here, and you now possess all the tools necessary to begin creating your own loot and trade tables for your custom experience!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/structureblockscommandtutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/structureblockscommandtutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createaninworldgame?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create an In-World Game with Commands 05/21/2025  In this tutorial, you'll learn how to apply what you've learned about commands and scoreboards to make a simple game mechanic. You'll create a command system that will detect the placement of certain blocks in particular areas of a world, and give visual clues to players about what they need to do to win. The world will give a player one diamond the first time they place a block of wool in the correct spot, to encourage them. However, to discourage players from placing the same color wool in the same spot over and over and getting a diamond each time (not that anyone would do that), we'll make it so the system only rewards them the first time they place each color of wool block correctly. When all three blocks are placed correctly, the player gets a diamond block.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Getting Started with Command Blocks Popular Commands Introduction to Scoreboards The setup  You'll want to start with a creative mode world that has its coordinates shown. Build a monument that looks sort of like a dark prismarine couch with stained glass windows to indicate what colors of wool should be placed in front of them on the \"couch cushions.\" Of course, you can build any sort of monument you like—the important part is that there are spaces where a user can place wool and that you make note of the coordinates where each color of wool should be placed. You'll need those coordinates later when you set up the command blocks.  Add a wool_placed scoreboard objective to keep track of which colors of wool have been placed. This information must be stored to prevent the player from simply breaking one of the wool blocks and placing it back down to cheat and earn more rewards. You don't have to make this information display anywhere, although you can if you want.  Copy /scoreboard objectives add wool_placed dummy   Add a totals objective to store the total number of wool blocks placed.  Copy /scoreboard objectives add totals dummy   So, this next part might seem a little weird. Scoreboards track information about about objectives and players. But what if we want to track information about something else, like whether or not a red wool block has been placed? Well, we can tell the scoreboard that \"red wool\" is a player and that the scoreboard needs to track information about it—and it will believe us!   Note  In computer science language, we're using the scoreboard to track when the score for \"red wool\" goes from 0 to 1, like a Boolean value. This concept might come in handy later when you're building your own worlds.  To keep things nice and tidy, we're going to create three fake players so that the scoreboard will track whether red, green, or blue wool is placed. If we name our fake players #red, #green, and #blue, the hash (#) at the start of each name will prevent our fake players from appearing in the list of scores on the sidebar.  Use these commands to create fake players, add them to the wool_placed objective, and give each one a score of 0.  Copy /scoreboard players set #red wool_placed 0 /scoreboard players set #green wool_placed 0 /scoreboard players set #blue wool_placed 0   We're going to add one more fake player named #total_wool to the totals objective and give it a score of 0, too. Even though we're using the same command, #total_wool is going to be used to tell when all three of the other wool blocks have been placed.  Copy /scoreboard players set #total_wool totals 0   Because repeating command blocks are going to be used, the chat is going to be flooded with command block output. This can be disabled using the \"commandblockoutput\" gamerule.  Copy /gamerule commandblockoutput false   When the player receives diamonds as a reward, a generic chat message will appear telling them they have been given items. This can be disabled, but be aware that some type of message to convey the reward may be beneficial to the player.  Copy /gamerule sendcommandfeedback false  Rewarding individual wool placements  Start by placing five command blocks all next to each other and all pointing in the same direction.  Edit each block's settings and command input like this:  Repeat, Unconditional, Always Active - Command Input: /testforblock X Y Z red_wool   Important  Be sure to replace X Y Z with the coordinates of where the wool will be placed in your own world.  Chain, Conditional, Always Active - Command Input: /scoreboard players test #red wool_placed 0 0  Chain, Conditional, Always Active - Command Input: /give @a diamond  Chain, Conditional, Always Active - Command Input: /scoreboard players set #red wool_placed 1  Chain, Conditional, Always Active - Command Input: /setblock X Y Z cake  What are the command blocks doing? A /testforblock command checks for the existence of red wool (indicated by the block state red_wool) at the expected coordinates in the monument. If the previous command successfully found the wool block, a /scoreboard command will check the score of the fake #red player. If the score is 0, that means the red wool hasn't been placed before. Because this is the first time the red wool is being placed, the player will receive one diamond for doing it. The score for \"#red\" will be set to 1, indicating that the red wool has been placed correctly. The red wool is replaced with cake. Not only is this another way to grant a reward, but it stops the infinite loop of diamonds. Detecting green wool  Next, set up five more command blocks just like the ones for red, but change every instance of the word \"red\" to \"green\" and make sure the X Y Z is the location where you want to detect green wool. The block state for green wool is green_wool.  Here are the command inputs:  Copy /testforblock X Y Z green_wool /scoreboard players test #green wool_placed 0 0 /give @a diamond /scoreboard players set #green wool_placed 1 /setblock X Y Z cake  Detecting blue wool  Do the same thing again, but change green_wool to blue_wool, and change the X Y Z coordinates.  Copy /testforblock X Y Z blue_wool /scoreboard players test #blue wool_placed 0 0 /give @a diamond /scoreboard players set #blue wool_placed 1 /setblock X Y Z cake  Rewarding monument completion  In the final step, we reward the player with a diamond block. To tell when we're done, we use math. Because each of the fake players has a score of 1 after the correct color of wool is detected, if the sum of the scores for all fake players is 3, then all wool blocks have been placed. The \"+=\" scoreboard operator is used to obtain the sum of scores.  Set up the command blocks like this:  Repeat, Unconditional, Always Active - Command Input: /scoreboard players set #total_wool totals 0 Chain, Unconditional, Always Active - Command Input: /scoreboard players operation #total_wool totals += * wool_placed Chain, Unconditional, Always Active - Command Input: /scoreboard players test #total_wool totals 3 3 Chain, Conditional, Always Active - Command Input: /give @a diamond_block_ Chain, Conditional, Always Active - Command Input: /scoreboard players set #red wool_placed 2 What are these command blocks doing? The fake player named \"#total_wool\" first has their score set to 0, and then the += adds one to the score when a wool block is correctly placed. The += operator is used to tally up the scores of all players in the \"wool_placed\" objective (denoted by the asterisk *), and the result is stored as the score of the fake player \"#total_wool\" in the \"totals\" objective. The score of \"#total_wool\" is checked to see if it's exactly 3. If so, this means all wools have been placed. If the score is 3, all players receive a diamond block. A command is needed to stop the process. Setting the score of any wool color to be anything higher than 1 will cause the sum to be higher than 3, preventing the system from flooding the player's inventory with diamond blocks. There are plenty of other ways to go about this, including disabling the command block chain in some manner. What's Next?  Now that you have the hang of command systems, mixing them in with behavior packs can greatly increase the interaction between your players and your custom content. Learning about Add-Ons and behavior packs is the next step.  Getting Started with Minecraft Add-Ons Introduction to Behavior Packs  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createaninworldgame?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create an In-World Game with Commands 05/21/2025  In this tutorial, you'll learn how to apply what you've learned about commands and scoreboards to make a simple game mechanic. You'll create a command system that will detect the placement of certain blocks in particular areas of a world, and give visual clues to players about what they need to do to win. The world will give a player one diamond the first time they place a block of wool in the correct spot, to encourage them. However, to discourage players from placing the same color wool in the same spot over and over and getting a diamond each time (not that anyone would do that), we'll make it so the system only rewards them the first time they place each color of wool block correctly. When all three blocks are placed correctly, the player gets a diamond block.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Getting Started with Command Blocks Popular Commands Introduction to Scoreboards The setup  You'll want to start with a creative mode world that has its coordinates shown. Build a monument that looks sort of like a dark prismarine couch with stained glass windows to indicate what colors of wool should be placed in front of them on the \"couch cushions.\" Of course, you can build any sort of monument you like—the important part is that there are spaces where a user can place wool and that you make note of the coordinates where each color of wool should be placed. You'll need those coordinates later when you set up the command blocks.  Add a wool_placed scoreboard objective to keep track of which colors of wool have been placed. This information must be stored to prevent the player from simply breaking one of the wool blocks and placing it back down to cheat and earn more rewards. You don't have to make this information display anywhere, although you can if you want.  Copy /scoreboard objectives add wool_placed dummy   Add a totals objective to store the total number of wool blocks placed.  Copy /scoreboard objectives add totals dummy   So, this next part might seem a little weird. Scoreboards track information about about objectives and players. But what if we want to track information about something else, like whether or not a red wool block has been placed? Well, we can tell the scoreboard that \"red wool\" is a player and that the scoreboard needs to track information about it—and it will believe us!   Note  In computer science language, we're using the scoreboard to track when the score for \"red wool\" goes from 0 to 1, like a Boolean value. This concept might come in handy later when you're building your own worlds.  To keep things nice and tidy, we're going to create three fake players so that the scoreboard will track whether red, green, or blue wool is placed. If we name our fake players #red, #green, and #blue, the hash (#) at the start of each name will prevent our fake players from appearing in the list of scores on the sidebar.  Use these commands to create fake players, add them to the wool_placed objective, and give each one a score of 0.  Copy /scoreboard players set #red wool_placed 0 /scoreboard players set #green wool_placed 0 /scoreboard players set #blue wool_placed 0   We're going to add one more fake player named #total_wool to the totals objective and give it a score of 0, too. Even though we're using the same command, #total_wool is going to be used to tell when all three of the other wool blocks have been placed.  Copy /scoreboard players set #total_wool totals 0   Because repeating command blocks are going to be used, the chat is going to be flooded with command block output. This can be disabled using the \"commandblockoutput\" gamerule.  Copy /gamerule commandblockoutput false   When the player receives diamonds as a reward, a generic chat message will appear telling them they have been given items. This can be disabled, but be aware that some type of message to convey the reward may be beneficial to the player.  Copy /gamerule sendcommandfeedback false  Rewarding individual wool placements  Start by placing five command blocks all next to each other and all pointing in the same direction.  Edit each block's settings and command input like this:  Repeat, Unconditional, Always Active - Command Input: /testforblock X Y Z red_wool   Important  Be sure to replace X Y Z with the coordinates of where the wool will be placed in your own world.  Chain, Conditional, Always Active - Command Input: /scoreboard players test #red wool_placed 0 0  Chain, Conditional, Always Active - Command Input: /give @a diamond  Chain, Conditional, Always Active - Command Input: /scoreboard players set #red wool_placed 1  Chain, Conditional, Always Active - Command Input: /setblock X Y Z cake  What are the command blocks doing? A /testforblock command checks for the existence of red wool (indicated by the block state red_wool) at the expected coordinates in the monument. If the previous command successfully found the wool block, a /scoreboard command will check the score of the fake #red player. If the score is 0, that means the red wool hasn't been placed before. Because this is the first time the red wool is being placed, the player will receive one diamond for doing it. The score for \"#red\" will be set to 1, indicating that the red wool has been placed correctly. The red wool is replaced with cake. Not only is this another way to grant a reward, but it stops the infinite loop of diamonds. Detecting green wool  Next, set up five more command blocks just like the ones for red, but change every instance of the word \"red\" to \"green\" and make sure the X Y Z is the location where you want to detect green wool. The block state for green wool is green_wool.  Here are the command inputs:  Copy /testforblock X Y Z green_wool /scoreboard players test #green wool_placed 0 0 /give @a diamond /scoreboard players set #green wool_placed 1 /setblock X Y Z cake  Detecting blue wool  Do the same thing again, but change green_wool to blue_wool, and change the X Y Z coordinates.  Copy /testforblock X Y Z blue_wool /scoreboard players test #blue wool_placed 0 0 /give @a diamond /scoreboard players set #blue wool_placed 1 /setblock X Y Z cake  Rewarding monument completion  In the final step, we reward the player with a diamond block. To tell when we're done, we use math. Because each of the fake players has a score of 1 after the correct color of wool is detected, if the sum of the scores for all fake players is 3, then all wool blocks have been placed. The \"+=\" scoreboard operator is used to obtain the sum of scores.  Set up the command blocks like this:  Repeat, Unconditional, Always Active - Command Input: /scoreboard players set #total_wool totals 0 Chain, Unconditional, Always Active - Command Input: /scoreboard players operation #total_wool totals += * wool_placed Chain, Unconditional, Always Active - Command Input: /scoreboard players test #total_wool totals 3 3 Chain, Conditional, Always Active - Command Input: /give @a diamond_block_ Chain, Conditional, Always Active - Command Input: /scoreboard players set #red wool_placed 2 What are these command blocks doing? The fake player named \"#total_wool\" first has their score set to 0, and then the += adds one to the score when a wool block is correctly placed. The += operator is used to tally up the scores of all players in the \"wool_placed\" objective (denoted by the asterisk *), and the result is stored as the score of the fake player \"#total_wool\" in the \"totals\" objective. The score of \"#total_wool\" is checked to see if it's exactly 3. If so, this means all wools have been placed. If the score is 3, all players receive a diamond block. A command is needed to stop the process. Setting the score of any wool color to be anything higher than 1 will cause the sum to be higher than 3, preventing the system from flooding the player's inventory with diamond blocks. There are plenty of other ways to go about this, including disabling the command block chain in some manner. What's Next?  Now that you have the hang of command systems, mixing them in with behavior packs can greatly increase the interaction between your players and your custom content. Learning about Add-Ons and behavior packs is the next step.  Getting Started with Minecraft Add-Ons Introduction to Behavior Packs  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/npcdialogue?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn NPC Dialogue Command 04/21/2025  Branching Dialogue lets creators craft dynamic non-player character (NPC) dialogue scripts that can provide updated dialogue based on a player's in-game actions or responses.  The Branching Dialogue system has three parts: the NPC entity, the dialogue commands, and the resource scene files.  In this guide, you will learn:  How to use the NPC Dialogue Command. How and why you'd create dialogue scene JSON files for dialogue options. Requirements  We strongly suggest that the following tutorial be completed before reviewing this guide. For best results, when creating your NPC, name them 'Ducky'.  Create a Custom NPC NPC Dialogue Sample Behavior Pack  There is a sample NPC dialogue behavior pack available at the Minecraft Samples GitHub. You can use it to check your work after using this tutorial.  Creating NPC Dialogue  We will be building on the Create a Custom NPC tutorial to create custom dialogue for that character. We will create a dialogue folder that contain a scene.json file in a behavior pack.  The scene.json file is located inside the dialogue folder in the root directory of your behavior pack that contains all the information needed for your branching dialogue.   Note  If you need help finding your com.mojang folder, look in the Getting Started tutorial.  You can create as many scene files as you need. In fact, you can create a scene file for each NPC in your world, or a scene file for each chapter of your narrative, or one scene file for the entire world. The branching dialogue feature reads all of the files in the dialogue folder regardless of how they are organized.  Set up the Behavior Pack Inside your development_behavior_packs folder, create a folder and name it npc_dialogue_behavior_pack. Create a folder inside there and name it dialogue. Inside the dialogue folder, create a file and name it scene.json. Put this content into your scene.json file: JSON Copy {     \"format_version\":\"1.17\",     \"minecraft:npc_dialogue\":{         \"scenes\":[             {                 \"scene_tag\":\"ducky_intro\",                 \"npc_name\":\"Ducky\",                 \"text\":\"Hello new friend\",                 \"on_open_commands\":[                     \"/clear @p\"                 ],                 \"on_close_commands\":[                     \"/say Farewell! \"                 ],                 \"buttons\":[                     {                         \"name\":\"Take Gold?\",                         \"commands\":[                             \"/give @initiator gold_ingot\"                         ]                     },                     {                           \"name\":\"Wish Luck\",                         \"commands\":[                             \"/say Good luck!\"                         ]                      }                 ]             }         ]     } }   The \"scenes\" property is where all of the branching dialogue will live. Every new instance of NPC dialogue will require a new scene, which is defined in the scene.json file by creating a scene_tag. You will use the scene tag in-game to call the text supplied in the scene file. You can also set up NPC buttons and commands that will behave identically as they would if set up using the in-game NPC editor.  Scene Properties Expand table Name\tType\tDescription scene_tag\tString\tRequired. The name you will use to call this scene in-game. npc_name\tString or rawtext\tOptional. Add or change a name for your NPC dialogue box. Useful for dynamically changing NPC names. text\tString or rawtext\tOptional. This is where you enter the dialogue you want your NPC to display in-game for this scene. You can type the dialogue text directly here or use raw text if you are using a language file. Without text, this will show an empty dialogue. on_open_commands\tArray containing commands\tOptional. The commands that will fire when the NPC dialogue box opens. on_close_commands\tArray containing commands\tOptional. The commands that will fire when the NPC dialogue box closes. buttons\tObject\tOptional. Include this to create buttons for your NPC. Its properties are name and commands. The name property sets the text that is going to be displayed on your NPC's button. The commands property is the commands which will be run in-game when the button is pressed. These are required for NPC buttons to appear on the dialogue. Rawtext  You can learn more about the rawtext format here: Raw Message JSON  Dialogue Command  The Dialogue command enables NPCs to open or read scene files. The command has two distinct modes, each with their own unique purpose and syntax.  Dialogue Open  dialogue open is used to force open an NPC dialogue box to the targeted player(s). This command can be used on any NPC and doesn't require a behavior pack unless you want the NPC to use an optional scene file for its dialogue.  The syntax for dialogue open is:  Copy /dialogue open <npc: target> <player: target> [sceneName:string]   /dialogue: The initial command.  open: The command variant.  <npc: target>: The NPC that you are targeting.  <player: target>: The player that you are targeting. This the player who will see the NPC dialog box.  [sceneName:string]: This is the name used if you want to use dialogue contained in a scene file. The string must be a valid scene tag name, or it will fail. This is an optional parameter.   Note  If no sceneName is specified, then the previous dialogue that NPC said remains displayed.  /dialogue open is primarily used in two ways:  The first is to initiate an NPC dialogue box without the player interacting directly with the NPC, essentially using the NPC as a 'pop-up' window that doesn't require the player to click the NPC. The NPC in this scenario doesn't have to be visible to the player in the world, but they must be in a loaded chunk and within ticking distance of the player receiving the dialogue. The NPC could be stashed underground or in another inaccessible location.  The second way /dialogue open is used is to create branching dialogue trees using the scene file. By using the /dialogue open command inside of an NPCs scene file, the NPC can automatically open the next dialogue box for a player. This is the basis for all dialogue tree branching paths.  Dialogue Change  /dialogue change is used to direct an NPC to use the dialogue provided in a specifically designated scene file. The command will instruct the targeted NPC to pull its dialogue from the location designated by the scene tag name. The command should be run before the player initiates contact with the NPC.  The syntax for Dialogue open is:  Copy /dialogue change <npc: target> <sceneName:string> [player: target]   /dialogue: The initial command.  change: The command variant.  <npc: target>: The NPC that you are targeting.  <sceneName:string>: This is the name used if you want to use dialogue contained in a scene file. The string must be a valid scene tag name, or it will fail.  [player: target]: The player that you are targeting (this is the player who will see the dialogue box). If omitted in a /dialogue change command, the NPC dialogue will be updated for all players.  /dialogue change is primarily used to change an NPC's dialogue using commands. The command can come from a player-triggered command block in the world, fired by another NPC, or can be run from the targeted NPC itself.  You may want to change an NPCs dialogue based on a player's actions in the world, such as entering a particular area, speaking with another NPC, or performing a specific task. If the action can be assessed, it can be used to run the dialogue command and change the NPC's dialogue.  /dialogue change does not display the NPC dialog box as Dialogue Open does, it simply points the NPC to the scene file dialogue that you want the player to see during their next interaction with that NPC.  Targeting  Targeting is a vital part of the NPC dialogue branching system. It determines which NPCs receive the commands and which players see the dialogue. It is also used to ensure that each player sees the dialogue you want them to see and does not lose the dialogue in multiplayer scenarios.  Targeting NPCs  To use the /dialogue command, you must target an NPC. This will act as the NPC 'saying' the dialogue and will use that NPC's image inside the dialog's portrait.  The NPC you want to trigger the dialog from must exist inside the world, but they can be hidden in an inacessible location.  Tagging  Use the /tag command to target an NPC in a scene.  Copy /tag <entity: target> <add or remove> <name: string>   /tag: The initial command.  <entity: target> The NPC you're targeting.  <add or remove> To add or remove the tag.  <name: string> The name given to the NPC.  Targeting Players  When using the /dialogue command, there will be times you will need to target players as well. To target players, use player selectors such as @a (all players) or @p (nearest player). Those will typically work well for a single-player experience. If you wish to have per-player scene changes, you will need to use a special target type called @initiator (the player interacting with the NPC).   Note  NPC Dialogue is the only place the @initiator selector is used.  Example:  JSON Copy \"buttons\":[     {         \"name\":\"Take Gold?\",         \"commands\":[             \"/give @initiator gold_ingot\"         ]     },     {           \"name\":\"Wish Luck\",         \"commands\":[             \"/say Good luck!\"         ]      } ]   Using this target selector with NPCs allows them to update their dialogue on a per-player basis, meaning that in multiplayer games, NPCs can remember each player's dialogue state and send unique dialogue accordingly.  This is useful for times where a player changing an NPCs dialogue could result in other players missing out on the complete dialogue branch, ensuring each player only receives one item from an NPC, not allowing that same player to return to the NPC for more items, or locking out other players from collecting their items.  Run the Scene Change the game mode to Survival in Settings. Run the dialogue command while targeting the NPC. You can use the following command: /dialogue open @e[type=npc, r=2] @p ducky_intro. This command opens the dialogue, calls an entity with type NPC in a 2 block radius, targets the player, and then runs the ducky_intro file. Or you can tag the npc with /tag @e[type=npc] add dusty and then run the dialogue command with /dialogue open @e[tag=dusty] @p ducky_intro.  See more about target selectors here.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/npcdialogue?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn NPC Dialogue Command 04/21/2025  Branching Dialogue lets creators craft dynamic non-player character (NPC) dialogue scripts that can provide updated dialogue based on a player's in-game actions or responses.  The Branching Dialogue system has three parts: the NPC entity, the dialogue commands, and the resource scene files.  In this guide, you will learn:  How to use the NPC Dialogue Command. How and why you'd create dialogue scene JSON files for dialogue options. Requirements  We strongly suggest that the following tutorial be completed before reviewing this guide. For best results, when creating your NPC, name them 'Ducky'.  Create a Custom NPC NPC Dialogue Sample Behavior Pack  There is a sample NPC dialogue behavior pack available at the Minecraft Samples GitHub. You can use it to check your work after using this tutorial.  Creating NPC Dialogue  We will be building on the Create a Custom NPC tutorial to create custom dialogue for that character. We will create a dialogue folder that contain a scene.json file in a behavior pack.  The scene.json file is located inside the dialogue folder in the root directory of your behavior pack that contains all the information needed for your branching dialogue.   Note  If you need help finding your com.mojang folder, look in the Getting Started tutorial.  You can create as many scene files as you need. In fact, you can create a scene file for each NPC in your world, or a scene file for each chapter of your narrative, or one scene file for the entire world. The branching dialogue feature reads all of the files in the dialogue folder regardless of how they are organized.  Set up the Behavior Pack Inside your development_behavior_packs folder, create a folder and name it npc_dialogue_behavior_pack. Create a folder inside there and name it dialogue. Inside the dialogue folder, create a file and name it scene.json. Put this content into your scene.json file: JSON Copy {     \"format_version\":\"1.17\",     \"minecraft:npc_dialogue\":{         \"scenes\":[             {                 \"scene_tag\":\"ducky_intro\",                 \"npc_name\":\"Ducky\",                 \"text\":\"Hello new friend\",                 \"on_open_commands\":[                     \"/clear @p\"                 ],                 \"on_close_commands\":[                     \"/say Farewell! \"                 ],                 \"buttons\":[                     {                         \"name\":\"Take Gold?\",                         \"commands\":[                             \"/give @initiator gold_ingot\"                         ]                     },                     {                           \"name\":\"Wish Luck\",                         \"commands\":[                             \"/say Good luck!\"                         ]                      }                 ]             }         ]     } }   The \"scenes\" property is where all of the branching dialogue will live. Every new instance of NPC dialogue will require a new scene, which is defined in the scene.json file by creating a scene_tag. You will use the scene tag in-game to call the text supplied in the scene file. You can also set up NPC buttons and commands that will behave identically as they would if set up using the in-game NPC editor.  Scene Properties Expand table Name\tType\tDescription scene_tag\tString\tRequired. The name you will use to call this scene in-game. npc_name\tString or rawtext\tOptional. Add or change a name for your NPC dialogue box. Useful for dynamically changing NPC names. text\tString or rawtext\tOptional. This is where you enter the dialogue you want your NPC to display in-game for this scene. You can type the dialogue text directly here or use raw text if you are using a language file. Without text, this will show an empty dialogue. on_open_commands\tArray containing commands\tOptional. The commands that will fire when the NPC dialogue box opens. on_close_commands\tArray containing commands\tOptional. The commands that will fire when the NPC dialogue box closes. buttons\tObject\tOptional. Include this to create buttons for your NPC. Its properties are name and commands. The name property sets the text that is going to be displayed on your NPC's button. The commands property is the commands which will be run in-game when the button is pressed. These are required for NPC buttons to appear on the dialogue. Rawtext  You can learn more about the rawtext format here: Raw Message JSON  Dialogue Command  The Dialogue command enables NPCs to open or read scene files. The command has two distinct modes, each with their own unique purpose and syntax.  Dialogue Open  dialogue open is used to force open an NPC dialogue box to the targeted player(s). This command can be used on any NPC and doesn't require a behavior pack unless you want the NPC to use an optional scene file for its dialogue.  The syntax for dialogue open is:  Copy /dialogue open <npc: target> <player: target> [sceneName:string]   /dialogue: The initial command.  open: The command variant.  <npc: target>: The NPC that you are targeting.  <player: target>: The player that you are targeting. This the player who will see the NPC dialog box.  [sceneName:string]: This is the name used if you want to use dialogue contained in a scene file. The string must be a valid scene tag name, or it will fail. This is an optional parameter.   Note  If no sceneName is specified, then the previous dialogue that NPC said remains displayed.  /dialogue open is primarily used in two ways:  The first is to initiate an NPC dialogue box without the player interacting directly with the NPC, essentially using the NPC as a 'pop-up' window that doesn't require the player to click the NPC. The NPC in this scenario doesn't have to be visible to the player in the world, but they must be in a loaded chunk and within ticking distance of the player receiving the dialogue. The NPC could be stashed underground or in another inaccessible location.  The second way /dialogue open is used is to create branching dialogue trees using the scene file. By using the /dialogue open command inside of an NPCs scene file, the NPC can automatically open the next dialogue box for a player. This is the basis for all dialogue tree branching paths.  Dialogue Change  /dialogue change is used to direct an NPC to use the dialogue provided in a specifically designated scene file. The command will instruct the targeted NPC to pull its dialogue from the location designated by the scene tag name. The command should be run before the player initiates contact with the NPC.  The syntax for Dialogue open is:  Copy /dialogue change <npc: target> <sceneName:string> [player: target]   /dialogue: The initial command.  change: The command variant.  <npc: target>: The NPC that you are targeting.  <sceneName:string>: This is the name used if you want to use dialogue contained in a scene file. The string must be a valid scene tag name, or it will fail.  [player: target]: The player that you are targeting (this is the player who will see the dialogue box). If omitted in a /dialogue change command, the NPC dialogue will be updated for all players.  /dialogue change is primarily used to change an NPC's dialogue using commands. The command can come from a player-triggered command block in the world, fired by another NPC, or can be run from the targeted NPC itself.  You may want to change an NPCs dialogue based on a player's actions in the world, such as entering a particular area, speaking with another NPC, or performing a specific task. If the action can be assessed, it can be used to run the dialogue command and change the NPC's dialogue.  /dialogue change does not display the NPC dialog box as Dialogue Open does, it simply points the NPC to the scene file dialogue that you want the player to see during their next interaction with that NPC.  Targeting  Targeting is a vital part of the NPC dialogue branching system. It determines which NPCs receive the commands and which players see the dialogue. It is also used to ensure that each player sees the dialogue you want them to see and does not lose the dialogue in multiplayer scenarios.  Targeting NPCs  To use the /dialogue command, you must target an NPC. This will act as the NPC 'saying' the dialogue and will use that NPC's image inside the dialog's portrait.  The NPC you want to trigger the dialog from must exist inside the world, but they can be hidden in an inacessible location.  Tagging  Use the /tag command to target an NPC in a scene.  Copy /tag <entity: target> <add or remove> <name: string>   /tag: The initial command.  <entity: target> The NPC you're targeting.  <add or remove> To add or remove the tag.  <name: string> The name given to the NPC.  Targeting Players  When using the /dialogue command, there will be times you will need to target players as well. To target players, use player selectors such as @a (all players) or @p (nearest player). Those will typically work well for a single-player experience. If you wish to have per-player scene changes, you will need to use a special target type called @initiator (the player interacting with the NPC).   Note  NPC Dialogue is the only place the @initiator selector is used.  Example:  JSON Copy \"buttons\":[     {         \"name\":\"Take Gold?\",         \"commands\":[             \"/give @initiator gold_ingot\"         ]     },     {           \"name\":\"Wish Luck\",         \"commands\":[             \"/say Good luck!\"         ]      } ]   Using this target selector with NPCs allows them to update their dialogue on a per-player basis, meaning that in multiplayer games, NPCs can remember each player's dialogue state and send unique dialogue accordingly.  This is useful for times where a player changing an NPCs dialogue could result in other players missing out on the complete dialogue branch, ensuring each player only receives one item from an NPC, not allowing that same player to return to the NPC for more items, or locking out other players from collecting their items.  Run the Scene Change the game mode to Survival in Settings. Run the dialogue command while targeting the NPC. You can use the following command: /dialogue open @e[type=npc, r=2] @p ducky_intro. This command opens the dialogue, calls an entity with type NPC in a 2 block radius, targets the player, and then runs the ducky_intro file. Or you can tag the npc with /tag @e[type=npc] add dusty and then run the dialogue command with /dialogue open @e[tag=dusty] @p ducky_intro.  See more about target selectors here.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createnpcs?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create a Custom NPC 09/20/2023  Non-Player Characters (NPCs) are characters in Minecraft that are not controlled by the player. NPCs can perform commands and deliver dialog when players interact with them, making them excellent tools for creating narrative and gameplay experiences.  In this tutorial, you will learn the following:  How to create an NPC. How to change NPC skins. How to add commands to an NPC. How to add buttons to an NPC. Prequisites  To create NPCs, start in a world with the following settings:  Creative mode Cheats enabled Operator permissions   Note  Later, to interact with your custom NPCs, you will need to switch from Creative mode to either Survival mode or Adventure mode.  Spawn an NPC  To obtain a custom NPC, follow these instructions:  Get an NPC spawn egg from the creative menu or by using the command /give @p spawn_egg 1 51. Right-click to place an NPC on your desired block. If you misplace an NPC, you can left-click to despawn them. Right-click the NPC to open the NPC interface. Enter a name for your NPC. Names are limited to 32 characters. You can use color codes to change the color of the name text.  The NPC editor has a built in dialog feature to give players more information about the commands they will execute or to deliver story details.  This dialog box has a limit of 307 characters before the text goes off the screen. You can also use color codes to change the color of the text.  You can use behavior packs and commands to create a more advanced dialogue system for your custom NPCs. See NPC Dialogue Command for more information.  Change NPC skins  You can choose from a list of skins to customize the appearance of your NPC.  To change an NPC's skin, follow these instructions:  Right-click the NPC you want to edit. In the Appearance section, click the skin that you want to use for your NPC. You can use the left and right arrow buttons to see more skins. Add commands to an NPC  You can add commands to an NPC that the NPC will execute after a player closes their dialog window. Unlike a Command Block, a single NPC can execute multiple commands.  To add commands to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. If you want to add more commands, click the Add Command button and enter the commands you want to enter.  Your NPC will execute these commands in order whenever a player interacts with them and closes their dialog box. There is more information about commands in the Introduction to Commands article.  Advanced Command Settings  There are settings to customize the way commands work with NPCs.  Button Mode  If Button Mode is toggled on, a text box appears where you can enter text that will appear on a button. This command will only run if the button is pressed.  For example, we could use a combination of the command /give @p gold_ingot and a button labelled Money? When players click the Money? button, they receive one gold ingot into their inventory.  On Enter  If On Enter is toggled, then the command will run when players initiate a conversation with the NPC.  In this case, with On Enter toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box opens on dialogue initiation with the NPC.  On Exit  If On Exit is toggled, then the command will trigger when the player ends and interaction and closes the NPC dialogue.  In this case, with On Exit toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box closes and the NPC interaction ends.  Add buttons to an NPC  You can also add buttons to an NPC. If you use the Button Mode setting, an NPC command will be displayed as a button in the NPC's dialog box. Players who interact with that NPC can click the appropriate button to execute that command.  To add buttons to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. Activate Button Mode and enter the button text in the new field.  If you want to add more buttons, click the Add Command button and repeat this process.  Once you have added your button commands, your NPC will display the command buttons in order after their dialog when players interact with them.  What's Next?  With the NPC created and the first dialogue box has been created, you can learn how to create branching dialogue boxes to design your own custom narrative driven content.  NPC Dialogue Command  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createnpcs?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create a Custom NPC 09/20/2023  Non-Player Characters (NPCs) are characters in Minecraft that are not controlled by the player. NPCs can perform commands and deliver dialog when players interact with them, making them excellent tools for creating narrative and gameplay experiences.  In this tutorial, you will learn the following:  How to create an NPC. How to change NPC skins. How to add commands to an NPC. How to add buttons to an NPC. Prequisites  To create NPCs, start in a world with the following settings:  Creative mode Cheats enabled Operator permissions   Note  Later, to interact with your custom NPCs, you will need to switch from Creative mode to either Survival mode or Adventure mode.  Spawn an NPC  To obtain a custom NPC, follow these instructions:  Get an NPC spawn egg from the creative menu or by using the command /give @p spawn_egg 1 51. Right-click to place an NPC on your desired block. If you misplace an NPC, you can left-click to despawn them. Right-click the NPC to open the NPC interface. Enter a name for your NPC. Names are limited to 32 characters. You can use color codes to change the color of the name text.  The NPC editor has a built in dialog feature to give players more information about the commands they will execute or to deliver story details.  This dialog box has a limit of 307 characters before the text goes off the screen. You can also use color codes to change the color of the text.  You can use behavior packs and commands to create a more advanced dialogue system for your custom NPCs. See NPC Dialogue Command for more information.  Change NPC skins  You can choose from a list of skins to customize the appearance of your NPC.  To change an NPC's skin, follow these instructions:  Right-click the NPC you want to edit. In the Appearance section, click the skin that you want to use for your NPC. You can use the left and right arrow buttons to see more skins. Add commands to an NPC  You can add commands to an NPC that the NPC will execute after a player closes their dialog window. Unlike a Command Block, a single NPC can execute multiple commands.  To add commands to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. If you want to add more commands, click the Add Command button and enter the commands you want to enter.  Your NPC will execute these commands in order whenever a player interacts with them and closes their dialog box. There is more information about commands in the Introduction to Commands article.  Advanced Command Settings  There are settings to customize the way commands work with NPCs.  Button Mode  If Button Mode is toggled on, a text box appears where you can enter text that will appear on a button. This command will only run if the button is pressed.  For example, we could use a combination of the command /give @p gold_ingot and a button labelled Money? When players click the Money? button, they receive one gold ingot into their inventory.  On Enter  If On Enter is toggled, then the command will run when players initiate a conversation with the NPC.  In this case, with On Enter toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box opens on dialogue initiation with the NPC.  On Exit  If On Exit is toggled, then the command will trigger when the player ends and interaction and closes the NPC dialogue.  In this case, with On Exit toggled on and the command /give @p gold_ingot, players would receive one gold ingot in their inventory when the dialogue box closes and the NPC interaction ends.  Add buttons to an NPC  You can also add buttons to an NPC. If you use the Button Mode setting, an NPC command will be displayed as a button in the NPC's dialog box. Players who interact with that NPC can click the appropriate button to execute that command.  To add buttons to an NPC, follow these instructions:  Right-click the NPC you want to edit. Click Advanced Settings. Enter the Command you want to execute. Make sure you only enter one command in this field. Activate Button Mode and enter the button text in the new field.  If you want to add more buttons, click the Add Command button and repeat this process.  Once you have added your button commands, your NPC will display the command buttons in order after their dialog when players interact with them.  What's Next?  With the NPC created and the first dialogue box has been created, you can learn how to create branching dialogue boxes to design your own custom narrative driven content.  NPC Dialogue Command  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/npcdialoguedesigner?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create NPC Dialogues with DialogueDesigner 05/02/2024  This tutorial shows how to create NPC entities with dialogue windows, using the community DialogueDesigner tool (jannisx11.github.io/dialogue-designer).  NPC dialogues are a great way to add stories to your custom map. They can be used for anything from a simple text to provide information to the player, to complex multi page conversations with different reply options to choose from.  Requirements  Before learning how to create NPC dialogues, it is recommended that you understand the basics of creating resource and behavior packs.  Introduction to Behavior Packs Introduction to Resource Packs NPC Dialogue Command Creating New Entity Types  An NPC entity is required to use the dialogue. For simple applications, the built-in Minecraft NPC entity can be used and it comes with a list of texture presets for a lot of situations. But for custom designs, it is required to create a new entity.  The Minecraft Entity Wizard can be used to make this easier.  Set-up  Before getting started with the dialogue, we should set up our NPC entity.  If you are using the Entity Wizard, proceed by creating an entity with the \"NPC\" behavior preset. If you are creating the NPC from scratch, make sure to include the \"minecraft:npc\" component and a type family called \"npc\".  You can also use the NPC entity that is included with Minecraft and comes with a list of preset skins. You can use it by searching for the \"NPC Spawn Egg\" in the creative inventory, and using that spawn egg.  Creating a Dialogue  Open the DialogueDesigner web app in your web browser by navigating to jannisx11.github.io/dialogue-designer.  On the start screen, press New Dialogue to create a new project. This will bring you into the workspace.  On the left side of the screen, you can see the sidebar. This is where you can manage your project and your different scenes.  In the sidebar, under File Name, enter the name of your dialogue file. You should use snake case here (each letter is lower-case, instead of spaces between words we use underscore characters). Let's call it castle_guard.  Right below, we can enter the common prefix of all scenes in the project. This is usually the project name, plus an additional underscore at the end: castle_guard_.  Scenes  Each dialogue file can contain any number of scenes. Scenes are individual dialogue pages in a conversation. You can create individual scenes, or create more complex conversations by linking different scenes together via buttons that the player can press.  Let's add our first scene by pressing the plus button in the sidebar under Scenes. This will create a scene. You can rename the scene by double-clicking its name in the sidebar. We'll call it entry because it will be the entry point to our conversation.  The main workspace of the screen will now be split into two sections. At the top, you can see a preview of the dialogue pop-up in-game. At the bottom, you can configure custom commands that run when the dialogue is opened, closed, or later on when a button is pressed.  Using the two buttons between the preview and the commands selection, you can switch between Edit and Preview mode. In Edit mode, you can edit the dialogue, while Preview mode allows you to see how it will look and behave in-game.  The dialogue has three separate sections that you can edit: the title, the body, and the button row.  Let's enter our text into the title and body text field.  We'll also press the plus sign in the button row two times to create two buttons.  Let's also create a second page, named directions, that looks like this:  Linking scenes  We can now go back to the entry scene, select the \"Directions\" button, and change the navigation option to directions. This will tell the button to open the \"directions\" scene when clicked.  Use the mode selector and switch to Preview mode to test this. Clicking the button should now navigate to the Directions scene. Clicking the \"Goodbye!\" button will close the dialog. That is the default behavior for buttons.  Commands  Commands allow us to customize the NPC dialogue further. As an example, let's add a sound that plays when a player starts talking to an NPC.  Switch to the \"entry\" scene, locate the \"On Open\" tab in the Commands section at the bottom, and enter this command:  Copy playsound mob.villager.haggle @initiator   Here we are using the playsound command to play the villager haggle sound. The @initiator targets the player who has opened the dialogue. @s in this case would select the NPC entity. You can learn more about commands here: Introduction to Commands  Export  We are now ready to export the dialogue into Minecraft. To export the project, click the yellow \"Export\" button in the top right corner. This opens the Export window, which gives you all the instructions on how to implement your project into Minecraft.  First, create a folder called dialogue inside your behavior pack. Download the dialogue file and place it into that folder.  If you are using language files later on, you will also need to save them. More on that in the Advanced features section.  Now open your Minecraft world with the behavior pack applied, and use the provided command to apply the dialogue to your NPC entity. The command will apply the dialogue to the closest NPC-type entity that's in an 8-block radius around you.  After that, you can test your dialogue. Make sure you are in adventure or survival mode, then right-click the NPC. This should open the entry dialogue scene while playing the villager sound.  You have now successfully created and implemented an NPC dialogue!  Advanced features  For more experienced users, DialogueDesigner offers some advanced features to support all capabilities that the dialogue format provides.  Formatting  You can use Minecraft's Formatting codes to add formatting to your text, including making your text bold, italic, or changing the color.  Simply enter the section sign (§), followed by a specific number or letter, into the text field, ahead of the word that you want to format. After the word, you can put §r to reset the formatting.  Formatting codes can be used directly in text fields, in translations, or in raw JSON text. You can test formatting by switching to Preview mode.  For example, the following code will render like this:  Sarah owns a §bDiamond§r, an §cApple§r, and an §7Iron Sword§r!  Translations  Using translations, the dialogue can be made available in more than one language.  Translations are saved in text files in the texts folder of the resource pack. They are saved as key-value pairs, where the key identifies the translation string, and the value provides the value in a specific language.  You can get started by creating a Language in DialogueDesigner. In the bottom left, under Languages, press the Plus icon to create a language file. The first file that is created will be called en_US. This file is intended for American English, and it's also the fallback for when no translation is provided in the language that a player selects in Minecraft.  You can now enter translations into the file:  Copy dialogue.castle_guard.npc_name=Castle Guard   Each line provides a translation string. The part before the = sign is the key, the part after is the value that will be displayed to the player.  Let's now create a second language file. The name defaults to de_DE, which is the code for German. But you can edit the code at the top of your screen to something like it_IT for Italian. There is a list of Add-On Pack Languages. We'll also add our translation string into this file, but translated into the respective language:  Copy dialogue.castle_guard.npc_name=Burgwache   Now, let's switch back to our dialogue file. Make sure you are in edit mode, then click into any text field to edit it. A black box saying \"Text\" will appear in the corner of the input. Switch this option to \"Translate\". Now you can enter the translation key into the text field:  Copy dialogue.castle_guard.npc_name   Switch to Preview mode, and you will see that the name from the language file is used.  You can click on any of the language files that you have created in the left sidebar to preview your dialogue in that language. Double-click (or long-press) the language file to edit it again.  Raw JSON  Another powerful way to customize your text is to use JSON Rawtext. This allows you to mix and match text with translations, and you can even include dynamic data such as scoreboard values in your text.  To edit raw JSON, select a text field, and set the text type selector to \"Raw JSON\". This will open a pop-up, in which you can edit the raw JSON.  When you are done, press the Confirm button. If there are JSON syntax errors, a red error message will show up and prevent you from saving your changes. Fix any JSON errors to proceed.  You can learn more about the rawtext format here: Raw Message JSON.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/npcdialoguedesigner?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create NPC Dialogues with DialogueDesigner 05/02/2024  This tutorial shows how to create NPC entities with dialogue windows, using the community DialogueDesigner tool (jannisx11.github.io/dialogue-designer).  NPC dialogues are a great way to add stories to your custom map. They can be used for anything from a simple text to provide information to the player, to complex multi page conversations with different reply options to choose from.  Requirements  Before learning how to create NPC dialogues, it is recommended that you understand the basics of creating resource and behavior packs.  Introduction to Behavior Packs Introduction to Resource Packs NPC Dialogue Command Creating New Entity Types  An NPC entity is required to use the dialogue. For simple applications, the built-in Minecraft NPC entity can be used and it comes with a list of texture presets for a lot of situations. But for custom designs, it is required to create a new entity.  The Minecraft Entity Wizard can be used to make this easier.  Set-up  Before getting started with the dialogue, we should set up our NPC entity.  If you are using the Entity Wizard, proceed by creating an entity with the \"NPC\" behavior preset. If you are creating the NPC from scratch, make sure to include the \"minecraft:npc\" component and a type family called \"npc\".  You can also use the NPC entity that is included with Minecraft and comes with a list of preset skins. You can use it by searching for the \"NPC Spawn Egg\" in the creative inventory, and using that spawn egg.  Creating a Dialogue  Open the DialogueDesigner web app in your web browser by navigating to jannisx11.github.io/dialogue-designer.  On the start screen, press New Dialogue to create a new project. This will bring you into the workspace.  On the left side of the screen, you can see the sidebar. This is where you can manage your project and your different scenes.  In the sidebar, under File Name, enter the name of your dialogue file. You should use snake case here (each letter is lower-case, instead of spaces between words we use underscore characters). Let's call it castle_guard.  Right below, we can enter the common prefix of all scenes in the project. This is usually the project name, plus an additional underscore at the end: castle_guard_.  Scenes  Each dialogue file can contain any number of scenes. Scenes are individual dialogue pages in a conversation. You can create individual scenes, or create more complex conversations by linking different scenes together via buttons that the player can press.  Let's add our first scene by pressing the plus button in the sidebar under Scenes. This will create a scene. You can rename the scene by double-clicking its name in the sidebar. We'll call it entry because it will be the entry point to our conversation.  The main workspace of the screen will now be split into two sections. At the top, you can see a preview of the dialogue pop-up in-game. At the bottom, you can configure custom commands that run when the dialogue is opened, closed, or later on when a button is pressed.  Using the two buttons between the preview and the commands selection, you can switch between Edit and Preview mode. In Edit mode, you can edit the dialogue, while Preview mode allows you to see how it will look and behave in-game.  The dialogue has three separate sections that you can edit: the title, the body, and the button row.  Let's enter our text into the title and body text field.  We'll also press the plus sign in the button row two times to create two buttons.  Let's also create a second page, named directions, that looks like this:  Linking scenes  We can now go back to the entry scene, select the \"Directions\" button, and change the navigation option to directions. This will tell the button to open the \"directions\" scene when clicked.  Use the mode selector and switch to Preview mode to test this. Clicking the button should now navigate to the Directions scene. Clicking the \"Goodbye!\" button will close the dialog. That is the default behavior for buttons.  Commands  Commands allow us to customize the NPC dialogue further. As an example, let's add a sound that plays when a player starts talking to an NPC.  Switch to the \"entry\" scene, locate the \"On Open\" tab in the Commands section at the bottom, and enter this command:  Copy playsound mob.villager.haggle @initiator   Here we are using the playsound command to play the villager haggle sound. The @initiator targets the player who has opened the dialogue. @s in this case would select the NPC entity. You can learn more about commands here: Introduction to Commands  Export  We are now ready to export the dialogue into Minecraft. To export the project, click the yellow \"Export\" button in the top right corner. This opens the Export window, which gives you all the instructions on how to implement your project into Minecraft.  First, create a folder called dialogue inside your behavior pack. Download the dialogue file and place it into that folder.  If you are using language files later on, you will also need to save them. More on that in the Advanced features section.  Now open your Minecraft world with the behavior pack applied, and use the provided command to apply the dialogue to your NPC entity. The command will apply the dialogue to the closest NPC-type entity that's in an 8-block radius around you.  After that, you can test your dialogue. Make sure you are in adventure or survival mode, then right-click the NPC. This should open the entry dialogue scene while playing the villager sound.  You have now successfully created and implemented an NPC dialogue!  Advanced features  For more experienced users, DialogueDesigner offers some advanced features to support all capabilities that the dialogue format provides.  Formatting  You can use Minecraft's Formatting codes to add formatting to your text, including making your text bold, italic, or changing the color.  Simply enter the section sign (§), followed by a specific number or letter, into the text field, ahead of the word that you want to format. After the word, you can put §r to reset the formatting.  Formatting codes can be used directly in text fields, in translations, or in raw JSON text. You can test formatting by switching to Preview mode.  For example, the following code will render like this:  Sarah owns a §bDiamond§r, an §cApple§r, and an §7Iron Sword§r!  Translations  Using translations, the dialogue can be made available in more than one language.  Translations are saved in text files in the texts folder of the resource pack. They are saved as key-value pairs, where the key identifies the translation string, and the value provides the value in a specific language.  You can get started by creating a Language in DialogueDesigner. In the bottom left, under Languages, press the Plus icon to create a language file. The first file that is created will be called en_US. This file is intended for American English, and it's also the fallback for when no translation is provided in the language that a player selects in Minecraft.  You can now enter translations into the file:  Copy dialogue.castle_guard.npc_name=Castle Guard   Each line provides a translation string. The part before the = sign is the key, the part after is the value that will be displayed to the player.  Let's now create a second language file. The name defaults to de_DE, which is the code for German. But you can edit the code at the top of your screen to something like it_IT for Italian. There is a list of Add-On Pack Languages. We'll also add our translation string into this file, but translated into the respective language:  Copy dialogue.castle_guard.npc_name=Burgwache   Now, let's switch back to our dialogue file. Make sure you are in edit mode, then click into any text field to edit it. A black box saying \"Text\" will appear in the corner of the input. Switch this option to \"Translate\". Now you can enter the translation key into the text field:  Copy dialogue.castle_guard.npc_name   Switch to Preview mode, and you will see that the name from the language file is used.  You can click on any of the language files that you have created in the left sidebar to preview your dialogue in that language. Double-click (or long-press) the language file to edit it again.  Raw JSON  Another powerful way to customize your text is to use JSON Rawtext. This allows you to mix and match text with translations, and you can even include dynamic data such as scoreboard values in your text.  To edit raw JSON, select a text field, and set the text type selector to \"Raw JSON\". This will open a pop-up, in which you can edit the raw JSON.  When you are done, press the Confirm button. If there are JSON syntax errors, a red error message will show up and prevent you from saving your changes. Fix any JSON errors to proceed.  You can learn more about the rawtext format here: Raw Message JSON.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Commands 05/07/2025  Commands are specific instructions that Minecraft: Bedrock Edition will carry out. These instructions can be as simple as changing the time of day or as complex as setting up and working with a scoreboard. There are a wide variety of commands, and each has its own potential to improve your content.  Content creators use commands to change or react to the environment around the player. Rather than having a static world, the player would be able to perform a task that a command system could detect and respond to in some way. An example of this is detecting if a player has placed a colored wool block at a specific location for a \"Complete the Monument\" style of map.  In this tutorial, you'll learn the following:  What commands are and how to begin using them. Command syntax. How to use target selectors and selector parameters. Enabling Commands  Before getting started with commands, cheats must be enabled. This can be done when you create a world or when you edit an existing one. Be aware that enabling cheats will disable achievements for that world.  Activating cheats lets you use commands in the chat interface. Running commands in the chat is essential for getting the first command block in a newly created world, which must also be enabled (in the same menu) in order to use them. Command blocks will be enabled by default, so you do not have to change that option.  While not required, it's helpful to set the default game mode to creative when starting out, as command blocks can only be edited in creative mode. Setting the default game mode to creative will also activate cheats.  Finally, you may need to enable the \"operator commands\" permission for yourself in order to run commands in the chat and access command blocks. While this setting is on by default for new worlds you create, you may need to change this on previously created worlds or for other players you would like to grant this permission to. This can be done by opening the pause menu while in the world and clicking the icon to the right of your player.  A list of various permissions will be shown. The \"operator commands\" permission in particular must be enabled in order to use commands in the chat and access command blocks.  Using the chat for commands  The first step to learning commands is learning how to use the chat functionality. This is where you run simple commands, learn syntax, test, and ultimately open the gateway to command blocks. If your settings and permissions are set correctly, typing a forward slash / in the chat will display a large number of commands.  A quick-action button also becomes available to generate a command for specific situations (such as changing the time of day or the current weather).  As you type, the list of commands displayed on the chat screen will filter to match the characters you input. You can press tab to cycle through the list at any time in order to choose the command to run. When the name of the command has been fully typed out, the list of commands changes to a list of syntaxes for the selected command.   Note  If you open the chat and press the up arrow on your keyboard, you can see the previous commands you've entered. This comes in handy when you're entering variations of the same command over and over. And over.  Command syntax  All commands follow the same grammar:  Start the command with a forward slash (/). Follow the slash with the name of the command. If there are any arguments to the command, they come after the command, separated by spaces.  For example, the /say command sends a message to the chat for all players to see:  Copy /say Hello World  It starts with a forward slash. The command's name is \"say\". Because there are arguments, a space is placed after the name. Then, the only argument for /say is provided, the message to display.  As a result, \"Hello World\" will be printed out in the chat.  Arguments  Different commands need different arguments. The /help command describes both a command and the arguments it takes. The auto-complete feature, which is available in the chat when typing out a command, displays the same information.  For example, typing /help testfor in the chat will provide the available syntax for the /testfor command.  Copy /testfor <victim: target>   The command has only one argument: a target to test for the existence of. Filling in the argument with a player name and running the command will print out a success message if the named player is logged into the world.  Copy /testfor PlayerName   Arguments can be required, optional, or literal.  A required argument is shown in help surrounded by angle brackets, like <this>. In the case of the /testfor command, you can tell that the only argument it has is required. because it is surrounded by angle brackets. If the argument is not provided, the command will fail to run.  Required arguments have a short descriptor of the argument as well as the expected input type. For /testfor, the argument is the victim, and the input type is target: a player name or target selector. Other commands can take different kinds of input values for the same argument, such as /difficulty:  Copy /difficulty <difficulty: Difficulty> /difficulty <difficulty: int>   The /difficulty command sets the world's difficulty level. You can specify it as a Difficulty, the name of a difficulty level such as \"peaceful\", \"easy\", \"normal\", or \"hard\"; you can also specify it as an int, an integer number that corresponds to a difficulty level from 0 to 3. Either of these commands sets the difficulty to hard:  Copy /difficulty hard /difficulty 3   An optional argument is shown surrounded by square brackets, like [this]. Optional arguments don't have to be provided.  Copy /gamemode <gameMode: GameMode> [player: target] /gamemode <gameMode: int> [player: target]   As with the /difficulty command, the /gamemode command has two different ways to do the same thing: you can set the game mode by using the name of a GameMode, or using an integer from 0 to 2 corresponding to a game mode.  The gameMode argument is required, but the command takes an optional argument to specify a player who will have their game mode changed. The input type is \"target\", which accepts either a player name or a target selector. Without supplying the optional argument, the command will still run. Doing so changes the game mode of the player who executed the command. By filling in the optional argument, the game mode of the target will be changed instead.  Either of the following commands will set the game mode for the specified player (\"PlayerName\") to survival mode:  Copy /gamemode survival PlayerName /gamemode 0 PlayerName   A literal argument should be typed exactly as is, and when shown in help, it has no descriptors or value types.  A literal argument that's the first argument to a command generally acts as a subcommand. For example, the /time command has a literal argument called \"set\":  Copy /time set <amount: int> /time set <time: TimeSpec>   Since set is a subcommand, it's not shown in angle brackets, but it's still required.  Copy /time set 6000 /time set noon   A literal argument can have multiple accepted values. In those cases, a vertical bar separates the possible values. The /weather command uses this for the type of weather to apply:  Copy /weather <clear|rain|thunder> [duration: int] /weather rain 10000   An optional literal argument will be shown surrounded by square brackets. The final argument of /testforblocks is an optional literal argument that can be either \"all\" or \"masked\". If none is specified, it defaults to \"all\". The \"masked\" option will cause the comparison to ignore air blocks, allowing any block to exist at the destination where there would be an air block at the source.  Copy /testforblocks <begin: x y z> <end: x y z> <destination: x y z> [masked|all] /testforblocks 0 64 0 20 64 20 100 50 100 /testforblocks 0 64 0 20 64 20 100 50 100 masked  Input types  Any argument that isn't a literal argument will specify the expected input type after the descriptor.  Copy /command <descriptor: type> /command [descriptor: type]   There are a large number of input types. The most common ones are primitive numeric values, but there are many that are exclusive to one command. The table below details the most common input types and some popular commands they belong to. Most unique input types, such as \"GameMode\" from the /gamemode command, can easily have their input checked by using the auto-complete feature in the chat.  Expand table Type\tDescription\tCommon commands Boolean\ttrue or false.\t/effect, /gamerule int\tAn integer (1, 2, 3).\t/give, /scoreboard, /time, /weather, /xp float\tA decimal number (1, 2.3, 4, 5.6).\t/spreadplayers string\tEither a single word or text within \"quotation marks\".\t/scoreboard, /summon, /tag message\tText that does not need to be in quotation marks.\t/me, /msg, /say, /tell, /title, /w x y z\t3 floats separated by spaces to specify coordinates.  Each value can also be a tilde (~), which indicates no change from the execution origin on that axis, or a tilde followed by a number (~5) to indicate the number of blocks away from the execution origin on that axis.\t/clone, /execute, /fill, /setblock, /summon, /teleport, /testforblock Block\tA block ID.\t/clone, /execute, /fill, /setblock, /testforblock Item\tAn item ID.\t/clear, /give, /replaceitem EntityType\tAn entity ID.\t/summon json\tJSON-formatted text.\t/give, /replaceitem, /summon, /tellraw, /titleraw target\tEither a player name or a target selector.\t/clear, /execute, /gamemode, /give, /kill, /replaceitem, /scoreboard, /tag, /teleport, /testfor What's Next?  Now that you've learned about commands, you can learn more about target selectors, commands, or about how to use command blocks to move beyond the chat window.  Target Selectors Popular Commands Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Commands 05/07/2025  Commands are specific instructions that Minecraft: Bedrock Edition will carry out. These instructions can be as simple as changing the time of day or as complex as setting up and working with a scoreboard. There are a wide variety of commands, and each has its own potential to improve your content.  Content creators use commands to change or react to the environment around the player. Rather than having a static world, the player would be able to perform a task that a command system could detect and respond to in some way. An example of this is detecting if a player has placed a colored wool block at a specific location for a \"Complete the Monument\" style of map.  In this tutorial, you'll learn the following:  What commands are and how to begin using them. Command syntax. How to use target selectors and selector parameters. Enabling Commands  Before getting started with commands, cheats must be enabled. This can be done when you create a world or when you edit an existing one. Be aware that enabling cheats will disable achievements for that world.  Activating cheats lets you use commands in the chat interface. Running commands in the chat is essential for getting the first command block in a newly created world, which must also be enabled (in the same menu) in order to use them. Command blocks will be enabled by default, so you do not have to change that option.  While not required, it's helpful to set the default game mode to creative when starting out, as command blocks can only be edited in creative mode. Setting the default game mode to creative will also activate cheats.  Finally, you may need to enable the \"operator commands\" permission for yourself in order to run commands in the chat and access command blocks. While this setting is on by default for new worlds you create, you may need to change this on previously created worlds or for other players you would like to grant this permission to. This can be done by opening the pause menu while in the world and clicking the icon to the right of your player.  A list of various permissions will be shown. The \"operator commands\" permission in particular must be enabled in order to use commands in the chat and access command blocks.  Using the chat for commands  The first step to learning commands is learning how to use the chat functionality. This is where you run simple commands, learn syntax, test, and ultimately open the gateway to command blocks. If your settings and permissions are set correctly, typing a forward slash / in the chat will display a large number of commands.  A quick-action button also becomes available to generate a command for specific situations (such as changing the time of day or the current weather).  As you type, the list of commands displayed on the chat screen will filter to match the characters you input. You can press tab to cycle through the list at any time in order to choose the command to run. When the name of the command has been fully typed out, the list of commands changes to a list of syntaxes for the selected command.   Note  If you open the chat and press the up arrow on your keyboard, you can see the previous commands you've entered. This comes in handy when you're entering variations of the same command over and over. And over.  Command syntax  All commands follow the same grammar:  Start the command with a forward slash (/). Follow the slash with the name of the command. If there are any arguments to the command, they come after the command, separated by spaces.  For example, the /say command sends a message to the chat for all players to see:  Copy /say Hello World  It starts with a forward slash. The command's name is \"say\". Because there are arguments, a space is placed after the name. Then, the only argument for /say is provided, the message to display.  As a result, \"Hello World\" will be printed out in the chat.  Arguments  Different commands need different arguments. The /help command describes both a command and the arguments it takes. The auto-complete feature, which is available in the chat when typing out a command, displays the same information.  For example, typing /help testfor in the chat will provide the available syntax for the /testfor command.  Copy /testfor <victim: target>   The command has only one argument: a target to test for the existence of. Filling in the argument with a player name and running the command will print out a success message if the named player is logged into the world.  Copy /testfor PlayerName   Arguments can be required, optional, or literal.  A required argument is shown in help surrounded by angle brackets, like <this>. In the case of the /testfor command, you can tell that the only argument it has is required. because it is surrounded by angle brackets. If the argument is not provided, the command will fail to run.  Required arguments have a short descriptor of the argument as well as the expected input type. For /testfor, the argument is the victim, and the input type is target: a player name or target selector. Other commands can take different kinds of input values for the same argument, such as /difficulty:  Copy /difficulty <difficulty: Difficulty> /difficulty <difficulty: int>   The /difficulty command sets the world's difficulty level. You can specify it as a Difficulty, the name of a difficulty level such as \"peaceful\", \"easy\", \"normal\", or \"hard\"; you can also specify it as an int, an integer number that corresponds to a difficulty level from 0 to 3. Either of these commands sets the difficulty to hard:  Copy /difficulty hard /difficulty 3   An optional argument is shown surrounded by square brackets, like [this]. Optional arguments don't have to be provided.  Copy /gamemode <gameMode: GameMode> [player: target] /gamemode <gameMode: int> [player: target]   As with the /difficulty command, the /gamemode command has two different ways to do the same thing: you can set the game mode by using the name of a GameMode, or using an integer from 0 to 2 corresponding to a game mode.  The gameMode argument is required, but the command takes an optional argument to specify a player who will have their game mode changed. The input type is \"target\", which accepts either a player name or a target selector. Without supplying the optional argument, the command will still run. Doing so changes the game mode of the player who executed the command. By filling in the optional argument, the game mode of the target will be changed instead.  Either of the following commands will set the game mode for the specified player (\"PlayerName\") to survival mode:  Copy /gamemode survival PlayerName /gamemode 0 PlayerName   A literal argument should be typed exactly as is, and when shown in help, it has no descriptors or value types.  A literal argument that's the first argument to a command generally acts as a subcommand. For example, the /time command has a literal argument called \"set\":  Copy /time set <amount: int> /time set <time: TimeSpec>   Since set is a subcommand, it's not shown in angle brackets, but it's still required.  Copy /time set 6000 /time set noon   A literal argument can have multiple accepted values. In those cases, a vertical bar separates the possible values. The /weather command uses this for the type of weather to apply:  Copy /weather <clear|rain|thunder> [duration: int] /weather rain 10000   An optional literal argument will be shown surrounded by square brackets. The final argument of /testforblocks is an optional literal argument that can be either \"all\" or \"masked\". If none is specified, it defaults to \"all\". The \"masked\" option will cause the comparison to ignore air blocks, allowing any block to exist at the destination where there would be an air block at the source.  Copy /testforblocks <begin: x y z> <end: x y z> <destination: x y z> [masked|all] /testforblocks 0 64 0 20 64 20 100 50 100 /testforblocks 0 64 0 20 64 20 100 50 100 masked  Input types  Any argument that isn't a literal argument will specify the expected input type after the descriptor.  Copy /command <descriptor: type> /command [descriptor: type]   There are a large number of input types. The most common ones are primitive numeric values, but there are many that are exclusive to one command. The table below details the most common input types and some popular commands they belong to. Most unique input types, such as \"GameMode\" from the /gamemode command, can easily have their input checked by using the auto-complete feature in the chat.  Expand table Type\tDescription\tCommon commands Boolean\ttrue or false.\t/effect, /gamerule int\tAn integer (1, 2, 3).\t/give, /scoreboard, /time, /weather, /xp float\tA decimal number (1, 2.3, 4, 5.6).\t/spreadplayers string\tEither a single word or text within \"quotation marks\".\t/scoreboard, /summon, /tag message\tText that does not need to be in quotation marks.\t/me, /msg, /say, /tell, /title, /w x y z\t3 floats separated by spaces to specify coordinates.  Each value can also be a tilde (~), which indicates no change from the execution origin on that axis, or a tilde followed by a number (~5) to indicate the number of blocks away from the execution origin on that axis.\t/clone, /execute, /fill, /setblock, /summon, /teleport, /testforblock Block\tA block ID.\t/clone, /execute, /fill, /setblock, /testforblock Item\tAn item ID.\t/clear, /give, /replaceitem EntityType\tAn entity ID.\t/summon json\tJSON-formatted text.\t/give, /replaceitem, /summon, /tellraw, /titleraw target\tEither a player name or a target selector.\t/clear, /execute, /gamemode, /give, /kill, /replaceitem, /scoreboard, /tag, /teleport, /testfor What's Next?  Now that you've learned about commands, you can learn more about target selectors, commands, or about how to use command blocks to move beyond the chat window.  Target Selectors Popular Commands Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/redstoneguide?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn A Guide to Redstone 09/20/2023  This guide is intended to show you some basic ways to use redstone components so that you might feel inspired to try your own projects and feel more prepared to go learn from other redstone creators.  In this tutorial you will learn the following:  Basic redstone components and how they work. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction to Commands  This guide assumes that you know how to make a flat, creative-mode world and how to give yourself the things you need, like redstone dust and pistons.  Redstone Fundamentals  What is redstone? Redstone is kind of like electrical circuits within Minecraft. As with electrical circuits, it's possible to build incredibly sophisticated machines based on the combination of simple connections and switches among components.  Using redstone torches, redstone blocks, and redstone dust  You can power most redstone devices, like a redstone lamp, by putting a redstone torch on an adjacent block.  Putting the torch on the lamp itself will not power it.  Placing a redstone block on the lamp will power it.  Redstone dust acts like a conduit between a power source and a component. As the power signal travels farther from the power source, it gets weaker at a predictable rate. The redstone signal coming out of a power source starts at 15 and decreases by 1 for each block the line of redstone dust is extended.  Let's do an experiment to test this:  Give yourself redstone dust and a redstone torch.  Place one handful of redstone dust dust on the ground. It makes a dark red blob.  Place a redstone torch next to the blob. The redstone blob will glow and align itself to point towards the torch. Neat!  Place more redstone dust to continue the line in one direction. Notice that the glow gets fainter as you get farther from the torch.  Extend the line at least 15 blocks.  Give yourself a piston and place it anywhere around the dark end of the redstone line. The pistons won't do anything if the signal is too weak to make the redstone touching the piston glow.  Place another piston next to the glowing part of the redstone. It should extend.  You could also add another redstone torch to boost the power.  Random redstone dust, torch, and block facts, in no particular order A blob of redstone dust will power all the blocks around it and the block it is placed on. Redstone blocks and redstone torches each have a signal strength of 15. Power radiates out from a redstone torch in all directions, as shown in this grid that is powered by one redstone torch.  A redstone torch powers the block above it, takes redstone signal from it, and powers all adjacent redstone components including above and below the torch.  A redstone torch will not power the is block it is placed on. Placing a redstone torch on a powered block will deactivate the block.  The redstone torch or redstone block must be next to or below the piston to power it. Placing the torch or block in front of the piston will not power it.  Redstone torches don't power the block they're on. For example, putting a redstone torch on top of a piston will not power it, but placing a redstone block on top of a piston will power it.  A redstone torch can be deactivated by powering the block it is placed on.  Power from a redstone torch is continuous. Power can also travel in pulses called \"ticks\" and there are ways to vary the rate.  Time Tick and Redstone Tick  In Minecraft, the term for time passing is \"ticks\" and time passes at 20 ticks per second. Redstone signals pass at the rate of 10 ticks per second. By controlling the speed of the ticks, you can control the speed at which a component does something. So, as you experiment with how different components are powered, keep in mind that the power does not have to be continuous.  Components that emit redstone power  These are things that can power redstone components even though there is no redstone in their recipes.  Button: press to get a short pulse of power. Lever: toggles full signal strength on or off. Pressure plate, wood or stone: sends a pulse of power when you press or step on it. They can be activated by mobs stepping on them, too. Different mobs may activate the pressure plates at different strengths. For example, the signal strength emitted when a creeper steps on the plate is lower than the strength emitted when an iron golem steps on it. When the player or mob leaves the plate, it will deactivate after 5 redstone ticks. A wooden pressure plate also activates if an item is dropped on it. Weighted pressure plate, iron (\"heavy\") or gold (\"light\"): signal strength grows as the number of entities (players, mobs, or items) on top of it increases. Light plate requires fewer items for maximum signal strength than heavy plate needs. Tripwire: emits signal strength when wire is activated (tripped). Lectern with a book on it: emits a pulse of power as you turn the pages. Common redstone components  Piston and sticky piston: These stay extended for as long as they are powered. A piston can push up to 12 blocks. Sticky pistons can pull the block stuck to it back again. Pistons take one tick to extend, zero ticks to retract.  Repeater: Place along a line of redstone dust to continue the signal. As long as a signal strength of 1 or higher is going into the repeater, it will output the maximum level of 15. Redstone repeaters only power the dust or component directly in front of them. They have a built-in delay of 1 tick and can be toggled to extend the delay to 4 ticks. If the input pulse delay is shorter than the delay toggled on the repeater, it will extend the pulse. For example, if you route a 1-tick pulse into a 4-tick repeater, the pulse gets extended to 4 ticks.  Comparator: Unlike a repeater, the comparator outputs the same signal strength that comes into the back of it. Comparators also take in a signal running into the side and compare it to the strength of the signal coming into the back. In normal mode (when the light is NOT switched on) then it will not output a signal if the strength of the signal running into the side is stronger than the signal strength running into the back. If the redstone comparator is in subtract mode (meaning the light is on), it will subtract the signal strength that comes into the side from the signal strength that comes into the back and output the result. So, if a signal strength of 10 is running through a comparator that is in subtract mode (light ON) and we put in a signal strength of 7, the it will output a signal strength of 3.  (Remember, the signal starts at 15 and then goes down by one for each segment of redstone dust.)  Daylight sensor: Produces different levels of power depending on the level of light it detects. It can be inverted to emit light when it detects darkness. To invert it, place one and right-click on it. It will turn blue.  Dropper: Spits out a random item from its inventory when powered directly or powered by an adjacent block. For example, if loaded with a horse spawn egg, when activated, it drops a horse spawn egg. If loaded with arrows, it spits out an arrow.  Dispenser: Works like the dropper, but has special powers depending on what items are loaded into it. For example, if it is loaded with a horse spawn egg, it dispenses a horse. If loaded with arrows, it will fire the arrow. Other items with special behavior include armor stands, boats, bone meal, potions, and buckets.  Observer: When it detects block updates with its face, it sends a one-tick pulse through the red spot on the back. Observers will emit a pulse when they are moved by pistons.  Trapped chest: Activates when opened. Signal varies according to how many players are viewing the contents.  Noteblock: Plays a note when it receives a signal.  Redstone lamp: Produces light when powered.  TNT: Activates when powered directly or by an adjacent powered block. Fuse time is 40 redstone ticks.  What's Next?  Now that you know more about redstone, you could use it to enhance a \"Complete the Monument\" map.  Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/redstoneguide?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn A Guide to Redstone 09/20/2023  This guide is intended to show you some basic ways to use redstone components so that you might feel inspired to try your own projects and feel more prepared to go learn from other redstone creators.  In this tutorial you will learn the following:  Basic redstone components and how they work. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction to Commands  This guide assumes that you know how to make a flat, creative-mode world and how to give yourself the things you need, like redstone dust and pistons.  Redstone Fundamentals  What is redstone? Redstone is kind of like electrical circuits within Minecraft. As with electrical circuits, it's possible to build incredibly sophisticated machines based on the combination of simple connections and switches among components.  Using redstone torches, redstone blocks, and redstone dust  You can power most redstone devices, like a redstone lamp, by putting a redstone torch on an adjacent block.  Putting the torch on the lamp itself will not power it.  Placing a redstone block on the lamp will power it.  Redstone dust acts like a conduit between a power source and a component. As the power signal travels farther from the power source, it gets weaker at a predictable rate. The redstone signal coming out of a power source starts at 15 and decreases by 1 for each block the line of redstone dust is extended.  Let's do an experiment to test this:  Give yourself redstone dust and a redstone torch.  Place one handful of redstone dust dust on the ground. It makes a dark red blob.  Place a redstone torch next to the blob. The redstone blob will glow and align itself to point towards the torch. Neat!  Place more redstone dust to continue the line in one direction. Notice that the glow gets fainter as you get farther from the torch.  Extend the line at least 15 blocks.  Give yourself a piston and place it anywhere around the dark end of the redstone line. The pistons won't do anything if the signal is too weak to make the redstone touching the piston glow.  Place another piston next to the glowing part of the redstone. It should extend.  You could also add another redstone torch to boost the power.  Random redstone dust, torch, and block facts, in no particular order A blob of redstone dust will power all the blocks around it and the block it is placed on. Redstone blocks and redstone torches each have a signal strength of 15. Power radiates out from a redstone torch in all directions, as shown in this grid that is powered by one redstone torch.  A redstone torch powers the block above it, takes redstone signal from it, and powers all adjacent redstone components including above and below the torch.  A redstone torch will not power the is block it is placed on. Placing a redstone torch on a powered block will deactivate the block.  The redstone torch or redstone block must be next to or below the piston to power it. Placing the torch or block in front of the piston will not power it.  Redstone torches don't power the block they're on. For example, putting a redstone torch on top of a piston will not power it, but placing a redstone block on top of a piston will power it.  A redstone torch can be deactivated by powering the block it is placed on.  Power from a redstone torch is continuous. Power can also travel in pulses called \"ticks\" and there are ways to vary the rate.  Time Tick and Redstone Tick  In Minecraft, the term for time passing is \"ticks\" and time passes at 20 ticks per second. Redstone signals pass at the rate of 10 ticks per second. By controlling the speed of the ticks, you can control the speed at which a component does something. So, as you experiment with how different components are powered, keep in mind that the power does not have to be continuous.  Components that emit redstone power  These are things that can power redstone components even though there is no redstone in their recipes.  Button: press to get a short pulse of power. Lever: toggles full signal strength on or off. Pressure plate, wood or stone: sends a pulse of power when you press or step on it. They can be activated by mobs stepping on them, too. Different mobs may activate the pressure plates at different strengths. For example, the signal strength emitted when a creeper steps on the plate is lower than the strength emitted when an iron golem steps on it. When the player or mob leaves the plate, it will deactivate after 5 redstone ticks. A wooden pressure plate also activates if an item is dropped on it. Weighted pressure plate, iron (\"heavy\") or gold (\"light\"): signal strength grows as the number of entities (players, mobs, or items) on top of it increases. Light plate requires fewer items for maximum signal strength than heavy plate needs. Tripwire: emits signal strength when wire is activated (tripped). Lectern with a book on it: emits a pulse of power as you turn the pages. Common redstone components  Piston and sticky piston: These stay extended for as long as they are powered. A piston can push up to 12 blocks. Sticky pistons can pull the block stuck to it back again. Pistons take one tick to extend, zero ticks to retract.  Repeater: Place along a line of redstone dust to continue the signal. As long as a signal strength of 1 or higher is going into the repeater, it will output the maximum level of 15. Redstone repeaters only power the dust or component directly in front of them. They have a built-in delay of 1 tick and can be toggled to extend the delay to 4 ticks. If the input pulse delay is shorter than the delay toggled on the repeater, it will extend the pulse. For example, if you route a 1-tick pulse into a 4-tick repeater, the pulse gets extended to 4 ticks.  Comparator: Unlike a repeater, the comparator outputs the same signal strength that comes into the back of it. Comparators also take in a signal running into the side and compare it to the strength of the signal coming into the back. In normal mode (when the light is NOT switched on) then it will not output a signal if the strength of the signal running into the side is stronger than the signal strength running into the back. If the redstone comparator is in subtract mode (meaning the light is on), it will subtract the signal strength that comes into the side from the signal strength that comes into the back and output the result. So, if a signal strength of 10 is running through a comparator that is in subtract mode (light ON) and we put in a signal strength of 7, the it will output a signal strength of 3.  (Remember, the signal starts at 15 and then goes down by one for each segment of redstone dust.)  Daylight sensor: Produces different levels of power depending on the level of light it detects. It can be inverted to emit light when it detects darkness. To invert it, place one and right-click on it. It will turn blue.  Dropper: Spits out a random item from its inventory when powered directly or powered by an adjacent block. For example, if loaded with a horse spawn egg, when activated, it drops a horse spawn egg. If loaded with arrows, it spits out an arrow.  Dispenser: Works like the dropper, but has special powers depending on what items are loaded into it. For example, if it is loaded with a horse spawn egg, it dispenses a horse. If loaded with arrows, it will fire the arrow. Other items with special behavior include armor stands, boats, bone meal, potions, and buckets.  Observer: When it detects block updates with its face, it sends a one-tick pulse through the red spot on the back. Observers will emit a pulse when they are moved by pistons.  Trapped chest: Activates when opened. Signal varies according to how many players are viewing the contents.  Noteblock: Plays a note when it receives a signal.  Redstone lamp: Produces light when powered.  TNT: Activates when powered directly or by an adjacent powered block. Fuse time is 40 redstone ticks.  What's Next?  Now that you know more about redstone, you could use it to enhance a \"Complete the Monument\" map.  Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/molangbeginnersguide?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Molang: a Beginner's Guide 09/21/2023  Molang (sometimes written as \"MoLang\") is a scripting language that can be used to enhance Minecraft functionality. It's typically used one or two lines at a time, although there have been creators who have written pages and pages of the stuff to do incredible things ... because of course they did.  Molang can be used in pretty much any Minecraft JSON file a creator can access, usually in behavior packs and resource packs.  In this tutorial you will learn the following:  What Molang is and an example of where you could use it How to change the experience and loot drop from an attack cow How to edit the animation for our attack cow to make it even scarier Requirements  You're going to want to feel comfortable using resource packs and behavior packs in Minecraft. Review these if you need to, and hang onto the attack cow behavior pack.  Getting Started with Add-On Development Introduction To Resource Packs Introduction To Behavior Packs Using Molang in a Behavior Pack  This tutorial starts with the completed attack cow behavior pack created from the behavior pack tutorial.  We are going to use Molang to make the attack cow drop more experience points. We are also going to edit a non-Molang line of code so the cow drops fancy End City loot instead of the usual leather and beef when you unalive it.  Open cow.json and find the minecraft:cow_adult line of code.  The original code looks like this:  JSON Copy \"minecraft:cow_adult\": {         \"minecraft:experience_reward\": {           \"on_bred\": \"Math.Random(1,7)\",           \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"         },         \"minecraft:loot\": {           \"table\": \"loot_tables/entities/cow.json\"         },   The first line we care about is \"on_death\" inside the \"Minecraft:experience_reward\" section. This is the line of code that gives you those little green and yellow jinglies of experience.  This code:  JSON Copy  \"minecraft:experience_reward\": {           \"on_bred\": \"Math.Random(1,7)\",           \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"         },   ... translates to this:  \"In the context of how a cow can reward experience points to a player, there are two ways; when you feed wheat to two cows so they breed a baby cow (\"on_bred\") or when you kill a cow (\"on_death\").  This line of code:  \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"  translates to:  Upon the death of a cow: Run a query to see who was the last player to hit it. If you find a player, then use a random number generator to pick 1, 2, or 3. Return that value as experience_reward. Otherwise, if something goes horribly wrong and we can't find a player, then return a 0 and let's pretend nothing happened.  Edit the \"on_death\" line to look like this:  \"on_death\": \"query.last_hit_by_player ? 300 * Math.Random(1,3) : 0\"  This multiplies the returned number of experience points by 300.  Now, let's make the cow drop End City loot. Note: THIS IS NOT MOLANG! It's just simple JSON code editing. But, since we're here anyway...  In the conveniently close \"minecraft:loot\" section of the cow.json code, change the \"table\" line from this:  \"table\": \"loot_tables/entities/cow.json\"  to this:  \"table\": \"loot_tables/chests/end_city_treasure.json\"  Woohoo!  Here is a summary of what we just did:  JSON Copy \"minecraft:cow_adult\": {   \"minecraft:experience_reward\": {       \"on_bred\": \"Math.Random(1,7)\",       \"on_death\": \"query.last_hit_by_player ? 300 * Math.Random(1,1) : 0\"   },       \"minecraft:loot\": {       \"table\": \"loot_tables/chests/end_city_treasure.json\"   },   Save it. Play it. Enjoy your diamond armor.  Resource Pack Animation with Molang  We are going to use a line of Molang in an animation file to make the cow's head wobble around menacingly. You're going to need a resource pack with the usual manifest file. It's okay to use the one that gets created with the resource pack tutorial. You can also download one from the sample collection and test it out before moving on to this next bit:  A resource pack sample  Everything works? Resource pack loads and the dirt is green or whatever? Great!  Create a folder on the same level as the manifest.json file and name it animations. Put a text file in there and name it cow.animation.json Copy and paste this text into that file: JSON Copy {   \"format_version\": \"1.8.0\",   \"animations\": {     \"animation.cow.baby_transform\": {       \"loop\": true,       \"bones\": {         \"head\": {           \"position\": [0.0, 4.0, 4.0],           \"scale\": 2.0         }       }     },     \"animation.cow.setup\": {       \"loop\": true,       \"bones\": {         \"body\": {           \"rotation\": [\"-this\", 0.0, 0.0]         },         \"head\": {           \"rotation\": [0, 0, \"math.sin(query.life_time*360) * 40\"]         }       }     },     \"animation.cow.setup.v1.0\": {       \"loop\": true,       \"bones\": {         \"body\": {           \"rotation\": [\"90 - this\", 0.0, 0.0]         }       }     }   } }    If you compare this code to the Vanilla animations/cow.animation.json file in the Vanilla Resource pack, you will see that the only change is the addition of this line of code:  JSON Copy \"head\": {        \"rotation\": [0, 0, \"math.sin(query.life_time*360) * 40\"]       }    The code in brackets is Molang and it is using a sine function to control how the head rotates. Yay, trigonometry!  After you reload Minecraft and find (or summon) an \"enhanced\" cow, you can experiment with different values and functions in that expression to do different things.  Extra credit: Use the resource pack to edit the cow's skin to make it even more terrifying.  Molang Links  So, you just learned one way to use Molang to harness the power of math and logical expressions to make your world more like how you want it. Another way is to use a third party program like Blockbench. Either way, it might help or inspire you to learn more about what Molang can do, so here are the reference files:  Molang Introduction Domain Examples Query Functions Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/molangbeginnersguide?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Molang: a Beginner's Guide 09/21/2023  Molang (sometimes written as \"MoLang\") is a scripting language that can be used to enhance Minecraft functionality. It's typically used one or two lines at a time, although there have been creators who have written pages and pages of the stuff to do incredible things ... because of course they did.  Molang can be used in pretty much any Minecraft JSON file a creator can access, usually in behavior packs and resource packs.  In this tutorial you will learn the following:  What Molang is and an example of where you could use it How to change the experience and loot drop from an attack cow How to edit the animation for our attack cow to make it even scarier Requirements  You're going to want to feel comfortable using resource packs and behavior packs in Minecraft. Review these if you need to, and hang onto the attack cow behavior pack.  Getting Started with Add-On Development Introduction To Resource Packs Introduction To Behavior Packs Using Molang in a Behavior Pack  This tutorial starts with the completed attack cow behavior pack created from the behavior pack tutorial.  We are going to use Molang to make the attack cow drop more experience points. We are also going to edit a non-Molang line of code so the cow drops fancy End City loot instead of the usual leather and beef when you unalive it.  Open cow.json and find the minecraft:cow_adult line of code.  The original code looks like this:  JSON Copy \"minecraft:cow_adult\": {         \"minecraft:experience_reward\": {           \"on_bred\": \"Math.Random(1,7)\",           \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"         },         \"minecraft:loot\": {           \"table\": \"loot_tables/entities/cow.json\"         },   The first line we care about is \"on_death\" inside the \"Minecraft:experience_reward\" section. This is the line of code that gives you those little green and yellow jinglies of experience.  This code:  JSON Copy  \"minecraft:experience_reward\": {           \"on_bred\": \"Math.Random(1,7)\",           \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"         },   ... translates to this:  \"In the context of how a cow can reward experience points to a player, there are two ways; when you feed wheat to two cows so they breed a baby cow (\"on_bred\") or when you kill a cow (\"on_death\").  This line of code:  \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"  translates to:  Upon the death of a cow: Run a query to see who was the last player to hit it. If you find a player, then use a random number generator to pick 1, 2, or 3. Return that value as experience_reward. Otherwise, if something goes horribly wrong and we can't find a player, then return a 0 and let's pretend nothing happened.  Edit the \"on_death\" line to look like this:  \"on_death\": \"query.last_hit_by_player ? 300 * Math.Random(1,3) : 0\"  This multiplies the returned number of experience points by 300.  Now, let's make the cow drop End City loot. Note: THIS IS NOT MOLANG! It's just simple JSON code editing. But, since we're here anyway...  In the conveniently close \"minecraft:loot\" section of the cow.json code, change the \"table\" line from this:  \"table\": \"loot_tables/entities/cow.json\"  to this:  \"table\": \"loot_tables/chests/end_city_treasure.json\"  Woohoo!  Here is a summary of what we just did:  JSON Copy \"minecraft:cow_adult\": {   \"minecraft:experience_reward\": {       \"on_bred\": \"Math.Random(1,7)\",       \"on_death\": \"query.last_hit_by_player ? 300 * Math.Random(1,1) : 0\"   },       \"minecraft:loot\": {       \"table\": \"loot_tables/chests/end_city_treasure.json\"   },   Save it. Play it. Enjoy your diamond armor.  Resource Pack Animation with Molang  We are going to use a line of Molang in an animation file to make the cow's head wobble around menacingly. You're going to need a resource pack with the usual manifest file. It's okay to use the one that gets created with the resource pack tutorial. You can also download one from the sample collection and test it out before moving on to this next bit:  A resource pack sample  Everything works? Resource pack loads and the dirt is green or whatever? Great!  Create a folder on the same level as the manifest.json file and name it animations. Put a text file in there and name it cow.animation.json Copy and paste this text into that file: JSON Copy {   \"format_version\": \"1.8.0\",   \"animations\": {     \"animation.cow.baby_transform\": {       \"loop\": true,       \"bones\": {         \"head\": {           \"position\": [0.0, 4.0, 4.0],           \"scale\": 2.0         }       }     },     \"animation.cow.setup\": {       \"loop\": true,       \"bones\": {         \"body\": {           \"rotation\": [\"-this\", 0.0, 0.0]         },         \"head\": {           \"rotation\": [0, 0, \"math.sin(query.life_time*360) * 40\"]         }       }     },     \"animation.cow.setup.v1.0\": {       \"loop\": true,       \"bones\": {         \"body\": {           \"rotation\": [\"90 - this\", 0.0, 0.0]         }       }     }   } }    If you compare this code to the Vanilla animations/cow.animation.json file in the Vanilla Resource pack, you will see that the only change is the addition of this line of code:  JSON Copy \"head\": {        \"rotation\": [0, 0, \"math.sin(query.life_time*360) * 40\"]       }    The code in brackets is Molang and it is using a sine function to control how the head rotates. Yay, trigonometry!  After you reload Minecraft and find (or summon) an \"enhanced\" cow, you can experiment with different values and functions in that expression to do different things.  Extra credit: Use the resource pack to edit the cow's skin to make it even more terrifying.  Molang Links  So, you just learned one way to use Molang to harness the power of math and logical expressions to make your world more like how you want it. Another way is to use a third party program like Blockbench. Either way, it might help or inspire you to learn more about what Molang can do, so here are the reference files:  Molang Introduction Domain Examples Query Functions Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontogamerules?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Gamerules 06/28/2024  The /gamerule command lets you adjust certain features of your game world and even turn them on and off. Gamerules can be extremely helpful when setting up the basics for how your Minecraft world will behave. For example, if you want to create an amusement park world, you can use gamerules to make sure that it's always a sunny, perfect day to enjoy all of the rides or attractions. Let's take a closer look at gamerules to see how we can use them to create experiences in Minecraft.  Prerequisites  We recommend completing the following before beginning this tutorial:  Introduction to Commands Using /gamerule Commands  For a full list of /gamerule commands and their descriptions, see gamerule Command.  Don't worry if you don't know all of the /gamerule commands by heart - we'll go over the specific commands we want to use in the following sections. For now, just know that you can use the command in Minecraft in the following format: /gamerule [INSERT GAMERULE COMMAND HERE] [INSERT GAMERULE VALUE HERE].  Sample /gamerule Configurations  Now let's take a look at how we can use gamerules to create a customized experience in Minecraft. We'll use examples of different types of Minecraft worlds to explore how we might use gamerules to set up your world so that you can see how different sets of gamerules can create unique experiences for you and your players to enjoy.  Amusement Park Gamerules  As we mentioned earlier, when visiting an amusement park, it's always the most fun on a bright, sunny day. Let's use gamerules to set up an ideal Minecraft amusement park world:  Expand table /gamerule command\tValue\tEffect on the World commandblockoutput\tfalse\tWe don't want our guests getting all of the behind-the-scenes information on the mechanics of our park, so let's turn off command block output. dodaylightcycle\ttrue\tIf your amusement park has night hours (and maybe attractions that feature light shows!), we definitely want the world to shift from day to night. dofiretick\tfalse\tThis setting will help us keep those minor disasters under control, especially if you have attractions that feature pyrotechnics! domobspawning\tfalse\tPaying customers only, please! Let's turn off mob spawning so we don't get zombies or creepers crashing the party. doweathercycle\tfalse\tThis will prevent the weather from changing and ensure that it's sunny every day. drowningdamage\tfalse\tA rule to help keep our guests safe. falldamage\tfalse\tA rule to help keep our guests safe. firedamage\tfalse\tA rule to help keep our guests safe. pvp\tfalse\tThis prevents players from damaging each other. Please be respectful of other guests in our park! doinsomnia\tfalse\tThis turns off phantoms and other effects of not sleeping and allows players to have fun for as long as they would like in our park. freezedamage\tfalse\tA rule to help keep our guests safe.  This basic set of rules will ensure that players don't take damage from sources like fire, ice, and water, which can all be used as great effects for the attractions in our amusement park. It also makes sure that we keep our guests safe from natural hazards like falling or mobs that would be drawn to our park and that guests will be respectful of one another and let everyone enjoy themselves. Finally, it will ensure that we experience both day and night, but that the weather will always be perfect for enjoying our park.  Battle Royale Gamerules  In a battle royale world, we want to create a fast-paced, fun player-versus-player (PvP) setting where players are encouraged to jump into the action and test their skills.  Expand table /gamerule command\tValue\tEffect on the World commandblockoutput\ttrue\tMaybe you have command blocks that players can press that will give them an advantage or maybe you want to watch your players from a central control room. Either way, you probably want other players to know that things have happened in the world. doentitydrops\ttrue\tThis will make sure that entities in the world drop items for your players so that they can grab loot to do battle with. domobspawning\tfalse\tBattle royale is all about player-vs-player combat, let's keep mobs out of it. keepinventory\tfalse\tThis will cause players to drop their inventory when they respawn. This way, they'll have to gather more loot and other players can take what they drop! pvp\ttrue\tThere's not much point to a battle royale if PvP isn't enabled! showcoordinates\tfalse\tLeaving the coordinate display off helps to increase immersion and also makes it more difficult for players to know their exact position (and the position of their enemies!). naturalregeneration\tfalse\tTurning off natural health regeneration prevents players from hiding to heal and dragging the match out. doinsomnia\tfalse\tThe match may last several game days and nights, depending on your settings - there's no need to add phantoms to the mix! doimmediaterespawn\ttrue\tSetting immediate respawns means that players have to jump back into the action right away. showdeathmessages\ttrue\tThis will let other players know each time a player is eliminated. showbordereffects\ttrue\tThis makes sure that your game map is well-defined for your players.  With these gamerules, you've got the building blocks for an exciting battle royale match. Players will be thrown into the mix with each other and encouraged to fight for survival and be the last one standing. We used gamerules to ensure that mobs and other environmental dangers don't affect the PvP combat and that players won't be able to hide or rely on external factors to delay a match. Once you add your finishing touches, it will be time to join the fight!  Customizing and Next Steps  Of course, you can change these gamerules to fit your specific implementations. Maybe you want an amusement park full of real zombies for a Halloween event, or maybe you want a battle royale match that features player-versus-player-versus-environment (PvPvE) action where players can get special loot from mobs that spawn in the world. When you're creating immersive and customized experiences in Minecraft, the possibilities are endless, but setting gamerules is a great place to start.  Check out the following resources to see how you can tailor your Minecraft world even further.  Create Custom Grass Blocks: An Introduction to Resource Packs Create an Angry Cow: An Introduction To Behavior Packs Getting Started with Command Blocks Loot and Trade Table Functions Scripting and Gamerules  As you progress through your Minecraft customization journey, you may become interested in writing scripts that set all of these gamerules at once. Though your gamerules will stay in place in your created worlds, scripts can help to make your Minecraft experiences more efficient and enjoyable, since you won't have to enter the individual /gamerule commands every time you start up a new world. You can also change the gamerules based on certain conditions and use other advanced techniques to customize your experience for you and your friends.  To learn more about Minecraft scripting, see Introduction to Scripting in Minecraft.  Once you have begun writing scripts, you can use this reference to include gamerules in your scripts with the appropriate names and syntax: GameRule Enumeration.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontogamerules?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Gamerules 06/28/2024  The /gamerule command lets you adjust certain features of your game world and even turn them on and off. Gamerules can be extremely helpful when setting up the basics for how your Minecraft world will behave. For example, if you want to create an amusement park world, you can use gamerules to make sure that it's always a sunny, perfect day to enjoy all of the rides or attractions. Let's take a closer look at gamerules to see how we can use them to create experiences in Minecraft.  Prerequisites  We recommend completing the following before beginning this tutorial:  Introduction to Commands Using /gamerule Commands  For a full list of /gamerule commands and their descriptions, see gamerule Command.  Don't worry if you don't know all of the /gamerule commands by heart - we'll go over the specific commands we want to use in the following sections. For now, just know that you can use the command in Minecraft in the following format: /gamerule [INSERT GAMERULE COMMAND HERE] [INSERT GAMERULE VALUE HERE].  Sample /gamerule Configurations  Now let's take a look at how we can use gamerules to create a customized experience in Minecraft. We'll use examples of different types of Minecraft worlds to explore how we might use gamerules to set up your world so that you can see how different sets of gamerules can create unique experiences for you and your players to enjoy.  Amusement Park Gamerules  As we mentioned earlier, when visiting an amusement park, it's always the most fun on a bright, sunny day. Let's use gamerules to set up an ideal Minecraft amusement park world:  Expand table /gamerule command\tValue\tEffect on the World commandblockoutput\tfalse\tWe don't want our guests getting all of the behind-the-scenes information on the mechanics of our park, so let's turn off command block output. dodaylightcycle\ttrue\tIf your amusement park has night hours (and maybe attractions that feature light shows!), we definitely want the world to shift from day to night. dofiretick\tfalse\tThis setting will help us keep those minor disasters under control, especially if you have attractions that feature pyrotechnics! domobspawning\tfalse\tPaying customers only, please! Let's turn off mob spawning so we don't get zombies or creepers crashing the party. doweathercycle\tfalse\tThis will prevent the weather from changing and ensure that it's sunny every day. drowningdamage\tfalse\tA rule to help keep our guests safe. falldamage\tfalse\tA rule to help keep our guests safe. firedamage\tfalse\tA rule to help keep our guests safe. pvp\tfalse\tThis prevents players from damaging each other. Please be respectful of other guests in our park! doinsomnia\tfalse\tThis turns off phantoms and other effects of not sleeping and allows players to have fun for as long as they would like in our park. freezedamage\tfalse\tA rule to help keep our guests safe.  This basic set of rules will ensure that players don't take damage from sources like fire, ice, and water, which can all be used as great effects for the attractions in our amusement park. It also makes sure that we keep our guests safe from natural hazards like falling or mobs that would be drawn to our park and that guests will be respectful of one another and let everyone enjoy themselves. Finally, it will ensure that we experience both day and night, but that the weather will always be perfect for enjoying our park.  Battle Royale Gamerules  In a battle royale world, we want to create a fast-paced, fun player-versus-player (PvP) setting where players are encouraged to jump into the action and test their skills.  Expand table /gamerule command\tValue\tEffect on the World commandblockoutput\ttrue\tMaybe you have command blocks that players can press that will give them an advantage or maybe you want to watch your players from a central control room. Either way, you probably want other players to know that things have happened in the world. doentitydrops\ttrue\tThis will make sure that entities in the world drop items for your players so that they can grab loot to do battle with. domobspawning\tfalse\tBattle royale is all about player-vs-player combat, let's keep mobs out of it. keepinventory\tfalse\tThis will cause players to drop their inventory when they respawn. This way, they'll have to gather more loot and other players can take what they drop! pvp\ttrue\tThere's not much point to a battle royale if PvP isn't enabled! showcoordinates\tfalse\tLeaving the coordinate display off helps to increase immersion and also makes it more difficult for players to know their exact position (and the position of their enemies!). naturalregeneration\tfalse\tTurning off natural health regeneration prevents players from hiding to heal and dragging the match out. doinsomnia\tfalse\tThe match may last several game days and nights, depending on your settings - there's no need to add phantoms to the mix! doimmediaterespawn\ttrue\tSetting immediate respawns means that players have to jump back into the action right away. showdeathmessages\ttrue\tThis will let other players know each time a player is eliminated. showbordereffects\ttrue\tThis makes sure that your game map is well-defined for your players.  With these gamerules, you've got the building blocks for an exciting battle royale match. Players will be thrown into the mix with each other and encouraged to fight for survival and be the last one standing. We used gamerules to ensure that mobs and other environmental dangers don't affect the PvP combat and that players won't be able to hide or rely on external factors to delay a match. Once you add your finishing touches, it will be time to join the fight!  Customizing and Next Steps  Of course, you can change these gamerules to fit your specific implementations. Maybe you want an amusement park full of real zombies for a Halloween event, or maybe you want a battle royale match that features player-versus-player-versus-environment (PvPvE) action where players can get special loot from mobs that spawn in the world. When you're creating immersive and customized experiences in Minecraft, the possibilities are endless, but setting gamerules is a great place to start.  Check out the following resources to see how you can tailor your Minecraft world even further.  Create Custom Grass Blocks: An Introduction to Resource Packs Create an Angry Cow: An Introduction To Behavior Packs Getting Started with Command Blocks Loot and Trade Table Functions Scripting and Gamerules  As you progress through your Minecraft customization journey, you may become interested in writing scripts that set all of these gamerules at once. Though your gamerules will stay in place in your created worlds, scripts can help to make your Minecraft experiences more efficient and enjoyable, since you won't have to enter the individual /gamerule commands every time you start up a new world. You can also change the gamerules based on certain conditions and use other advanced techniques to customize your experience for you and your friends.  To learn more about Minecraft scripting, see Introduction to Scripting in Minecraft.  Once you have begun writing scripts, you can use this reference to include gamerules in your scripts with the appropriate names and syntax: GameRule Enumeration.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptingintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Scripting in Minecraft 04/17/2025  \"Scripting\" is just another way of saying \"writing a list of instructions for the computer to follow to make it do what you want it to do.\"  You can use a script to control many things in your Minecraft world, including characteristics of the world; the behaviors of entities, blocks, and items; and even an entire game loop!  In this tutorial, we will write a few small scripts in the JavaScript programming language, which is used by the rest of the world to create web pages, apps, and more! Minecraft scripts can also be written in TypeScript, which is like a new and improved version of JavaScript. TypeScript is preferable to JavaScript because it provides better error reporting and more abilities than JavaScript. However, it does require more tooling to be installed. That's why, for this beginner tutorial, we will be using JavaScript to show you the simplest way to get a script up and running in Minecraft. You can learn how to set up a Minecraft TypeScript project in the Build a Gameplay Experience with TypeScript tutorial, which is highly recommended after completing this tutorial!  If you are new to coding in general, this tutorial should break down different elements of code enough for you to understand how to write a basic script. However, if anything seems too advanced or you are confused about something that is discussed in this tutorial, please reference this Beginner JavaScript Tutorial for more information.  Also, all of the concepts you will learn about here will be applicable to TypeScript as well (though it will have slightly different ways of writing things), so you should feel confident in moving on to the TypeScript tutorial after successfully completing this one.  Prerequisites  Before you begin, you should have gone through the Getting Started with Add-Ons tutorial and the Introduction to Behavior Packs tutorial.  Getting Started with Add-On Development Introduction To Behavior Packs  It should be clear to you how add-on folders must be structured, and what the required files in the behavior pack (such as manifest.json) should contain.  What You Need  Let's set up your computer. Here are the things you will need:  Minecraft: Bedrock Edition A Windows 10 (or higher) computer Keyboard and mouse Visual Studio Code (or another similar text editor) The Attack Cow sample behavior pack downloaded from the Minecraft samples GitHub repository.   Note  If you have never downloaded and used a sample behavior pack, here's how:  Go to https://github.com/microsoft/minecraft-samples/tree/main, click the green Code button, and choose \"Download ZIP\" from the drop-down menu. Open your Downloads folder and extract the minecraft-samples-main zipped folder contents. Inside the extracted minecraft-samples-main folder, find the behavior_pack_sample folder and open it. Look at the README.md file inside and follow the instructions to deploy the behavior pack. Displaying a Message using Scripting  Our first goal of this tutorial is to make Minecraft display a little message without the player having to lift a finger. It's just a small task, but it will demonstrate that we can make things happen automatically in Minecraft using a script.  To get there, we are going to start with the Attack Cow behavior pack, add the files we need for scripting, and then run the script in a Minecraft world.  Setup and Test the Attack Cow Behavior Pack If you haven't already followed this step from the README, copy the sample_behavior_pack into the development_behavior_packs folder in your com.mojang folder. Launch Minecraft and create a survival world with cheats on and the Attack Cow behavior pack activated in it. It needs to be a survival world because the cow's attack behavior won't work in a creative world, and cheats should be on so you can summon a cow. Summon a cow using the \"/summon\" command and make sure it attacks you, as expected. Now we know all systems are go! Save & Quit the world to return to the Minecraft Main Menu screen. Add a Script to the Behavior Pack Minimize Minecraft and open your sample_behavior_pack in Visual Studio Code. Open and view the manifest.json file.  In the manifest file, we need to add a new module (our script) as well as a new dependency (@minecraft/server, a module that contains information that we will use in writing our script). This tells the game that our script exists and that it should be processed. So, replace the contents of the manifest.json file with this: JSON Copy {     \"format_version\": 2,     \"header\": {       \"description\": \"My scripting behavior pack Add-On!\",       \"name\": \"My Behavior Pack\",       \"uuid\":\"PUT A NEW UUID HERE\",       \"version\": [1, 0, 0],       \"min_engine_version\": [1, 20, 30]     },     \"modules\":       [         {           \"description\": \"My Second Add-On!\",             \"type\": \"data\",             \"uuid\": \"PUT A NEW UUID HERE\",             \"version\": [1, 0, 0]         },         {           \"description\": \"Test Scripting\",             \"type\": \"script\",             \"uuid\": \"PUT A NEW UUID HERE\",             \"version\": [1, 0, 0],             \"entry\": \"scripts/main.js\"         }       ],     \"dependencies\": [       {         \"module_name\":\"@minecraft/server\",         \"version\":\"1.5.0\"       }    ]   }  Replace the three instances of PUT A NEW UUID HERE with new UUIDs, just like you did in the Introduction to Behavior Packs tutorial. Save your edited manifest.json file. In the behavior_pack_sample folder, create a folder and name it scripts and open it. Create a file inside there and name it main.js. Copy this code into main.js: JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  function mainTick() {   if (system.currentTick === 400) {     world.sendMessage(\"All systems GO!\");   }   system.run(mainTick); }  system.run(mainTick);  Save main.js.  When you're done, it should look like this:  Go back to Minecraft, create a world with the behavior pack activated. When you go into the world, your test message will appear after about 20 seconds.  That proves your script is working. Neat!  Save & Quit the world and go back to your main.js file.  For this particular script that we just tried, you must create a new world if you want to update the message in \"world.sendMessage\" and check that it has updated.  Hot reloading (using the /reload command) will NOT cause an updated message to display if the original message was displayed before your update, because the 400th tick (meaning the 20th second of the world existing) has already passed, and this line of the code specifically wants that particular tick:  if (system.currentTick === 400) {  Don't worry, we'll cover /reload later in this tutorial.  Even if you leave the world and come back, the world starts at the tick where it left off, so your update will not be apparent using that method either. In this case where we are executing code on a specific tick, you must create a new world. But this example should teach you that you should be very careful and intentional when relying on a specific tick to execute logic because it will only execute once, at a specific time.  We will teach you other patterns below that allow you to edit your code and refresh the game using hot reloading (making it much easier and less clunky to make updates).  JavaScript Code Explanation  Here's what's happening in the code above...  The import part at the top of the script is telling Minecraft which pieces of the game you want to access in your script. After the import statement, contained in curly braces (\"{ }\"), is a list of classes that we want to access from the Minecraft game. A class describes an object in the game, contains information about it, and allows you to perform actions on it.  For example, we imported system, which allowed us to access its property currentTick and use it in our code.  We also imported world, which allowed us access to its function sendMessage, which we used in our code to send a message to the screen.  Some other examples of classes are Player, Entity, Block, and ItemStack, but there are WAY more that you can read about in the @minecraft/server Module documentation.  The from part tells Minecraft which module your requested classes are defined in. A module stores a bunch of classes and APIs that you can use. There are several modules in Minecraft, but the most important one that contains most of the basic classes and APIs is \"@minecraft/server\".  The function part defines a function, which is a block of code that completes a specific task. Eventually, you will have many functions that do different tasks, whose names are descriptive of what they do (we will add more functions in a later section of this tutorial).  This function is named mainTick because we are using it to define the main game loop. A game loop is a sequence of processes (such as updating entity movement, detecting player input and acting on it, or updating the weather) that run over and over again to continuously update the game. A tick describes the time it takes to run the game loop once, which in Minecraft is 1/20th of a second (so 1 second = 20 ticks). The word \"tick\" can also describe one run through of the game loop, which is why our function is described as the \"main tick.\"  The system.run function allows you to provide the name of a function (mainTick in our case) to run during that game tick. This line at the bottom of the file...  system.run(mainTick);  ... calls our function mainTick for the first time. If we did not add this line, the mainTick function would be defined but not called, so it would not run and nothing would happen. We also have the same line at the end of the mainTick function itself. This is so that mainTick will run again the next tick when this tick is finished. This causes mainTick to run once per tick, thus giving us our game loop.  The contents of the mainTick function start with this line:  if (system.currentTick === 400)  This statement is checking if we are currently on the 400th tick. If we are on the 400th tick, then this statement is true and the code inside the if statement's curly braces will be executed:  world.sendMessage(\"All systems GO!\");  Otherwise, the code inside the if statement's curly braces will be skipped. Lastly, despite whether the if statement were true or false, system.run(mainTick) will be called again, to check again the next tick.  As mentioned earlier, 20 ticks equals 1 second in Minecraft. If your computer takes longer than 20 seconds to load the world, then this message will not get displayed unless you change the currentTick value from 400 to something greater. This is something to keep in mind as a creator! You do not want any world setup code to run before your world is even loaded!  Anyway, when we load our world with this script in it, that statement is false for a while.  It's like when you're hungry but it's not quite lunchtime, so you keep looking at the clock and asking \"Is it lunchtime yet?\" Well, it's not lunchtime yet, so the answer is \"No. Check again.\" So, 1/20th of a second later, you check again. \"Is it lunchtime yet?\" \"No. Check again.\" \"Is it lunchtime yet?\" \"No. Check again.\" This continues looping until it finally IS lunchtime, so you get to go have lunch! Yay!  What is Hot Reloading?  As alluded to previously, hot reloading is a super cool feature of scripting in Minecraft. Instead of having to close the game and reopen it in order to reload your script, hot reloading allows you to reload your script while you are inside your world and the game is still running, and your game will be updated to use the latest version of your script. You will find that this will drastically reduce your game development time because you will be able to test your changes almost instantly.  Let's try it! But first, we'll need to make one change to our current code to make it work with hot reloading.  Open main.js. Change this line of code:  if (system.currentTick === 400)  ...to this, instead:  if (system.currentTick % 200 === 0)  The \"%\" is known as the modulo operator, and it is used to obtain the remainder of a division between two integers.  Also, we're changing the 400 to 200 so you have a shorter wait time.  So what we are now saying is \"if the remainder of the current tick divided by 200 equals 0, then execute this code.\" In other words, \"if the current tick is evenly divisible by 200, then execute this code.\" So this statement will now be true every 200 ticks, instead of being true solely on the 400th tick.  Due to this change, our line of code within the if statement's brackets:  world.sendMessage(\"All systems GO!\");  ... will run every 10 seconds, so the message \"All systems GO!\" will be displayed on the screen every 10 seconds.  First, we will test if our change works correctly, then we will use it to demonstrate how to use hot reloading.  Save main.js, and go back into your world that has your behavior pack applied. The message should appear every 10 seconds as expected, so something like this will be displayed in your chat and commands window:  Now that we know our program works, let's use it to learn how hot reloading works.  DO NOT SAVE AND QUIT TO THE MAIN MENU. Keep your Minecraft world open and running in the background (you might want to switch to creative mode if you are afraid of monsters creeping up on you!). Switch back to main.js in Visual Studio Code. Change your printed message to something else, such as \"My new message, ha ha!\" Save main.js, and switch back to your Minecraft window, which should still have your world open and running. Run the command /reload:  A message will appear stating that your function and script files have been reloaded, followed by your new message:  With that powerful tool now in your toolbox, let's write a couple more cool scripts!  Using a Variable to Count Seconds  Next, we will implement a simple script that counts the seconds that pass from the beginning of world load.  Replace your entire main.js file with the following code: JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  let secondsPassed = 0;  function mainTick() {   if (system.currentTick % 20 === 0) {     secondsPassed += 1;     world.sendMessage(\"Seconds Passed: \" + secondsPassed);   }   system.run(mainTick); }  system.run(mainTick);   The first thing to notice here is the line that says let secondsPassed = 0;. Here, we are declaring and initializing a variable.  A variable is a container for a value that can be used, reused, and changed. The let part tells the computer that we are creating (\"declaring\") a variable; the secondsPassed part is the descriptive name that we are giving the variable; and the = 0 part is putting the value of 0 into the secondsPassed container (or \"initializing\" it to 0). Next time we reference secondsPassed, it will be as if we are referencing the number 0.  Variables can be used to store all different types of values, not just numbers. They can also store things like Booleans (true/false), floating point numbers (decimal numbers), strings (text contained in \"quotes\"), arrays (lists of things), and classes (objects).  Our variable, secondsPassed, is declared in the main part of the script (not inside a function), so it is referred to as a global variable. Global variables can be used/changed inside any functions or any part of your script (within the same file).  You can also declare a variable inside a function, inside an if/else block, or inside a for loop, and those are referred to as local variables, because they are local to the block within which they are defined (they do not exist outside of that block of code).  The next thing to notice here is that inside the if statement, we changed the tick we are checking to 20. Remember that 20 ticks equals 1 second, so we are now running this block of code every second. This is so that our message can report the number of seconds that have passed, each second.  Inside the if statement, notice the line that says secondsPassed += 1;. This line has the same meaning as:  secondsPassed = secondsPassed + 1;  which gets translated to:  secondsPassed = 0 + 1;  and can be simplified to:  secondsPassed = 1;  So in summary, this line adds 1 to the current value of secondsPassed. The next time this line is run, secondsPassed will equal 1, and 1 more will be added to it, and then it will be 2, and so on. The next line, containing the world.sendMessage function call, is printing the number of seconds that have been counted up to that point. The message that we are sending is: \"Seconds Passed: \" + secondsPassed, which will print the string \"Seconds Passed: \" with the current value of the secondsPassed variable at the end.  In JavaScript you can concatenate, or chain together, different types of variables (such as numbers) seamlessly with strings. In many other languages, you can't use the \"+\" operator with different types like that.  Go back into your world, reload your script, and view the result:  Conditional (if/else) Spawn Entity Script  In this next example, we will write a script that spawns an entity every 10 seconds. If we are in the Overworld, a fox will be spawned. If we are in the Nether, a hoglin will be spawned. In any other dimension, a wolf will be spawned. Ready? Let's go!  A script like this will require us to use an if/else statement, use a few more variables, write a few more functions, and learn how to spawn entities.  Based on our description above of what we want our script to do, here is the skeleton of the code that we need to write, with some things written in English. To begin, replace your entire main.js with the following code:  JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  function mainTick() {   if (system.currentTick % 200 === 0) {     const playerDimension = getPlayerDimension();     const playerLocation = getPlayerLocation();     if (playerDimension !== undefined && playerLocation !== undefined) {       if (/* we are in the Overworld */) {         // spawn a fox       }       else if (/* we are in the Nether */) {         // spawn a hoglin       }       else {         // spawn a wolf       }     }   }   system.run(mainTick); }  system.run(mainTick);   Now, instead of printing a message every second, we will be executing this block of code every 10 seconds! Let's do a quick rundown of this code, and then let's convert it from English to JavaScript together. First, take a look inside the if statement that is checking for every 200th tick.  The first two lines are declaring variables called playerDimension and playerLocation that are being initialized to getPlayerDimension() and getPlayerLocation().  If Visual Studio is yelling at you about these function calls, have no fear. That is because these are functions that we have not defined yet, but will define in a little bit. Just know for now that this is how we are obtaining the player's dimension and the player's location (x, y, z coordinates).  You will notice that we used the keyword const to declare the playerDimension and playerLocation variables, instead of the keyword let. This is because we do not want the values inside these variables to be accidentally or intentionally changed later on in the code (const stands for \"constant\"). This helps keep our code robust, intentional, and less error prone. In our previous script, we wanted to reassign the secondsPassed variable every second, so we used the keyword let. In the case of our new script, we do not want playerDimension or playerLocation to be reassigned at all, so we use const.  In the if statement below, we are making sure that playerDimension and playerLocation are NOT undefined so that we can use them in our code. If you try to use something undefined, you will get errors! The \"!==\" operator means \"does not equal\", and the \"&&\" operator means \"and\". So we only run the code inside that if statement if \"playerDimension does not equal undefined and playerLocation does not equal undefined.\"  Inside that if statement, you may not recognize the /**/ and // characters. These denote a comment in the code, which is part of the JavaScript file that will be ignored. You can use comments to help make sense of confusing code by taking notes directly in the code. We are merely using them as placeholders that we will soon replace.  In this block of code, we first come across another if statement. This one is checking if we are in the Overworld. If that is true, then a fox will be spawned.  Next, we come across two statements we have not encountered before: else if, and after that, an else. In the previous script we wrote, we noticed that an if statement does not require an else if or an else to follow it; however, else if statements are useful when you want another action (spawning a hoglin) to be executed for a different case (us being in the Nether), and else statements are useful when you want to offer a default action (spawning a wolf) for every other case that is not mentioned in the if or else if statements (us being in any other than the Overworld and the Nether). Note that you can have as many else if statements that you want for as many cases as you may have.  Now, we will replace the English comments with code together!  First, we need a way to access the player's dimension (to check which dimension we're in) and the player's location (to know where to spawn the entity). We will do that by implementing the functions that we called above, getPlayerDimension() and getPlayerLocation().  Copy and paste these three functions above the mainTick function:  JavaScript Copy function getPlayer() {   const allPlayers = world.getAllPlayers();   if (allPlayers.length === 0) {     return undefined;   }    return allPlayers[0]; }  function getPlayerDimension() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.dimension; }  function getPlayerLocation() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.location; }   As you recall, the function mainTick does not have a return statement like these functions do. That is because mainTick is a function whose task does not need to return a result to the code. However, in these functions, the tasks are intended to give us specific information that we are requesting, such as the player's dimension and the player's location. Thus, wherever we call these functions, that information will be returned to us for us to use.  In the first function, getPlayer(), we attempt to obtain and return Player 1.  First, we call world.getAllPlayers() to get an array (which is a kind of list) of all of the players in the world. We store that array in a variable called allPlayers. If that array were empty, we would get errors if we tried to access a player from the array. So, we check that there are indeed players in that array by making sure that the length of the array of players is greater than zero. The if statement performs the check and if it comes back true that the array is empty, the getPlayer() function returns a status of undefined.  If the array is not empty, then the function returns the first player in the array, which is denoted as allPlayers[0].   Note  In most programming languages, \"0\" denotes the first item in an array, and you access the first item by putting \"[0]\" on the end of the array's name. You can access the second item by putting \"[1]\", the third item by putting \"[2]\", and so on. Always make sure to affirm that the array's length is what you expect before accessing items willy nilly!  In the next two functions, we use the getPlayer() function that we just created to get the player, store it in a variable called player, and then return the player's dimension and location properties. Just like before, we will need to assure that player is NOT undefined before accessing the player's properties, or we will get an error.  Next, let's add our checks that will tell us which dimension the player is in. To do this, we need to access the Dimension's ID property, to check whether it matches either \"minecraft:overworld\", \"minecraft:nether\", or anywhere else, like so:  JavaScript Copy   if (playerDimension.id === \"minecraft:overworld\") {       // spawn a fox    }    else if (playerDimension.id === \"minecraft:nether\") {        // spawn a hoglin    }    else {        // spawn a wolf    }    Now, let's use the spawnEntity function from the Dimension class to spawn these entities.  This function is a little different than the ones we've come across so far, because it takes in parameters.  A parameter in a function is a piece of data that you give to the function as input, that will affect its output value.  For example, the spawnEntity function takes in two arguments: the identifier of the entity you want to spawn, and the location where you want it to spawn. These input values affect the output because you are telling the function which entity to spawn and where. We must provide these parameters within the parentheses at the end of the function.  For the first parameter, identifier, we will provide \"minecraft:fox\", \"minecraft:hoglin\", or \"minecraft:wolf\".  For the second parameter, location, we will provide the player's location using the variable we made above, playerLocation.  Here are the completed if statements:  JavaScript Copy   if (playerDimension.id === \"minecraft:overworld\") {        playerDimension.spawnEntity(\"minecraft:fox\", playerLocation);    }    else if (playerDimension.id === \"minecraft:nether\") {        playerDimension.spawnEntity(\"minecraft:hoglin\", playerLocation);    }    else {        playerDimension.spawnEntity(\"minecraft:wolf\", playerLocation);   }   Now it is apparent why we store some values inside variables, such as playerDimension and playerLocation. This greatly helps with reuse of values and conciseness of code.  And that's it! We have implemented our script that spawns foxes in the Overworld, hoglins in the Nether, and wolves in every other dimension! (Spoiler alert: the only other dimension is the End).  Here is how your whole script should look by the end (no pun intended):  JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  function getPlayer() {   const allPlayers = world.getAllPlayers();   if (allPlayers.length === 0) {     return undefined;   }    return allPlayers[0]; }  function getPlayerDimension() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.dimension; }  function getPlayerLocation() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.location; }  function mainTick() {   if (system.currentTick % 200 === 0) {     const playerDimension = getPlayerDimension();     const playerLocation = getPlayerLocation();     if (playerDimension !== undefined && playerLocation !== undefined) {       if (playerDimension.id === \"minecraft:overworld\") {          playerDimension.spawnEntity(\"minecraft:fox\", playerLocation);        }        else if (playerDimension.id === \"minecraft:nether\") {          playerDimension.spawnEntity(\"minecraft:hoglin\", playerLocation);        }       else {         playerDimension.spawnEntity(\"minecraft:wolf\", playerLocation);       }     }   }   system.run(mainTick); }  system.run(mainTick);   Next, let's go back to the game, run /reload, and observe the magic! You will have to build portals to the other dimensions to test if the script works correctly in those dimensions, but I'll let you figure out that part on your own. The only advice I'll give is to do it in Creative mode, or else it'll take mighty long to test them out!  What to Learn Next  You can spend lots and lots of time learning all about JavaScript. There are free (and not-so-free) resources on the Internet where you can learn everything you want to know about JavaScript.  Here is another link to Microsoft's Beginner Series to: JavaScript tutorial. Note that all of these learnings accrue perfectly to Typescript as well!  To learn more about what we did in this tutorial, look into:  Variables (global and local) JavaScript data types like number, Boolean, float, string, array Classes and objects if, else if, and else statements import statement/modules functions  You can use what you learn about JavaScript to change these scripts and decide what happens in your Minecraft world!  Advanced Topics  When you're more comfortable with JavaScript, you can research the more advanced things you will need for Typescript and scripting in general:  npm ecosystem node.js TypeScript Gulp for and while loops Using more code files to organize your project Debugging Congratulations!!  You have graduated from Scripting 101! To continue building on your coding skills, please move on to the Build a Gameplay Experience with TypeScript tutorial!  There, you will download some tools to make your life much easier as a scripter and take your knowledge to the next level by learning how to implement a functioning game in TypeScript.  You will also learn how to take advantage of all of the goodness of TypeScript and the npm ecosystem like:  Intellisense / autocomplete (a game changer) Inline reference documentation for types (always good to have handy) Static typing, which helps prevent errors in the long run and makes it much easier to update to new versions of the API when you want to use new features (worth it) Easier debugging due to errors surfacing during compile time, as opposed to runtime (a real time saver)  These may just sound like abstract coding terms, but trust me, the benefits of going through our TypeScript setup will make your scripting experience go much more smoothly once you begin to expand your knowledge and write more complex scripts. Also, all of our samples are written in TypeScript, so you will have lots of examples to test out! Please give it a go once you feel you've gotten the basics down from this tutorial... you will not regret it!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptingintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Scripting in Minecraft 04/17/2025  \"Scripting\" is just another way of saying \"writing a list of instructions for the computer to follow to make it do what you want it to do.\"  You can use a script to control many things in your Minecraft world, including characteristics of the world; the behaviors of entities, blocks, and items; and even an entire game loop!  In this tutorial, we will write a few small scripts in the JavaScript programming language, which is used by the rest of the world to create web pages, apps, and more! Minecraft scripts can also be written in TypeScript, which is like a new and improved version of JavaScript. TypeScript is preferable to JavaScript because it provides better error reporting and more abilities than JavaScript. However, it does require more tooling to be installed. That's why, for this beginner tutorial, we will be using JavaScript to show you the simplest way to get a script up and running in Minecraft. You can learn how to set up a Minecraft TypeScript project in the Build a Gameplay Experience with TypeScript tutorial, which is highly recommended after completing this tutorial!  If you are new to coding in general, this tutorial should break down different elements of code enough for you to understand how to write a basic script. However, if anything seems too advanced or you are confused about something that is discussed in this tutorial, please reference this Beginner JavaScript Tutorial for more information.  Also, all of the concepts you will learn about here will be applicable to TypeScript as well (though it will have slightly different ways of writing things), so you should feel confident in moving on to the TypeScript tutorial after successfully completing this one.  Prerequisites  Before you begin, you should have gone through the Getting Started with Add-Ons tutorial and the Introduction to Behavior Packs tutorial.  Getting Started with Add-On Development Introduction To Behavior Packs  It should be clear to you how add-on folders must be structured, and what the required files in the behavior pack (such as manifest.json) should contain.  What You Need  Let's set up your computer. Here are the things you will need:  Minecraft: Bedrock Edition A Windows 10 (or higher) computer Keyboard and mouse Visual Studio Code (or another similar text editor) The Attack Cow sample behavior pack downloaded from the Minecraft samples GitHub repository.   Note  If you have never downloaded and used a sample behavior pack, here's how:  Go to https://github.com/microsoft/minecraft-samples/tree/main, click the green Code button, and choose \"Download ZIP\" from the drop-down menu. Open your Downloads folder and extract the minecraft-samples-main zipped folder contents. Inside the extracted minecraft-samples-main folder, find the behavior_pack_sample folder and open it. Look at the README.md file inside and follow the instructions to deploy the behavior pack. Displaying a Message using Scripting  Our first goal of this tutorial is to make Minecraft display a little message without the player having to lift a finger. It's just a small task, but it will demonstrate that we can make things happen automatically in Minecraft using a script.  To get there, we are going to start with the Attack Cow behavior pack, add the files we need for scripting, and then run the script in a Minecraft world.  Setup and Test the Attack Cow Behavior Pack If you haven't already followed this step from the README, copy the sample_behavior_pack into the development_behavior_packs folder in your com.mojang folder. Launch Minecraft and create a survival world with cheats on and the Attack Cow behavior pack activated in it. It needs to be a survival world because the cow's attack behavior won't work in a creative world, and cheats should be on so you can summon a cow. Summon a cow using the \"/summon\" command and make sure it attacks you, as expected. Now we know all systems are go! Save & Quit the world to return to the Minecraft Main Menu screen. Add a Script to the Behavior Pack Minimize Minecraft and open your sample_behavior_pack in Visual Studio Code. Open and view the manifest.json file.  In the manifest file, we need to add a new module (our script) as well as a new dependency (@minecraft/server, a module that contains information that we will use in writing our script). This tells the game that our script exists and that it should be processed. So, replace the contents of the manifest.json file with this: JSON Copy {     \"format_version\": 2,     \"header\": {       \"description\": \"My scripting behavior pack Add-On!\",       \"name\": \"My Behavior Pack\",       \"uuid\":\"PUT A NEW UUID HERE\",       \"version\": [1, 0, 0],       \"min_engine_version\": [1, 20, 30]     },     \"modules\":       [         {           \"description\": \"My Second Add-On!\",             \"type\": \"data\",             \"uuid\": \"PUT A NEW UUID HERE\",             \"version\": [1, 0, 0]         },         {           \"description\": \"Test Scripting\",             \"type\": \"script\",             \"uuid\": \"PUT A NEW UUID HERE\",             \"version\": [1, 0, 0],             \"entry\": \"scripts/main.js\"         }       ],     \"dependencies\": [       {         \"module_name\":\"@minecraft/server\",         \"version\":\"1.5.0\"       }    ]   }  Replace the three instances of PUT A NEW UUID HERE with new UUIDs, just like you did in the Introduction to Behavior Packs tutorial. Save your edited manifest.json file. In the behavior_pack_sample folder, create a folder and name it scripts and open it. Create a file inside there and name it main.js. Copy this code into main.js: JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  function mainTick() {   if (system.currentTick === 400) {     world.sendMessage(\"All systems GO!\");   }   system.run(mainTick); }  system.run(mainTick);  Save main.js.  When you're done, it should look like this:  Go back to Minecraft, create a world with the behavior pack activated. When you go into the world, your test message will appear after about 20 seconds.  That proves your script is working. Neat!  Save & Quit the world and go back to your main.js file.  For this particular script that we just tried, you must create a new world if you want to update the message in \"world.sendMessage\" and check that it has updated.  Hot reloading (using the /reload command) will NOT cause an updated message to display if the original message was displayed before your update, because the 400th tick (meaning the 20th second of the world existing) has already passed, and this line of the code specifically wants that particular tick:  if (system.currentTick === 400) {  Don't worry, we'll cover /reload later in this tutorial.  Even if you leave the world and come back, the world starts at the tick where it left off, so your update will not be apparent using that method either. In this case where we are executing code on a specific tick, you must create a new world. But this example should teach you that you should be very careful and intentional when relying on a specific tick to execute logic because it will only execute once, at a specific time.  We will teach you other patterns below that allow you to edit your code and refresh the game using hot reloading (making it much easier and less clunky to make updates).  JavaScript Code Explanation  Here's what's happening in the code above...  The import part at the top of the script is telling Minecraft which pieces of the game you want to access in your script. After the import statement, contained in curly braces (\"{ }\"), is a list of classes that we want to access from the Minecraft game. A class describes an object in the game, contains information about it, and allows you to perform actions on it.  For example, we imported system, which allowed us to access its property currentTick and use it in our code.  We also imported world, which allowed us access to its function sendMessage, which we used in our code to send a message to the screen.  Some other examples of classes are Player, Entity, Block, and ItemStack, but there are WAY more that you can read about in the @minecraft/server Module documentation.  The from part tells Minecraft which module your requested classes are defined in. A module stores a bunch of classes and APIs that you can use. There are several modules in Minecraft, but the most important one that contains most of the basic classes and APIs is \"@minecraft/server\".  The function part defines a function, which is a block of code that completes a specific task. Eventually, you will have many functions that do different tasks, whose names are descriptive of what they do (we will add more functions in a later section of this tutorial).  This function is named mainTick because we are using it to define the main game loop. A game loop is a sequence of processes (such as updating entity movement, detecting player input and acting on it, or updating the weather) that run over and over again to continuously update the game. A tick describes the time it takes to run the game loop once, which in Minecraft is 1/20th of a second (so 1 second = 20 ticks). The word \"tick\" can also describe one run through of the game loop, which is why our function is described as the \"main tick.\"  The system.run function allows you to provide the name of a function (mainTick in our case) to run during that game tick. This line at the bottom of the file...  system.run(mainTick);  ... calls our function mainTick for the first time. If we did not add this line, the mainTick function would be defined but not called, so it would not run and nothing would happen. We also have the same line at the end of the mainTick function itself. This is so that mainTick will run again the next tick when this tick is finished. This causes mainTick to run once per tick, thus giving us our game loop.  The contents of the mainTick function start with this line:  if (system.currentTick === 400)  This statement is checking if we are currently on the 400th tick. If we are on the 400th tick, then this statement is true and the code inside the if statement's curly braces will be executed:  world.sendMessage(\"All systems GO!\");  Otherwise, the code inside the if statement's curly braces will be skipped. Lastly, despite whether the if statement were true or false, system.run(mainTick) will be called again, to check again the next tick.  As mentioned earlier, 20 ticks equals 1 second in Minecraft. If your computer takes longer than 20 seconds to load the world, then this message will not get displayed unless you change the currentTick value from 400 to something greater. This is something to keep in mind as a creator! You do not want any world setup code to run before your world is even loaded!  Anyway, when we load our world with this script in it, that statement is false for a while.  It's like when you're hungry but it's not quite lunchtime, so you keep looking at the clock and asking \"Is it lunchtime yet?\" Well, it's not lunchtime yet, so the answer is \"No. Check again.\" So, 1/20th of a second later, you check again. \"Is it lunchtime yet?\" \"No. Check again.\" \"Is it lunchtime yet?\" \"No. Check again.\" This continues looping until it finally IS lunchtime, so you get to go have lunch! Yay!  What is Hot Reloading?  As alluded to previously, hot reloading is a super cool feature of scripting in Minecraft. Instead of having to close the game and reopen it in order to reload your script, hot reloading allows you to reload your script while you are inside your world and the game is still running, and your game will be updated to use the latest version of your script. You will find that this will drastically reduce your game development time because you will be able to test your changes almost instantly.  Let's try it! But first, we'll need to make one change to our current code to make it work with hot reloading.  Open main.js. Change this line of code:  if (system.currentTick === 400)  ...to this, instead:  if (system.currentTick % 200 === 0)  The \"%\" is known as the modulo operator, and it is used to obtain the remainder of a division between two integers.  Also, we're changing the 400 to 200 so you have a shorter wait time.  So what we are now saying is \"if the remainder of the current tick divided by 200 equals 0, then execute this code.\" In other words, \"if the current tick is evenly divisible by 200, then execute this code.\" So this statement will now be true every 200 ticks, instead of being true solely on the 400th tick.  Due to this change, our line of code within the if statement's brackets:  world.sendMessage(\"All systems GO!\");  ... will run every 10 seconds, so the message \"All systems GO!\" will be displayed on the screen every 10 seconds.  First, we will test if our change works correctly, then we will use it to demonstrate how to use hot reloading.  Save main.js, and go back into your world that has your behavior pack applied. The message should appear every 10 seconds as expected, so something like this will be displayed in your chat and commands window:  Now that we know our program works, let's use it to learn how hot reloading works.  DO NOT SAVE AND QUIT TO THE MAIN MENU. Keep your Minecraft world open and running in the background (you might want to switch to creative mode if you are afraid of monsters creeping up on you!). Switch back to main.js in Visual Studio Code. Change your printed message to something else, such as \"My new message, ha ha!\" Save main.js, and switch back to your Minecraft window, which should still have your world open and running. Run the command /reload:  A message will appear stating that your function and script files have been reloaded, followed by your new message:  With that powerful tool now in your toolbox, let's write a couple more cool scripts!  Using a Variable to Count Seconds  Next, we will implement a simple script that counts the seconds that pass from the beginning of world load.  Replace your entire main.js file with the following code: JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  let secondsPassed = 0;  function mainTick() {   if (system.currentTick % 20 === 0) {     secondsPassed += 1;     world.sendMessage(\"Seconds Passed: \" + secondsPassed);   }   system.run(mainTick); }  system.run(mainTick);   The first thing to notice here is the line that says let secondsPassed = 0;. Here, we are declaring and initializing a variable.  A variable is a container for a value that can be used, reused, and changed. The let part tells the computer that we are creating (\"declaring\") a variable; the secondsPassed part is the descriptive name that we are giving the variable; and the = 0 part is putting the value of 0 into the secondsPassed container (or \"initializing\" it to 0). Next time we reference secondsPassed, it will be as if we are referencing the number 0.  Variables can be used to store all different types of values, not just numbers. They can also store things like Booleans (true/false), floating point numbers (decimal numbers), strings (text contained in \"quotes\"), arrays (lists of things), and classes (objects).  Our variable, secondsPassed, is declared in the main part of the script (not inside a function), so it is referred to as a global variable. Global variables can be used/changed inside any functions or any part of your script (within the same file).  You can also declare a variable inside a function, inside an if/else block, or inside a for loop, and those are referred to as local variables, because they are local to the block within which they are defined (they do not exist outside of that block of code).  The next thing to notice here is that inside the if statement, we changed the tick we are checking to 20. Remember that 20 ticks equals 1 second, so we are now running this block of code every second. This is so that our message can report the number of seconds that have passed, each second.  Inside the if statement, notice the line that says secondsPassed += 1;. This line has the same meaning as:  secondsPassed = secondsPassed + 1;  which gets translated to:  secondsPassed = 0 + 1;  and can be simplified to:  secondsPassed = 1;  So in summary, this line adds 1 to the current value of secondsPassed. The next time this line is run, secondsPassed will equal 1, and 1 more will be added to it, and then it will be 2, and so on. The next line, containing the world.sendMessage function call, is printing the number of seconds that have been counted up to that point. The message that we are sending is: \"Seconds Passed: \" + secondsPassed, which will print the string \"Seconds Passed: \" with the current value of the secondsPassed variable at the end.  In JavaScript you can concatenate, or chain together, different types of variables (such as numbers) seamlessly with strings. In many other languages, you can't use the \"+\" operator with different types like that.  Go back into your world, reload your script, and view the result:  Conditional (if/else) Spawn Entity Script  In this next example, we will write a script that spawns an entity every 10 seconds. If we are in the Overworld, a fox will be spawned. If we are in the Nether, a hoglin will be spawned. In any other dimension, a wolf will be spawned. Ready? Let's go!  A script like this will require us to use an if/else statement, use a few more variables, write a few more functions, and learn how to spawn entities.  Based on our description above of what we want our script to do, here is the skeleton of the code that we need to write, with some things written in English. To begin, replace your entire main.js with the following code:  JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  function mainTick() {   if (system.currentTick % 200 === 0) {     const playerDimension = getPlayerDimension();     const playerLocation = getPlayerLocation();     if (playerDimension !== undefined && playerLocation !== undefined) {       if (/* we are in the Overworld */) {         // spawn a fox       }       else if (/* we are in the Nether */) {         // spawn a hoglin       }       else {         // spawn a wolf       }     }   }   system.run(mainTick); }  system.run(mainTick);   Now, instead of printing a message every second, we will be executing this block of code every 10 seconds! Let's do a quick rundown of this code, and then let's convert it from English to JavaScript together. First, take a look inside the if statement that is checking for every 200th tick.  The first two lines are declaring variables called playerDimension and playerLocation that are being initialized to getPlayerDimension() and getPlayerLocation().  If Visual Studio is yelling at you about these function calls, have no fear. That is because these are functions that we have not defined yet, but will define in a little bit. Just know for now that this is how we are obtaining the player's dimension and the player's location (x, y, z coordinates).  You will notice that we used the keyword const to declare the playerDimension and playerLocation variables, instead of the keyword let. This is because we do not want the values inside these variables to be accidentally or intentionally changed later on in the code (const stands for \"constant\"). This helps keep our code robust, intentional, and less error prone. In our previous script, we wanted to reassign the secondsPassed variable every second, so we used the keyword let. In the case of our new script, we do not want playerDimension or playerLocation to be reassigned at all, so we use const.  In the if statement below, we are making sure that playerDimension and playerLocation are NOT undefined so that we can use them in our code. If you try to use something undefined, you will get errors! The \"!==\" operator means \"does not equal\", and the \"&&\" operator means \"and\". So we only run the code inside that if statement if \"playerDimension does not equal undefined and playerLocation does not equal undefined.\"  Inside that if statement, you may not recognize the /**/ and // characters. These denote a comment in the code, which is part of the JavaScript file that will be ignored. You can use comments to help make sense of confusing code by taking notes directly in the code. We are merely using them as placeholders that we will soon replace.  In this block of code, we first come across another if statement. This one is checking if we are in the Overworld. If that is true, then a fox will be spawned.  Next, we come across two statements we have not encountered before: else if, and after that, an else. In the previous script we wrote, we noticed that an if statement does not require an else if or an else to follow it; however, else if statements are useful when you want another action (spawning a hoglin) to be executed for a different case (us being in the Nether), and else statements are useful when you want to offer a default action (spawning a wolf) for every other case that is not mentioned in the if or else if statements (us being in any other than the Overworld and the Nether). Note that you can have as many else if statements that you want for as many cases as you may have.  Now, we will replace the English comments with code together!  First, we need a way to access the player's dimension (to check which dimension we're in) and the player's location (to know where to spawn the entity). We will do that by implementing the functions that we called above, getPlayerDimension() and getPlayerLocation().  Copy and paste these three functions above the mainTick function:  JavaScript Copy function getPlayer() {   const allPlayers = world.getAllPlayers();   if (allPlayers.length === 0) {     return undefined;   }    return allPlayers[0]; }  function getPlayerDimension() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.dimension; }  function getPlayerLocation() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.location; }   As you recall, the function mainTick does not have a return statement like these functions do. That is because mainTick is a function whose task does not need to return a result to the code. However, in these functions, the tasks are intended to give us specific information that we are requesting, such as the player's dimension and the player's location. Thus, wherever we call these functions, that information will be returned to us for us to use.  In the first function, getPlayer(), we attempt to obtain and return Player 1.  First, we call world.getAllPlayers() to get an array (which is a kind of list) of all of the players in the world. We store that array in a variable called allPlayers. If that array were empty, we would get errors if we tried to access a player from the array. So, we check that there are indeed players in that array by making sure that the length of the array of players is greater than zero. The if statement performs the check and if it comes back true that the array is empty, the getPlayer() function returns a status of undefined.  If the array is not empty, then the function returns the first player in the array, which is denoted as allPlayers[0].   Note  In most programming languages, \"0\" denotes the first item in an array, and you access the first item by putting \"[0]\" on the end of the array's name. You can access the second item by putting \"[1]\", the third item by putting \"[2]\", and so on. Always make sure to affirm that the array's length is what you expect before accessing items willy nilly!  In the next two functions, we use the getPlayer() function that we just created to get the player, store it in a variable called player, and then return the player's dimension and location properties. Just like before, we will need to assure that player is NOT undefined before accessing the player's properties, or we will get an error.  Next, let's add our checks that will tell us which dimension the player is in. To do this, we need to access the Dimension's ID property, to check whether it matches either \"minecraft:overworld\", \"minecraft:nether\", or anywhere else, like so:  JavaScript Copy   if (playerDimension.id === \"minecraft:overworld\") {       // spawn a fox    }    else if (playerDimension.id === \"minecraft:nether\") {        // spawn a hoglin    }    else {        // spawn a wolf    }    Now, let's use the spawnEntity function from the Dimension class to spawn these entities.  This function is a little different than the ones we've come across so far, because it takes in parameters.  A parameter in a function is a piece of data that you give to the function as input, that will affect its output value.  For example, the spawnEntity function takes in two arguments: the identifier of the entity you want to spawn, and the location where you want it to spawn. These input values affect the output because you are telling the function which entity to spawn and where. We must provide these parameters within the parentheses at the end of the function.  For the first parameter, identifier, we will provide \"minecraft:fox\", \"minecraft:hoglin\", or \"minecraft:wolf\".  For the second parameter, location, we will provide the player's location using the variable we made above, playerLocation.  Here are the completed if statements:  JavaScript Copy   if (playerDimension.id === \"minecraft:overworld\") {        playerDimension.spawnEntity(\"minecraft:fox\", playerLocation);    }    else if (playerDimension.id === \"minecraft:nether\") {        playerDimension.spawnEntity(\"minecraft:hoglin\", playerLocation);    }    else {        playerDimension.spawnEntity(\"minecraft:wolf\", playerLocation);   }   Now it is apparent why we store some values inside variables, such as playerDimension and playerLocation. This greatly helps with reuse of values and conciseness of code.  And that's it! We have implemented our script that spawns foxes in the Overworld, hoglins in the Nether, and wolves in every other dimension! (Spoiler alert: the only other dimension is the End).  Here is how your whole script should look by the end (no pun intended):  JavaScript Copy import {     world,     system   } from \"@minecraft/server\";  function getPlayer() {   const allPlayers = world.getAllPlayers();   if (allPlayers.length === 0) {     return undefined;   }    return allPlayers[0]; }  function getPlayerDimension() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.dimension; }  function getPlayerLocation() {   const player = getPlayer();   if (player === undefined) {     return undefined;   }   return player.location; }  function mainTick() {   if (system.currentTick % 200 === 0) {     const playerDimension = getPlayerDimension();     const playerLocation = getPlayerLocation();     if (playerDimension !== undefined && playerLocation !== undefined) {       if (playerDimension.id === \"minecraft:overworld\") {          playerDimension.spawnEntity(\"minecraft:fox\", playerLocation);        }        else if (playerDimension.id === \"minecraft:nether\") {          playerDimension.spawnEntity(\"minecraft:hoglin\", playerLocation);        }       else {         playerDimension.spawnEntity(\"minecraft:wolf\", playerLocation);       }     }   }   system.run(mainTick); }  system.run(mainTick);   Next, let's go back to the game, run /reload, and observe the magic! You will have to build portals to the other dimensions to test if the script works correctly in those dimensions, but I'll let you figure out that part on your own. The only advice I'll give is to do it in Creative mode, or else it'll take mighty long to test them out!  What to Learn Next  You can spend lots and lots of time learning all about JavaScript. There are free (and not-so-free) resources on the Internet where you can learn everything you want to know about JavaScript.  Here is another link to Microsoft's Beginner Series to: JavaScript tutorial. Note that all of these learnings accrue perfectly to Typescript as well!  To learn more about what we did in this tutorial, look into:  Variables (global and local) JavaScript data types like number, Boolean, float, string, array Classes and objects if, else if, and else statements import statement/modules functions  You can use what you learn about JavaScript to change these scripts and decide what happens in your Minecraft world!  Advanced Topics  When you're more comfortable with JavaScript, you can research the more advanced things you will need for Typescript and scripting in general:  npm ecosystem node.js TypeScript Gulp for and while loops Using more code files to organize your project Debugging Congratulations!!  You have graduated from Scripting 101! To continue building on your coding skills, please move on to the Build a Gameplay Experience with TypeScript tutorial!  There, you will download some tools to make your life much easier as a scripter and take your knowledge to the next level by learning how to implement a functioning game in TypeScript.  You will also learn how to take advantage of all of the goodness of TypeScript and the npm ecosystem like:  Intellisense / autocomplete (a game changer) Inline reference documentation for types (always good to have handy) Static typing, which helps prevent errors in the long run and makes it much easier to update to new versions of the API when you want to use new features (worth it) Easier debugging due to errors surfacing during compile time, as opposed to runtime (a real time saver)  These may just sound like abstract coding terms, but trust me, the benefits of going through our TypeScript setup will make your scripting experience go much more smoothly once you begin to expand your knowledge and write more complex scripts. Also, all of our samples are written in TypeScript, so you will have lots of examples to test out! Please give it a go once you feel you've gotten the basics down from this tutorial... you will not regret it!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scoreboardintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Scoreboards 09/27/2023  Scoreboards can store and display information about your world. You can use commands in the chat, command blocks, functions, or a combination of these features to set up and interact with scoreboards.  In this tutorial you will learn the following:  The parts of a scoreboard and how to add information to them. The /scoreboard command syntax. How to use a scoreboard. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Parts of a Scoreboard  In this example, you will create a basic scoreboard, display it on the screen, and make it show a few player names and values.  In a world with cheats enabled, open the chat window and enter /scoreboard with a space after the command. The chat window will display the available scoreboard commands.  The two main things to notice here are the subcategories for a scoreboard: objectives and players. An objective is something in the game you want to track, such as how many times a sheep is sheared or a potato is planted. You create objectives and give them an internal name and a name to display on the screen. In this example, we are going to create an objective to track the number of sheep that have been sheared. Then, we will add players and some made-up scores that say how many times each player accomplished the objective.  Because the objectives we are tracking do not already exist in the game, you will give them the type called \"dummy.\"  In chat, enter /scoreboard objectives add shearedSheep dummy \"Top Shearers\". You should get the message \"Added new objective 'shearedSheep' successfully.\"  Your objective exists, but we can't see it until we display it on the screen. Your options are to display the information in a sidebar, on the pause screen, or below the player's name.  Enter /scoreboard objectives setdisplay sidebar shearedSheep. You should now see a sidebar on the screen with the header Top Shearers.  Now that our objective exists, add a player named \"SomeRandomPlayer\" and give them a score of 0. Enter /scoreboard players set SomeRandomPlayer shearedSheep 0. The player's name will be displayed on the sidebar under Top Shearers.  Add yourself and give yourself a score of 50: /scoreboard players set @s shearedSheep 50. Your own name will be displayed on the list.  Scoreboard Objectives Commands  The available scoreboard objective commands can be listed using the chat's auto-complete feature.  Copy /scoreboard objectives   add  The first step to using a scoreboard is to add an objective for the game to track. Your objective will need one name for the game to use and another one to display to the players.  Copy /scoreboard objectives add <objective: string> dummy [displayName: string]  list  This command returns a list of all of the objectives in the world.  Copy /scoreboard objectives list  remove  To remove an objective from the game use:  Copy /scoreboard objective remove <objective: string>  setdisplay  You can modify how scoreboard objectives are displayed in the game. There are three slots that an objective can be displayed in: belowName, list, and sidebar. Specifying a slot without an objective name clears that display slot.  Use the list option to see scoreboard information listed on the pause screen. You can specify whether the players are ranked in ascending or descending order, according to score.  Copy /scoreboard objectives setdisplay list [objective: string] [ascending|descending]   Use the sidebar option to display objective information on the main screen. You can specify whether the players are ranked in ascending or descending order, according to score.  Copy /scoreboard objectives setdisplay sidebar [objective: string] [ascending|descending]   Use the belowname option to display objective information below player names in the world.  Copy /scoreboard objectives setdisplay belowname [objective: string]  Scoreboard Players Commands  The following scoreboard player commands affect a player's score value. The arguments can be listed using the chat's auto-complete feature.  set  The set operation directly sets a player's score to a value. The players don't have to be active in the world at the time or even be real players at all. The objective must already exist and you have to give them a score or you get an error.  Copy /scoreboard players set <player: target> <objective: string> <count: int>  add  You can use the add operation to add points to a player's score.  Copy /scoreboard players add <player: target> <objective: string> <count: int>  remove  This remove operation is used to remove points from the player's score.  Copy /scoreboard players remove <player: target> <objective: string> <count: int>   If you're actually trying to remove a player from a scoreboard, use the reset command (as explained below).  list  To get a list of all of the players in a world (including any fake ones you created), enter:  Copy /scoreboard players list   Use this command with the name of a player to get a list of that player's tracked objectives.  Copy /scoreboard players list [playername: target]  operation  You can perform mathematical operations to calculate and assign scores.  Copy /scoreboard players operation <TargetPlayer> <TargetObjective> <operation> <SourcePlayer> <SourceObjective>   Each operation uses the scores for two players. The players can be from two different objectives, which is why you have to specify the objective for each player.  For each operation, the score for SourcePlayer is used to get a result, and the result is returned as a new score for TargetPlayer. If that isn't super clear, here is a whole tutorial to show you how operations work: Scoreboard Operations Tutorial.  %= Modulo - Divides the first score by the second score and returns the remainder.  *= Multiplication - Returns the product of the scores after multiplying them.  += Addition - Returns the sum of the scores.  -= Subtraction - Returns the value you get when you subtract the second score from the first.  /= Division - Returns the number you get when you divide the first score by the second score. The returned value is rounded down.  < Compare, Less Than - If the second score is lower than the first score, then the first score is replaced with that lower score.  = Assign - Assigns the second score's value to the first score.  > Compare, Greater Than - If the second score is higher than the first score, then the first score is replaced with that higher score.  >< Swap Values - The scores are given each other's values. This is the only operation to affect the source score.  random  Use this to give a player a random score within a certain range. The numbers you give for the minimum and maximum are included in the list of possible scores.  Copy /scoreboard players random <player: target> <objective: string> <min: int> <max: int>   For example, if you want to assign Steve a random score of 1, 2, 3 or 4 for the shearedSheep objective, you would use:  Copy /scoreboard players random Steve shearedSheep 1 4   If you try to use this command with the \"all players\" or '@a' selector, only real players are selected and given random scores - any players you created by giving them a name will have to be given a random score individually.  reset  The reset operation removes a player from all objectives, resetting their value. The objective argument is optional, and will reset a player only in that objective.  Copy /scoreboard players reset <player: target> [objective: string]  test  You can test whether a player's score is within a specified range. You may insert the wild card (*) instead of a number to include the smallest possible value, or the largest possible value.  Copy /scoreboard players test <player: target> <objective: string> [min: int] [max: int]   You will get either a true or false message after running the command. The range of test values is inclusive, which means that if the score you're testing is the same as either the min or max value, you will get a true message.  What's Next?  Now that you have learned more about scoreboards, you could learn more about scoreboard operations or create a Complete the Monument challenge.  Scoreboard Operations Tutorial Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scoreboardintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Scoreboards 09/27/2023  Scoreboards can store and display information about your world. You can use commands in the chat, command blocks, functions, or a combination of these features to set up and interact with scoreboards.  In this tutorial you will learn the following:  The parts of a scoreboard and how to add information to them. The /scoreboard command syntax. How to use a scoreboard. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Parts of a Scoreboard  In this example, you will create a basic scoreboard, display it on the screen, and make it show a few player names and values.  In a world with cheats enabled, open the chat window and enter /scoreboard with a space after the command. The chat window will display the available scoreboard commands.  The two main things to notice here are the subcategories for a scoreboard: objectives and players. An objective is something in the game you want to track, such as how many times a sheep is sheared or a potato is planted. You create objectives and give them an internal name and a name to display on the screen. In this example, we are going to create an objective to track the number of sheep that have been sheared. Then, we will add players and some made-up scores that say how many times each player accomplished the objective.  Because the objectives we are tracking do not already exist in the game, you will give them the type called \"dummy.\"  In chat, enter /scoreboard objectives add shearedSheep dummy \"Top Shearers\". You should get the message \"Added new objective 'shearedSheep' successfully.\"  Your objective exists, but we can't see it until we display it on the screen. Your options are to display the information in a sidebar, on the pause screen, or below the player's name.  Enter /scoreboard objectives setdisplay sidebar shearedSheep. You should now see a sidebar on the screen with the header Top Shearers.  Now that our objective exists, add a player named \"SomeRandomPlayer\" and give them a score of 0. Enter /scoreboard players set SomeRandomPlayer shearedSheep 0. The player's name will be displayed on the sidebar under Top Shearers.  Add yourself and give yourself a score of 50: /scoreboard players set @s shearedSheep 50. Your own name will be displayed on the list.  Scoreboard Objectives Commands  The available scoreboard objective commands can be listed using the chat's auto-complete feature.  Copy /scoreboard objectives   add  The first step to using a scoreboard is to add an objective for the game to track. Your objective will need one name for the game to use and another one to display to the players.  Copy /scoreboard objectives add <objective: string> dummy [displayName: string]  list  This command returns a list of all of the objectives in the world.  Copy /scoreboard objectives list  remove  To remove an objective from the game use:  Copy /scoreboard objective remove <objective: string>  setdisplay  You can modify how scoreboard objectives are displayed in the game. There are three slots that an objective can be displayed in: belowName, list, and sidebar. Specifying a slot without an objective name clears that display slot.  Use the list option to see scoreboard information listed on the pause screen. You can specify whether the players are ranked in ascending or descending order, according to score.  Copy /scoreboard objectives setdisplay list [objective: string] [ascending|descending]   Use the sidebar option to display objective information on the main screen. You can specify whether the players are ranked in ascending or descending order, according to score.  Copy /scoreboard objectives setdisplay sidebar [objective: string] [ascending|descending]   Use the belowname option to display objective information below player names in the world.  Copy /scoreboard objectives setdisplay belowname [objective: string]  Scoreboard Players Commands  The following scoreboard player commands affect a player's score value. The arguments can be listed using the chat's auto-complete feature.  set  The set operation directly sets a player's score to a value. The players don't have to be active in the world at the time or even be real players at all. The objective must already exist and you have to give them a score or you get an error.  Copy /scoreboard players set <player: target> <objective: string> <count: int>  add  You can use the add operation to add points to a player's score.  Copy /scoreboard players add <player: target> <objective: string> <count: int>  remove  This remove operation is used to remove points from the player's score.  Copy /scoreboard players remove <player: target> <objective: string> <count: int>   If you're actually trying to remove a player from a scoreboard, use the reset command (as explained below).  list  To get a list of all of the players in a world (including any fake ones you created), enter:  Copy /scoreboard players list   Use this command with the name of a player to get a list of that player's tracked objectives.  Copy /scoreboard players list [playername: target]  operation  You can perform mathematical operations to calculate and assign scores.  Copy /scoreboard players operation <TargetPlayer> <TargetObjective> <operation> <SourcePlayer> <SourceObjective>   Each operation uses the scores for two players. The players can be from two different objectives, which is why you have to specify the objective for each player.  For each operation, the score for SourcePlayer is used to get a result, and the result is returned as a new score for TargetPlayer. If that isn't super clear, here is a whole tutorial to show you how operations work: Scoreboard Operations Tutorial.  %= Modulo - Divides the first score by the second score and returns the remainder.  *= Multiplication - Returns the product of the scores after multiplying them.  += Addition - Returns the sum of the scores.  -= Subtraction - Returns the value you get when you subtract the second score from the first.  /= Division - Returns the number you get when you divide the first score by the second score. The returned value is rounded down.  < Compare, Less Than - If the second score is lower than the first score, then the first score is replaced with that lower score.  = Assign - Assigns the second score's value to the first score.  > Compare, Greater Than - If the second score is higher than the first score, then the first score is replaced with that higher score.  >< Swap Values - The scores are given each other's values. This is the only operation to affect the source score.  random  Use this to give a player a random score within a certain range. The numbers you give for the minimum and maximum are included in the list of possible scores.  Copy /scoreboard players random <player: target> <objective: string> <min: int> <max: int>   For example, if you want to assign Steve a random score of 1, 2, 3 or 4 for the shearedSheep objective, you would use:  Copy /scoreboard players random Steve shearedSheep 1 4   If you try to use this command with the \"all players\" or '@a' selector, only real players are selected and given random scores - any players you created by giving them a name will have to be given a random score individually.  reset  The reset operation removes a player from all objectives, resetting their value. The objective argument is optional, and will reset a player only in that objective.  Copy /scoreboard players reset <player: target> [objective: string]  test  You can test whether a player's score is within a specified range. You may insert the wild card (*) instead of a number to include the smallest possible value, or the largest possible value.  Copy /scoreboard players test <player: target> <objective: string> [min: int] [max: int]   You will get either a true or false message after running the command. The range of test values is inclusive, which means that if the score you're testing is the same as either the min or max value, you will get a true message.  What's Next?  Now that you have learned more about scoreboards, you could learn more about scoreboard operations or create a Complete the Monument challenge.  Scoreboard Operations Tutorial Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scoreboardoperationstutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Working with Scoreboard Operations 09/21/2023  The purpose of this tutorial is to show you how to use each of the scoreboard player operations.  The concept is to create one objective with six players to represent digits 0, 1, 2, 3, 5, and 10, and another objective to hold two players whose scores will be changed when you do the operations.  Numbers: 0, 1, 2, 3, 5, 10  Friends: Alex, Toast  Setup  Start by creating two scoreboard objectives called \"Numbers\" and \"Friends.\"  Copy /scoreboard objectives add Numbers dummy Numbers /scoreboard objectives add Friends dummy Friends   Display the Numbers objective with the list option and display the Friends objective with the sidebar option.  Copy /scoreboard objectives setdisplay list Numbers  Copy /scoreboard objectives setdisplay sidebar Friends   To the objective named Numbers, add players \"Zero\", \"One\", \"Two\", \"Three\", \"Five\", and \"Ten\" and give each one the same number of points as their name.  Copy /scoreboard players add One Numbers 1 /scoreboard players add Two Numbers 2 . . . /scoreboard players add Ten Numbers 10    Note  After you add a player, when you go back into the chat screen to add another, you can press the up arrow on your keyboard to scroll through previous commands and just change the player name and score value. It saves a little bit of typing.  Add players named \"Alex\" and \"Toast\" to the Friends objective and give each of them a score of 4.  Copy /scoreboard players add Alex Friends 4 /scoreboard players add Toast Friends 4   Let's Operate 1. = Assign  The current value for Alex's score is 4. Use the = operator to assign the value of player Ten's score, which is 10.  Copy /scoreboard players operation Alex Friends = Ten Numbers   Result: Alex now has a score of 10.  2. >< Swap Values  One of the ways to give a player a particular score is to swap scores between two players.  Copy /scoreboard players operation Alex Friends >< Toast Friends   Result: Alex has a score of 4, Toast has a score of 10.  3. *= Multiply  Multiply Toast's score of 10 times 3.  Copy /scoreboard players operation Toast Friends *= Three Numbers   Result: Toast has 30 points.  4. += Add  Add Toast's score to Alex's score.  Copy /scoreboard players operation Alex Friends += Toast Friends   Result: Alex has 34 points. Toast's score is unaffected so it stays at 30.  5. -= Subtract  Subtract 5 from Toast's score.  Copy /scoreboard players operation Toast Friends -= Five Numbers   Result: Toast has 25 points.  6. /= Divide  Simple - No remainder  Divide Toast's score by 5.  Copy /scoreboard players operation Toast Friends /= Five Numbers   More Complicated - Has remainder  Divide Alex's score by 5.  Copy /scoreboard players operation Alex Friends /= Five Numbers   Result: Alex now has a score of 6. The remainder is ignored.  What if I divide by zero?  Divide Toast's score by 0.  Copy /scoreboard players operation Toast Friends /= Zero Numbers   Result: Nothing happens. (Whew!)  7. > Compare - Greater Than  Compare Toast's score to Alex's score. Toast's score will be set to whichever score is higher.  Copy /scoreboard players operation Toast Friends > Alex Friends   Result: Toast's score was set to 6, Alex's score is not affected.  If you try the operation again with both scores being equal, you get the same message.  8. < Compare - Less Than  Compare Toast's score to Three's score of 3. Toast's score will be set to whichever score is lower.  Copy /scoreboard players operation Toast Friends < Three Numbers   Result: Toast's score is set to 3.  9. %= Modulo  This operation takes Alex's current score, divides it by 2, and then puts the remainder as Alex's new score.  Copy /scoreboard players operation Alex Friends %= Two Numbers   Result: Alex's score is set to 0.   What's Next?  Now that you have learned about scoreboard operations, you could learn more about command blocks and functions and try combining it all together.  Command Blocks Introduction to Functions  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scoreboardoperationstutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Working with Scoreboard Operations 09/21/2023  The purpose of this tutorial is to show you how to use each of the scoreboard player operations.  The concept is to create one objective with six players to represent digits 0, 1, 2, 3, 5, and 10, and another objective to hold two players whose scores will be changed when you do the operations.  Numbers: 0, 1, 2, 3, 5, 10  Friends: Alex, Toast  Setup  Start by creating two scoreboard objectives called \"Numbers\" and \"Friends.\"  Copy /scoreboard objectives add Numbers dummy Numbers /scoreboard objectives add Friends dummy Friends   Display the Numbers objective with the list option and display the Friends objective with the sidebar option.  Copy /scoreboard objectives setdisplay list Numbers  Copy /scoreboard objectives setdisplay sidebar Friends   To the objective named Numbers, add players \"Zero\", \"One\", \"Two\", \"Three\", \"Five\", and \"Ten\" and give each one the same number of points as their name.  Copy /scoreboard players add One Numbers 1 /scoreboard players add Two Numbers 2 . . . /scoreboard players add Ten Numbers 10    Note  After you add a player, when you go back into the chat screen to add another, you can press the up arrow on your keyboard to scroll through previous commands and just change the player name and score value. It saves a little bit of typing.  Add players named \"Alex\" and \"Toast\" to the Friends objective and give each of them a score of 4.  Copy /scoreboard players add Alex Friends 4 /scoreboard players add Toast Friends 4   Let's Operate 1. = Assign  The current value for Alex's score is 4. Use the = operator to assign the value of player Ten's score, which is 10.  Copy /scoreboard players operation Alex Friends = Ten Numbers   Result: Alex now has a score of 10.  2. >< Swap Values  One of the ways to give a player a particular score is to swap scores between two players.  Copy /scoreboard players operation Alex Friends >< Toast Friends   Result: Alex has a score of 4, Toast has a score of 10.  3. *= Multiply  Multiply Toast's score of 10 times 3.  Copy /scoreboard players operation Toast Friends *= Three Numbers   Result: Toast has 30 points.  4. += Add  Add Toast's score to Alex's score.  Copy /scoreboard players operation Alex Friends += Toast Friends   Result: Alex has 34 points. Toast's score is unaffected so it stays at 30.  5. -= Subtract  Subtract 5 from Toast's score.  Copy /scoreboard players operation Toast Friends -= Five Numbers   Result: Toast has 25 points.  6. /= Divide  Simple - No remainder  Divide Toast's score by 5.  Copy /scoreboard players operation Toast Friends /= Five Numbers   More Complicated - Has remainder  Divide Alex's score by 5.  Copy /scoreboard players operation Alex Friends /= Five Numbers   Result: Alex now has a score of 6. The remainder is ignored.  What if I divide by zero?  Divide Toast's score by 0.  Copy /scoreboard players operation Toast Friends /= Zero Numbers   Result: Nothing happens. (Whew!)  7. > Compare - Greater Than  Compare Toast's score to Alex's score. Toast's score will be set to whichever score is higher.  Copy /scoreboard players operation Toast Friends > Alex Friends   Result: Toast's score was set to 6, Alex's score is not affected.  If you try the operation again with both scores being equal, you get the same message.  8. < Compare - Less Than  Compare Toast's score to Three's score of 3. Toast's score will be set to whichever score is lower.  Copy /scoreboard players operation Toast Friends < Three Numbers   Result: Toast's score is set to 3.  9. %= Modulo  This operation takes Alex's current score, divides it by 2, and then puts the remainder as Alex's new score.  Copy /scoreboard players operation Alex Friends %= Two Numbers   Result: Alex's score is set to 0.   What's Next?  Now that you have learned about scoreboard operations, you could learn more about command blocks and functions and try combining it all together.  Command Blocks Introduction to Functions  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandblocks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Command Blocks 04/17/2025  Command blocks are a specialized type of block within a Minecraft: Bedrock Edition world that allows the use of console commands in-game. The same commands that players can type from chat can be run automatically by command blocks using redstone power.  In this tutorial, you will learn the following:  What are command blocks and how to access them in-game. How commands can be used via command blocks. How command block chains work by stringing together multiple command blocks. Create a gameplay loop to reward a player after performing an action.  In this guide, we will set up a command block chain to look for a certain type of block in a set location, and then reward the player for placing a block in the correct place.  Requirements Introduction to Commands A Minecraft world with cheats enabled. Setting up the world  While command blocks can be used in any Minecraft world, we will be using a flat world for a simple and clean environment.  Launch Minecraft: Bedrock Edition. Select Play, select Create New, then select Create New World. In the world settings, set the world type to Flat. In the world settings, enable Show Coordinates. In the world settings, enable Activate Cheats. Select Create. Getting command blocks  Command blocks can only be obtained by running a command.  Open up chat. Type the following command: /give @p command_block.  You'll see a command block added to your inventory.  Using command blocks  Start by placing the command block on the ground like any other block. If you look at the command block from the side, you should see an arrow.  These arrows always point in the direction of the player at the time the command block is placed. The arrows show the flow of execution. As shown in the image, the block on the left will execute first, followed by the middle command block, and finally the last block on the right will execute.  Click the Use button (right-click on PC) to open up the command block user interface.  Block Type defines what type of command block this is. There are 3 options: Impulse command blocks are activated when they receive a redstone signal. Chain command blocks are activated when a command block pointing into it is activated. Repeat command blocks are activated once every in-game tick, as long as they have a redstone signal. Minecraft has 20 ticks per second. Condition defines when a command block will execute its action. There are 2 options: Conditional will only execute if the previous block in a chain was successful. Unconditional will execute regardless if the previous block was successful or not. Redstone defines whether or not a command block requires redstone to activate. There are 2 options: Needs Redstone will set the command block to only activate when it has redstone power. Always Active will set the command block to always activate with or without redstone. For impulse command blocks, this causes them to only run once, so it isn't very useful. For chain command blocks, this is enabled by default. Execute on First Tick is only usable for repeating command blocks with a delay. If enabled, the command will execute as soon as the block is powered, and then will wait for the delay before running again. If disabled, the command will not run the first time until the delay has finished. Delay in Ticks is a value that defines how long a command block waits to execute after the command block receives redstone power. Designing a gameplay loop  A use case of command blocks is allowing creators to create gameplay loops within Minecraft. A simple gameplay loop would be rewarding a player for completing an action. If the gameplay loop was to give a player an emerald for placing a diamond block in a certain location, you can break down each step needed:  Check to see if a diamond block exists at a set location. If it does, check to see if the player has already received the reward. If the player hasn't received the reward, give the player an emerald. After giving the player an emerald, mark that they have received the reward. Setting up the first command block  Now that we have looked at the settings of a command block, let's set up the first block to detect a certain type of block in a location.  Place a command block on the ground in a location near your player character. Open up the command block interface. Set the Block Type to Repeat. Set the Redstone to Always Active. The /testforblock command  The /testforblock command looks for a specific block at a specified point in the world.  /testforblock <position: x y z> <tileName: Block> [dataValue: int]  position is the coordinates in the world where the command will look for the specific block. Example: 0 4 0. tileName is the type of block you are looking for. Example: diamond_block. dataValue is an optional argument used to handle variations of the same block. For this tutorial, we won't be needing to use this.  If you are following this tutorial, you will be in a flat world. As you walk around, you can see your player's position in the top-left of the screen. Let's check for a block near the origin.  In the Command Input section, input the following: /testforblock 0 4 0 diamond_block. Close the interface. Command block chains  For the next steps, we need to place two command blocks in a chain. As mentioned above, chain command blocks execute when a block pointing into them is activated. Make sure you place the block like the image showing the arrows.  Setting up the /testfor command block Place another command block next to the existing block. Make sure that the new block is placed in front of the direction that the arrow is pointing. Open the command block interface. Set the Block Type to Chain. Set the Condition to Conditional. Set the Redstone to Always Active. Set the Command Input to /testfor @p[tag=!placed_block]  Since the second block is set to Conditional, this new block will only execute if the first command block succeeds, meaning the diamond block was present. This command checks to see if the player hasn't already received the reward.  Setting up the reward command block  Let's add a third block to set a command to reward the player for placing a block in the right spot.  Place another command block next to the existing block. Make sure that the new block is placed in front of the direction that the arrow is pointing. Open the command block interface. Set the Block Type to Chain. Set the Condition to Conditional. Set the Redstone to Always Active. Set the Command Input to /give @p emerald.  Once again, this command will only activate if the previous command succeeded, meaning both the diamond block was present and the player hasn't received the reward yet.  Closing the loop  If we stop now, placing the diamond block at 0 4 0 will give the player 20 emeralds per second! We need to do one last step, marking the player as having received the reward.  Place another command block next to the existing block. Make sure that the new block is placed in front of the direction that the arrow is pointing. Open the command block interface. Set the Block Type to Chain. Set the Condition to Conditional. Set the Redstone to Always Active. Set the Command Input to /tag @p add placed_block Testing the loop  If everything has been set up correctly, you can now place a diamond block on location 0, 4, 0 and you will receive a single emerald in your player inventory.  Commands Introduction Popular Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandblocks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Command Blocks 04/17/2025  Command blocks are a specialized type of block within a Minecraft: Bedrock Edition world that allows the use of console commands in-game. The same commands that players can type from chat can be run automatically by command blocks using redstone power.  In this tutorial, you will learn the following:  What are command blocks and how to access them in-game. How commands can be used via command blocks. How command block chains work by stringing together multiple command blocks. Create a gameplay loop to reward a player after performing an action.  In this guide, we will set up a command block chain to look for a certain type of block in a set location, and then reward the player for placing a block in the correct place.  Requirements Introduction to Commands A Minecraft world with cheats enabled. Setting up the world  While command blocks can be used in any Minecraft world, we will be using a flat world for a simple and clean environment.  Launch Minecraft: Bedrock Edition. Select Play, select Create New, then select Create New World. In the world settings, set the world type to Flat. In the world settings, enable Show Coordinates. In the world settings, enable Activate Cheats. Select Create. Getting command blocks  Command blocks can only be obtained by running a command.  Open up chat. Type the following command: /give @p command_block.  You'll see a command block added to your inventory.  Using command blocks  Start by placing the command block on the ground like any other block. If you look at the command block from the side, you should see an arrow.  These arrows always point in the direction of the player at the time the command block is placed. The arrows show the flow of execution. As shown in the image, the block on the left will execute first, followed by the middle command block, and finally the last block on the right will execute.  Click the Use button (right-click on PC) to open up the command block user interface.  Block Type defines what type of command block this is. There are 3 options: Impulse command blocks are activated when they receive a redstone signal. Chain command blocks are activated when a command block pointing into it is activated. Repeat command blocks are activated once every in-game tick, as long as they have a redstone signal. Minecraft has 20 ticks per second. Condition defines when a command block will execute its action. There are 2 options: Conditional will only execute if the previous block in a chain was successful. Unconditional will execute regardless if the previous block was successful or not. Redstone defines whether or not a command block requires redstone to activate. There are 2 options: Needs Redstone will set the command block to only activate when it has redstone power. Always Active will set the command block to always activate with or without redstone. For impulse command blocks, this causes them to only run once, so it isn't very useful. For chain command blocks, this is enabled by default. Execute on First Tick is only usable for repeating command blocks with a delay. If enabled, the command will execute as soon as the block is powered, and then will wait for the delay before running again. If disabled, the command will not run the first time until the delay has finished. Delay in Ticks is a value that defines how long a command block waits to execute after the command block receives redstone power. Designing a gameplay loop  A use case of command blocks is allowing creators to create gameplay loops within Minecraft. A simple gameplay loop would be rewarding a player for completing an action. If the gameplay loop was to give a player an emerald for placing a diamond block in a certain location, you can break down each step needed:  Check to see if a diamond block exists at a set location. If it does, check to see if the player has already received the reward. If the player hasn't received the reward, give the player an emerald. After giving the player an emerald, mark that they have received the reward. Setting up the first command block  Now that we have looked at the settings of a command block, let's set up the first block to detect a certain type of block in a location.  Place a command block on the ground in a location near your player character. Open up the command block interface. Set the Block Type to Repeat. Set the Redstone to Always Active. The /testforblock command  The /testforblock command looks for a specific block at a specified point in the world.  /testforblock <position: x y z> <tileName: Block> [dataValue: int]  position is the coordinates in the world where the command will look for the specific block. Example: 0 4 0. tileName is the type of block you are looking for. Example: diamond_block. dataValue is an optional argument used to handle variations of the same block. For this tutorial, we won't be needing to use this.  If you are following this tutorial, you will be in a flat world. As you walk around, you can see your player's position in the top-left of the screen. Let's check for a block near the origin.  In the Command Input section, input the following: /testforblock 0 4 0 diamond_block. Close the interface. Command block chains  For the next steps, we need to place two command blocks in a chain. As mentioned above, chain command blocks execute when a block pointing into them is activated. Make sure you place the block like the image showing the arrows.  Setting up the /testfor command block Place another command block next to the existing block. Make sure that the new block is placed in front of the direction that the arrow is pointing. Open the command block interface. Set the Block Type to Chain. Set the Condition to Conditional. Set the Redstone to Always Active. Set the Command Input to /testfor @p[tag=!placed_block]  Since the second block is set to Conditional, this new block will only execute if the first command block succeeds, meaning the diamond block was present. This command checks to see if the player hasn't already received the reward.  Setting up the reward command block  Let's add a third block to set a command to reward the player for placing a block in the right spot.  Place another command block next to the existing block. Make sure that the new block is placed in front of the direction that the arrow is pointing. Open the command block interface. Set the Block Type to Chain. Set the Condition to Conditional. Set the Redstone to Always Active. Set the Command Input to /give @p emerald.  Once again, this command will only activate if the previous command succeeded, meaning both the diamond block was present and the player hasn't received the reward yet.  Closing the loop  If we stop now, placing the diamond block at 0 4 0 will give the player 20 emeralds per second! We need to do one last step, marking the player as having received the reward.  Place another command block next to the existing block. Make sure that the new block is placed in front of the direction that the arrow is pointing. Open the command block interface. Set the Block Type to Chain. Set the Condition to Conditional. Set the Redstone to Always Active. Set the Command Input to /tag @p add placed_block Testing the loop  If everything has been set up correctly, you can now place a diamond block on location 0, 4, 0 and you will receive a single emerald in your player inventory.  Commands Introduction Popular Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/morefunwithstructureblocks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn More Fun with Structure Blocks 03/12/2025  After you get comfortable with the basics of saving, exporting, and importing structures with structure blocks, you might find it helpful to use structure blocks to do more.  In this tutorial, you will learn how to use structure blocks to:  Rotate a structure Load a group of mobs Take a cross-section of the world Rotate a Structure  Suppose you built a structure and then realized it's facing the wrong direction. That's okay. We can fix it.  Start by exporting the structure and saving it on your computer.  Place a structure block and set it to load your exported structure.  Before you click Load, set the rotation to the direction you prefer.  Import the structure.  Now the structure is pointing the correct direction.  Load a Group of Mobs - Without the Structure  You can use a structure block to select, save, and load just a group of mobs. Basically, you create a structure that has no blocks - it's just the mobs inside and the air blocks around them.  Start by selecting a structure that will contain your spawned-in mobs.  Spawn them in the usual way - with eggs or by summoning them with a command.  Select only the blocks containing the mobs. It will look like a room without walls.  Save the selection like you would any other structure.  Use a load block to bring in the mobs.  Take a Cross-Section of the World  A cross-section or \"core sample\" is a good way to see what's going on underground. You can use this to check for an Ancient City, or to evaluate the density of diamonds, or to see if your cave carver feature is functioning as expected.  Start by placing a Save structure block on top of the surface of the world.  Adjust the Size and offset to make the y settings dig deep down in the ground.  We are starting at y-level 123, and we want to take a \"core sample\" from the grass blocks down to bedrock. So that means our size and offset settings should look like this:  Size: X = 10, Y = 210, Z = 10  Offset: X: 0, Y = -182, Z: 0  Now, load your saved the core sample structure and see what you find!  This could come in handy for finding Ancient Cities...  What's Next?  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/morefunwithstructureblocks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn More Fun with Structure Blocks 03/12/2025  After you get comfortable with the basics of saving, exporting, and importing structures with structure blocks, you might find it helpful to use structure blocks to do more.  In this tutorial, you will learn how to use structure blocks to:  Rotate a structure Load a group of mobs Take a cross-section of the world Rotate a Structure  Suppose you built a structure and then realized it's facing the wrong direction. That's okay. We can fix it.  Start by exporting the structure and saving it on your computer.  Place a structure block and set it to load your exported structure.  Before you click Load, set the rotation to the direction you prefer.  Import the structure.  Now the structure is pointing the correct direction.  Load a Group of Mobs - Without the Structure  You can use a structure block to select, save, and load just a group of mobs. Basically, you create a structure that has no blocks - it's just the mobs inside and the air blocks around them.  Start by selecting a structure that will contain your spawned-in mobs.  Spawn them in the usual way - with eggs or by summoning them with a command.  Select only the blocks containing the mobs. It will look like a room without walls.  Save the selection like you would any other structure.  Use a load block to bring in the mobs.  Take a Cross-Section of the World  A cross-section or \"core sample\" is a good way to see what's going on underground. You can use this to check for an Ancient City, or to evaluate the density of diamonds, or to see if your cave carver feature is functioning as expected.  Start by placing a Save structure block on top of the surface of the world.  Adjust the Size and offset to make the y settings dig deep down in the ground.  We are starting at y-level 123, and we want to take a \"core sample\" from the grass blocks down to bedrock. So that means our size and offset settings should look like this:  Size: X = 10, Y = 210, Z = 10  Offset: X: 0, Y = -182, Z: 0  Now, load your saved the core sample structure and see what you find!  This could come in handy for finding Ancient Cities...  What's Next?  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandblocksnowballfight?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Use Command Blocks to Have a Snowball Fight 03/06/2025  Command Blocks are a tool that you can use to execute commands or even a series of commands in a Minecraft world and give you several advantages, such as giving other players the ability to execute commands without giving them server privileges. But how exactly do we use command blocks to change up the way we play in Minecraft?  Let's take a look at some \"cool\" command block tricks that we can pull off in order to create a snowball fight game mode in Survival!  Assign Players to Teams  One of the best things you can do with command blocks is automate processes that would normally take a long time to do by hand. Assigning players to teams in a world is time-consuming because you normally have to assign each player to a team one-by-one. On top of that, you have to know who wants to be on which team and keep track of it for everyone. But it wouldn't be an epic snowball fight if there weren't two sides going all-out across a snowy field so let's look at how command blocks can help you create and assign teams.  Assign Teams manually  Create two separate staging areas for each team to start in. In the area for Team 1, place two repeating command blocks vertically and make sure they are set to Always Active. Make sure to dig two blocks into the ground and place them so that players can walk over the top block to execute the command.  Place the first command block on the bottom with the following command:  /tag @p[r=2] remove team2  Place the second command block above the first one with the command:  /tag @p[r=1] add team1  The reason we place the command blocks this way is because we're constantly executing the command, but only in the specified range ([r=2]). This way, the bottom command block will still affect the player because its effective range is 2 blocks away from it.  Now, for the other team's area, create a similar set of command blocks, but invert the add and remove team commands:  Bottom command block:  tag @p[r=2] remove team1  Top command block:  tag @p[r=1] add team2  Now, players can move to their desired team's area and get added to the team. You can create scoreboards to track objectives and points and use these teams for all sorts of custom game modes.  Obviously you can create more teams, just recreate the same set of command blocks and add an additional team - just note that you will have to create an additional command block to remove any additional team tags, like this:  tag @p[r=3] remove team3  Assign Teams Randomly  Let's say you want to assign the teams randomly. Great news, command blocks can do that, too! Instead of creating areas where players can go to select their teams, let's do things a bit differently.  Create an impulse command block and enter the following command:  /scoreboard objectives add random test  Chain a command block set to Always Active with the following command:  /scoreboard players random @p test <min> <max>  Replace the <min> and <max> with your desired maximum number - to make things easy, try using the number of players in your game. This command sets a random \"score\" for the player to a random number between zero and your maximum number.  Chain another command set to Always Active block with this command:  /execute if score @s test matches <min_score>..<max_score> run tag @s add team1  Your <min_score> and <max_score> is a number range that will divide players based on their randomly assigned score. In our example, for a two team game, make this number the halfway point between 0 and your maximum number. So, what does this look like in game? Let's say we have a game with 2 teams and 16 players.  Command block 1  /scoreboard objectives add random test  Command block 2  /scoreboard players random @p test 0 16  Command block 3  /execute if score @p test matches 0..8 run tag @p add team1  Command block 4  /execute if score @p test matches 9..16 run tag @p add team2  Now we add a lever in front of our impulse command block and have each player come up and flip the switch in turn. If you want to get fancy, you can add the repeating command blocks from earlier that removed your team tags - just make sure they're not placed where the players will stand to flip the lever, otherwise they will remove the tags we just gave them!   Note  If you want to ensure that teams are distributed evenly, you may get better results if you increase the <NUMBER_RANGE> value. There is no way to ensure that each player's randomized score will be unique, so creating a much higher number range will often yield more evenly distributed teams. For example, instead of 0 to 16, assign random scores of 0 to 100, making the range for team1 0 to 50 and for team2 51 to 100. As you add more teams, you can further divide your <min_score> and <max_score> ranges, such as three teams being divided with scores of 0..33, 34..66, and 67..99 for team1, team2, and team3 respectively.  Make Lethal Snowballs!  Now it's time to hand out the ammunition for our snowball fight!  Create a repeating command block set to Always Active and enter the following command:  /execute as @e[type=snowball] at @e[family=player, c=1] if entity @e[type=snowball,r=1] at @e[family=player, c=1] run damage @e[family=player, c=1, r=1] 2  Whew! Okay, let's break that down. We're using the execute command in a repeating command block to continuously execute a command everywhere in the world, all the time. The as @e[type=snowball] part means that we are executing the command as any snowball in the world. The at @e[family=player, c=1] means that the snowball will target the closest player within one block of itself (c=1) that has the player family type. If all of those conditions are met, then it will damage that player for 2 health. You can adjust this final value to increase or decrease the amount of damage dealt by each snowball.  Snowball Fight!  Now you've got everything you need to create an epic snowball fight! You can set a scoreboard to track how much damage is scored by each team or how many times players on each team are eliminated. You can also combine the snowball fight mode we've created here with more advanced game mechanics - like a capture the flag or king of the hill scenario! Either way, this is just a taste of what you can do with command blocks. Stay tuned for more fun ideas!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandblocksnowballfight?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Use Command Blocks to Have a Snowball Fight 03/06/2025  Command Blocks are a tool that you can use to execute commands or even a series of commands in a Minecraft world and give you several advantages, such as giving other players the ability to execute commands without giving them server privileges. But how exactly do we use command blocks to change up the way we play in Minecraft?  Let's take a look at some \"cool\" command block tricks that we can pull off in order to create a snowball fight game mode in Survival!  Assign Players to Teams  One of the best things you can do with command blocks is automate processes that would normally take a long time to do by hand. Assigning players to teams in a world is time-consuming because you normally have to assign each player to a team one-by-one. On top of that, you have to know who wants to be on which team and keep track of it for everyone. But it wouldn't be an epic snowball fight if there weren't two sides going all-out across a snowy field so let's look at how command blocks can help you create and assign teams.  Assign Teams manually  Create two separate staging areas for each team to start in. In the area for Team 1, place two repeating command blocks vertically and make sure they are set to Always Active. Make sure to dig two blocks into the ground and place them so that players can walk over the top block to execute the command.  Place the first command block on the bottom with the following command:  /tag @p[r=2] remove team2  Place the second command block above the first one with the command:  /tag @p[r=1] add team1  The reason we place the command blocks this way is because we're constantly executing the command, but only in the specified range ([r=2]). This way, the bottom command block will still affect the player because its effective range is 2 blocks away from it.  Now, for the other team's area, create a similar set of command blocks, but invert the add and remove team commands:  Bottom command block:  tag @p[r=2] remove team1  Top command block:  tag @p[r=1] add team2  Now, players can move to their desired team's area and get added to the team. You can create scoreboards to track objectives and points and use these teams for all sorts of custom game modes.  Obviously you can create more teams, just recreate the same set of command blocks and add an additional team - just note that you will have to create an additional command block to remove any additional team tags, like this:  tag @p[r=3] remove team3  Assign Teams Randomly  Let's say you want to assign the teams randomly. Great news, command blocks can do that, too! Instead of creating areas where players can go to select their teams, let's do things a bit differently.  Create an impulse command block and enter the following command:  /scoreboard objectives add random test  Chain a command block set to Always Active with the following command:  /scoreboard players random @p test <min> <max>  Replace the <min> and <max> with your desired maximum number - to make things easy, try using the number of players in your game. This command sets a random \"score\" for the player to a random number between zero and your maximum number.  Chain another command set to Always Active block with this command:  /execute if score @s test matches <min_score>..<max_score> run tag @s add team1  Your <min_score> and <max_score> is a number range that will divide players based on their randomly assigned score. In our example, for a two team game, make this number the halfway point between 0 and your maximum number. So, what does this look like in game? Let's say we have a game with 2 teams and 16 players.  Command block 1  /scoreboard objectives add random test  Command block 2  /scoreboard players random @p test 0 16  Command block 3  /execute if score @p test matches 0..8 run tag @p add team1  Command block 4  /execute if score @p test matches 9..16 run tag @p add team2  Now we add a lever in front of our impulse command block and have each player come up and flip the switch in turn. If you want to get fancy, you can add the repeating command blocks from earlier that removed your team tags - just make sure they're not placed where the players will stand to flip the lever, otherwise they will remove the tags we just gave them!   Note  If you want to ensure that teams are distributed evenly, you may get better results if you increase the <NUMBER_RANGE> value. There is no way to ensure that each player's randomized score will be unique, so creating a much higher number range will often yield more evenly distributed teams. For example, instead of 0 to 16, assign random scores of 0 to 100, making the range for team1 0 to 50 and for team2 51 to 100. As you add more teams, you can further divide your <min_score> and <max_score> ranges, such as three teams being divided with scores of 0..33, 34..66, and 67..99 for team1, team2, and team3 respectively.  Make Lethal Snowballs!  Now it's time to hand out the ammunition for our snowball fight!  Create a repeating command block set to Always Active and enter the following command:  /execute as @e[type=snowball] at @e[family=player, c=1] if entity @e[type=snowball,r=1] at @e[family=player, c=1] run damage @e[family=player, c=1, r=1] 2  Whew! Okay, let's break that down. We're using the execute command in a repeating command block to continuously execute a command everywhere in the world, all the time. The as @e[type=snowball] part means that we are executing the command as any snowball in the world. The at @e[family=player, c=1] means that the snowball will target the closest player within one block of itself (c=1) that has the player family type. If all of those conditions are met, then it will damage that player for 2 health. You can adjust this final value to increase or decrease the amount of damage dealt by each snowball.  Snowball Fight!  Now you've got everything you need to create an epic snowball fight! You can set a scoreboard to track how much damage is scored by each team or how many times players on each team are eliminated. You can also combine the snowball fight mode we've created here with more advanced game mechanics - like a capture the flag or king of the hill scenario! Either way, this is just a taste of what you can do with command blocks. Stay tuned for more fun ideas!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandspopularcommands?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Popular Commands 05/07/2025  This list covers some of the more popular and useful commands available in Minecraft: Bedrock Edition.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Getting Started with Command Blocks /help  First and foremost is the /help command.  Copy /help <page: int> /help [command: CommandName]   Running /help in the chat by itself will list every command you can run. However, since there are so many, they have been divided up into pages. Supplying a page number will change which page of commands to show.  Whenever you want to know the usage and all of the syntaxes of a command, you can use /help followed by the name of the command. This can be helpful if you want an overview of the command.  /effect  Adding and removing status effects is done with the /effect command. All status effects on the target can also be cleared.  /execute  The primary function of the /execute command is to modify the executor and execution origin of a nested command. However, its syntax allows for some conditional command execution that would otherwise be missing in functions.  Find more information on the Execute reference page and the New Execute Syntax page  Copy /execute as <origin: target> <chainedCommand: ExecuteChainedOption_0>   For example, to detect if there's a specific block beneath the player and run a command as a result, the \"detect\" argument can be used instead of having a nested /testforblock command.  Copy /execute as @s positioned as @s if block ~ ~-1 ~ grass run say Player is standing on grass.  /gamemode  When developing content, most often you'll be playing in creative mode. However, testing your content may require you to enter survival or adventure mode. The /gamemode command allows you to change your current game mode.  Copy /gamemode <gameMode: GameMode> [player: target] /gamemode <gameMode: int> [player: target]   You have several options for the game mode: the full name, a single character, or a numeric representation. The accepted values are \"survival\" (\"s\" or 0), \"creative\" (\"c\" or 1), and \"adventure\" (\"a\" or 2). There is also \"default\" (\"d\"), which sets your game mode to whatever the world's default game mode is. The following will set your own game mode to creative when you run it in the chat.  Copy /gamemode creative   You can also change the game mode of a specific player using target selectors, which can be helpful when controlling gameplay aspects (such as the inability to mine anything in adventure mode). The following changes the game mode of all players with the \"sometag\" tag to adventure mode.  Copy /gamemode adventure @a[tag=sometag]  /gamerule  This /gamerule command changes specific gameplay aspects and has options helpful for development. There are a large number of gamerules, which can be listed using the chat's auto-complete feature.  Copy /gamerule <rule: BoolGameRule> [value: Boolean] /gamerule <rule: IntGameRule> [value: int]   Some gamerules accept only true or false as the value of the rule (\"BoolGameRule\") while others only accept integers (\"IntGameRule\"). The primary gamerules crucial for development, which are all booleans, are \"commandblockoutput\", \"sendcommandfeedback\", and \"commandblocksenabled\", \"dodaylightcycle\", and \"doweathercycle\" listed below.  commandblockoutput  You may have noticed that all of the previous command examples send an output to the chat. This can be a nuisance, especially for commands running every tick. The \"commandblockoutput\" gamerule, when set to false, will disable that chat output.  Copy /gamerule commandblockoutput false  sendcommandfeedback  Disabling command block output does not disable all feedback. Some commands, such as /xp, continue providing feedback even when command block output is disabled. The \"sendcommandfeedback\" gamerule disables these messages as well, allowing for a completely silent command system.  Copy /gamerule sendcommandfeedback false  commandblocksenabled  To quickly enable or disable command blocks in the world, the \"commandblocksenabled\" can be toggled on and off. This can be especially helpful if a repeating command block is repeatedly teleporting you.  Copy /gamerule commandblocksenabled false  dodaylightcycle  Either for development or for gameplay concerns, you can choose to prevent the daylight cycle from moving. This means that whatever time you set the game to (such as with the /time command), it will stay at that time.  Copy /gamerule dodaylightcycle false  doweathercycle  As with \"dodaylightcycle\", you may also want to control the weather cycle. If you intend to have a happy setting, a thunderstorm setting in may not achieve the best effect. When \"doweathercycle\" is disabled, the weather will stay as it is, including when set with the /weather command.  Copy /gamerule doweathercycle false  /give, /clear, /replaceitem  These commands manipulate the player's inventory; /replaceitem can also modify non-player entity inventories and blocks with inventories. The /give command provides items, the /clear command removes items, and the /replaceitem command places items in specific slots in the inventory.  /locate  Finds the nearest specified biome or structure if it exists in the current dimension. Prints an error if it does not.  Copy /locate biome <biome name> /locate structure <structure name>   The locate command takes two arguments: \"biome\" or \"structure\" specifies which to locate, followed by the name of the biome or structure you're looking for.  Copy /locate biome beach /locate structure village  /scoreboard  The /scoreboard command is a powerful method of keeping track of numeric values on a per-entity basis, as well as performing mathematical operations with commands. The first step is creating an objective and (optionally) displaying it on the sidebar.  Copy /scoreboard objectives add objectiveA dummy  /scoreboard objectives setdisplay sidebar objectiveA   The simplest course of action would be rewarding the player with a point if they accomplish some task.  Copy /scoreboard players add @p objectiveA 1   Afterwards, target selectors can be used to select players who achieve a certain number of points.  Copy @a[scores={objectiveA=10..}]  /setblock, /fill, /clone  These commands change the physical blocks in the world. The /setblock command can set a single block while the /fill command can set multiple of the same block. The /clone command, on the other hand, will take a copy of blocks from one area and paste it into another.  /summon  The /summon command is used to spawn a new entity into the world, from cows to sheep to your own custom entities.  /setworldspawn  If you have a specific location that you want players new to the world or players who die to spawn at, the /setworldspawn command provides that ability.  Copy /setworldspawn [spawnPoint: x y z]   Note that players who die after they have set their spawn with a bed will still respawn at their bed.  /tag  Similar to /scoreboard, the /tag command allows you to keep track of string values on a per-entity basis. Tags would be used when a numeric value is not needed, such as for \"true or false\" situations. For example, you could tag entities as being a boss and later target those same entities based on that tag.  Copy /tag @e[type=sheep] add boss /tag @e[type=minecart] add boss  Copy /say Bosses: @e[tag=boss]  /tellraw, /titleraw  The /say, /tell, and /title commands don't provide translation support. To provide that, use the /tellraw and /titleraw commands, which take JSON objects for their messages. The /tellraw command is also clearer in intent, as the message is not accompanied with a \"whisper\" statement.  Copy /tellraw @a {\"rawtext\":[{\"translate\":\"commands.testfor.success\",\"with\":[\"PlayerName\"]}]}  /tellraw @a {\"rawtext\":[{\"text\":\"Hello World\"}]}  /testfor, /testforblock, /testforblocks  These commands test for the existence of an entity, block, and a copy of a block structure. While these commands can be useful alongside conditional command blocks, they are less useful in functions, as there is no equivalent conditional setting in functions.  Both the /testfor and /testforblock commands can generally be skipped over in favor of /execute, which can run a command based on the existence of an entity or a block.  /time set  Changing the gameplay environment can be essential for providing the right atmosphere. Changing the time of day is one method of doing so.  Copy /time set <amount: int> /time set <time: TimeSpec>   You can either provide an integer which represents a precise time of the day, or \"TimeSpec\" can be set to one of the following values to more easily select common times of day: \"day\", \"midnight\", \"night\", \"noon\", \"sunrise\", and \"sunset\". For example, quickly setting the sun directly above the player would use the following:  Copy /time set noon  /tp or /teleport  Sometimes you may want to provide an easy means of transportation or need a form of controlling where the player (or even non-player entity) is. The /tp command will teleport targeted players to specific locations, or even to other entities. The syntaxes for /tp may look daunting at first, but note many branch to and from the same options.  Copy /tp <victim: target> <destination: target> [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> [yRot: value] [xRot: value] [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> facing <lookAtEntity: target> [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> facing <lookAtPosition: x y z> [checkForBlocks: Boolean]   At its simplest, you can teleport the player to a specific coordinate location.  Copy /tp @p 100 50 100   You can also teleport them to another player or entity. The destination target must resolve to a single entity, so you have to use a target selector that can only target one entity or ensure there are no duplicates of the intended target (such as using the /tag command to identify targets).  Copy /tp Steve Alex /tp @p @e[type=minecraft:armor_stand,c=1] /tp @a @e[type=minecraft:creeper,tag=destination_1]   The common option \"checkForBlocks\" defaults to false, but when it is set to true, it will prevent teleporting the player if the location they would end up in is occupied by blocks.  This command teleports Steve to coordinates [50, 63, 50] and makes sure there are no blocks in the way.  Copy /tp Steve 50 63 50 true    Note  One of the differences between using commands and commands blocks is that /tp @s ... will not work in a command block.  /weather  Like /time set, the /weather command can be used to change the environment. If you want a specific type of weather to occur, this would be the command you would use.  Copy /weather <clear|rain|thunder> [duration: int]   The optional duration is the number of game ticks that the selected weather will last for. 20 game ticks is one second, so for each second you want the weather to last, multiply it by twenty. The following sets the weather to thunder for 30 seconds, which is 600 ticks.  Copy /weather thunder 600   Be sure that the \"doweathercycle\" gamerule is false if you intend on making use of the duration. If it is true, the weather cycle will not occur, rendering the duration useless.  What's next?  After learning about commands and target selectors, command blocks, and a variety of useful commands, it's time to put them together and create a small project in the form of a Complete the Monument system.  Create an In-World Game with Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandspopularcommands?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Popular Commands 05/07/2025  This list covers some of the more popular and useful commands available in Minecraft: Bedrock Edition.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Getting Started with Command Blocks /help  First and foremost is the /help command.  Copy /help <page: int> /help [command: CommandName]   Running /help in the chat by itself will list every command you can run. However, since there are so many, they have been divided up into pages. Supplying a page number will change which page of commands to show.  Whenever you want to know the usage and all of the syntaxes of a command, you can use /help followed by the name of the command. This can be helpful if you want an overview of the command.  /effect  Adding and removing status effects is done with the /effect command. All status effects on the target can also be cleared.  /execute  The primary function of the /execute command is to modify the executor and execution origin of a nested command. However, its syntax allows for some conditional command execution that would otherwise be missing in functions.  Find more information on the Execute reference page and the New Execute Syntax page  Copy /execute as <origin: target> <chainedCommand: ExecuteChainedOption_0>   For example, to detect if there's a specific block beneath the player and run a command as a result, the \"detect\" argument can be used instead of having a nested /testforblock command.  Copy /execute as @s positioned as @s if block ~ ~-1 ~ grass run say Player is standing on grass.  /gamemode  When developing content, most often you'll be playing in creative mode. However, testing your content may require you to enter survival or adventure mode. The /gamemode command allows you to change your current game mode.  Copy /gamemode <gameMode: GameMode> [player: target] /gamemode <gameMode: int> [player: target]   You have several options for the game mode: the full name, a single character, or a numeric representation. The accepted values are \"survival\" (\"s\" or 0), \"creative\" (\"c\" or 1), and \"adventure\" (\"a\" or 2). There is also \"default\" (\"d\"), which sets your game mode to whatever the world's default game mode is. The following will set your own game mode to creative when you run it in the chat.  Copy /gamemode creative   You can also change the game mode of a specific player using target selectors, which can be helpful when controlling gameplay aspects (such as the inability to mine anything in adventure mode). The following changes the game mode of all players with the \"sometag\" tag to adventure mode.  Copy /gamemode adventure @a[tag=sometag]  /gamerule  This /gamerule command changes specific gameplay aspects and has options helpful for development. There are a large number of gamerules, which can be listed using the chat's auto-complete feature.  Copy /gamerule <rule: BoolGameRule> [value: Boolean] /gamerule <rule: IntGameRule> [value: int]   Some gamerules accept only true or false as the value of the rule (\"BoolGameRule\") while others only accept integers (\"IntGameRule\"). The primary gamerules crucial for development, which are all booleans, are \"commandblockoutput\", \"sendcommandfeedback\", and \"commandblocksenabled\", \"dodaylightcycle\", and \"doweathercycle\" listed below.  commandblockoutput  You may have noticed that all of the previous command examples send an output to the chat. This can be a nuisance, especially for commands running every tick. The \"commandblockoutput\" gamerule, when set to false, will disable that chat output.  Copy /gamerule commandblockoutput false  sendcommandfeedback  Disabling command block output does not disable all feedback. Some commands, such as /xp, continue providing feedback even when command block output is disabled. The \"sendcommandfeedback\" gamerule disables these messages as well, allowing for a completely silent command system.  Copy /gamerule sendcommandfeedback false  commandblocksenabled  To quickly enable or disable command blocks in the world, the \"commandblocksenabled\" can be toggled on and off. This can be especially helpful if a repeating command block is repeatedly teleporting you.  Copy /gamerule commandblocksenabled false  dodaylightcycle  Either for development or for gameplay concerns, you can choose to prevent the daylight cycle from moving. This means that whatever time you set the game to (such as with the /time command), it will stay at that time.  Copy /gamerule dodaylightcycle false  doweathercycle  As with \"dodaylightcycle\", you may also want to control the weather cycle. If you intend to have a happy setting, a thunderstorm setting in may not achieve the best effect. When \"doweathercycle\" is disabled, the weather will stay as it is, including when set with the /weather command.  Copy /gamerule doweathercycle false  /give, /clear, /replaceitem  These commands manipulate the player's inventory; /replaceitem can also modify non-player entity inventories and blocks with inventories. The /give command provides items, the /clear command removes items, and the /replaceitem command places items in specific slots in the inventory.  /locate  Finds the nearest specified biome or structure if it exists in the current dimension. Prints an error if it does not.  Copy /locate biome <biome name> /locate structure <structure name>   The locate command takes two arguments: \"biome\" or \"structure\" specifies which to locate, followed by the name of the biome or structure you're looking for.  Copy /locate biome beach /locate structure village  /scoreboard  The /scoreboard command is a powerful method of keeping track of numeric values on a per-entity basis, as well as performing mathematical operations with commands. The first step is creating an objective and (optionally) displaying it on the sidebar.  Copy /scoreboard objectives add objectiveA dummy  /scoreboard objectives setdisplay sidebar objectiveA   The simplest course of action would be rewarding the player with a point if they accomplish some task.  Copy /scoreboard players add @p objectiveA 1   Afterwards, target selectors can be used to select players who achieve a certain number of points.  Copy @a[scores={objectiveA=10..}]  /setblock, /fill, /clone  These commands change the physical blocks in the world. The /setblock command can set a single block while the /fill command can set multiple of the same block. The /clone command, on the other hand, will take a copy of blocks from one area and paste it into another.  /summon  The /summon command is used to spawn a new entity into the world, from cows to sheep to your own custom entities.  /setworldspawn  If you have a specific location that you want players new to the world or players who die to spawn at, the /setworldspawn command provides that ability.  Copy /setworldspawn [spawnPoint: x y z]   Note that players who die after they have set their spawn with a bed will still respawn at their bed.  /tag  Similar to /scoreboard, the /tag command allows you to keep track of string values on a per-entity basis. Tags would be used when a numeric value is not needed, such as for \"true or false\" situations. For example, you could tag entities as being a boss and later target those same entities based on that tag.  Copy /tag @e[type=sheep] add boss /tag @e[type=minecart] add boss  Copy /say Bosses: @e[tag=boss]  /tellraw, /titleraw  The /say, /tell, and /title commands don't provide translation support. To provide that, use the /tellraw and /titleraw commands, which take JSON objects for their messages. The /tellraw command is also clearer in intent, as the message is not accompanied with a \"whisper\" statement.  Copy /tellraw @a {\"rawtext\":[{\"translate\":\"commands.testfor.success\",\"with\":[\"PlayerName\"]}]}  /tellraw @a {\"rawtext\":[{\"text\":\"Hello World\"}]}  /testfor, /testforblock, /testforblocks  These commands test for the existence of an entity, block, and a copy of a block structure. While these commands can be useful alongside conditional command blocks, they are less useful in functions, as there is no equivalent conditional setting in functions.  Both the /testfor and /testforblock commands can generally be skipped over in favor of /execute, which can run a command based on the existence of an entity or a block.  /time set  Changing the gameplay environment can be essential for providing the right atmosphere. Changing the time of day is one method of doing so.  Copy /time set <amount: int> /time set <time: TimeSpec>   You can either provide an integer which represents a precise time of the day, or \"TimeSpec\" can be set to one of the following values to more easily select common times of day: \"day\", \"midnight\", \"night\", \"noon\", \"sunrise\", and \"sunset\". For example, quickly setting the sun directly above the player would use the following:  Copy /time set noon  /tp or /teleport  Sometimes you may want to provide an easy means of transportation or need a form of controlling where the player (or even non-player entity) is. The /tp command will teleport targeted players to specific locations, or even to other entities. The syntaxes for /tp may look daunting at first, but note many branch to and from the same options.  Copy /tp <victim: target> <destination: target> [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> [yRot: value] [xRot: value] [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> facing <lookAtEntity: target> [checkForBlocks: Boolean] /tp <victim: target> <destination: x y z> facing <lookAtPosition: x y z> [checkForBlocks: Boolean]   At its simplest, you can teleport the player to a specific coordinate location.  Copy /tp @p 100 50 100   You can also teleport them to another player or entity. The destination target must resolve to a single entity, so you have to use a target selector that can only target one entity or ensure there are no duplicates of the intended target (such as using the /tag command to identify targets).  Copy /tp Steve Alex /tp @p @e[type=minecraft:armor_stand,c=1] /tp @a @e[type=minecraft:creeper,tag=destination_1]   The common option \"checkForBlocks\" defaults to false, but when it is set to true, it will prevent teleporting the player if the location they would end up in is occupied by blocks.  This command teleports Steve to coordinates [50, 63, 50] and makes sure there are no blocks in the way.  Copy /tp Steve 50 63 50 true    Note  One of the differences between using commands and commands blocks is that /tp @s ... will not work in a command block.  /weather  Like /time set, the /weather command can be used to change the environment. If you want a specific type of weather to occur, this would be the command you would use.  Copy /weather <clear|rain|thunder> [duration: int]   The optional duration is the number of game ticks that the selected weather will last for. 20 game ticks is one second, so for each second you want the weather to last, multiply it by twenty. The following sets the weather to thunder for 30 seconds, which is 600 ticks.  Copy /weather thunder 600   Be sure that the \"doweathercycle\" gamerule is false if you intend on making use of the duration. If it is true, the weather cycle will not occur, rendering the duration useless.  What's next?  After learning about commands and target selectors, command blocks, and a variety of useful commands, it's time to put them together and create a small project in the form of a Complete the Monument system.  Create an In-World Game with Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/targetselectors?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Target Selectors 09/21/2023  Using player names as values for arguments isn't ideal for a command system that's intended to work for anyone. It's not possible to know the names of the players who will be making use of your content ahead of time. Target selectors, which can target players and other entities arbitrarily, fixes this issue.  There are 6 base selectors to pick from: @p, @a, @r, @e, @s, and @initiator. The selector to choose depends on who or what the intended target is.  @p: selects the single closest living player unless the execution origin is changed with the x, y, and z selector parameters. If the executor was a command block, the player closest to the command block would be selected since the command block's coordinates are the execution origin. @a: selects all online players, alive or not. @r: selects one random living player unless the type parameter is specified. @e: selects all entities (players, cows, dropped items, etc.) @s: selects the executing entity, which can be changed with the /execute command. @initiator: selects the player that initiates an NPC dialogue interaction.  Selectors replace a player name where possible. For example, instead of specifying a player name in the /gamemode command, a selector can be used in its place. The following would change the game mode of all players to creative mode:  Copy /gamemode creative @a   If no targets are found by the selector, the command will fail to run.  Selector parameters  Alongside the base selectors are parameters. These optional parameters help to narrow down the desired targets, such as if you wanted to only target players in adventure mode. All parameters are contained within a set of square brackets and each parameter is separated from one another with a comma. The name of the parameter is followed by an equals sign, which is then followed by the value of the parameter.  Copy @<selector>[param1=value1,param2=value2]   If the desired targets of the previous /gamemode command should instead be all players in adventure mode, the m parameter will reduce the potential targets of the selector to only those in adventure mode. A list of all parameters can be found below.  Copy /gamemode creative @a[m=adventure]   A potential target must match all specified parameters before being selected. This means that using @p[tag=sometag,m=survival] would select the closest player that has the tag \"sometag\" and is in survival mode.  List of parameters Expand table Parameter\tDescription\tExample x, y, z\tSpecifies the coordinates to find players from. Not all axes have to be specified.\tUsing @p[x=0,y=64,z=0] will select the player closest to those coordinates, rather than the player closest to the execution origin. r, rm\tSelects targets within a radius around the execution origin, unless changed by the \"x, y, z\" parameters.  r is the maximum number of blocks away from the origin to select, while rm is the minimum blocks away from the origin.  One may be specified without specifying the other.\t@p[x=0,y=64,z=0,r=1] will select a player that is 1 block away from the specified coordinates.  @a[rm=3] will select all players 3 blocks away from the execution origin.  @e[rm=3,r=10] will select all entities that are between 3 and 10 blocks of the execution origin. dx, dy, dz\tSelects targets in a rectangular cuboid. The execution origin will be one corner while each of these parameters specifies the distance away from the origin to the other corner.  If any one of these parameters are specified, the others that are not specified will default to 0.\t@a[x=60,y=64,z=60,dx=5,dy=3,dz=5] will select players that are 5 blocks within the X and Z directions and 3 blocks within the Y direction of the specified coordinates.  @a[dy=50] will select players that are within 50 blocks of the execution origin in the Y direction, while also being within 0 blocks in the X and Z directions. This means the player must be at the same horizontal position of the origin, but up to 50 blocks above it. c\tChanges the maximum number of targets that can potentially be selected. The targets chosen depends on the target selector's sorting.  Note that if there are fewer available targets than the value given to the parameter, the selector will still succeed in selecting those targets.\t@a[c=5] will select, at most, the closest 5 players rather than all players. If there are only 3 players in the world, they will still be selected.  @p[c=100] will select up to the closest 100 players to the execution origin.  @r[c=3] will select up to 3 random players. type\tSelects targets based on their entity ID. This parameter cannot be used with @a or @p selectors.  Can be used with @r to target entities other than players.  The value can be negated to select targets that are not the specified entity.  Multiple of this parameter can be used to further restrict targets but only if the parameters are negated.\t@e[type=minecraft:bat] will select all bats.  @r[type=minecraft:cow] will select one random cow.  @s[type=!minecraft:player] will select the executing entity if they're not a player.  @r[type=!minecraft:sheep, type=!minecraft:chicken] will select one random entity that is not a sheep or chicken. m\tSelects players based on their game mode.  The value can be negated to select players that are not in the specified game mode.\t@a[m=survival] will select all players in survival mode.  @a[m=!creative] will select all players that are not in creative mode. tag\tSelects targets who have the specified tag (given via the /tag command).  Can be negated to select targets that do not have the specified tag.  Multiple of this parameter can be used to further restrict targets.\t@e[tag=myfriend] will select all entities with the \"myfriend\" tag.  @e[tag=!myfriend] will select all entities that do not have the \"myfriend\" tag.  @a[tag=a,tag=b,tag=!c] will select all players who have both the \"a\" and \"b\" tag, but only if they do not have the \"c\" tag. name\tSelects targets with the specified name, whether it's a player name or the custom name of an entity.  Can be negated to select targets that do not have the specified name.  Multiple of this parameter can be used but only if the extra parameters are negated.\t@a[name=PlayerName] will select all players named \"PlayerName\".  @a[name=!PlayerName] will select all players that are not named \"PlayerName\".  @e[name=!a,name=!b] will select entities that are not named \"a\" or \"b\". l, lm\tSelects players between a minimum experience level (lm) and a maximum experience level (l).  One can be specified without specifying the other.\t@a[lm=10] will select all players that have 10 or more experience levels.  @a[l=15] will select all players that have 15 or fewer experience levels.  @a[lm=10,l=15] will select all players that have an experience level between 10 and 15. rx, rxm\tSelects targets whose X rotation (pitch) is between a minimum rotation (rxm) and maximum rotation (rx). The pitch of an entity is between -90 degrees (facing straight up) and 90 degrees (facing straight down).  One can be specified without specifying the other.\t@p[rxm=45,rx=90] will select the closest player who is looking down between a 45-degree angle and a 90-degree angle.  @e[rx=-45] will select all entities that are looking up between a 45-degree angle and a 90-degree angle. ry, rym\tSelects targets whose Y rotation (yaw) is between a minimum rotation (rym) and a maximum rotation (ry). The yaw of an entity is between -180 degrees and 180 degrees.  One can be specified without specifying the other.\t@a[rym=45,ry=135] will select all players that are generally facing west.  @a[rym=-180,ry=-180] will select all players facing exactly north. scores\tSelects targets that have a particular score in an objective.  The parameter can specify multiple objectives within a set of curly brackets, with each objective separated by a comma.  A range between two inclusive values can be specified using \"..\" notation, such that \"3..7\" would check for a value between 3 and 7.  The value of a given objective can be negated to select targets who do not have a matching score value. Note that a null value is not equal to a negated value.\t@e[scores={objectiveA=3}] will select all entities that have a score of 3 in the \"objectiveA\" objective.  @a[scores={points=4,deaths=!5}] will select all players that have a \"points\" score of 4, and do not have a \"deaths\" score of 5.  @a[scores={points=10..50}] will select all players who have a \"points\" score between 10 and 50.  @a[scores={deaths=10..,points=..2}] will select all players who have a \"deaths\" score of 10 or higher and a \"points\" score of 2 or lower. family\tSelects targets who belong to the family type, as defined in an entity's minecraft:type_family component.  The value can be negated to select targets that do not belong to the family type.  Multiple of this parameter can be used to further restrict targets.\t@e[family=skeleton] will select all entities who belong to the \"skeleton\" family.  @e[family=!monster] will select all entities that do not belong to the \"monster\" family. What's Next?  Now that you've learned about target selectors, you can learn more about popular commands or about how to use command blocks to move beyond the chat window.  Commands Introduction Popular Commands Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/targetselectors?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Target Selectors 09/21/2023  Using player names as values for arguments isn't ideal for a command system that's intended to work for anyone. It's not possible to know the names of the players who will be making use of your content ahead of time. Target selectors, which can target players and other entities arbitrarily, fixes this issue.  There are 6 base selectors to pick from: @p, @a, @r, @e, @s, and @initiator. The selector to choose depends on who or what the intended target is.  @p: selects the single closest living player unless the execution origin is changed with the x, y, and z selector parameters. If the executor was a command block, the player closest to the command block would be selected since the command block's coordinates are the execution origin. @a: selects all online players, alive or not. @r: selects one random living player unless the type parameter is specified. @e: selects all entities (players, cows, dropped items, etc.) @s: selects the executing entity, which can be changed with the /execute command. @initiator: selects the player that initiates an NPC dialogue interaction.  Selectors replace a player name where possible. For example, instead of specifying a player name in the /gamemode command, a selector can be used in its place. The following would change the game mode of all players to creative mode:  Copy /gamemode creative @a   If no targets are found by the selector, the command will fail to run.  Selector parameters  Alongside the base selectors are parameters. These optional parameters help to narrow down the desired targets, such as if you wanted to only target players in adventure mode. All parameters are contained within a set of square brackets and each parameter is separated from one another with a comma. The name of the parameter is followed by an equals sign, which is then followed by the value of the parameter.  Copy @<selector>[param1=value1,param2=value2]   If the desired targets of the previous /gamemode command should instead be all players in adventure mode, the m parameter will reduce the potential targets of the selector to only those in adventure mode. A list of all parameters can be found below.  Copy /gamemode creative @a[m=adventure]   A potential target must match all specified parameters before being selected. This means that using @p[tag=sometag,m=survival] would select the closest player that has the tag \"sometag\" and is in survival mode.  List of parameters Expand table Parameter\tDescription\tExample x, y, z\tSpecifies the coordinates to find players from. Not all axes have to be specified.\tUsing @p[x=0,y=64,z=0] will select the player closest to those coordinates, rather than the player closest to the execution origin. r, rm\tSelects targets within a radius around the execution origin, unless changed by the \"x, y, z\" parameters.  r is the maximum number of blocks away from the origin to select, while rm is the minimum blocks away from the origin.  One may be specified without specifying the other.\t@p[x=0,y=64,z=0,r=1] will select a player that is 1 block away from the specified coordinates.  @a[rm=3] will select all players 3 blocks away from the execution origin.  @e[rm=3,r=10] will select all entities that are between 3 and 10 blocks of the execution origin. dx, dy, dz\tSelects targets in a rectangular cuboid. The execution origin will be one corner while each of these parameters specifies the distance away from the origin to the other corner.  If any one of these parameters are specified, the others that are not specified will default to 0.\t@a[x=60,y=64,z=60,dx=5,dy=3,dz=5] will select players that are 5 blocks within the X and Z directions and 3 blocks within the Y direction of the specified coordinates.  @a[dy=50] will select players that are within 50 blocks of the execution origin in the Y direction, while also being within 0 blocks in the X and Z directions. This means the player must be at the same horizontal position of the origin, but up to 50 blocks above it. c\tChanges the maximum number of targets that can potentially be selected. The targets chosen depends on the target selector's sorting.  Note that if there are fewer available targets than the value given to the parameter, the selector will still succeed in selecting those targets.\t@a[c=5] will select, at most, the closest 5 players rather than all players. If there are only 3 players in the world, they will still be selected.  @p[c=100] will select up to the closest 100 players to the execution origin.  @r[c=3] will select up to 3 random players. type\tSelects targets based on their entity ID. This parameter cannot be used with @a or @p selectors.  Can be used with @r to target entities other than players.  The value can be negated to select targets that are not the specified entity.  Multiple of this parameter can be used to further restrict targets but only if the parameters are negated.\t@e[type=minecraft:bat] will select all bats.  @r[type=minecraft:cow] will select one random cow.  @s[type=!minecraft:player] will select the executing entity if they're not a player.  @r[type=!minecraft:sheep, type=!minecraft:chicken] will select one random entity that is not a sheep or chicken. m\tSelects players based on their game mode.  The value can be negated to select players that are not in the specified game mode.\t@a[m=survival] will select all players in survival mode.  @a[m=!creative] will select all players that are not in creative mode. tag\tSelects targets who have the specified tag (given via the /tag command).  Can be negated to select targets that do not have the specified tag.  Multiple of this parameter can be used to further restrict targets.\t@e[tag=myfriend] will select all entities with the \"myfriend\" tag.  @e[tag=!myfriend] will select all entities that do not have the \"myfriend\" tag.  @a[tag=a,tag=b,tag=!c] will select all players who have both the \"a\" and \"b\" tag, but only if they do not have the \"c\" tag. name\tSelects targets with the specified name, whether it's a player name or the custom name of an entity.  Can be negated to select targets that do not have the specified name.  Multiple of this parameter can be used but only if the extra parameters are negated.\t@a[name=PlayerName] will select all players named \"PlayerName\".  @a[name=!PlayerName] will select all players that are not named \"PlayerName\".  @e[name=!a,name=!b] will select entities that are not named \"a\" or \"b\". l, lm\tSelects players between a minimum experience level (lm) and a maximum experience level (l).  One can be specified without specifying the other.\t@a[lm=10] will select all players that have 10 or more experience levels.  @a[l=15] will select all players that have 15 or fewer experience levels.  @a[lm=10,l=15] will select all players that have an experience level between 10 and 15. rx, rxm\tSelects targets whose X rotation (pitch) is between a minimum rotation (rxm) and maximum rotation (rx). The pitch of an entity is between -90 degrees (facing straight up) and 90 degrees (facing straight down).  One can be specified without specifying the other.\t@p[rxm=45,rx=90] will select the closest player who is looking down between a 45-degree angle and a 90-degree angle.  @e[rx=-45] will select all entities that are looking up between a 45-degree angle and a 90-degree angle. ry, rym\tSelects targets whose Y rotation (yaw) is between a minimum rotation (rym) and a maximum rotation (ry). The yaw of an entity is between -180 degrees and 180 degrees.  One can be specified without specifying the other.\t@a[rym=45,ry=135] will select all players that are generally facing west.  @a[rym=-180,ry=-180] will select all players facing exactly north. scores\tSelects targets that have a particular score in an objective.  The parameter can specify multiple objectives within a set of curly brackets, with each objective separated by a comma.  A range between two inclusive values can be specified using \"..\" notation, such that \"3..7\" would check for a value between 3 and 7.  The value of a given objective can be negated to select targets who do not have a matching score value. Note that a null value is not equal to a negated value.\t@e[scores={objectiveA=3}] will select all entities that have a score of 3 in the \"objectiveA\" objective.  @a[scores={points=4,deaths=!5}] will select all players that have a \"points\" score of 4, and do not have a \"deaths\" score of 5.  @a[scores={points=10..50}] will select all players who have a \"points\" score between 10 and 50.  @a[scores={deaths=10..,points=..2}] will select all players who have a \"deaths\" score of 10 or higher and a \"points\" score of 2 or lower. family\tSelects targets who belong to the family type, as defined in an entity's minecraft:type_family component.  The value can be negated to select targets that do not belong to the family type.  Multiple of this parameter can be used to further restrict targets.\t@e[family=skeleton] will select all entities who belong to the \"skeleton\" family.  @e[family=!monster] will select all entities that do not belong to the \"monster\" family. What's Next?  Now that you've learned about target selectors, you can learn more about popular commands or about how to use command blocks to move beyond the chat window.  Commands Introduction Popular Commands Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/functionsintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Functions 09/20/2023  Commands are powerful tools for adding logic and gameplay features. However, redstone and command blocks can be cumbersome. With function files, you can group together multiple commands into a single file and execute all of them with a single command.   Tip  Minecraft: Bedrock Edition cannot run more than 10,000 commands in one function call.  In this tutorial you will learn the following:  How to create a function file. How to use a function file in-game. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction To Behavior Packs Introduction to Commands  You will also need the following:  Your own behavior pack folder that already contains a manifest.json file. A Minecraft world with cheats enabled. Setting up the Functions Folder  Function files have a .mcfunction extension and they live in the functions folder of your behavior pack.  Start by creating a folder inside your behavior pack and name it functions. This folder should be on the same level as your manifest.json file.  Open the functions folder and create a text file.  Name the file ouch.mcfunction.  Open the file, then copy and paste the following code into it:  JSON Copy say Bye... playsound random.explode teleport @s ~10 ~10 ~10 true say OUCH!   Save the file.   Important  When working with commands in a .mcfunction file, you do not need to start commands with the leading slash /.  Testing the function Launch Minecraft. Open a world with cheats enabled and the behavior pack you created applied to it. Enter /function ouch. Advanced function feature  You can place functions inside directories to organize them and to avoid conflicts with functions in other behavior packs.  For example, if you have another folder inside your functions folder called init and you put ouch.mcfunction in there, you would run it like this: /function init/ouch  What's Next?  Now that you have an overview of how a function file works, you can learn how to use the in-game tick function and a tick.json file to fire off custom functions on repeat.  Tick.json Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/functionsintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Functions 09/20/2023  Commands are powerful tools for adding logic and gameplay features. However, redstone and command blocks can be cumbersome. With function files, you can group together multiple commands into a single file and execute all of them with a single command.   Tip  Minecraft: Bedrock Edition cannot run more than 10,000 commands in one function call.  In this tutorial you will learn the following:  How to create a function file. How to use a function file in-game. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction To Behavior Packs Introduction to Commands  You will also need the following:  Your own behavior pack folder that already contains a manifest.json file. A Minecraft world with cheats enabled. Setting up the Functions Folder  Function files have a .mcfunction extension and they live in the functions folder of your behavior pack.  Start by creating a folder inside your behavior pack and name it functions. This folder should be on the same level as your manifest.json file.  Open the functions folder and create a text file.  Name the file ouch.mcfunction.  Open the file, then copy and paste the following code into it:  JSON Copy say Bye... playsound random.explode teleport @s ~10 ~10 ~10 true say OUCH!   Save the file.   Important  When working with commands in a .mcfunction file, you do not need to start commands with the leading slash /.  Testing the function Launch Minecraft. Open a world with cheats enabled and the behavior pack you created applied to it. Enter /function ouch. Advanced function feature  You can place functions inside directories to organize them and to avoid conflicts with functions in other behavior packs.  For example, if you have another folder inside your functions folder called init and you put ouch.mcfunction in there, you would run it like this: /function init/ouch  What's Next?  Now that you have an overview of how a function file works, you can learn how to use the in-game tick function and a tick.json file to fire off custom functions on repeat.  Tick.json Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tickjsonintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to tick.json 09/20/2023  While command blocks are great for running a series of commands based on in-game events, Minecraft: Bedrock Edition offers the ability to use the in-game tick function to repeatedly run a series of functions by using a file called tick.json. tick.json is stored in the functions folder of a behavior pack next to the files containing the functions you want to run.   Note  tick.json uses the gameplay tick which is 20 ticks per second, as opposed to the redstone tick which is 10 ticks per second.   Important  Unlike repeating command blocks, tick.json will execute commands before the world has fully loaded in. This might cause unintended behavior if you do not plan function usage carefully. Be cautious not to run too many commands every tick, as it could affect performance, especially in low-end devices.  In this tutorial you will learn the following:  How to create the tick.json file How to use tick.json to run functions. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction To Behavior Packs Introduction to Commands Introduction to Functions  You will also need the following:  Your own behavior pack folder that already contains a manifest.json file. A Minecraft world with cheats enabled. Setting up the Functions Folder  The tick.json file contains the names of functions that you want to run every tick. Before creating tick.json, you will need to have functions for it to run. This example creates two function files to demonstrate how tick.json calls the files repeatedly.  If you don't already have one create a folder inside your behavior pack and name it functions. This folder should be on the same level as your manifest.json file. Open the functions folder and create a text file. Name the file function_say_one.mcfunction. Open the file and enter say one on the first line. Save the file. Create another function file and name it function_say_two.mcfunction. Open the file and enter say two on the first line. Save the file.  Now there are two files for tick.json to call.  Creating tick.json  The tick.json file contains a list of the functions that you want to execute on every tick of the game. You can also set the order that the functions will be called.  Inside the functions folder, create a text file and name it tick.json. Copy the following text and paste it into your tick.json file. Save the file. JSON Copy  {     \"values\": [         \"function_say_one\", \"function_say_two\"     ]   }   The tick.json file uses only the values key, and the values are the names of the functions to run, without the .mcfunction extension.  Testing the file  Launch Minecraft and activate the behavior pack. When the world loads, there will be repeated messages displayed on the screen from [Server].   Note  tick.json files are additive and multiple will run if they exist in multiple behavior packs. For example, if the behavior pack stack has multiple behavior packs, all functions in tick.json will be run every tick.  What's Next?  Block JSON Documentation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tickjsonintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to tick.json 09/20/2023  While command blocks are great for running a series of commands based on in-game events, Minecraft: Bedrock Edition offers the ability to use the in-game tick function to repeatedly run a series of functions by using a file called tick.json. tick.json is stored in the functions folder of a behavior pack next to the files containing the functions you want to run.   Note  tick.json uses the gameplay tick which is 20 ticks per second, as opposed to the redstone tick which is 10 ticks per second.   Important  Unlike repeating command blocks, tick.json will execute commands before the world has fully loaded in. This might cause unintended behavior if you do not plan function usage carefully. Be cautious not to run too many commands every tick, as it could affect performance, especially in low-end devices.  In this tutorial you will learn the following:  How to create the tick.json file How to use tick.json to run functions. Requirements  It's recommended that the following be completed before beginning this tutorial:  Introduction To Behavior Packs Introduction to Commands Introduction to Functions  You will also need the following:  Your own behavior pack folder that already contains a manifest.json file. A Minecraft world with cheats enabled. Setting up the Functions Folder  The tick.json file contains the names of functions that you want to run every tick. Before creating tick.json, you will need to have functions for it to run. This example creates two function files to demonstrate how tick.json calls the files repeatedly.  If you don't already have one create a folder inside your behavior pack and name it functions. This folder should be on the same level as your manifest.json file. Open the functions folder and create a text file. Name the file function_say_one.mcfunction. Open the file and enter say one on the first line. Save the file. Create another function file and name it function_say_two.mcfunction. Open the file and enter say two on the first line. Save the file.  Now there are two files for tick.json to call.  Creating tick.json  The tick.json file contains a list of the functions that you want to execute on every tick of the game. You can also set the order that the functions will be called.  Inside the functions folder, create a text file and name it tick.json. Copy the following text and paste it into your tick.json file. Save the file. JSON Copy  {     \"values\": [         \"function_say_one\", \"function_say_two\"     ]   }   The tick.json file uses only the values key, and the values are the names of the functions to run, without the .mcfunction extension.  Testing the file  Launch Minecraft and activate the behavior pack. When the world loads, there will be repeated messages displayed on the screen from [Server].   Note  tick.json files are additive and multiple will run if they exist in multiple behavior packs. For example, if the behavior pack stack has multiple behavior packs, all functions in tick.json will be run every tick.  What's Next?  Block JSON Documentation  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsdamageintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to the Damage Command 09/20/2023  The /damage command allows users to deal damage to a specified entity from a specified source. For example, you can deal fire damage to a creeper or fall damage to a zombie. This feature provides a more direct and controlled way to apply damage when compared to other methods, such as spawning in arrows.  In this tutorial you will learn the following:  What the /damage command is and how to use it Special use cases and exceptions Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Syntax of the Damage Command  The damage command can be called in two ways.  Copy /damage <target> <amount> [cause]  Copy /damage <target> <amount> <cause> entity <damager>   target is a selector. It determines the entities that will receive the damage.  amount is an integer. This is the amount of damage that will be dealt.  cause determines what kind of damage will be dealt. This can affect the death message, and some targets may resist or ignore certain damage causes  For example, helmets reduce stalactite damage, and cats are immune to fall damage. Cause must be one of anvil, block_explosion, charging, contact, drowning, entity_attack, entity_explosion, fall, falling_block, fire, fire_tick, fireworks, fly_into_wall, freezing, lava, lightning, magic, magma, none, override, piston, projectile, self-destruct, stalactite, stalagmite, starve, suffocation, temperature, thorns, void, wither.  damager is a selector that must evaluate to one entity. It determines which entity will be treated as dealing the damage to the target. For example, a damaged zombified piglin will get angry at this entity.  If specified, the target will also take knockback such that they are pushed away from the damager, no matter the distance between the two entities. In peaceful difficulty, the player will ignore all damage if the damager is a mob. Special use cases  Because both the damage and source follow the damage rules specified in behavior packs, there are some unique use cases that may not deal damage, or may deal damage when it would be expected they shouldn't.  If the affected entity has a damage_sensor component, the damage dealt by this command will activate it when applicable. The presence or absence of this behavior on vanilla mobs may make some situations unintuitive. Here are a few examples:  Drowning damage  drowning damage can still be dealt to aquatic and undead mobs. This is because while they can breathe underwater, they are not immune to drowning damage itself.  Zombie conversion  A villager may receive damage from a zombie or husk, but will only transform into a zombie if the damage was fatal.  Drowning zombies  Dealing drowning damage does not turn zombies and husks into Drowned. This is because the check to change something to a Drowned is based on the amount of time underwater, not the amount of damage dealt.  Glow squid glow  A glow squid will stop glowing and emit ink when damaged, but only if there was a damage source.  This logic also applies to the glow squid and squids inking behavior. If the damage applied has no source, it will not \"ink\".  Slow falling  The player receives fall damage by using the /damage command when the Slow Falling status effect is applied. The Slow Falling status effect does not prevent fall damage explicitly, so it would not prevent the Damage Command from applying damage.  What's Next?  There are more commands out there for you to use to unleash mayhem upon your world - or use to make things nice. It's up to you.  Popular Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsdamageintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to the Damage Command 09/20/2023  The /damage command allows users to deal damage to a specified entity from a specified source. For example, you can deal fire damage to a creeper or fall damage to a zombie. This feature provides a more direct and controlled way to apply damage when compared to other methods, such as spawning in arrows.  In this tutorial you will learn the following:  What the /damage command is and how to use it Special use cases and exceptions Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Syntax of the Damage Command  The damage command can be called in two ways.  Copy /damage <target> <amount> [cause]  Copy /damage <target> <amount> <cause> entity <damager>   target is a selector. It determines the entities that will receive the damage.  amount is an integer. This is the amount of damage that will be dealt.  cause determines what kind of damage will be dealt. This can affect the death message, and some targets may resist or ignore certain damage causes  For example, helmets reduce stalactite damage, and cats are immune to fall damage. Cause must be one of anvil, block_explosion, charging, contact, drowning, entity_attack, entity_explosion, fall, falling_block, fire, fire_tick, fireworks, fly_into_wall, freezing, lava, lightning, magic, magma, none, override, piston, projectile, self-destruct, stalactite, stalagmite, starve, suffocation, temperature, thorns, void, wither.  damager is a selector that must evaluate to one entity. It determines which entity will be treated as dealing the damage to the target. For example, a damaged zombified piglin will get angry at this entity.  If specified, the target will also take knockback such that they are pushed away from the damager, no matter the distance between the two entities. In peaceful difficulty, the player will ignore all damage if the damager is a mob. Special use cases  Because both the damage and source follow the damage rules specified in behavior packs, there are some unique use cases that may not deal damage, or may deal damage when it would be expected they shouldn't.  If the affected entity has a damage_sensor component, the damage dealt by this command will activate it when applicable. The presence or absence of this behavior on vanilla mobs may make some situations unintuitive. Here are a few examples:  Drowning damage  drowning damage can still be dealt to aquatic and undead mobs. This is because while they can breathe underwater, they are not immune to drowning damage itself.  Zombie conversion  A villager may receive damage from a zombie or husk, but will only transform into a zombie if the damage was fatal.  Drowning zombies  Dealing drowning damage does not turn zombies and husks into Drowned. This is because the check to change something to a Drowned is based on the amount of time underwater, not the amount of damage dealt.  Glow squid glow  A glow squid will stop glowing and emit ink when damaged, but only if there was a damage source.  This logic also applies to the glow squid and squids inking behavior. If the damage applied has no source, it will not \"ink\".  Slow falling  The player receives fall damage by using the /damage command when the Slow Falling status effect is applied. The Slow Falling status effect does not prevent fall damage explicitly, so it would not prevent the Damage Command from applying damage.  What's Next?  There are more commands out there for you to use to unleash mayhem upon your world - or use to make things nice. It's up to you.  Popular Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tickingareacommand?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Ticking Areas 09/20/2023  Minecraft time passes (typically) only in the chunks of the world where there is a player. The chunk of area around a player is where time passes in ticks, so we call this a \"ticking area.\" In this area, crops grow, mobs spawn, and command blocks function as intended. But when the player leaves the ticking area, time stops. Crops don't grow, mobs won't spawn, and command blocks stop functioning. If you want command block to work all the time, no matter where players are, you can use the /tickingarea command.  In this tutorial you will learn the following:  How to create a ticking area. How to find out what ticking areas have been created. What it means if a ticking area is preloaded. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Introduction to Command Blocks  You will need a Minecraft world with cheats enabled and coordinates shown.  add  Ticking areas are not made up of blocks - they are made up of the chunks Minecraft uses to create worlds.  When you use the /tickingarea add ... command, it uses the parameters you give it to draw a shape that extends all the way up and all the way down from where you place it - like a column. But, you won't actually see the shape in the game, so it's like an imaginary column. Any chunks that are touched by this column are included in the ticking area. This chunk, or collection of chunks, is then saved with a name that you give it as a ticking area.  You can have up to 10 ticking areas in one world and you can keep track of them by name or by their coordinates.  There are two ways to draw the shapes used to add a ticking area:  /tickingarea add <from: x y z> <to: x y z> [name: string] This one draws an imaginary square, rectangle, or cube - depending on what coordinates you give it. Remember: the y coordinate doesn't really matter because the shape extends upwards and downwards to the boundaries of your world.  /tickingarea add circle <center: x y z> <radius> int> [name: string] This one draws an imaginary circle with a maximum radius of 4.  Before you add a ticking area, give yourself a command block that gives you an emerald once every 15 ticks.  Note the coordinates of the command block.  Travel in one direction away from the command block until you notice the command stops. This means you have traveled out of the chunk containing the command block.  Add a ticking area around the command block's coordinates. If you placed the command block at 0 72 0, then you could use /tickingarea add circle 0 72 0 3 emerald_block.  You will start getting emeralds again.  list  To see a list of all of the ticking areas in a world, use:  /tickingarea list [all-dimensions]  remove  To remove a ticking area from the game use:  Copy /tickingarea remove <name:string>   or  Copy /tickingarea remove <position x y z>  remove_all  To remove all of the ticking areas from the game use:  Copy /tickingarea remove_all  Preloaded ticking areas  Ticking areas typically load after the world containing them is launched, unless you use the preload overload. This could be a useful tool for you if you're having problems with the order things are loading into a world.  Like the tickingarea add command, there are two syntaxes for the preload overload: one taking a position and one taking an area name.  Copy /tickingarea preload <position> [optional preload value]   /tickingarea preload <area name> [optional preload value]    If the optional preload value is not specified, then the command queries the current preload value. This will print out the ticking area info as well as message with a count of how many matching areas area marked with preload.  For /tickingarea add..., there is an option value to specify that the new area should preload, for both the box and circle variants.  Copy /tickingarea add <min position> <max position> [optional name] [optional preload value]   /tickingarea add circle <center position> <radius in chunks> [optional name] [optional preload value]  Using the Schedule command with a ticking area  Creators can use the /schedule command to make the game wait for chunks and entities to be loaded before executing a series of commands, such as those configured in a ticking area. This is important for our creators so that they can know when they can run their commands in each area.  Syntax of the /schedule command Copy /schedule on_area_loaded add <from: x y z> <to: x y z> <function:filepath>   /schedule on_area_loaded add circle <center: x y z> <radius: int> <function: filepath>   /schedule on_area_loaded add tickingarea <name: string> <function: filepath>  What's Next?  Now that you have learned more about ticking areas, you could learn more about scoreboard operations or create a Complete the Monument challenge.  Scoreboard Operations Tutorial Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tickingareacommand?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Ticking Areas 09/20/2023  Minecraft time passes (typically) only in the chunks of the world where there is a player. The chunk of area around a player is where time passes in ticks, so we call this a \"ticking area.\" In this area, crops grow, mobs spawn, and command blocks function as intended. But when the player leaves the ticking area, time stops. Crops don't grow, mobs won't spawn, and command blocks stop functioning. If you want command block to work all the time, no matter where players are, you can use the /tickingarea command.  In this tutorial you will learn the following:  How to create a ticking area. How to find out what ticking areas have been created. What it means if a ticking area is preloaded. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Commands Introduction to Command Blocks  You will need a Minecraft world with cheats enabled and coordinates shown.  add  Ticking areas are not made up of blocks - they are made up of the chunks Minecraft uses to create worlds.  When you use the /tickingarea add ... command, it uses the parameters you give it to draw a shape that extends all the way up and all the way down from where you place it - like a column. But, you won't actually see the shape in the game, so it's like an imaginary column. Any chunks that are touched by this column are included in the ticking area. This chunk, or collection of chunks, is then saved with a name that you give it as a ticking area.  You can have up to 10 ticking areas in one world and you can keep track of them by name or by their coordinates.  There are two ways to draw the shapes used to add a ticking area:  /tickingarea add <from: x y z> <to: x y z> [name: string] This one draws an imaginary square, rectangle, or cube - depending on what coordinates you give it. Remember: the y coordinate doesn't really matter because the shape extends upwards and downwards to the boundaries of your world.  /tickingarea add circle <center: x y z> <radius> int> [name: string] This one draws an imaginary circle with a maximum radius of 4.  Before you add a ticking area, give yourself a command block that gives you an emerald once every 15 ticks.  Note the coordinates of the command block.  Travel in one direction away from the command block until you notice the command stops. This means you have traveled out of the chunk containing the command block.  Add a ticking area around the command block's coordinates. If you placed the command block at 0 72 0, then you could use /tickingarea add circle 0 72 0 3 emerald_block.  You will start getting emeralds again.  list  To see a list of all of the ticking areas in a world, use:  /tickingarea list [all-dimensions]  remove  To remove a ticking area from the game use:  Copy /tickingarea remove <name:string>   or  Copy /tickingarea remove <position x y z>  remove_all  To remove all of the ticking areas from the game use:  Copy /tickingarea remove_all  Preloaded ticking areas  Ticking areas typically load after the world containing them is launched, unless you use the preload overload. This could be a useful tool for you if you're having problems with the order things are loading into a world.  Like the tickingarea add command, there are two syntaxes for the preload overload: one taking a position and one taking an area name.  Copy /tickingarea preload <position> [optional preload value]   /tickingarea preload <area name> [optional preload value]    If the optional preload value is not specified, then the command queries the current preload value. This will print out the ticking area info as well as message with a count of how many matching areas area marked with preload.  For /tickingarea add..., there is an option value to specify that the new area should preload, for both the box and circle variants.  Copy /tickingarea add <min position> <max position> [optional name] [optional preload value]   /tickingarea add circle <center position> <radius in chunks> [optional name] [optional preload value]  Using the Schedule command with a ticking area  Creators can use the /schedule command to make the game wait for chunks and entities to be loaded before executing a series of commands, such as those configured in a ticking area. This is important for our creators so that they can know when they can run their commands in each area.  Syntax of the /schedule command Copy /schedule on_area_loaded add <from: x y z> <to: x y z> <function:filepath>   /schedule on_area_loaded add circle <center: x y z> <radius: int> <function: filepath>   /schedule on_area_loaded add tickingarea <name: string> <function: filepath>  What's Next?  Now that you have learned more about ticking areas, you could learn more about scoreboard operations or create a Complete the Monument challenge.  Scoreboard Operations Tutorial Create an In-World Game  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsnewexecute?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn New execute command support in Minecraft version 1.19.70 10/25/2023  We're working on a new, extended version of Minecraft's /execute command. Starting with version 1.19.70, we're introducing the next step for the /execute command, which moves the command in Minecraft: Bedrock Edition towards parity with Java edition. This move also adds new functionality for creators. In this article, you'll see upcoming changes for the /execute command, the new powers it will bring, and how you can get started.  What the /execute command does today  The /execute command lies at the heart of gameplay for many more advanced add-ons in Minecraft. If you're not familiar with execute, the execute command does three very powerful things:  It allows you to run a subcommand from the perspective of multiple entities within the world. One command becomes many! For example, run a command for every one of 20 skeletons near to a location.  When a command runs as an individual entity, all selectors and relative locations run from the perspective of that entity. This means that when you run a command for every nearby skeleton, you can manipulate the world next to every individual skeleton.  You can also express additional conditions for whether those commands will execute, such as the state of blocks close to the entity. For example, you can run a command for skeletons only if a skeleton is standing on dirt.  If you have development experience, it might be helpful to think about the execute command as being somewhat like a foreach (<criteria of entities to select>) { if (<additional criteria>) run <command> } loop. It provides a way to run a command across a wide range of entities that you can select and filter.  How we're updating the execute command  The biggest news is that with the 1.19.70 update, how the command works will fundamentally shift over to adopt Java edition syntax, with new keywords such as as, at, and if. This also gives the command much more room to add new capabilities moving forward.  With this foundation in place, the new command will have additional capabilities, such as:  The ability to use score as a conditional for how commands execute. For example, you can run commands for players based on what their score might be. New flexibility on how you can test for the state of blocks nearby to an entity through the use of multiple if and unless statements.  Note that the /execute command does not have full parity with Java Edition's /execute command, yet. The new Bedrock Edition /execute command does not support storing the results of commands or working with conditions based on the rotation of entities, for example. Stay tuned for more to come with the /execute command.  Getting started with the new execute command  Let's create a world that can use the new /execute syntax and explore some of the new features.  Use version 1.19.70 or higher  To get started, you'll want to use version 1.19.70 or higher of Minecraft. One of the best ways to get the latest versions of Minecraft is to download Minecraft Preview, which is available from the Xbox store on Windows as well as available on iOS and Xbox. See more on Minecraft Preview here.  IMPORTANT: If you have commands in command blocks that were written with the older Bedrock-specific syntax, those commands will continue to work like they always have. However, if you decide to edit those command blocks, you will need to rewrite the command to have the newer syntax.  Update a Behavior Pack to version 1.19.70  Commands are also very commonly used within Behavior Packs. To opt into the new Command Syntax, you'll need a minimum engine version (min_engine_version) of 1.19.70 expressed within your behavior pack's manifest.json file. This will enable the new execute command syntax in your MCFunctions, tick.json files, and more within your behavior pack.  Major syntax changes and their equivalents  Let's dig into the updated new command syntax in 1.19.70 and how you can upgrade existing commands to the new syntax.  Summon a salmon for every fox  In the older Minecraft: Bedrock Edition syntax, commands are expressed in the following form:  (earlier /execute command syntax): execute @e[type=fox] ^ ^ ^ summon salmon ^ ^1 ^  This command will select entities of type fox (@e[type=fox]), and then, at a position above those respective foxes' heads, (^ ^1 ^) will summon salmon for those foxes to consider.  Note that in this screenshot, three salmon were spawned next to the three nearby foxes.  In the new Minecraft execute command syntax, commands are expressed in a more structured form and the command is more readable. The equivalent command is:  (new /execute command syntax): execute as @e[type=fox] positioned as @s run summon salmon ^ ^1 ^  Let's break this down:  The as @e[type=fox] segment is where you can select which entities to run the subsequent command as. The positioned as @s segment helps you determine the positioning of the command. positioned as @s means, in this case, run it as the selected entity. This gives you more flexibility in how you position the result of your command.  For example, if you wanted to spawn the salmon close to the nearest player, rather than right next to the fox, you could do that with a positioned as @p - in other words, position to the nearest player - segment.  The run summon salmon ^ ^1 ^ command is where you can determine the exact command to run. Detect blocks around an entity as a conditional  The older Minecraft execute command also supported a very basic conditional functionality for detecting blocks around an entity.  With this command:  (earlier /execute command syntax): execute @e[type=fox] ^ ^ ^ detect ^ ^-1 ^ stone 0 summon salmon  This variant of the execute command will only run for foxes (@e[type=fox]) that are stepping on stone (detect ^ ^-1 ^ stone 0). ^ ^-1 ^ in this context will check to see if the block at y=-1 (underneath) the fox is a basic variant of type stone (stone 0).  With the newer syntax, the execute command is a bit longer, but also more explanatory with room for expansion in the future:  (newer /execute command syntax): execute as @e[type=fox] positioned as @s if block ^ ^-1 ^ stone 0 run summon salmon  This is the same as the command before, but notice the new if block ^ ^-1 ^ stone 0 subcommand. This new subcommand basically says that if the block underneath (^ ^-1 ^) the selected entities (foxes) is the basic variant of stone (stone 0), then only run the command in that condition.  And this gives the same result as before:   Note that the command summoned the salmon for the fox standing on stone, but the block test failed for the other two foxes not standing on stone. So, no salmon for them!  But wait, there's more  With this new foundation, the execute command is positioned to support more flexible conditional queries.  The new execute syntax supports both an if and an unless semantic. The if subcommand will only let commands run if a certain criteria is met, as you've seen above with the execute if block example. The unless variant is the opposite: commands will run for as long as certain criteria are not met.  Importantly, note that you can add multiple if and unless statements to a command. For example, you can run a command if a fox is stepping on stone and unless there is a nearby chicken, by adding both an if and an unless subvariant to your execute command.  There are additional query types, as well:  /execute (if/unless) blocks This blocks variant of the execute if command will check to see if a volume of blocks matches a source set of blocks.  /execute (if/unless) entity The entity variant will allow you to exercise an entity selector. In the case of execute if entity, the condition is satisfied if at least one entity matches your criteria. In the case of execute unless entity, the condition is satisfied for as long as no entities match your criteria. For example, you could give a fox salmon unless there is a nearby chicken.  /execute (if/unless) score The score variant, typically used in conjunction with player selectors, will only run a command if a score matches a criteria. For example, if score @s teamFlags matches 3 run say @s You win! will only run if a players' score for teamFlags matches 3. With the score command you can also compare the score for multiple entities as well (e.g, between player A and player B, run a command only for a player with the highest score.)  Summing up  With new flexibility in the /execute command, you can now express more sophisticated game logic across your command blocks, MCFunctions, and more!  Please open any bugs or issues via our Report a Bug tool, or log an issue in our GitHub repository at https://github.com/MicrosoftDocs/minecraft-creator.  Thank you for taking a look at new /execute command functionality!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/commandsnewexecute?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn New execute command support in Minecraft version 1.19.70 10/25/2023  We're working on a new, extended version of Minecraft's /execute command. Starting with version 1.19.70, we're introducing the next step for the /execute command, which moves the command in Minecraft: Bedrock Edition towards parity with Java edition. This move also adds new functionality for creators. In this article, you'll see upcoming changes for the /execute command, the new powers it will bring, and how you can get started.  What the /execute command does today  The /execute command lies at the heart of gameplay for many more advanced add-ons in Minecraft. If you're not familiar with execute, the execute command does three very powerful things:  It allows you to run a subcommand from the perspective of multiple entities within the world. One command becomes many! For example, run a command for every one of 20 skeletons near to a location.  When a command runs as an individual entity, all selectors and relative locations run from the perspective of that entity. This means that when you run a command for every nearby skeleton, you can manipulate the world next to every individual skeleton.  You can also express additional conditions for whether those commands will execute, such as the state of blocks close to the entity. For example, you can run a command for skeletons only if a skeleton is standing on dirt.  If you have development experience, it might be helpful to think about the execute command as being somewhat like a foreach (<criteria of entities to select>) { if (<additional criteria>) run <command> } loop. It provides a way to run a command across a wide range of entities that you can select and filter.  How we're updating the execute command  The biggest news is that with the 1.19.70 update, how the command works will fundamentally shift over to adopt Java edition syntax, with new keywords such as as, at, and if. This also gives the command much more room to add new capabilities moving forward.  With this foundation in place, the new command will have additional capabilities, such as:  The ability to use score as a conditional for how commands execute. For example, you can run commands for players based on what their score might be. New flexibility on how you can test for the state of blocks nearby to an entity through the use of multiple if and unless statements.  Note that the /execute command does not have full parity with Java Edition's /execute command, yet. The new Bedrock Edition /execute command does not support storing the results of commands or working with conditions based on the rotation of entities, for example. Stay tuned for more to come with the /execute command.  Getting started with the new execute command  Let's create a world that can use the new /execute syntax and explore some of the new features.  Use version 1.19.70 or higher  To get started, you'll want to use version 1.19.70 or higher of Minecraft. One of the best ways to get the latest versions of Minecraft is to download Minecraft Preview, which is available from the Xbox store on Windows as well as available on iOS and Xbox. See more on Minecraft Preview here.  IMPORTANT: If you have commands in command blocks that were written with the older Bedrock-specific syntax, those commands will continue to work like they always have. However, if you decide to edit those command blocks, you will need to rewrite the command to have the newer syntax.  Update a Behavior Pack to version 1.19.70  Commands are also very commonly used within Behavior Packs. To opt into the new Command Syntax, you'll need a minimum engine version (min_engine_version) of 1.19.70 expressed within your behavior pack's manifest.json file. This will enable the new execute command syntax in your MCFunctions, tick.json files, and more within your behavior pack.  Major syntax changes and their equivalents  Let's dig into the updated new command syntax in 1.19.70 and how you can upgrade existing commands to the new syntax.  Summon a salmon for every fox  In the older Minecraft: Bedrock Edition syntax, commands are expressed in the following form:  (earlier /execute command syntax): execute @e[type=fox] ^ ^ ^ summon salmon ^ ^1 ^  This command will select entities of type fox (@e[type=fox]), and then, at a position above those respective foxes' heads, (^ ^1 ^) will summon salmon for those foxes to consider.  Note that in this screenshot, three salmon were spawned next to the three nearby foxes.  In the new Minecraft execute command syntax, commands are expressed in a more structured form and the command is more readable. The equivalent command is:  (new /execute command syntax): execute as @e[type=fox] positioned as @s run summon salmon ^ ^1 ^  Let's break this down:  The as @e[type=fox] segment is where you can select which entities to run the subsequent command as. The positioned as @s segment helps you determine the positioning of the command. positioned as @s means, in this case, run it as the selected entity. This gives you more flexibility in how you position the result of your command.  For example, if you wanted to spawn the salmon close to the nearest player, rather than right next to the fox, you could do that with a positioned as @p - in other words, position to the nearest player - segment.  The run summon salmon ^ ^1 ^ command is where you can determine the exact command to run. Detect blocks around an entity as a conditional  The older Minecraft execute command also supported a very basic conditional functionality for detecting blocks around an entity.  With this command:  (earlier /execute command syntax): execute @e[type=fox] ^ ^ ^ detect ^ ^-1 ^ stone 0 summon salmon  This variant of the execute command will only run for foxes (@e[type=fox]) that are stepping on stone (detect ^ ^-1 ^ stone 0). ^ ^-1 ^ in this context will check to see if the block at y=-1 (underneath) the fox is a basic variant of type stone (stone 0).  With the newer syntax, the execute command is a bit longer, but also more explanatory with room for expansion in the future:  (newer /execute command syntax): execute as @e[type=fox] positioned as @s if block ^ ^-1 ^ stone 0 run summon salmon  This is the same as the command before, but notice the new if block ^ ^-1 ^ stone 0 subcommand. This new subcommand basically says that if the block underneath (^ ^-1 ^) the selected entities (foxes) is the basic variant of stone (stone 0), then only run the command in that condition.  And this gives the same result as before:   Note that the command summoned the salmon for the fox standing on stone, but the block test failed for the other two foxes not standing on stone. So, no salmon for them!  But wait, there's more  With this new foundation, the execute command is positioned to support more flexible conditional queries.  The new execute syntax supports both an if and an unless semantic. The if subcommand will only let commands run if a certain criteria is met, as you've seen above with the execute if block example. The unless variant is the opposite: commands will run for as long as certain criteria are not met.  Importantly, note that you can add multiple if and unless statements to a command. For example, you can run a command if a fox is stepping on stone and unless there is a nearby chicken, by adding both an if and an unless subvariant to your execute command.  There are additional query types, as well:  /execute (if/unless) blocks This blocks variant of the execute if command will check to see if a volume of blocks matches a source set of blocks.  /execute (if/unless) entity The entity variant will allow you to exercise an entity selector. In the case of execute if entity, the condition is satisfied if at least one entity matches your criteria. In the case of execute unless entity, the condition is satisfied for as long as no entities match your criteria. For example, you could give a fox salmon unless there is a nearby chicken.  /execute (if/unless) score The score variant, typically used in conjunction with player selectors, will only run a command if a score matches a criteria. For example, if score @s teamFlags matches 3 run say @s You win! will only run if a players' score for teamFlags matches 3. With the score command you can also compare the score for multiple entities as well (e.g, between player A and player B, run a command only for a player with the highest score.)  Summing up  With new flexibility in the /execute command, you can now express more sophisticated game logic across your command blocks, MCFunctions, and more!  Please open any bugs or issues via our Report a Bug tool, or log an issue in our GitHub repository at https://github.com/MicrosoftDocs/minecraft-creator.  Thank you for taking a look at new /execute command functionality!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptinggettingstarted?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Build a gameplay experience with TypeScript 04/17/2025  This guide leverages a starter sample available on our public GitHub repository with a simple build process and TypeScript compilation for Minecraft. From it, you can build out and expand simple gameplay styles. You can also use this project as a starter for your own scripting projects.   Important  Just getting started with JavaScript? You may want to check out Introduction to Scripting to learn the basics of creating a simple behavior pack using JavaScript fundamentals. Once you're comfortable with the JavaScript fundamentals and concepts, this article will help you use TypeScript with Minecraft for more complex customization. TypeScript is a more helpfully structured dialect of JavaScript; however, because TypeScript must be compiled into JavaScript before Minecraft can use it, there is a bit more project structure you'll need to establish up front that this tutorial will walk you through.  On the Minecraft Creator Channel  If you prefer to watch a video version of this tutorial, you can view it on the Minecraft Creator Channel, available here.  Prerequisites Install Node.js tools, if you haven't already  We're going to use the Node Package Manager (or NPM) to get more tools to make the process of building our project easier.  Visit https://nodejs.org/.  Download the version with \"LTS\" next to the number and install it. (LTS stands for Long Term Support, if you're curious.) You do not need to install any additional tools for Native compilation.  Install Visual Studio Code, if you haven't already  Visit the Visual Studio Code website and install Visual Studio Code.  Getting Started  Download a copy of the starter project from GitHub by visiting https://github.com/microsoft/minecraft-scripting-samples/ and, under the Code button, selecting Download ZIP.  The ts-starter folder contains a starter TypeScript project for Minecraft. Note that there is a ts-starter-complete-cotta folder that will show you the finished product and code.  To make your own environment look like the example, create a folder on your C:\\ drive and call it projects. Create a subfolder called cotta.  Put the extracted contents of the TypeScript Starter Project folder into cotta.  Open a Windows Terminal or PowerShell window and change the working directory to your cotta folder:  PowerShell Copy cd c:\\projects\\cotta\\   Use NPM to install our tools:  PowerShell Copy npm i   Use this shortcut command to open the project in Visual Studio Code:  PowerShell Copy code .   It might also ask you to install the Minecraft Debugger and Blockception's Visual Studio Code plugin, which are plugins to Visual Studio Code that can help with Minecraft development. Go ahead and do that, if you haven't already.  Chapter 1. Customize the behavior pack  In Visual Studio Code, open the file .env. This contains the environment variables to use to configure project:  Copy PROJECT_NAME=\"starter\" MINECRAFT_PRODUCT=\"BedrockUWP\" CUSTOM_DEPLOYMENT_PATH=\"\"   PROJECT_NAME is used as the folder name under all the assets are going to be deployed inside the game directories (e.g., development_behavior_packs\\PROJECT_NAME, development_resource_packs\\PROJECT_NAME).  MINECRAFT_PRODUCT. You can choose to use either Minecraft or Minecraft Preview to debug and work with your scripts. These are the possible values: BedrockUWP, PreviewUWP, Custom. Use Custom in case of deploy on any other path.  CUSTOM_DEPLOYMENT_PATH. In case of using Custom for MINECRAFT_PRODUCT, this is the path used to generate the assets.  Go back the Files tree view and open behavior_packs\\cotta\\manifest.json  Update the name and description properties to something like \"Cotta Behavior Pack\" and \"My TypeScript Project\".  Update the first and second UUID properties to make it unique to your project. See this article for tips on working with behavior packs and creating your own unique UUIDs.  Chapter 2. Let's test the parts of our project  To get started, go into PowerShell and navigate to your C:\\projects\\cotta directory. Run this command:  PowerShell Copy Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass   Run this one, too.  PowerShell Copy npm run local-deploy   This uses a build tool called just-scripts and automatically compiles your TypeScript project and pushes it over into Minecraft.  Launch Minecraft and create a new world:  Call it Cotta Test. Select a Creative game mode. Select a Flat world option, under the Advanced section of the Create New World screen. Under Behavior Packs, under Available, you should see your Cotta Behavior Pack. Select it and Activate it. Create the world and go into it.  Now you're in. Great!  By default, this starter pack comes with a simple script that will display a message every five seconds:  [Script Engine] Hello starter! Tick: <number>  This means your behavior pack is working and your tools for compiling and pushing TypeScript are just fine. Awesome!  Chapter 3. Scripting your gameplay  Let's go back to Visual Studio Code and change up some code.  Open up scripts/main.ts within Visual Studio Code.  Add some initialization code  Remove all the existing script code in main.ts. Replace it with this to start:  TypeScript Copy import { world, system, BlockPermutation, EntityInventoryComponent, ItemStack, DisplaySlotId } from \"@minecraft/server\";  const START_TICK = 100; const ARENA_X_SIZE = 30; const ARENA_Z_SIZE = 30; const ARENA_X_OFFSET = 0; const ARENA_Y_OFFSET = -60; const ARENA_Z_OFFSET = 0;  // global variables let curTick = 0;  function initializeBreakTheTerracotta() {   const overworld = world.getDimension(\"overworld\");    let scoreObjective = world.scoreboard.getObjective(\"score\");    if (!scoreObjective) {     scoreObjective = world.scoreboard.addObjective(\"score\", \"Level\");   }    // eliminate pesky nearby mobs   let entities = overworld.getEntities({     excludeTypes: [\"player\"],   });    for (let entity of entities) {     entity.kill();   }    // set up scoreboard   world.scoreboard.setObjectiveAtDisplaySlot(DisplaySlotId.Sidebar, {     objective: scoreObjective,   });    const players = world.getAllPlayers();    for (const player of players) {     scoreObjective.setScore(player, 0);      let inv = player.getComponent(\"inventory\") as EntityInventoryComponent;     inv.container?.addItem(new ItemStack(\"diamond_sword\"));     inv.container?.addItem(new ItemStack(\"dirt\", 64));      player.teleport(       {         x: ARENA_X_OFFSET - 3,         y: ARENA_Y_OFFSET,         z: ARENA_Z_OFFSET - 3,       },       {         dimension: overworld,         rotation: { x: 0, y: 0 },       }     );   }    world.sendMessage(\"BREAK THE TERRACOTTA\"); }  function gameTick() {   try {     curTick++;      if (curTick === START_TICK) {       initializeBreakTheTerracotta();     }   } catch (e) {     console.warn(\"Tick error: \" + e);   }    system.run(gameTick); }  system.run(gameTick);   This code does some work to initialize our gameplay for Minecraft by running several commands.  First, we queue up a run to our main tick function, gameTick. Note that at the end, we will requeue a game tick, which will run within the next tick frame. This will give us a callback that fires 20 times a second, and within this, we can put all of our game logic. We want the game to initialize some code; namely, the initializeBreakTheTerracotta function.  Note that we wait until START_TICK (100 ticks in) before the world is actually initialized. This gives Minecraft time to fully load up and get ready.  Within the initialize function, we run commands that:  Clear out any existing mobs near the player in the world. Set up a scoreboard objective for overall Level of the player, meaning the number of terracotta breaks they have Give the current player a diamond sword and some dirty dirt Use chat to give the player an instructional message  Now, let's run the code. This time, we're going to run the local-deploy task in \"watch mode\" - meaning it will just sit in the background and watch for changes, and if they happen, they will automatically compile and deploy to the Minecraft folder. This way, we won't have to worry about separately compiling every time we make a change to code.  Go back to your PowerShell window, and enter:  PowerShell Copy npm run local-deploy -- --watch   You should see that the local-deploy task compiles and deploys to the Minecraft folder. From here, we don't need to tend to PowerShell except to see if there are any compilation errors down the road.  When you are done coding for the day, either hit ctrl-c in the PowerShell Window to stop the watch mode or close the window.  Now, let's go back to Minecraft.  Save and Quit to exit out of the world. We'll want to reload the world from here - any time you make a script change, you need to exit out of the world and reload it to see changes. Or, you can run the /reload command to reload the JavaScript files that have been deployed.  Now load the world. You should see your initialization changes: a new scoreboard, new items in your inventory, and a script message.  Note that as you work through this tutorial, we are going to run the initialization code more than once, so your player is going to get multiples of these items during this development and test phase.  Build your arena with some helper code  We're going to start by adding some handy helper utility code functions. This will show you how you can organize your code into separate modules or classes.  Add a new file to your scripts folder called Utilities.ts. Correct capitalization matters, so make sure the U is capitalized. Add the following code:  TypeScript Copy import { world, BlockPermutation } from \"@minecraft/server\";  export default class Utilities {   static fillBlock(     blockPerm: BlockPermutation,     xFrom: number,     yFrom: number,     zFrom: number,     xTo: number,     yTo: number,     zTo: number   ) {     const overworld = world.getDimension(\"overworld\");      for (let i = xFrom; i <= xTo; i++) {       for (let j = yFrom; j <= yTo; j++) {         for (let k = zFrom; k <= zTo; k++) {           overworld.getBlock({ x: i, y: j, z: k })?.setPermutation(blockPerm);         }       }     }   }    static fourWalls(     perm: BlockPermutation,     xFrom: number,     yFrom: number,     zFrom: number,     xTo: number,     yTo: number,     zTo: number   ) {     const overworld = world.getDimension(\"overworld\");      for (let i = xFrom; i <= xTo; i++) {       for (let k = yFrom; k <= yTo; k++) {         overworld.getBlock({ x: i, y: k, z: zFrom })?.setPermutation(perm);         overworld.getBlock({ x: i, y: k, z: zTo })?.setPermutation(perm);       }     }      for (let j = zFrom + 1; j < zTo; j++) {       for (let k = yFrom; k <= yTo; k++) {         overworld.getBlock({ x: xFrom, y: k, z: j })?.setPermutation(perm);         overworld.getBlock({ x: xTo, y: k, z: j })?.setPermutation(perm);       }     }   } }   The first utility function here (Utilities.fillBlock) is relatively straightforward:  Across three dimensions (within three loops), it will basically set a block in the overworld to a particular type. This function just makes a big chunk of blocks.  The second utility function here (Utilities.fourWalls) basically creates a walled enclave. The first inner loop creates two stripes of blocks left to right (across X). The second inner loop creates two stripes of blocks south to north (across Z) - thus completing four walls that join each other.  Go back to main.ts. Let's use these functions in our initialization function.  First, we'll need an import function. Add a new line above const START_TICK = 100; and make this the second line of the file:  TypeScript Copy import Utilities from \"./Utilities.js\";   Then, within initializeBreakTheTerracotta, let's add our arena initialization beneath the world.sendMessage(\"BREAK THE TERRACOTTA!\"); line of code:  TypeScript Copy let airBlockPerm = BlockPermutation.resolve(\"minecraft:air\"); let cobblestoneBlockPerm = BlockPermutation.resolve(\"minecraft:cobblestone\");  if (airBlockPerm) {   Utilities.fillBlock(     airBlockPerm,     ARENA_X_OFFSET - ARENA_X_SIZE / 2 + 1,     ARENA_Y_OFFSET,     ARENA_Z_OFFSET - ARENA_Z_SIZE / 2 + 1,     ARENA_X_OFFSET + ARENA_X_SIZE / 2 - 1,     ARENA_Y_OFFSET + 10,     ARENA_Z_OFFSET + ARENA_Z_SIZE / 2 - 1   ); }  if (cobblestoneBlockPerm) {   Utilities.fourWalls(     cobblestoneBlockPerm,     ARENA_X_OFFSET - ARENA_X_SIZE / 2,     ARENA_Y_OFFSET,     ARENA_Z_OFFSET - ARENA_Z_SIZE / 2,     ARENA_X_OFFSET + ARENA_X_SIZE / 2,     ARENA_Y_OFFSET + 10,     ARENA_Z_OFFSET + ARENA_Z_SIZE / 2   ); }   The first line just fills a cuboid with air - basically clearing out the arena of any previous items. The second line re-installs and adds four walls of cobblestone.  Exit out of your Minecraft world and restart it to load your changes. After a brief delay, you should find yourself in an arena.  Now, let's give ourselves some terracotta to break.  Chapter 4. Add some gameplay basics - scoring and objectives  First, let's track some more game variables. Inside main.ts, add this directly beneath the let curTick = 0 line of code:  TypeScript Copy let score = 0; let cottaX = 0; let cottaZ = 0; let spawnCountdown = 1;   Add the following to the gameTick function, beneath the curTick++ line of code:  TypeScript Copy if (curTick > START_TICK && curTick % 20 === 0) {   // no terracotta exists, and we're waiting to spawn a new one.   if (spawnCountdown > 0) {     spawnCountdown--;      if (spawnCountdown <= 0) {       spawnNewTerracotta();     }   } else {     checkForTerracotta();   } }   Now add the spawnNewTerracotta() and checkForTerracotta() functions after the last function and before the last system.run(gameTick); line of code:  TypeScript Copy function spawnNewTerracotta() {   const overworld = world.getDimension(\"overworld\");    // create new terracotta   cottaX = Math.floor(Math.random() * (ARENA_X_SIZE - 1)) - (ARENA_X_SIZE / 2 - 1);   cottaZ = Math.floor(Math.random() * (ARENA_Z_SIZE - 1)) - (ARENA_Z_SIZE / 2 - 1);    world.sendMessage(\"Creating new terracotta!\");   let block = overworld.getBlock({ x: cottaX + ARENA_X_OFFSET, y: 1 + ARENA_Y_OFFSET, z: cottaZ + ARENA_Z_OFFSET });    if (block) {     block.setPermutation(BlockPermutation.resolve(\"minecraft:yellow_glazed_terracotta\"));   } }  function checkForTerracotta() {   const overworld = world.getDimension(\"overworld\");    let block = overworld.getBlock({ x: cottaX + ARENA_X_OFFSET, y: 1 + ARENA_Y_OFFSET, z: cottaZ + ARENA_Z_OFFSET });    if (block && !block.permutation.matches(\"minecraft:yellow_glazed_terracotta\")) {     // we didn't find the terracotta! set a new spawn countdown     score++;     spawnCountdown = 2;     cottaX = -1;      let players = world.getAllPlayers();      for (let player of players) {       player.runCommand(\"scoreboard players set @s score \" + score);     }      world.sendMessage(\"You broke the terracotta! Creating new terracotta in a few seconds.\");     cottaZ = -1;   } }   Congratulations! You've just created a very basic and very easy game where you can run around and break terracotta with your sword.  To play, you will need to run the command /gamemode s to put Minecraft into survival mode so that you can break the terracotta.  After the terracotta is broken, your score will increment, and a new block is spawned.  Add a challenge - let's add some mobs  OK, let's add this function after the checkForTerracotta() function:  TypeScript Copy function spawnMobs() {   const overworld = world.getDimension(\"overworld\");    // spawn mobs = create 1-2 mobs   let spawnMobCount = Math.floor(Math.random() * 2) + 1;    for (let j = 0; j < spawnMobCount; j++) {     let zombieX = Math.floor(Math.random() * (ARENA_X_SIZE - 2)) - ARENA_X_SIZE / 2;     let zombieZ = Math.floor(Math.random() * (ARENA_Z_SIZE - 2)) - ARENA_Z_SIZE / 2;      overworld.spawnEntity(\"minecraft:zombie\", {       x: zombieX + ARENA_X_OFFSET,       y: 1 + ARENA_Y_OFFSET,       z: zombieZ + ARENA_Z_OFFSET,     });   } }   This function will spawn 1-2 zombies within the arena, at a random location. You can change the kinds of mobs to spawn, the number, and more within this function.  Let's call that function within our gameTick method:  TypeScript Copy   const spawnInterval = Math.ceil(200 / ((score + 1) / 3));   if (curTick > START_TICK && curTick % spawnInterval === 0) {     spawnMobs();   }   For gameplay, we want mobs to spawn more frequently as your score goes up. To do this, the frequency at which spawnMobs is called depends on the spawnInterval variable. spawnInterval is the span of time between spawning new mobs. Because we divide this interval by our current score, this means that as our score goes up, the interval of time between spawning mobs gets shorter. This makes the challenge harder over time.  As you play, zombies should spawn and start chasing you. They'll spawn slowly at first, but as you break blocks they'll start to accumulate and bother you while you try to break terracotta blocks.  Add more challenges!  Let's add a new gameplay twist: randomly spawning obstructions in the form of leaves.  Add this function to main.ts to randomly place some fuzzy leaves:  TypeScript Copy function addFuzzyLeaves() {   const overworld = world.getDimension(\"overworld\");    for (let i = 0; i < 10; i++) {     const leafX = Math.floor(Math.random() * (ARENA_X_SIZE - 1)) - (ARENA_X_SIZE / 2 - 1);     const leafY = Math.floor(Math.random() * 10);     const leafZ = Math.floor(Math.random() * (ARENA_Z_SIZE - 1)) - (ARENA_Z_SIZE / 2 - 1);      overworld       .getBlock({ x: leafX + ARENA_X_OFFSET, y: leafY + ARENA_Y_OFFSET, z: leafZ + ARENA_Z_OFFSET })       ?.setPermutation(BlockPermutation.resolve(\"minecraft:leaves\"));   } }   And call that function in your gameTick() function:  TypeScript Copy   if (curTick > START_TICK && curTick % 29 === 0) {     addFuzzyLeaves();   }   You may wonder why the interval here is 29. The main idea was to select a number to avoid the chance that on a particular tick we do everything at once (create new leaves, spawn mobs AND check terracotta state), so we try to have offset schedules for all of these different game activities.  Now exit out and reload your game. As you run around, you should see new leaves get spawned. This should add a little bit more challenge to your gameplay!  Other Commands  To run a lint operation (that is, scan your code for errors) use this shortcut command:  PowerShell Copy    npm run lint   To auto-fix lint issues, you can use this:  PowerShell Copy    npm run lint -- --fix   To create an addon file you can share, run:  PowerShell Copy    npm run mcaddon  Summary  With this starter, you've seen how to build a nice little arena game.  Like the randomly spawning leaves, you can see how you can add different gameplay elements into your arena. Maybe rather than leaves, you want to randomly generate some parkour platforms - or some treasures or weapons, or different types of mobs. Experiment and build your own custom competition arenas!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptinggettingstarted?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Build a gameplay experience with TypeScript 04/17/2025  This guide leverages a starter sample available on our public GitHub repository with a simple build process and TypeScript compilation for Minecraft. From it, you can build out and expand simple gameplay styles. You can also use this project as a starter for your own scripting projects.   Important  Just getting started with JavaScript? You may want to check out Introduction to Scripting to learn the basics of creating a simple behavior pack using JavaScript fundamentals. Once you're comfortable with the JavaScript fundamentals and concepts, this article will help you use TypeScript with Minecraft for more complex customization. TypeScript is a more helpfully structured dialect of JavaScript; however, because TypeScript must be compiled into JavaScript before Minecraft can use it, there is a bit more project structure you'll need to establish up front that this tutorial will walk you through.  On the Minecraft Creator Channel  If you prefer to watch a video version of this tutorial, you can view it on the Minecraft Creator Channel, available here.  Prerequisites Install Node.js tools, if you haven't already  We're going to use the Node Package Manager (or NPM) to get more tools to make the process of building our project easier.  Visit https://nodejs.org/.  Download the version with \"LTS\" next to the number and install it. (LTS stands for Long Term Support, if you're curious.) You do not need to install any additional tools for Native compilation.  Install Visual Studio Code, if you haven't already  Visit the Visual Studio Code website and install Visual Studio Code.  Getting Started  Download a copy of the starter project from GitHub by visiting https://github.com/microsoft/minecraft-scripting-samples/ and, under the Code button, selecting Download ZIP.  The ts-starter folder contains a starter TypeScript project for Minecraft. Note that there is a ts-starter-complete-cotta folder that will show you the finished product and code.  To make your own environment look like the example, create a folder on your C:\\ drive and call it projects. Create a subfolder called cotta.  Put the extracted contents of the TypeScript Starter Project folder into cotta.  Open a Windows Terminal or PowerShell window and change the working directory to your cotta folder:  PowerShell Copy cd c:\\projects\\cotta\\   Use NPM to install our tools:  PowerShell Copy npm i   Use this shortcut command to open the project in Visual Studio Code:  PowerShell Copy code .   It might also ask you to install the Minecraft Debugger and Blockception's Visual Studio Code plugin, which are plugins to Visual Studio Code that can help with Minecraft development. Go ahead and do that, if you haven't already.  Chapter 1. Customize the behavior pack  In Visual Studio Code, open the file .env. This contains the environment variables to use to configure project:  Copy PROJECT_NAME=\"starter\" MINECRAFT_PRODUCT=\"BedrockUWP\" CUSTOM_DEPLOYMENT_PATH=\"\"   PROJECT_NAME is used as the folder name under all the assets are going to be deployed inside the game directories (e.g., development_behavior_packs\\PROJECT_NAME, development_resource_packs\\PROJECT_NAME).  MINECRAFT_PRODUCT. You can choose to use either Minecraft or Minecraft Preview to debug and work with your scripts. These are the possible values: BedrockUWP, PreviewUWP, Custom. Use Custom in case of deploy on any other path.  CUSTOM_DEPLOYMENT_PATH. In case of using Custom for MINECRAFT_PRODUCT, this is the path used to generate the assets.  Go back the Files tree view and open behavior_packs\\cotta\\manifest.json  Update the name and description properties to something like \"Cotta Behavior Pack\" and \"My TypeScript Project\".  Update the first and second UUID properties to make it unique to your project. See this article for tips on working with behavior packs and creating your own unique UUIDs.  Chapter 2. Let's test the parts of our project  To get started, go into PowerShell and navigate to your C:\\projects\\cotta directory. Run this command:  PowerShell Copy Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass   Run this one, too.  PowerShell Copy npm run local-deploy   This uses a build tool called just-scripts and automatically compiles your TypeScript project and pushes it over into Minecraft.  Launch Minecraft and create a new world:  Call it Cotta Test. Select a Creative game mode. Select a Flat world option, under the Advanced section of the Create New World screen. Under Behavior Packs, under Available, you should see your Cotta Behavior Pack. Select it and Activate it. Create the world and go into it.  Now you're in. Great!  By default, this starter pack comes with a simple script that will display a message every five seconds:  [Script Engine] Hello starter! Tick: <number>  This means your behavior pack is working and your tools for compiling and pushing TypeScript are just fine. Awesome!  Chapter 3. Scripting your gameplay  Let's go back to Visual Studio Code and change up some code.  Open up scripts/main.ts within Visual Studio Code.  Add some initialization code  Remove all the existing script code in main.ts. Replace it with this to start:  TypeScript Copy import { world, system, BlockPermutation, EntityInventoryComponent, ItemStack, DisplaySlotId } from \"@minecraft/server\";  const START_TICK = 100; const ARENA_X_SIZE = 30; const ARENA_Z_SIZE = 30; const ARENA_X_OFFSET = 0; const ARENA_Y_OFFSET = -60; const ARENA_Z_OFFSET = 0;  // global variables let curTick = 0;  function initializeBreakTheTerracotta() {   const overworld = world.getDimension(\"overworld\");    let scoreObjective = world.scoreboard.getObjective(\"score\");    if (!scoreObjective) {     scoreObjective = world.scoreboard.addObjective(\"score\", \"Level\");   }    // eliminate pesky nearby mobs   let entities = overworld.getEntities({     excludeTypes: [\"player\"],   });    for (let entity of entities) {     entity.kill();   }    // set up scoreboard   world.scoreboard.setObjectiveAtDisplaySlot(DisplaySlotId.Sidebar, {     objective: scoreObjective,   });    const players = world.getAllPlayers();    for (const player of players) {     scoreObjective.setScore(player, 0);      let inv = player.getComponent(\"inventory\") as EntityInventoryComponent;     inv.container?.addItem(new ItemStack(\"diamond_sword\"));     inv.container?.addItem(new ItemStack(\"dirt\", 64));      player.teleport(       {         x: ARENA_X_OFFSET - 3,         y: ARENA_Y_OFFSET,         z: ARENA_Z_OFFSET - 3,       },       {         dimension: overworld,         rotation: { x: 0, y: 0 },       }     );   }    world.sendMessage(\"BREAK THE TERRACOTTA\"); }  function gameTick() {   try {     curTick++;      if (curTick === START_TICK) {       initializeBreakTheTerracotta();     }   } catch (e) {     console.warn(\"Tick error: \" + e);   }    system.run(gameTick); }  system.run(gameTick);   This code does some work to initialize our gameplay for Minecraft by running several commands.  First, we queue up a run to our main tick function, gameTick. Note that at the end, we will requeue a game tick, which will run within the next tick frame. This will give us a callback that fires 20 times a second, and within this, we can put all of our game logic. We want the game to initialize some code; namely, the initializeBreakTheTerracotta function.  Note that we wait until START_TICK (100 ticks in) before the world is actually initialized. This gives Minecraft time to fully load up and get ready.  Within the initialize function, we run commands that:  Clear out any existing mobs near the player in the world. Set up a scoreboard objective for overall Level of the player, meaning the number of terracotta breaks they have Give the current player a diamond sword and some dirty dirt Use chat to give the player an instructional message  Now, let's run the code. This time, we're going to run the local-deploy task in \"watch mode\" - meaning it will just sit in the background and watch for changes, and if they happen, they will automatically compile and deploy to the Minecraft folder. This way, we won't have to worry about separately compiling every time we make a change to code.  Go back to your PowerShell window, and enter:  PowerShell Copy npm run local-deploy -- --watch   You should see that the local-deploy task compiles and deploys to the Minecraft folder. From here, we don't need to tend to PowerShell except to see if there are any compilation errors down the road.  When you are done coding for the day, either hit ctrl-c in the PowerShell Window to stop the watch mode or close the window.  Now, let's go back to Minecraft.  Save and Quit to exit out of the world. We'll want to reload the world from here - any time you make a script change, you need to exit out of the world and reload it to see changes. Or, you can run the /reload command to reload the JavaScript files that have been deployed.  Now load the world. You should see your initialization changes: a new scoreboard, new items in your inventory, and a script message.  Note that as you work through this tutorial, we are going to run the initialization code more than once, so your player is going to get multiples of these items during this development and test phase.  Build your arena with some helper code  We're going to start by adding some handy helper utility code functions. This will show you how you can organize your code into separate modules or classes.  Add a new file to your scripts folder called Utilities.ts. Correct capitalization matters, so make sure the U is capitalized. Add the following code:  TypeScript Copy import { world, BlockPermutation } from \"@minecraft/server\";  export default class Utilities {   static fillBlock(     blockPerm: BlockPermutation,     xFrom: number,     yFrom: number,     zFrom: number,     xTo: number,     yTo: number,     zTo: number   ) {     const overworld = world.getDimension(\"overworld\");      for (let i = xFrom; i <= xTo; i++) {       for (let j = yFrom; j <= yTo; j++) {         for (let k = zFrom; k <= zTo; k++) {           overworld.getBlock({ x: i, y: j, z: k })?.setPermutation(blockPerm);         }       }     }   }    static fourWalls(     perm: BlockPermutation,     xFrom: number,     yFrom: number,     zFrom: number,     xTo: number,     yTo: number,     zTo: number   ) {     const overworld = world.getDimension(\"overworld\");      for (let i = xFrom; i <= xTo; i++) {       for (let k = yFrom; k <= yTo; k++) {         overworld.getBlock({ x: i, y: k, z: zFrom })?.setPermutation(perm);         overworld.getBlock({ x: i, y: k, z: zTo })?.setPermutation(perm);       }     }      for (let j = zFrom + 1; j < zTo; j++) {       for (let k = yFrom; k <= yTo; k++) {         overworld.getBlock({ x: xFrom, y: k, z: j })?.setPermutation(perm);         overworld.getBlock({ x: xTo, y: k, z: j })?.setPermutation(perm);       }     }   } }   The first utility function here (Utilities.fillBlock) is relatively straightforward:  Across three dimensions (within three loops), it will basically set a block in the overworld to a particular type. This function just makes a big chunk of blocks.  The second utility function here (Utilities.fourWalls) basically creates a walled enclave. The first inner loop creates two stripes of blocks left to right (across X). The second inner loop creates two stripes of blocks south to north (across Z) - thus completing four walls that join each other.  Go back to main.ts. Let's use these functions in our initialization function.  First, we'll need an import function. Add a new line above const START_TICK = 100; and make this the second line of the file:  TypeScript Copy import Utilities from \"./Utilities.js\";   Then, within initializeBreakTheTerracotta, let's add our arena initialization beneath the world.sendMessage(\"BREAK THE TERRACOTTA!\"); line of code:  TypeScript Copy let airBlockPerm = BlockPermutation.resolve(\"minecraft:air\"); let cobblestoneBlockPerm = BlockPermutation.resolve(\"minecraft:cobblestone\");  if (airBlockPerm) {   Utilities.fillBlock(     airBlockPerm,     ARENA_X_OFFSET - ARENA_X_SIZE / 2 + 1,     ARENA_Y_OFFSET,     ARENA_Z_OFFSET - ARENA_Z_SIZE / 2 + 1,     ARENA_X_OFFSET + ARENA_X_SIZE / 2 - 1,     ARENA_Y_OFFSET + 10,     ARENA_Z_OFFSET + ARENA_Z_SIZE / 2 - 1   ); }  if (cobblestoneBlockPerm) {   Utilities.fourWalls(     cobblestoneBlockPerm,     ARENA_X_OFFSET - ARENA_X_SIZE / 2,     ARENA_Y_OFFSET,     ARENA_Z_OFFSET - ARENA_Z_SIZE / 2,     ARENA_X_OFFSET + ARENA_X_SIZE / 2,     ARENA_Y_OFFSET + 10,     ARENA_Z_OFFSET + ARENA_Z_SIZE / 2   ); }   The first line just fills a cuboid with air - basically clearing out the arena of any previous items. The second line re-installs and adds four walls of cobblestone.  Exit out of your Minecraft world and restart it to load your changes. After a brief delay, you should find yourself in an arena.  Now, let's give ourselves some terracotta to break.  Chapter 4. Add some gameplay basics - scoring and objectives  First, let's track some more game variables. Inside main.ts, add this directly beneath the let curTick = 0 line of code:  TypeScript Copy let score = 0; let cottaX = 0; let cottaZ = 0; let spawnCountdown = 1;   Add the following to the gameTick function, beneath the curTick++ line of code:  TypeScript Copy if (curTick > START_TICK && curTick % 20 === 0) {   // no terracotta exists, and we're waiting to spawn a new one.   if (spawnCountdown > 0) {     spawnCountdown--;      if (spawnCountdown <= 0) {       spawnNewTerracotta();     }   } else {     checkForTerracotta();   } }   Now add the spawnNewTerracotta() and checkForTerracotta() functions after the last function and before the last system.run(gameTick); line of code:  TypeScript Copy function spawnNewTerracotta() {   const overworld = world.getDimension(\"overworld\");    // create new terracotta   cottaX = Math.floor(Math.random() * (ARENA_X_SIZE - 1)) - (ARENA_X_SIZE / 2 - 1);   cottaZ = Math.floor(Math.random() * (ARENA_Z_SIZE - 1)) - (ARENA_Z_SIZE / 2 - 1);    world.sendMessage(\"Creating new terracotta!\");   let block = overworld.getBlock({ x: cottaX + ARENA_X_OFFSET, y: 1 + ARENA_Y_OFFSET, z: cottaZ + ARENA_Z_OFFSET });    if (block) {     block.setPermutation(BlockPermutation.resolve(\"minecraft:yellow_glazed_terracotta\"));   } }  function checkForTerracotta() {   const overworld = world.getDimension(\"overworld\");    let block = overworld.getBlock({ x: cottaX + ARENA_X_OFFSET, y: 1 + ARENA_Y_OFFSET, z: cottaZ + ARENA_Z_OFFSET });    if (block && !block.permutation.matches(\"minecraft:yellow_glazed_terracotta\")) {     // we didn't find the terracotta! set a new spawn countdown     score++;     spawnCountdown = 2;     cottaX = -1;      let players = world.getAllPlayers();      for (let player of players) {       player.runCommand(\"scoreboard players set @s score \" + score);     }      world.sendMessage(\"You broke the terracotta! Creating new terracotta in a few seconds.\");     cottaZ = -1;   } }   Congratulations! You've just created a very basic and very easy game where you can run around and break terracotta with your sword.  To play, you will need to run the command /gamemode s to put Minecraft into survival mode so that you can break the terracotta.  After the terracotta is broken, your score will increment, and a new block is spawned.  Add a challenge - let's add some mobs  OK, let's add this function after the checkForTerracotta() function:  TypeScript Copy function spawnMobs() {   const overworld = world.getDimension(\"overworld\");    // spawn mobs = create 1-2 mobs   let spawnMobCount = Math.floor(Math.random() * 2) + 1;    for (let j = 0; j < spawnMobCount; j++) {     let zombieX = Math.floor(Math.random() * (ARENA_X_SIZE - 2)) - ARENA_X_SIZE / 2;     let zombieZ = Math.floor(Math.random() * (ARENA_Z_SIZE - 2)) - ARENA_Z_SIZE / 2;      overworld.spawnEntity(\"minecraft:zombie\", {       x: zombieX + ARENA_X_OFFSET,       y: 1 + ARENA_Y_OFFSET,       z: zombieZ + ARENA_Z_OFFSET,     });   } }   This function will spawn 1-2 zombies within the arena, at a random location. You can change the kinds of mobs to spawn, the number, and more within this function.  Let's call that function within our gameTick method:  TypeScript Copy   const spawnInterval = Math.ceil(200 / ((score + 1) / 3));   if (curTick > START_TICK && curTick % spawnInterval === 0) {     spawnMobs();   }   For gameplay, we want mobs to spawn more frequently as your score goes up. To do this, the frequency at which spawnMobs is called depends on the spawnInterval variable. spawnInterval is the span of time between spawning new mobs. Because we divide this interval by our current score, this means that as our score goes up, the interval of time between spawning mobs gets shorter. This makes the challenge harder over time.  As you play, zombies should spawn and start chasing you. They'll spawn slowly at first, but as you break blocks they'll start to accumulate and bother you while you try to break terracotta blocks.  Add more challenges!  Let's add a new gameplay twist: randomly spawning obstructions in the form of leaves.  Add this function to main.ts to randomly place some fuzzy leaves:  TypeScript Copy function addFuzzyLeaves() {   const overworld = world.getDimension(\"overworld\");    for (let i = 0; i < 10; i++) {     const leafX = Math.floor(Math.random() * (ARENA_X_SIZE - 1)) - (ARENA_X_SIZE / 2 - 1);     const leafY = Math.floor(Math.random() * 10);     const leafZ = Math.floor(Math.random() * (ARENA_Z_SIZE - 1)) - (ARENA_Z_SIZE / 2 - 1);      overworld       .getBlock({ x: leafX + ARENA_X_OFFSET, y: leafY + ARENA_Y_OFFSET, z: leafZ + ARENA_Z_OFFSET })       ?.setPermutation(BlockPermutation.resolve(\"minecraft:leaves\"));   } }   And call that function in your gameTick() function:  TypeScript Copy   if (curTick > START_TICK && curTick % 29 === 0) {     addFuzzyLeaves();   }   You may wonder why the interval here is 29. The main idea was to select a number to avoid the chance that on a particular tick we do everything at once (create new leaves, spawn mobs AND check terracotta state), so we try to have offset schedules for all of these different game activities.  Now exit out and reload your game. As you run around, you should see new leaves get spawned. This should add a little bit more challenge to your gameplay!  Other Commands  To run a lint operation (that is, scan your code for errors) use this shortcut command:  PowerShell Copy    npm run lint   To auto-fix lint issues, you can use this:  PowerShell Copy    npm run lint -- --fix   To create an addon file you can share, run:  PowerShell Copy    npm run mcaddon  Summary  With this starter, you've seen how to build a nice little arena game.  Like the randomly spawning leaves, you can see how you can add different gameplay elements into your arena. Maybe rather than leaves, you want to randomly generate some parkour platforms - or some treasures or weapons, or different types of mobs. Experiment and build your own custom competition arenas!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptdevelopertools?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Use Visual Studio Code tools to write script 06/05/2024  There are a few tools that can make the process of writing your JavaScript easier and more fun within Visual Studio Code. In this article, we'll discuss how you can install custom type definitions for Minecraft to provide autocomplete as you work, the Minecraft Script Debugger, and the Minecraft Script Profiler. A big note: in the GitHub repository at https://github.com/microsoft/minecraft-scripting-samples, there are various starter samples and examples that come with these tools pre-configured, so if you start your project using those, a lot of the configuration work is already done for you.  Custom type definition files for Visual Studio Code Intellisense  Visual Studio Code can display detailed type information for different libraries to provide hints and code-completion dropdowns as you type. Type information has been made available for scripting modules @minecraft/server,@minecraft/server-ui, and several beta modules such as @minecraft/server-gametest.  To get started, use the Node Package Manager, or npm. npm makes it easy to download and install different modules of code within your packages. Install Node.js – which includes npm - on your development device. More info on installing npm is available from nodejs.org. Install the latest LTS version of Node.js to get started.  Once Node.js is installed, getting the latest type definitions is a snap. From Visual Studio Code, open the folder where your behavior pack folder is located and simply run the following commands from a terminal console window:  PowerShell Copy npm i @minecraft/server npm i @minecraft/server-gametest   This will install type definitions in the node_modules folder within your project.  To edit with new code hinting, just open up Visual Studio Code. As you write JavaScript, you should see autocomplete:  and inline reference documentation for types:   Note  We are updating these type definitions to match the latest APIs, so be sure to check npm often to see if there are updated type definitions.  If you wish to access the latest beta API versions of modules, you can use the @beta version signifier, as follows:  PowerShell Copy npm i @minecraft/server@beta npm i @minecraft/server-ui@beta  Get insight into your code with Minecraft script debugging  As you build more of a codebase in script, you'll want to inspect your code at various points to see the state of variables and test your algorithms. In many starter projects, people start by using commands like Console.log or Chat to print various variables as they go – informally, this is called \"print debugging\". But for developers, there is a better way! With scripting in Minecraft Bedrock Edition, you can use script debugging capabilities that make inspecting data in Minecraft script a snap.  To get started, you'll want to use Visual Studio Code as your editor for the JavaScript files you've been developing. Steps from there include:  Install the Minecraft Bedrock Edition Debugger within Visual Studio Code – you'll need to do this once Open Visual Studio Code within your development_behavior_packs folder Depending on your testing client - either in Bedrock Dedicated Server or within Minecraft Bedrock clients -- connect Minecraft Bedrock Edition and Visual Studio Code Set break points and add watch variables in your code as you go, and then connect Minecraft to Visual Studio Code Debugging with Minecraft Bedrock Edition Step 1: Install the Minecraft Bedrock Edition Debugger within Visual Studio Code  To use debugger capabilities, you'll want to install the Minecraft Bedrock Edition Debugger within Visual Studio Code. To do this, please click on the button below to download the Minecraft Bedrock Edition Debugger from Visual Studio Code's marketplace.  Minecraft Bedrock Edition Debugger  Step 2: Ensure that the Minecraft Bedrock Edition client can make \"loopback\" requests  If you want to connect Minecraft Bedrock Edition client to Visual Studio Code running on the same machine (this is the most common scenario), you will need to exempt the Minecraft client from UWP loopback restrictions. To do this, run the following from a command prompt or the Start | Run app.  Minecraft Bedrock Edition:  PowerShell Copy CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-1958404141-86561845-1752920682-3514627264-368642714-62675701-733520436   Minecraft Bedrock Edition Preview:  PowerShell Copy CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-424268864-5579737-879501358-346833251-474568803-887069379-4040235476   Step 3: Open Visual Studio Code within your development_behavior_packs folder  In order for the debugger to know where to find your source JavaScript or TypeScript files, you'll need to specifically open up a window of Visual Studio Code relative to the behavior pack where your JavaScript or TypeScript source files are. This may be inside of Minecraft's development_behavior_packs folder (e.g., %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\development_behavior_packs) - or you may have your source code located in a separate folder (e.g., c:\\projects\\myaddon).  Open up a Visual Studio Code window pointed at the folder with your add-on script source.  Step 4: Prepare Visual Studio Code for a connection  To debug with Minecraft Bedrock Edition, you'll need to connect from Minecraft and into Visual Studio Code. This set of steps assumes you are debugging on the same Windows machine that you are running Minecraft from, but you can also debug across machines and across clients if you want to. If you are debugging across devices, you may need to open up a port within your firewall on the machine that you are running Visual Studio Code within.  You'll want to configure Visual Studio Code to know how to connect to Minecraft. If you're using a sample project such as the TS starter minecraft-scripting-samples/ts-starter, this .vscode/launch.json file is already configured for you. But if you're creating a project from scratch, follow these instructions:  At the root of the behavior pack you want to debug, add a .vscode subfolder. Add the following launch.json file into that .vscode folder.  If your source is in JavaScript and you are developing directly against that source (you do not use a script build process), you'll want to configure launch.json as follows:  JSON Copy {   \"version\": \"0.3.0\",   \"configurations\": [     {       \"type\": \"minecraft-js\",       \"request\": \"attach\",       \"name\": \"Debug with Minecraft\",       \"mode\": \"connect\",       \"preLaunchTask\": \"build\",       \"targetModuleUuid\": \"7c7e693f-99f4-41a9-95e0-1f57b37e1e12\",       \"localRoot\": \"${workspaceFolder}/\",       \"port\": 19144    }   ] }   localRoot should point at the folder which contains your behavior pack with script within it. Port 19144 is the default networking port for Minecraft Script Debugging.  In the example above, targetModuleUuid is an optional parameter that specifies the identifier of your script module, which is located in your behavior pack's manifest.json file. This is important to use if you are developing add-ons in Minecraft while there are multiple behavior packs with script active.  If your source is in a language like TypeScript that generates JavaScript for Minecraft, you will want to use sourceMapRoot and generatedSourceRoot parameters in launch.json:  JSON Copy {   \"version\": \"0.3.0\",   \"configurations\": [     {       \"type\": \"minecraft-js\",       \"request\": \"attach\",       \"name\": \"Debug with Minecraft\",       \"mode\": \"connect\",       \"preLaunchTask\": \"build\",       \"targetModuleUuid\": \"7c7e693f-99f4-41a9-95e0-1f57b37e1e12\",       \"sourceMapRoot\": \"${workspaceFolder}/dist/debug/\",       \"generatedSourceRoot\": \"${workspaceFolder}/dist/scripts/\",       \"port\": 19144    }   ] }   Note that generatedSourceRoot should point at a folder where your generated JavaScript files (*.js) are stored - for example, the outputs of a TypeScript build process. sourceMapRoot should point at a folder where you have source map files - typically created during your build process - that tie your generated JavaScript source files back to your potential TypeScript source.  Run your Minecraft Behavior Pack  Now that you've prepared Visual Studio Code and prepared your behavior pack, you're ready to start debugging!  Within Visual Studio Code, click the \"Debug with Minecraft\" option under the Run menu (or hit F5) to start debugging. This will place Visual Studio Code into \"Listen Mode\", where it awaits a connection from Minecraft.  Start Minecraft and load into a world with your scripting behavior pack.  Use this slash command to connect Minecraft to Visual Studio Code:  script debugger connect  You should see a \"Debugger connected to host\" response from this command if the connection is successful.  You can set breakpoints in your code by clicking on the left-hand side of the editor, on specific lines of code. As you run the tests in the behavior pack, your breakpoints should be hit. You can also view local variables and add watches as necessary.  Debugging with Minecraft Bedrock Dedicated Server  The procedure for debugging with Bedrock Dedicated Server is a little different. When debugging with Bedrock Dedicated Server, Bedrock Dedicated Server (not Visual Studio Code) will listen for debug connections initiated from Visual Studio Code. You'll want to start by installing the Minecraft Bedrock Edition Debugger for Visual Studio Code as described above.  Configure your Bedrock Dedicated Server  By default, Bedrock Dedicated Servers are not configured to allow debug connections. To enable this debugging, you'll need to change some settings within the server.properties file of your Bedrock Dedicated Server.  These settings configure debugging on Bedrock Dedicated Server:  allow-outbound-script-debugging (true/false): enables the /script debugger connect command. Defaults to false. allow-inbound-script-debugging (true false): enables the /script debugger listen command (and the opening of ports on a server). Defaults to false. force-inbound-debug-port (number): Locks the inbound debug port to a particular port. This will set the default script debugging port and prevent a user of the /script debugger listen command from specifying an alternate port.  Within Bedrock Dedicated Server's console, use this slash command to start listening on a port:  script debugger listen 19144  You should see a \"Debugger listening\" response from this command.  Within Visual Studio Code, you'll want to configure your debug settings in launch.json to have Visual Studio connect to Dedicated Server. To do this, set \"mode\" to \"connect\".  JSON Copy {     \"version\": \"0.3.0\",     \"configurations\": [       {         \"type\": \"minecraft-js\",         \"request\": \"attach\",         \"name\": \"Debug with Minecraft\",         \"mode\": \"connect\",         \"preLaunchTask\": \"build\",         \"sourceMapRoot\": \"${workspaceFolder}/dist/debug/\",         \"generatedSourceRoot\": \"${workspaceFolder}/dist/scripts/\",         \"port\": 19144       }     ]   }   Now, hit \"Start Debugging\" inside of Visual Studio Code.  As with when you debug against Minecraft clients, you can set breakpoints in your code by clicking on the left-hand side of the editor, on specific lines of code.  Using the Minecraft Scripting Profiler  A profiler is a set of monitoring code that measures the amount of time spent running various functions. With it, you can identify where most of your time is spent within your scripts. This may then lead you to discovering unexpected function calling patterns that may consume a lot of time.  Run the profiler during a typical session for your script  To get started, ensure you have a behavior pack with JavaScript within it. Your first step is to create a profile session, or in other words, log the performance characteristics of your script as you play through the game.  To run the script profiler and start a new profile session, run the following command:  Copy /script profiler start   Then, exercise your code by running through and playing Minecraft. You'll want to go through normal gameplay or testing patterns to have your JavaScript exercised in representative ways of how players might encounter your experience.  After a while – many minutes, perhaps, end your profiler session by running the following command:  Copy /script profiler stop   This will create a .cpuprofile with a timestamp within your Minecraft log folder.  If you are using the retail version of Minecraft, the log folder is located at:  %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\logs\\  If you are using Minecraft Preview, that log folder is located at:  %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\logs  To view a CPUProfile, simply open it within Visual Studio Code. The first time you open a CPUProfile file, your operating system will ask you how you wish to open the file. Select Open in Visual Studio Code:  (Note that if you wish to have source links from the profile resolve to your source files correctly, start Visual Studio Code (or set its working directory) within the root of your behavior pack.)  By default, this will give you a simple visual listing of the functions that were called during your CPU Profile session, and the cumulative time that they have taken:  As a developer, you can start to optimize your code to adjust for performance - in this case, perhaps organizing code to share instances of a dimension object rather than repeatedly calling world.getDimension.  Note that within Visual Studio Code, you can install an optional \"Flame Chart\" plugin by clicking the little flame icon in the upper right of your screen (circled in red, below):  Note: In versions 1.19.10 and beyond, the script profiler has been expanded to support coverage of core Bedrock API calls in addition to overall function calls.  With this profiler capability, you can quickly identify hotspots and where server time is spent, and spend your time optimizing your code where it matters.  Summary  That's it! Between updated code helpers as you add lines of JavaScript, debugger capabilities within Visual Studio Code, and profiler support we hope you'll be able to write more extensive tests and script much more quickly.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptdevelopertools?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Use Visual Studio Code tools to write script 06/05/2024  There are a few tools that can make the process of writing your JavaScript easier and more fun within Visual Studio Code. In this article, we'll discuss how you can install custom type definitions for Minecraft to provide autocomplete as you work, the Minecraft Script Debugger, and the Minecraft Script Profiler. A big note: in the GitHub repository at https://github.com/microsoft/minecraft-scripting-samples, there are various starter samples and examples that come with these tools pre-configured, so if you start your project using those, a lot of the configuration work is already done for you.  Custom type definition files for Visual Studio Code Intellisense  Visual Studio Code can display detailed type information for different libraries to provide hints and code-completion dropdowns as you type. Type information has been made available for scripting modules @minecraft/server,@minecraft/server-ui, and several beta modules such as @minecraft/server-gametest.  To get started, use the Node Package Manager, or npm. npm makes it easy to download and install different modules of code within your packages. Install Node.js – which includes npm - on your development device. More info on installing npm is available from nodejs.org. Install the latest LTS version of Node.js to get started.  Once Node.js is installed, getting the latest type definitions is a snap. From Visual Studio Code, open the folder where your behavior pack folder is located and simply run the following commands from a terminal console window:  PowerShell Copy npm i @minecraft/server npm i @minecraft/server-gametest   This will install type definitions in the node_modules folder within your project.  To edit with new code hinting, just open up Visual Studio Code. As you write JavaScript, you should see autocomplete:  and inline reference documentation for types:   Note  We are updating these type definitions to match the latest APIs, so be sure to check npm often to see if there are updated type definitions.  If you wish to access the latest beta API versions of modules, you can use the @beta version signifier, as follows:  PowerShell Copy npm i @minecraft/server@beta npm i @minecraft/server-ui@beta  Get insight into your code with Minecraft script debugging  As you build more of a codebase in script, you'll want to inspect your code at various points to see the state of variables and test your algorithms. In many starter projects, people start by using commands like Console.log or Chat to print various variables as they go – informally, this is called \"print debugging\". But for developers, there is a better way! With scripting in Minecraft Bedrock Edition, you can use script debugging capabilities that make inspecting data in Minecraft script a snap.  To get started, you'll want to use Visual Studio Code as your editor for the JavaScript files you've been developing. Steps from there include:  Install the Minecraft Bedrock Edition Debugger within Visual Studio Code – you'll need to do this once Open Visual Studio Code within your development_behavior_packs folder Depending on your testing client - either in Bedrock Dedicated Server or within Minecraft Bedrock clients -- connect Minecraft Bedrock Edition and Visual Studio Code Set break points and add watch variables in your code as you go, and then connect Minecraft to Visual Studio Code Debugging with Minecraft Bedrock Edition Step 1: Install the Minecraft Bedrock Edition Debugger within Visual Studio Code  To use debugger capabilities, you'll want to install the Minecraft Bedrock Edition Debugger within Visual Studio Code. To do this, please click on the button below to download the Minecraft Bedrock Edition Debugger from Visual Studio Code's marketplace.  Minecraft Bedrock Edition Debugger  Step 2: Ensure that the Minecraft Bedrock Edition client can make \"loopback\" requests  If you want to connect Minecraft Bedrock Edition client to Visual Studio Code running on the same machine (this is the most common scenario), you will need to exempt the Minecraft client from UWP loopback restrictions. To do this, run the following from a command prompt or the Start | Run app.  Minecraft Bedrock Edition:  PowerShell Copy CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-1958404141-86561845-1752920682-3514627264-368642714-62675701-733520436   Minecraft Bedrock Edition Preview:  PowerShell Copy CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-424268864-5579737-879501358-346833251-474568803-887069379-4040235476   Step 3: Open Visual Studio Code within your development_behavior_packs folder  In order for the debugger to know where to find your source JavaScript or TypeScript files, you'll need to specifically open up a window of Visual Studio Code relative to the behavior pack where your JavaScript or TypeScript source files are. This may be inside of Minecraft's development_behavior_packs folder (e.g., %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\development_behavior_packs) - or you may have your source code located in a separate folder (e.g., c:\\projects\\myaddon).  Open up a Visual Studio Code window pointed at the folder with your add-on script source.  Step 4: Prepare Visual Studio Code for a connection  To debug with Minecraft Bedrock Edition, you'll need to connect from Minecraft and into Visual Studio Code. This set of steps assumes you are debugging on the same Windows machine that you are running Minecraft from, but you can also debug across machines and across clients if you want to. If you are debugging across devices, you may need to open up a port within your firewall on the machine that you are running Visual Studio Code within.  You'll want to configure Visual Studio Code to know how to connect to Minecraft. If you're using a sample project such as the TS starter minecraft-scripting-samples/ts-starter, this .vscode/launch.json file is already configured for you. But if you're creating a project from scratch, follow these instructions:  At the root of the behavior pack you want to debug, add a .vscode subfolder. Add the following launch.json file into that .vscode folder.  If your source is in JavaScript and you are developing directly against that source (you do not use a script build process), you'll want to configure launch.json as follows:  JSON Copy {   \"version\": \"0.3.0\",   \"configurations\": [     {       \"type\": \"minecraft-js\",       \"request\": \"attach\",       \"name\": \"Debug with Minecraft\",       \"mode\": \"connect\",       \"preLaunchTask\": \"build\",       \"targetModuleUuid\": \"7c7e693f-99f4-41a9-95e0-1f57b37e1e12\",       \"localRoot\": \"${workspaceFolder}/\",       \"port\": 19144    }   ] }   localRoot should point at the folder which contains your behavior pack with script within it. Port 19144 is the default networking port for Minecraft Script Debugging.  In the example above, targetModuleUuid is an optional parameter that specifies the identifier of your script module, which is located in your behavior pack's manifest.json file. This is important to use if you are developing add-ons in Minecraft while there are multiple behavior packs with script active.  If your source is in a language like TypeScript that generates JavaScript for Minecraft, you will want to use sourceMapRoot and generatedSourceRoot parameters in launch.json:  JSON Copy {   \"version\": \"0.3.0\",   \"configurations\": [     {       \"type\": \"minecraft-js\",       \"request\": \"attach\",       \"name\": \"Debug with Minecraft\",       \"mode\": \"connect\",       \"preLaunchTask\": \"build\",       \"targetModuleUuid\": \"7c7e693f-99f4-41a9-95e0-1f57b37e1e12\",       \"sourceMapRoot\": \"${workspaceFolder}/dist/debug/\",       \"generatedSourceRoot\": \"${workspaceFolder}/dist/scripts/\",       \"port\": 19144    }   ] }   Note that generatedSourceRoot should point at a folder where your generated JavaScript files (*.js) are stored - for example, the outputs of a TypeScript build process. sourceMapRoot should point at a folder where you have source map files - typically created during your build process - that tie your generated JavaScript source files back to your potential TypeScript source.  Run your Minecraft Behavior Pack  Now that you've prepared Visual Studio Code and prepared your behavior pack, you're ready to start debugging!  Within Visual Studio Code, click the \"Debug with Minecraft\" option under the Run menu (or hit F5) to start debugging. This will place Visual Studio Code into \"Listen Mode\", where it awaits a connection from Minecraft.  Start Minecraft and load into a world with your scripting behavior pack.  Use this slash command to connect Minecraft to Visual Studio Code:  script debugger connect  You should see a \"Debugger connected to host\" response from this command if the connection is successful.  You can set breakpoints in your code by clicking on the left-hand side of the editor, on specific lines of code. As you run the tests in the behavior pack, your breakpoints should be hit. You can also view local variables and add watches as necessary.  Debugging with Minecraft Bedrock Dedicated Server  The procedure for debugging with Bedrock Dedicated Server is a little different. When debugging with Bedrock Dedicated Server, Bedrock Dedicated Server (not Visual Studio Code) will listen for debug connections initiated from Visual Studio Code. You'll want to start by installing the Minecraft Bedrock Edition Debugger for Visual Studio Code as described above.  Configure your Bedrock Dedicated Server  By default, Bedrock Dedicated Servers are not configured to allow debug connections. To enable this debugging, you'll need to change some settings within the server.properties file of your Bedrock Dedicated Server.  These settings configure debugging on Bedrock Dedicated Server:  allow-outbound-script-debugging (true/false): enables the /script debugger connect command. Defaults to false. allow-inbound-script-debugging (true false): enables the /script debugger listen command (and the opening of ports on a server). Defaults to false. force-inbound-debug-port (number): Locks the inbound debug port to a particular port. This will set the default script debugging port and prevent a user of the /script debugger listen command from specifying an alternate port.  Within Bedrock Dedicated Server's console, use this slash command to start listening on a port:  script debugger listen 19144  You should see a \"Debugger listening\" response from this command.  Within Visual Studio Code, you'll want to configure your debug settings in launch.json to have Visual Studio connect to Dedicated Server. To do this, set \"mode\" to \"connect\".  JSON Copy {     \"version\": \"0.3.0\",     \"configurations\": [       {         \"type\": \"minecraft-js\",         \"request\": \"attach\",         \"name\": \"Debug with Minecraft\",         \"mode\": \"connect\",         \"preLaunchTask\": \"build\",         \"sourceMapRoot\": \"${workspaceFolder}/dist/debug/\",         \"generatedSourceRoot\": \"${workspaceFolder}/dist/scripts/\",         \"port\": 19144       }     ]   }   Now, hit \"Start Debugging\" inside of Visual Studio Code.  As with when you debug against Minecraft clients, you can set breakpoints in your code by clicking on the left-hand side of the editor, on specific lines of code.  Using the Minecraft Scripting Profiler  A profiler is a set of monitoring code that measures the amount of time spent running various functions. With it, you can identify where most of your time is spent within your scripts. This may then lead you to discovering unexpected function calling patterns that may consume a lot of time.  Run the profiler during a typical session for your script  To get started, ensure you have a behavior pack with JavaScript within it. Your first step is to create a profile session, or in other words, log the performance characteristics of your script as you play through the game.  To run the script profiler and start a new profile session, run the following command:  Copy /script profiler start   Then, exercise your code by running through and playing Minecraft. You'll want to go through normal gameplay or testing patterns to have your JavaScript exercised in representative ways of how players might encounter your experience.  After a while – many minutes, perhaps, end your profiler session by running the following command:  Copy /script profiler stop   This will create a .cpuprofile with a timestamp within your Minecraft log folder.  If you are using the retail version of Minecraft, the log folder is located at:  %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\logs\\  If you are using Minecraft Preview, that log folder is located at:  %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\logs  To view a CPUProfile, simply open it within Visual Studio Code. The first time you open a CPUProfile file, your operating system will ask you how you wish to open the file. Select Open in Visual Studio Code:  (Note that if you wish to have source links from the profile resolve to your source files correctly, start Visual Studio Code (or set its working directory) within the root of your behavior pack.)  By default, this will give you a simple visual listing of the functions that were called during your CPU Profile session, and the cumulative time that they have taken:  As a developer, you can start to optimize your code to adjust for performance - in this case, perhaps organizing code to share instances of a dimension object rather than repeatedly calling world.getDimension.  Note that within Visual Studio Code, you can install an optional \"Flame Chart\" plugin by clicking the little flame icon in the upper right of your screen (circled in red, below):  Note: In versions 1.19.10 and beyond, the script profiler has been expanded to support coverage of core Bedrock API calls in addition to overall function calls.  With this profiler capability, you can quickly identify hotspots and where server time is spent, and spend your time optimizing your code where it matters.  Summary  That's it! Between updated code helpers as you add lines of JavaScript, debugger capabilities within Visual Studio Code, and profiler support we hope you'll be able to write more extensive tests and script much more quickly.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcomponents?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introducing Custom Components 03/27/2025  Custom components are a new way of connecting the configuration of Blocks and Items in JSON to the power of scripting in a very direct and targeted manner. This new concept allows for composability and reusability of script functionality across blocks and items, while also ensuring that the script only runs specifically for that specific block and item.  This new pattern combines a more structured way to listen to the block and item events while getting access to all the power within scripting and ensuring these events run with the same constraints as scripting events do today.  If you'd like to get started in building add-ons with custom components, see our custom components tutorial.   Note  Custom components will be revised and improved in the upcoming Scripting 2.0.0 release. This document describes the current Scripting 1.0.0 version of custom components.  Structure  This new feature is named custom components because script is connected to a given Block or Item's JSON in a manner very similar to attaching one of the built-in Minecraft components. As such, there is both a JSON aspect to the feature as well as a script aspect of the feature.  Script API  Starting from the script API, we are introducing two new major interfaces for Blocks: BlockComponentRegistry and BlockCustomComponent. The BlockComponentRegistry contains a single method on it for registering a new custom component by name:  TypeScript Copy /**  * Provides the functionality for registering custom components  * for blocks.  */ export class BlockComponentRegistry {     /**      * @remarks      * Registers a block custom component that can be used in block      * JSON configuration.      *      * @param name      * The id that represents this custom component. Must have a      * namespace. This id can be specified in a block's JSON      * configuration under the 'minecraft:custom_components' block      * component.      * @param customComponent      * The collection of event functions that will be called when      * the event occurs on a block using this custom component id.      */     registerCustomComponent(name: string, customComponent: BlockCustomComponent): void; }   A custom component in script is the association of name/id, with a set of functionality represented by events. The possible events to listen to are specified within the second interface BlockCustomComponent.  TypeScript Copy /**  * Contains a set of events that will be raised for a block.  * This object must be bound using the BlockRegistry.  */ export interface BlockCustomComponent {     /**      * @remarks      * This function will be called when an entity steps onto the      * block that this custom component is bound to.      *      */     onStepOn?: (arg: BlockComponentStepOnEvent) => void; }   From script, you are able to access the BlockComponentRegistry by listening to the new worldInitialize before event. All registration of custom components must happen during worldInitialize because this functionality is directly attached to block initialization from JSON. From within this event, you can then call registerCustomComponent with a unique namespaced name and an object that implements the BlockCustomComponent interface to register that component. Once a component is registered, any block that uses this component will invoke the callbacks on your object for the relevant events.  A small code sample showing this registration is as follows:  TypeScript Copy world.beforeEvents.worldInitialize.subscribe(initEvent => {     initEvent.blockComponentRegistry.registerCustomComponent('content:turn_to_air', {         onStepOn: e => {             e.block.setPermutation(BlockPermutation.resolve(MinecraftBlockTypes.Air));         },     }); });   In the above example, a custom component is registered with the name content:turn_to_air that listens to the onStepOn event. It is possible to register a JavaScript class as a custom component as well; the only thing that matters is that the BlockCustomComponent interface is adhered to. Here is an example that uses a class pattern instead.  TypeScript Copy class TurnToAirComponent implements BlockCustomComponent {     constructor() {         this.onStepOn = this.onStepOn.bind(this);     }      onStepOn(e: BlockComponentStepOnEvent): void {         e.block.setPermutation(BlockPermutation.resolve(MinecraftBlockTypes.Air));     } }  world.beforeEvents.worldInitialize.subscribe(initEvent => {     initEvent.blockComponentRegistry.registerCustomComponent('content:turn_to_air', new TurnToAirComponent()); });   It is up to you which pattern you prefer depending on the needs of your add-on or world! They are both functionally the same. An important note is that all the event notifications are stateless, and the event parameters will inform you which specific block they pertain to in the world.  To find out more about the Custom Component APIs, see the documentation for the ItemCustomComponent and BlockCustomComponent APIs.  JSON  With a custom component registered to a specific name, then it becomes a question of how to attach it to a custom block. Within a custom block JSON under the components key, there is a new minecraft:custom_components key where custom components can be registered. The custom components are listed here in an ordered array. This array lets you control the order in which registered custom components are notified of a specific event. The following is an example of registering our content:turn_to_air custom component.  JSON Copy     \"minecraft:block\": {         \"description\": {             \"identifier\": \"content:my_block\"         },         // Base Components         \"components\": {             \"minecraft:custom_components\": [\"content:turn_to_air\"],             \"minecraft:loot\": \"loot_tables/blocks/my_block.json\",   In the above example, the custom component is attached alongside other components, like the loot table. If there were multiple custom components registered, then for each type of event, the event will be sent to the custom components in the order they are listed in this array.  It is also possible to add custom components to each specific permutation under the components key as well. However, it is important to note that the custom components array in a permutation fully replaces that array in the base components list. The same custom component can also be used across multiple files. This content:turn_to_air component for example can be reused across multiple custom blocks to have easily aligned and composable behavior. In addition, a custom component can be registered in one behavior pack, and then used from another.  Workflow  As you author custom components and their corresponding scripting code, you have the full power of hot reload to iterate on your changes while in a world.  When making changes to JSON and/or the registration of new custom components, it will be necessary to exit out of a world and re-enter to see your changes reflected.  Once in script, your callbacks can use any API available in the scripting API just like any other script today with the same constraints.  Get started in building custom components  If you'd like to get started in building add-ons with custom components, visit the custom components tutorial.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcomponents?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introducing Custom Components 03/27/2025  Custom components are a new way of connecting the configuration of Blocks and Items in JSON to the power of scripting in a very direct and targeted manner. This new concept allows for composability and reusability of script functionality across blocks and items, while also ensuring that the script only runs specifically for that specific block and item.  This new pattern combines a more structured way to listen to the block and item events while getting access to all the power within scripting and ensuring these events run with the same constraints as scripting events do today.  If you'd like to get started in building add-ons with custom components, see our custom components tutorial.   Note  Custom components will be revised and improved in the upcoming Scripting 2.0.0 release. This document describes the current Scripting 1.0.0 version of custom components.  Structure  This new feature is named custom components because script is connected to a given Block or Item's JSON in a manner very similar to attaching one of the built-in Minecraft components. As such, there is both a JSON aspect to the feature as well as a script aspect of the feature.  Script API  Starting from the script API, we are introducing two new major interfaces for Blocks: BlockComponentRegistry and BlockCustomComponent. The BlockComponentRegistry contains a single method on it for registering a new custom component by name:  TypeScript Copy /**  * Provides the functionality for registering custom components  * for blocks.  */ export class BlockComponentRegistry {     /**      * @remarks      * Registers a block custom component that can be used in block      * JSON configuration.      *      * @param name      * The id that represents this custom component. Must have a      * namespace. This id can be specified in a block's JSON      * configuration under the 'minecraft:custom_components' block      * component.      * @param customComponent      * The collection of event functions that will be called when      * the event occurs on a block using this custom component id.      */     registerCustomComponent(name: string, customComponent: BlockCustomComponent): void; }   A custom component in script is the association of name/id, with a set of functionality represented by events. The possible events to listen to are specified within the second interface BlockCustomComponent.  TypeScript Copy /**  * Contains a set of events that will be raised for a block.  * This object must be bound using the BlockRegistry.  */ export interface BlockCustomComponent {     /**      * @remarks      * This function will be called when an entity steps onto the      * block that this custom component is bound to.      *      */     onStepOn?: (arg: BlockComponentStepOnEvent) => void; }   From script, you are able to access the BlockComponentRegistry by listening to the new worldInitialize before event. All registration of custom components must happen during worldInitialize because this functionality is directly attached to block initialization from JSON. From within this event, you can then call registerCustomComponent with a unique namespaced name and an object that implements the BlockCustomComponent interface to register that component. Once a component is registered, any block that uses this component will invoke the callbacks on your object for the relevant events.  A small code sample showing this registration is as follows:  TypeScript Copy world.beforeEvents.worldInitialize.subscribe(initEvent => {     initEvent.blockComponentRegistry.registerCustomComponent('content:turn_to_air', {         onStepOn: e => {             e.block.setPermutation(BlockPermutation.resolve(MinecraftBlockTypes.Air));         },     }); });   In the above example, a custom component is registered with the name content:turn_to_air that listens to the onStepOn event. It is possible to register a JavaScript class as a custom component as well; the only thing that matters is that the BlockCustomComponent interface is adhered to. Here is an example that uses a class pattern instead.  TypeScript Copy class TurnToAirComponent implements BlockCustomComponent {     constructor() {         this.onStepOn = this.onStepOn.bind(this);     }      onStepOn(e: BlockComponentStepOnEvent): void {         e.block.setPermutation(BlockPermutation.resolve(MinecraftBlockTypes.Air));     } }  world.beforeEvents.worldInitialize.subscribe(initEvent => {     initEvent.blockComponentRegistry.registerCustomComponent('content:turn_to_air', new TurnToAirComponent()); });   It is up to you which pattern you prefer depending on the needs of your add-on or world! They are both functionally the same. An important note is that all the event notifications are stateless, and the event parameters will inform you which specific block they pertain to in the world.  To find out more about the Custom Component APIs, see the documentation for the ItemCustomComponent and BlockCustomComponent APIs.  JSON  With a custom component registered to a specific name, then it becomes a question of how to attach it to a custom block. Within a custom block JSON under the components key, there is a new minecraft:custom_components key where custom components can be registered. The custom components are listed here in an ordered array. This array lets you control the order in which registered custom components are notified of a specific event. The following is an example of registering our content:turn_to_air custom component.  JSON Copy     \"minecraft:block\": {         \"description\": {             \"identifier\": \"content:my_block\"         },         // Base Components         \"components\": {             \"minecraft:custom_components\": [\"content:turn_to_air\"],             \"minecraft:loot\": \"loot_tables/blocks/my_block.json\",   In the above example, the custom component is attached alongside other components, like the loot table. If there were multiple custom components registered, then for each type of event, the event will be sent to the custom components in the order they are listed in this array.  It is also possible to add custom components to each specific permutation under the components key as well. However, it is important to note that the custom components array in a permutation fully replaces that array in the base components list. The same custom component can also be used across multiple files. This content:turn_to_air component for example can be reused across multiple custom blocks to have easily aligned and composable behavior. In addition, a custom component can be registered in one behavior pack, and then used from another.  Workflow  As you author custom components and their corresponding scripting code, you have the full power of hot reload to iterate on your changes while in a world.  When making changes to JSON and/or the registration of new custom components, it will be necessary to exit out of a world and re-enter to see your changes reflected.  Once in script, your callbacks can use any API available in the scripting API just like any other script today with the same constraints.  Get started in building custom components  If you'd like to get started in building add-ons with custom components, visit the custom components tutorial.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcomponentstutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Building with Custom Components 03/27/2025 Create an Add-On with Custom Components  Custom blocks and items use various components, declared in their definitions, to augment the behavior of the block or item.  Until now, all components have been built-in to Minecraft, with various parameters used to control the component's behavior. With custom components, you can define your own behavior for blocks and items when combined with scripting! In this tutorial we will make a small block and item example using custom components and scripting by adding a new strawberry crop and strawberry item. The strawberry plants will have the behavior that, if they are not picked when they are ripe, can go bad. You'll have to time it just right to get fresh strawberries, and in this sample, you'll see the block components that manage crop growth rates in addition to custom item effects.  You can find the source of this example on the github.com/microsoft/minecraft-scripting-samples.  Prerequisites  Before you begin, you should have gone through the Getting Started with Add-Ons tutorial, the Introduction to Behavior Packs tutorial, and the Introduction to Scripting tutorial.  Getting Started with Add-On Development Introduction to Behavior Packs Introduction to Scripting  You'll want to be comfortable with how add-on folders are structured, what required files the behavior pack should contain, and how to use scripting with your behavior pack.  Some other good resources to know are how to make blocks and items in your add-on:  Creating a Custom Die Block Item Custom Components  The strawberry item will utilize custom components to give the player that eats it night vision. First lets make the strawberry item itself.  JSON Copy {   \"format_version\": \"1.21.10\",   \"minecraft:item\": {     \"description\": {       \"menu_category\": {         \"group\": \"itemGroup.name.crop\",         \"category\": \"nature\"       },       \"identifier\": \"example:strawberry\"     },     \"components\": {       \"minecraft:icon\": \"strawberry\",       \"minecraft:max_stack_size\": 64,       \"minecraft:use_modifiers\": {         \"use_duration\": 1.6,         \"movement_modifier\": 0.35       },       \"minecraft:food\": {         \"can_always_eat\": true,         \"nutrition\": 1,         \"saturation_modifier\": 0.5       },       \"minecraft:use_animation\": \"eat\",     }   } }  Adding Custom Components to Items  To add custom components to an item, add a minecraft:custom_components component to the item which has an array of strings.  Within this array, the strings are the name of the component that you are adding. When an event occurs, the components will run some script, and this will run in the order defined in your JSON. This means that one item can run the same components in a different order than another item. For our strawberry, we will need only 1 component, but for your own items you can add more custom components to the array.  JSON Copy \"minecraft:custom_components\": [     \"example:add_night_vision_on_consume\" ]   The name you choose for your custom component requires a namespace before it. In the code above, the namespace is example and the component name is add_night_vision_on_consume.  Registering Item Custom Components in Script  Now that our item has been configured to have a custom component, we need to register the behavior for the component in script. The behavior we want is that when you eat the strawberry, the player receives night vision for some time. First, we register our component using the same name we defined in the JSON component to the ItemComponentRegistry and provide a list of events that this component is listening for. In this case we are going to listen to the onConsume event for item custom components which will run our code when the item is consumed by a player. We can then add the night vision effect to the player and our custom component is now ready to be used.  TypeScript Copy import { ItemComponentConsumeEvent, world } from \"@minecraft/server\";  world.beforeEvents.worldInitialize.subscribe(initEvent => {   initEvent.itemComponentRegistry.registerCustomComponent('example:add_night_vision_on_consume', {     onConsume(arg: ItemComponentConsumeEvent) {       arg.source.addEffect('minecraft:night_vision', 600);     }   }); });   Notice that the component code and name do not reference the strawberry item itself. You can reuse components on multiple items that have similar behavior.  Block Custom Components  Block custom components work very similarly to item custom components. First we need our block definition:  JSON Copy {   \"format_version\": \"1.21.10\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"example:strawberry_crop\",       \"states\": {         \"starter:crop_age\": [ 0, 1, 2, 3, 4 ]       }     },     \"permutations\": [       {         \"condition\": \"query.block_state('starter:crop_age') == 4\",         \"components\": {           \"minecraft:loot\": \"loot_tables/strawberry_grown_crop.json\"         }       }     ],     \"components\": {       \"minecraft:geometry\": \"geometry.starter_crop_geo\",       \"minecraft:loot\": \"loot_tables/strawberry_seed.json\",       \"minecraft:collision_box\": false,       \"minecraft:placement_filter\": {         \"conditions\": [           {             \"allowed_faces\": [\"up\"],             \"block_filter\": [\"minecraft:farmland\"]           }         ]       },       \"tag:minecraft:crop\": {}     }   } }  Adding Custom Components to Blocks  Similar to item custom components, we use the minecraft:custom_components component in the block JSON to define what custom components this block has. In this case we are going to add 2 different components definitions: one in the base of the block and one within the permutation. When both a block permutation and base block use the minecraft:custom_components component, only the components listed in the permutation will have their script code run. This allows you to reorder, remove, or add new custom components to specific permutations of a block. Since the first 4 permutations (age 0-3) of the strawberry crop all use the same custom components, we can just put this in the base block's component list. The last permutation (age 4) will have some additional functionality so we can harvest the fully grown strawberries, so it will need its own minecraft:custom_components to override the one in the base block.  JSON Copy {   \"format_version\": \"1.21.10\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"example:strawberry_crop\",       \"states\": {         \"starter:crop_age\": [ 0, 1, 2, 3, 4 ]       }     },     \"permutations\": [       {         \"condition\": \"query.block_state('example:crop_age') == 4\",         \"components\": {           \"minecraft:loot\": \"loot_tables/strawberry_grown_crop.json\"         },         \"minecraft:custom_components\": [           \"example:crop_harvest\"         ]       }     ],     \"components\": {       \"minecraft:geometry\": \"geometry.example_crop_geo\",       \"minecraft:loot\": \"loot_tables/strawberry_seed.json\",       \"minecraft:collision_box\": false,       \"minecraft:placement_filter\": {         \"conditions\": [           {             \"allowed_faces\": [\"up\"],             \"block_filter\": [\"minecraft:farmland\"]           }         ]       },       \"tag:minecraft:crop\": {},       \"minecraft:custom_components\": [         \"example:crop_grow\"       ]     }   } }  Registering Block Custom Components in Script  Similar to items, we register the component in script with a list of events that the component is listening to and the behavior that should be run when the event is raised. For items we used the ItemComponentRegistry to do this; for blocks we use the BlockComponentRegistry. In this case, we have two components to fill out. The item example above showed how to do this by placing your behavior in the registration statement. These two components will look at two alternate ways you can organize your code.  \"example:crop_grow\" Component  This component is designed to grow crops, which we can do by listening to the onRandomTick event for block custom components, and changing the block's permutation to the next age. This component is registered by giving the event a function to run where the previous item custom component example had its code.  TypeScript Copy import {   BlockComponentRandomTickEvent,   world } from \"@minecraft/server\";  function cropGrowRandomTick(event : BlockComponentRandomTickEvent) {   const age = event.block.permutation.getState('example:crop_age');   if (age === undefined || typeof age !== 'number') {     return;   }   else if (age === 4) {     return; // fully grown   }    event.block.setPermutation(event.block.permutation.withState('example:crop_age', age + 1)); }  world.beforeEvents.worldInitialize.subscribe(initEvent => {   initEvent.blockComponentRegistry.registerCustomComponent('example:crop_grow', {     onRandomTick: cropGrowRandomTick,   }); });  \"example:crop_harvest\" Component  The crop grown component exists on only the finished crop when it is ready to be harvested. This component will allow the player to interact with the block to harvest the strawberries without having to break the block. It then \"replants\" the strawberries by changing the block permutation back to the first growth stage. This component is registered by making a new class that implements the BlockCustomComponent object, giving you a third way to register components. The same can be done with items and the ItemCustomComponent object.  TypeScript Copy import {   BlockCustomComponent,   BlockComponentPlayerInteractEvent,   world } from \"@minecraft/server\";  class BlockCropHarvestComponent implements BlockCustomComponent {   onPlayerInteract(event : BlockComponentPlayerInteractEvent) {     if (event.player === undefined) {       return;     }      const blockPos = event.block.location;     event.dimension.runCommand('loot spawn ' +       blockPos.x + ' ' +       blockPos.y + ' ' +       blockPos.z + ' loot strawberry_grown_crop'     );     event.block.setPermutation(event.block.permutation.withState('example:crop_age', 0));   } };  world.beforeEvents.worldInitialize.subscribe(initEvent => {   initEvent.blockComponentRegistry.registerCustomComponent('example:crop_harvest', new BlockCropHarvestComponent()); });   Congratulations! You now have a block and an item using custom components. Check out our custom components sample at the Minecraft Scripting Samples repository.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcomponentstutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Building with Custom Components 03/27/2025 Create an Add-On with Custom Components  Custom blocks and items use various components, declared in their definitions, to augment the behavior of the block or item.  Until now, all components have been built-in to Minecraft, with various parameters used to control the component's behavior. With custom components, you can define your own behavior for blocks and items when combined with scripting! In this tutorial we will make a small block and item example using custom components and scripting by adding a new strawberry crop and strawberry item. The strawberry plants will have the behavior that, if they are not picked when they are ripe, can go bad. You'll have to time it just right to get fresh strawberries, and in this sample, you'll see the block components that manage crop growth rates in addition to custom item effects.  You can find the source of this example on the github.com/microsoft/minecraft-scripting-samples.  Prerequisites  Before you begin, you should have gone through the Getting Started with Add-Ons tutorial, the Introduction to Behavior Packs tutorial, and the Introduction to Scripting tutorial.  Getting Started with Add-On Development Introduction to Behavior Packs Introduction to Scripting  You'll want to be comfortable with how add-on folders are structured, what required files the behavior pack should contain, and how to use scripting with your behavior pack.  Some other good resources to know are how to make blocks and items in your add-on:  Creating a Custom Die Block Item Custom Components  The strawberry item will utilize custom components to give the player that eats it night vision. First lets make the strawberry item itself.  JSON Copy {   \"format_version\": \"1.21.10\",   \"minecraft:item\": {     \"description\": {       \"menu_category\": {         \"group\": \"itemGroup.name.crop\",         \"category\": \"nature\"       },       \"identifier\": \"example:strawberry\"     },     \"components\": {       \"minecraft:icon\": \"strawberry\",       \"minecraft:max_stack_size\": 64,       \"minecraft:use_modifiers\": {         \"use_duration\": 1.6,         \"movement_modifier\": 0.35       },       \"minecraft:food\": {         \"can_always_eat\": true,         \"nutrition\": 1,         \"saturation_modifier\": 0.5       },       \"minecraft:use_animation\": \"eat\",     }   } }  Adding Custom Components to Items  To add custom components to an item, add a minecraft:custom_components component to the item which has an array of strings.  Within this array, the strings are the name of the component that you are adding. When an event occurs, the components will run some script, and this will run in the order defined in your JSON. This means that one item can run the same components in a different order than another item. For our strawberry, we will need only 1 component, but for your own items you can add more custom components to the array.  JSON Copy \"minecraft:custom_components\": [     \"example:add_night_vision_on_consume\" ]   The name you choose for your custom component requires a namespace before it. In the code above, the namespace is example and the component name is add_night_vision_on_consume.  Registering Item Custom Components in Script  Now that our item has been configured to have a custom component, we need to register the behavior for the component in script. The behavior we want is that when you eat the strawberry, the player receives night vision for some time. First, we register our component using the same name we defined in the JSON component to the ItemComponentRegistry and provide a list of events that this component is listening for. In this case we are going to listen to the onConsume event for item custom components which will run our code when the item is consumed by a player. We can then add the night vision effect to the player and our custom component is now ready to be used.  TypeScript Copy import { ItemComponentConsumeEvent, world } from \"@minecraft/server\";  world.beforeEvents.worldInitialize.subscribe(initEvent => {   initEvent.itemComponentRegistry.registerCustomComponent('example:add_night_vision_on_consume', {     onConsume(arg: ItemComponentConsumeEvent) {       arg.source.addEffect('minecraft:night_vision', 600);     }   }); });   Notice that the component code and name do not reference the strawberry item itself. You can reuse components on multiple items that have similar behavior.  Block Custom Components  Block custom components work very similarly to item custom components. First we need our block definition:  JSON Copy {   \"format_version\": \"1.21.10\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"example:strawberry_crop\",       \"states\": {         \"starter:crop_age\": [ 0, 1, 2, 3, 4 ]       }     },     \"permutations\": [       {         \"condition\": \"query.block_state('starter:crop_age') == 4\",         \"components\": {           \"minecraft:loot\": \"loot_tables/strawberry_grown_crop.json\"         }       }     ],     \"components\": {       \"minecraft:geometry\": \"geometry.starter_crop_geo\",       \"minecraft:loot\": \"loot_tables/strawberry_seed.json\",       \"minecraft:collision_box\": false,       \"minecraft:placement_filter\": {         \"conditions\": [           {             \"allowed_faces\": [\"up\"],             \"block_filter\": [\"minecraft:farmland\"]           }         ]       },       \"tag:minecraft:crop\": {}     }   } }  Adding Custom Components to Blocks  Similar to item custom components, we use the minecraft:custom_components component in the block JSON to define what custom components this block has. In this case we are going to add 2 different components definitions: one in the base of the block and one within the permutation. When both a block permutation and base block use the minecraft:custom_components component, only the components listed in the permutation will have their script code run. This allows you to reorder, remove, or add new custom components to specific permutations of a block. Since the first 4 permutations (age 0-3) of the strawberry crop all use the same custom components, we can just put this in the base block's component list. The last permutation (age 4) will have some additional functionality so we can harvest the fully grown strawberries, so it will need its own minecraft:custom_components to override the one in the base block.  JSON Copy {   \"format_version\": \"1.21.10\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"example:strawberry_crop\",       \"states\": {         \"starter:crop_age\": [ 0, 1, 2, 3, 4 ]       }     },     \"permutations\": [       {         \"condition\": \"query.block_state('example:crop_age') == 4\",         \"components\": {           \"minecraft:loot\": \"loot_tables/strawberry_grown_crop.json\"         },         \"minecraft:custom_components\": [           \"example:crop_harvest\"         ]       }     ],     \"components\": {       \"minecraft:geometry\": \"geometry.example_crop_geo\",       \"minecraft:loot\": \"loot_tables/strawberry_seed.json\",       \"minecraft:collision_box\": false,       \"minecraft:placement_filter\": {         \"conditions\": [           {             \"allowed_faces\": [\"up\"],             \"block_filter\": [\"minecraft:farmland\"]           }         ]       },       \"tag:minecraft:crop\": {},       \"minecraft:custom_components\": [         \"example:crop_grow\"       ]     }   } }  Registering Block Custom Components in Script  Similar to items, we register the component in script with a list of events that the component is listening to and the behavior that should be run when the event is raised. For items we used the ItemComponentRegistry to do this; for blocks we use the BlockComponentRegistry. In this case, we have two components to fill out. The item example above showed how to do this by placing your behavior in the registration statement. These two components will look at two alternate ways you can organize your code.  \"example:crop_grow\" Component  This component is designed to grow crops, which we can do by listening to the onRandomTick event for block custom components, and changing the block's permutation to the next age. This component is registered by giving the event a function to run where the previous item custom component example had its code.  TypeScript Copy import {   BlockComponentRandomTickEvent,   world } from \"@minecraft/server\";  function cropGrowRandomTick(event : BlockComponentRandomTickEvent) {   const age = event.block.permutation.getState('example:crop_age');   if (age === undefined || typeof age !== 'number') {     return;   }   else if (age === 4) {     return; // fully grown   }    event.block.setPermutation(event.block.permutation.withState('example:crop_age', age + 1)); }  world.beforeEvents.worldInitialize.subscribe(initEvent => {   initEvent.blockComponentRegistry.registerCustomComponent('example:crop_grow', {     onRandomTick: cropGrowRandomTick,   }); });  \"example:crop_harvest\" Component  The crop grown component exists on only the finished crop when it is ready to be harvested. This component will allow the player to interact with the block to harvest the strawberries without having to break the block. It then \"replants\" the strawberries by changing the block permutation back to the first growth stage. This component is registered by making a new class that implements the BlockCustomComponent object, giving you a third way to register components. The same can be done with items and the ItemCustomComponent object.  TypeScript Copy import {   BlockCustomComponent,   BlockComponentPlayerInteractEvent,   world } from \"@minecraft/server\";  class BlockCropHarvestComponent implements BlockCustomComponent {   onPlayerInteract(event : BlockComponentPlayerInteractEvent) {     if (event.player === undefined) {       return;     }      const blockPos = event.block.location;     event.dimension.runCommand('loot spawn ' +       blockPos.x + ' ' +       blockPos.y + ' ' +       blockPos.z + ' loot strawberry_grown_crop'     );     event.block.setPermutation(event.block.permutation.withState('example:crop_age', 0));   } };  world.beforeEvents.worldInitialize.subscribe(initEvent => {   initEvent.blockComponentRegistry.registerCustomComponent('example:crop_harvest', new BlockCropHarvestComponent()); });   Congratulations! You now have a block and an item using custom components. Check out our custom components sample at the Minecraft Scripting Samples repository.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcommands?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Scripting Custom Commands Overview 03/27/2025  There is also a video version available of this overview of Scripting Custom Commands:  Scripting Custom Commands  Commands are a critical part of nearly any creator project. Commonly, projects are boot-strapped and tested via a set of custom commands and functions, including commands that can reset environments or change configurations. In multiplayer environments, a set of commands can be used to administer games. You can also use commands to provide helpful little builder functions, to further build out your world.  Starting in Minecraft Bedrock Edition 1.21.80.22 Preview, you can now implement custom commands in script. These commands have the full capability of scripting APIs and custom logic, allowing you to implement sophisticated operations.  Note that in the current beta, context on the executing environment (e.g., the player who ran the command, or the initiator in NPC environments) is not available; we are looking to bring this execution context in future.  You can view a sample project at https://github.com/microsoft/minecraft-scripting-samples.  Using 2.0.0-beta scripting environment  To get started, we'll want to work with the 2.0.0-beta scripting environment. Custom commands and registration only run in the v2.0.0 scripting environment, which itself is currently in beta.  You'll want to make sure you use 2.0.0-beta as your scripting environment, in the manifest of your behavior pack:  JSON Copy   {     \"module_name\": \"@minecraft/server\",     \"version\": \"2.0.0-beta\"   },  Registering Commands  The first step is to register the command. You can do this within the startup event of system.beforeEvents, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Celebration size\",     permissionLevel: CustomCommandPermissionLevel.Admin,     optionalParameters: [{ type: CustomCommandParamType.Integer, name: \"celebrationSize\" }],   };   init.customCommandRegistry.registerCommand(helloCommand, helloCustomCommand); }   There are several parameters you will need to specify:  Expand table Parameter\tDescription name\tName of the command that is used. Custom commands must be namespaced (that is, follow the form of namespace:commandname). description\tDescription of the command. This will show up in autocomplete for the command. permissionLevel\tRelative permission level of the command. mandatoryParameters\tA list of mandatory parameters for the command. These will come first in the list of parameters that a command may have. optionalParameters\tA list of optional parameters for the command. These will come second in the list of parameters. Permission Levels  Commands can have a permission level that is required from executing contexts and players.  Expand table Parameter\tDescription Any\tAny player or environment can run this command. GameDirectors\tRequires a player with an \"Operator Commands\" permission to run this command. Also, scripting and command environments, like command blocks, can run this command. Admin\tRequires a player with \"Operator Commands\" permission. Commands with this level cannot be used in automations like commands or script Host\tOnly the originating game owner can run this command. Owner\tIn dedicated server environments, this command can only be exited in the hosting environment at the dedicated server console. Command Enums  As of the 1.21.80-preview.27 release you can now register custom enums for script-based commands, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const commandRegistry = event.customCommandRegistry;    commandRegistry.registerEnum(\"creator:my_enum\", [\"foo\", \"bar\", \"baz\"]);    const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Example command\",     permissionLevel: CustomCommandPermissionLevel.Any,     mandatoryParameters: [       {          type: CustomCommandParamType.Enum,          name: \"creator:my_enum\" // The parameter name must match the registered enum name above     }],   };   commandRegistry.registerCommand(helloCommand, helloCustomCommand); }  Execution  After registering your command, Minecraft will call into your function with the parameters that are specified by the command context.  Expand table Parameter Type\tCorresponding data variable type BlockType\t@minecraft/server.BlockType Boolean\tboolean EntitySelector\tEntity[] Float\tnumber Integer\tnumber ItemType\t@minecraft/server.ItemType Position\tVector3 PlayerSelector\tPlayer[] String\tstring  If the parameter is optional, then undefined is passed in if the parameter is not specified.  Note that script command function runs in a \"before\" context, meaning that most methods that change state are unavailable in the command context. To run commands that change world state, you'll want to consider wrapping them in a function that defers execution until later in the tick, such as system.run for example:  TypeScript Copy     system.run(() => {       for (const player of world.getPlayers()) {         player.dimension.createExplosion(player.location, celebrationSize);       }     });  Summary  Custom script-based commands unlocks a new organization tool for functionality you have in your creations. Whether a simple internal reset tool or a sophisticated game administration suite, we hope that providing a set of powerful commands is easy and second nature in your projects.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customcommands?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Scripting Custom Commands Overview 03/27/2025  There is also a video version available of this overview of Scripting Custom Commands:  Scripting Custom Commands  Commands are a critical part of nearly any creator project. Commonly, projects are boot-strapped and tested via a set of custom commands and functions, including commands that can reset environments or change configurations. In multiplayer environments, a set of commands can be used to administer games. You can also use commands to provide helpful little builder functions, to further build out your world.  Starting in Minecraft Bedrock Edition 1.21.80.22 Preview, you can now implement custom commands in script. These commands have the full capability of scripting APIs and custom logic, allowing you to implement sophisticated operations.  Note that in the current beta, context on the executing environment (e.g., the player who ran the command, or the initiator in NPC environments) is not available; we are looking to bring this execution context in future.  You can view a sample project at https://github.com/microsoft/minecraft-scripting-samples.  Using 2.0.0-beta scripting environment  To get started, we'll want to work with the 2.0.0-beta scripting environment. Custom commands and registration only run in the v2.0.0 scripting environment, which itself is currently in beta.  You'll want to make sure you use 2.0.0-beta as your scripting environment, in the manifest of your behavior pack:  JSON Copy   {     \"module_name\": \"@minecraft/server\",     \"version\": \"2.0.0-beta\"   },  Registering Commands  The first step is to register the command. You can do this within the startup event of system.beforeEvents, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Celebration size\",     permissionLevel: CustomCommandPermissionLevel.Admin,     optionalParameters: [{ type: CustomCommandParamType.Integer, name: \"celebrationSize\" }],   };   init.customCommandRegistry.registerCommand(helloCommand, helloCustomCommand); }   There are several parameters you will need to specify:  Expand table Parameter\tDescription name\tName of the command that is used. Custom commands must be namespaced (that is, follow the form of namespace:commandname). description\tDescription of the command. This will show up in autocomplete for the command. permissionLevel\tRelative permission level of the command. mandatoryParameters\tA list of mandatory parameters for the command. These will come first in the list of parameters that a command may have. optionalParameters\tA list of optional parameters for the command. These will come second in the list of parameters. Permission Levels  Commands can have a permission level that is required from executing contexts and players.  Expand table Parameter\tDescription Any\tAny player or environment can run this command. GameDirectors\tRequires a player with an \"Operator Commands\" permission to run this command. Also, scripting and command environments, like command blocks, can run this command. Admin\tRequires a player with \"Operator Commands\" permission. Commands with this level cannot be used in automations like commands or script Host\tOnly the originating game owner can run this command. Owner\tIn dedicated server environments, this command can only be exited in the hosting environment at the dedicated server console. Command Enums  As of the 1.21.80-preview.27 release you can now register custom enums for script-based commands, like so:  TypeScript Copy system.beforeEvents.startup.subscribe((init: StartupEvent) => {   const commandRegistry = event.customCommandRegistry;    commandRegistry.registerEnum(\"creator:my_enum\", [\"foo\", \"bar\", \"baz\"]);    const helloCommand: CustomCommand = {     name: \"creator:hellocustomcommand\",     description: \"Example command\",     permissionLevel: CustomCommandPermissionLevel.Any,     mandatoryParameters: [       {          type: CustomCommandParamType.Enum,          name: \"creator:my_enum\" // The parameter name must match the registered enum name above     }],   };   commandRegistry.registerCommand(helloCommand, helloCustomCommand); }  Execution  After registering your command, Minecraft will call into your function with the parameters that are specified by the command context.  Expand table Parameter Type\tCorresponding data variable type BlockType\t@minecraft/server.BlockType Boolean\tboolean EntitySelector\tEntity[] Float\tnumber Integer\tnumber ItemType\t@minecraft/server.ItemType Position\tVector3 PlayerSelector\tPlayer[] String\tstring  If the parameter is optional, then undefined is passed in if the parameter is not specified.  Note that script command function runs in a \"before\" context, meaning that most methods that change state are unavailable in the command context. To run commands that change world state, you'll want to consider wrapping them in a function that defers execution until later in the tick, such as system.run for example:  TypeScript Copy     system.run(() => {       for (const player of world.getPlayers()) {         player.dimension.createExplosion(player.location, celebrationSize);       }     });  Summary  Custom script-based commands unlocks a new organization tool for functionality you have in your creations. Whether a simple internal reset tool or a sophisticated game administration suite, we hope that providing a set of powerful commands is easy and second nature in your projects.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/systemrunguide?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Game Loops and Timed Callbacks - a system.run Guide 02/16/2024  This guide will help you get familiar with the system.run APIs, how they work, how to use them, and why you might choose one over the other for a given task. After reading this article, you should have a good understanding of how system.run can be used to create a game loop and how system.runJob can assist you with long running operations.  The script tick  Before we dive into how to use the system.run APIs, let's first go over the Minecraft script tick. Consider the following outline of operations that occur during a single tick:  Tick Start  Minecraft simulation begins and before events are triggered.  Scripts for these are limited to read-only state. In other words, script is not allowed to alter world state within these callbacks.  Start of the \"script\" tick  Execution is now within the script portion of the tick.  Process \"asynchronous code\" continuations  Code following await would execute here.  Process system job queue with a time slice based on current and previous frame estimates  For generators created with system.runJob.  Loop over system.run callbacks and after events.  Process all system.run callbacks. Process all before and after events. Possibly queue any new before and after events as a result of previous steps. Repeat until no more events or system callbacks are queued for the current tick.  Increment tick and end the script portion of the tick.  Tick End The system.run family of APIs  You may be familiar with the concept of a game loop from other game engines or modding tools. While other game engines may have a update functions to override or function or tick events to register for, Bedrock takes a slightly different approach. Turning to web development for inspiration, Bedrock per tick APIs are modeled after the web's setInterval and setTimeout functions. The Bedrock equivalents are system.run, system.runTimeout, and system.runInterval. With these methods, you have everything you need to create a game loop.  A first look at the simplest one - system.run Using system.run to create the game loop JavaScript Copy import { system } from \"@minecraft/server\";  function update() {     // game logic here...      // queue update function for next tick     system.run(update); }  system.run(update);   This will execute the update() function for each iteration of the Minecraft simulation. This occurs during section 4 from above.  As shown in this example, it is acceptable to queue another callback from within an existing system.run callback. This works because system.run will mark the new callback to execute during the following tick. This is an important concept to understand. It ensures that the system.run method cannot call itself infinitely within a single tick, which would trigger a watchdog shutdown event.  Using system.run to queue work for later in the frame  Another interesting use case for system.run is to schedule work from a before event to later in the frame. As you may know, before events execute in 'read-only' mode. In this mode, functions that change Minecraft world state (such as spawning entities, or setting blocks) are not allowed. By using system.run, you can defer these operations until later in the tick. Consider the following script.  TypeScript Copy import {      ExplosionBeforeEvent,     system,     world } from \"@minecraft/server\";  function explosionBeforeEventHandler(e: ExplosionBeforeEvent) {     // cannot spawn a pig in the event handler,      // read-only operations only          // queue for later in the current tick     system.run(() => {         e.dimension.spawnEntity('pig', { x: 1, y: 4, z: 1 });     }) }  world.beforeEvents.explosion.subscribe(explosionBeforeEventHandler);   In this example, the work being done by the event handler alters world state so it must be deferred until later in the frame. Referencing the script tick from above, the event happens at section 1, and is deferred to section 4 using system.run.  Keep in mind that you would not be able to put event cancelation logic in the deferred portion of the event, as the event will have already happened by the time the system.run callback executes.  Next up: the one with a tick parameter - system.runTimeout  The system.runTimeout function behaves much like system.run except that it offers a new parameter that lets you indicate how many ticks into the future it should run. If that future tick is 0, it means the current tick or as soon as possible. If the parameter is 1, it behaves much like the standard system.run. A value of 2 means to skip the next tick and execute on the one after.  As stated above, system.runTimeout with a tick parameter of 1 is equivalent to system.run. And just like system.run, if called from within a system.run callback a value of 1 means the next tick. Only if called at the beginning of the tick, or otherwise outside of any system.run* callbacks would a value of 1 execute in the current tick.  A call to system.runTimeout with a tick parameter of 0 means to execute as soon as possible. And unlike system.run, if called from within a system.run callback a value of 0 means to execute within the current tick. This version does not stop you from creating infinite callbacks so be careful when using it in this way.  Here are some example usages:  JavaScript Copy // execute as soon as possible, the next time system.run events are processed system.runTimeout(() => {}, 0);  // execute this tick if we haven't yet processed system.run events,  // otherwise execute next tick system.runTimeout(() => {}, 1);  // execute the tick after next system.runTimeout(() => {}, 2);   When using system.runTimeout with a tick parameter of 0 or 1 it can sometimes be tricky to know exactly which tick that will execute on - either the current tick or the next. In most cases it is simpler to use system.run, knowing that it will execute as soon as possible while being safe enough to not cause infinite recursion.  Then the one that keeps going on its own - system.runInterval  Next we have system.runInterval. This method is similar to system.runTimeout except that it will re-queue the same callback on your behalf until you call system.clearRun. Much like system.runTimeout, system.runInterval with a tick parameter of 1 will run the first time on the next tick, and then again each subsequent tick until it is cleared. And system.runInterval with a tick parameter of 2 means to run every other tick. A value of 0 for the tick parameter is effectively the same as system.runInterval with a tick parameter of 1 - there is no way to get a runInterval to infinitely queue itself into a watchdog event.  JavaScript Copy import { system } from \"@minecraft/server\";  function tick() {     // called every tick } system.runInterval(tick, 0);   Could you use system.runInterval to create a game loop? Absolutely. But system.run is arguably more flexible. Perhaps there's a condition within the tick function that you are waiting on, and you don't need any additional tick callbacks until that condition is true. At that point, you can make the call to system.run to queue the next tick. However, with system.runInterval your tick function will be called every tick, whether you want it to or not.  And finally - system.runJob  The system.runJob method is different from the other system.run methods in a number of ways. It is not well suited for event deferral or game loops. It is best for handling long running tasks that don't need to finish on a specific tick.  It can be difficult to know how much work can be done in a given tick without slowing down the simulation. If you do too little, the results of the operation could take longer than necessary in terms of real game time. But if you do too much work it may trigger a watchdog event, or cause another aspect of the game to appear broken or slow to the user. Hardware differences make matters even worse: what is performant on a PC may be slow on a mobile device or console.  The system.runJob method aims to provide a mechanism for performing long running tasks on your behalf without the need to micromanage the amount of work that occurs each tick. It does this by performing work in small increments while closely monitoring how much time has been used, and how much time is left. When approaching the limit, it will stop and continue the remainder of the work next tick, or the tick after, or some future tick until all the work is completed.  How does it work? With the help of JavaScript generator functions. For example, let's say you want to place a 10x10x10 structure of blocks. If you attempt do this in a single tick, you risk running into a watchdog limit and a simulation slowdown. When using system.runJob, you can rely on the job system to only do as much work as the tick will allow. This may mean that your cube of blocks can be completed within a single frame, but more likely it will take a few frames to get the job done on anything less than the fastest PC hardware. Keep in mind that this is the tradeoff with system.runJob. You allow the job system to keep the simulation running at a consistent rate, but with the understanding that your task may not finish in the same number of ticks on all devices, or even on the same device depending on how much time is allotted to the job queue in a given tick.  JavaScript Copy import {     system,      world,     BlockPermutation } from \"@minecraft/server\";  function* blockPlacingGenerator(size, startX, startY, startZ) {     const overworld = world.getDimension('overworld');     const perm = BlockPermutation.resolve(\"minecraft:planks\");     for (let x = startX; x < startX + size; x++) {         for (let y = startY; y < startY + size; y++) {             for (let z = startZ; z < startZ + size; z++) {                 const block = overworld.getBlock({ x: x, y: y, z: z });                 if (block) {                     block.setPermutation(perm);                 }                 // yield back to job coordinator after ever place                 yield;             }         }     } } // build a 10x10x10 cube of plank blocks starting at world location -2, -60, 1. system.runJob(generator(10, -2, -60, 1));   In this example, the generator yields execution after every block place operation. This means that the job queue is the deciding factor for how many block place operations execute each tick. It is a best practice to author generator functions with a high level of granularity. That means generator functions should be authored such that a single iteration of the generator (a single block place in this example) would be unlikely to exceed the frame time. This enables the job system to scale based on the performance of the device. On a fast PC it may be able to do 30 block place operations, but on mobile that number drops to 5. A poorly authored generator function may perform 5 iterations on a fast PC but on a mobile device it can only do 1 and that single operation triggers a watchdog warning.  It is important to keep in mind that the job system will not starve your generators. At a minimum, every generator for every script behavior pack that has generators will be allowed to execute at least 1 iteration every tick. It is therefore up to the author to ensure a single iteration does not exceed the time allotment of the script tick.  Best practices when writing generator functions for system.runJob Choose a high level of granularity in your generator functions. This offers the most flexibility when the job system has to scale to the performance of different devices. Try to keep the amount of work consistent between iterations. This helps the job system correctly estimate how much time to give each generator per tick. Wrapping up  Hopefully you have enough information to get started using the system.run APIs, when to choose one over the other and how to know when a given callback will execute.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/systemrunguide?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Game Loops and Timed Callbacks - a system.run Guide 02/16/2024  This guide will help you get familiar with the system.run APIs, how they work, how to use them, and why you might choose one over the other for a given task. After reading this article, you should have a good understanding of how system.run can be used to create a game loop and how system.runJob can assist you with long running operations.  The script tick  Before we dive into how to use the system.run APIs, let's first go over the Minecraft script tick. Consider the following outline of operations that occur during a single tick:  Tick Start  Minecraft simulation begins and before events are triggered.  Scripts for these are limited to read-only state. In other words, script is not allowed to alter world state within these callbacks.  Start of the \"script\" tick  Execution is now within the script portion of the tick.  Process \"asynchronous code\" continuations  Code following await would execute here.  Process system job queue with a time slice based on current and previous frame estimates  For generators created with system.runJob.  Loop over system.run callbacks and after events.  Process all system.run callbacks. Process all before and after events. Possibly queue any new before and after events as a result of previous steps. Repeat until no more events or system callbacks are queued for the current tick.  Increment tick and end the script portion of the tick.  Tick End The system.run family of APIs  You may be familiar with the concept of a game loop from other game engines or modding tools. While other game engines may have a update functions to override or function or tick events to register for, Bedrock takes a slightly different approach. Turning to web development for inspiration, Bedrock per tick APIs are modeled after the web's setInterval and setTimeout functions. The Bedrock equivalents are system.run, system.runTimeout, and system.runInterval. With these methods, you have everything you need to create a game loop.  A first look at the simplest one - system.run Using system.run to create the game loop JavaScript Copy import { system } from \"@minecraft/server\";  function update() {     // game logic here...      // queue update function for next tick     system.run(update); }  system.run(update);   This will execute the update() function for each iteration of the Minecraft simulation. This occurs during section 4 from above.  As shown in this example, it is acceptable to queue another callback from within an existing system.run callback. This works because system.run will mark the new callback to execute during the following tick. This is an important concept to understand. It ensures that the system.run method cannot call itself infinitely within a single tick, which would trigger a watchdog shutdown event.  Using system.run to queue work for later in the frame  Another interesting use case for system.run is to schedule work from a before event to later in the frame. As you may know, before events execute in 'read-only' mode. In this mode, functions that change Minecraft world state (such as spawning entities, or setting blocks) are not allowed. By using system.run, you can defer these operations until later in the tick. Consider the following script.  TypeScript Copy import {      ExplosionBeforeEvent,     system,     world } from \"@minecraft/server\";  function explosionBeforeEventHandler(e: ExplosionBeforeEvent) {     // cannot spawn a pig in the event handler,      // read-only operations only          // queue for later in the current tick     system.run(() => {         e.dimension.spawnEntity('pig', { x: 1, y: 4, z: 1 });     }) }  world.beforeEvents.explosion.subscribe(explosionBeforeEventHandler);   In this example, the work being done by the event handler alters world state so it must be deferred until later in the frame. Referencing the script tick from above, the event happens at section 1, and is deferred to section 4 using system.run.  Keep in mind that you would not be able to put event cancelation logic in the deferred portion of the event, as the event will have already happened by the time the system.run callback executes.  Next up: the one with a tick parameter - system.runTimeout  The system.runTimeout function behaves much like system.run except that it offers a new parameter that lets you indicate how many ticks into the future it should run. If that future tick is 0, it means the current tick or as soon as possible. If the parameter is 1, it behaves much like the standard system.run. A value of 2 means to skip the next tick and execute on the one after.  As stated above, system.runTimeout with a tick parameter of 1 is equivalent to system.run. And just like system.run, if called from within a system.run callback a value of 1 means the next tick. Only if called at the beginning of the tick, or otherwise outside of any system.run* callbacks would a value of 1 execute in the current tick.  A call to system.runTimeout with a tick parameter of 0 means to execute as soon as possible. And unlike system.run, if called from within a system.run callback a value of 0 means to execute within the current tick. This version does not stop you from creating infinite callbacks so be careful when using it in this way.  Here are some example usages:  JavaScript Copy // execute as soon as possible, the next time system.run events are processed system.runTimeout(() => {}, 0);  // execute this tick if we haven't yet processed system.run events,  // otherwise execute next tick system.runTimeout(() => {}, 1);  // execute the tick after next system.runTimeout(() => {}, 2);   When using system.runTimeout with a tick parameter of 0 or 1 it can sometimes be tricky to know exactly which tick that will execute on - either the current tick or the next. In most cases it is simpler to use system.run, knowing that it will execute as soon as possible while being safe enough to not cause infinite recursion.  Then the one that keeps going on its own - system.runInterval  Next we have system.runInterval. This method is similar to system.runTimeout except that it will re-queue the same callback on your behalf until you call system.clearRun. Much like system.runTimeout, system.runInterval with a tick parameter of 1 will run the first time on the next tick, and then again each subsequent tick until it is cleared. And system.runInterval with a tick parameter of 2 means to run every other tick. A value of 0 for the tick parameter is effectively the same as system.runInterval with a tick parameter of 1 - there is no way to get a runInterval to infinitely queue itself into a watchdog event.  JavaScript Copy import { system } from \"@minecraft/server\";  function tick() {     // called every tick } system.runInterval(tick, 0);   Could you use system.runInterval to create a game loop? Absolutely. But system.run is arguably more flexible. Perhaps there's a condition within the tick function that you are waiting on, and you don't need any additional tick callbacks until that condition is true. At that point, you can make the call to system.run to queue the next tick. However, with system.runInterval your tick function will be called every tick, whether you want it to or not.  And finally - system.runJob  The system.runJob method is different from the other system.run methods in a number of ways. It is not well suited for event deferral or game loops. It is best for handling long running tasks that don't need to finish on a specific tick.  It can be difficult to know how much work can be done in a given tick without slowing down the simulation. If you do too little, the results of the operation could take longer than necessary in terms of real game time. But if you do too much work it may trigger a watchdog event, or cause another aspect of the game to appear broken or slow to the user. Hardware differences make matters even worse: what is performant on a PC may be slow on a mobile device or console.  The system.runJob method aims to provide a mechanism for performing long running tasks on your behalf without the need to micromanage the amount of work that occurs each tick. It does this by performing work in small increments while closely monitoring how much time has been used, and how much time is left. When approaching the limit, it will stop and continue the remainder of the work next tick, or the tick after, or some future tick until all the work is completed.  How does it work? With the help of JavaScript generator functions. For example, let's say you want to place a 10x10x10 structure of blocks. If you attempt do this in a single tick, you risk running into a watchdog limit and a simulation slowdown. When using system.runJob, you can rely on the job system to only do as much work as the tick will allow. This may mean that your cube of blocks can be completed within a single frame, but more likely it will take a few frames to get the job done on anything less than the fastest PC hardware. Keep in mind that this is the tradeoff with system.runJob. You allow the job system to keep the simulation running at a consistent rate, but with the understanding that your task may not finish in the same number of ticks on all devices, or even on the same device depending on how much time is allotted to the job queue in a given tick.  JavaScript Copy import {     system,      world,     BlockPermutation } from \"@minecraft/server\";  function* blockPlacingGenerator(size, startX, startY, startZ) {     const overworld = world.getDimension('overworld');     const perm = BlockPermutation.resolve(\"minecraft:planks\");     for (let x = startX; x < startX + size; x++) {         for (let y = startY; y < startY + size; y++) {             for (let z = startZ; z < startZ + size; z++) {                 const block = overworld.getBlock({ x: x, y: y, z: z });                 if (block) {                     block.setPermutation(perm);                 }                 // yield back to job coordinator after ever place                 yield;             }         }     } } // build a 10x10x10 cube of plank blocks starting at world location -2, -60, 1. system.runJob(generator(10, -2, -60, 1));   In this example, the generator yields execution after every block place operation. This means that the job queue is the deciding factor for how many block place operations execute each tick. It is a best practice to author generator functions with a high level of granularity. That means generator functions should be authored such that a single iteration of the generator (a single block place in this example) would be unlikely to exceed the frame time. This enables the job system to scale based on the performance of the device. On a fast PC it may be able to do 30 block place operations, but on mobile that number drops to 5. A poorly authored generator function may perform 5 iterations on a fast PC but on a mobile device it can only do 1 and that single operation triggers a watchdog warning.  It is important to keep in mind that the job system will not starve your generators. At a minimum, every generator for every script behavior pack that has generators will be allowed to execute at least 1 iteration every tick. It is therefore up to the author to ensure a single iteration does not exceed the time allotment of the script tick.  Best practices when writing generator functions for system.runJob Choose a high level of granularity in your generator functions. This offers the most flexibility when the job system has to scale to the performance of different devices. Try to keep the amount of work consistent between iterations. This helps the job system correctly estimate how much time to give each generator per tick. Wrapping up  Hopefully you have enough information to get started using the system.run APIs, when to choose one over the other and how to know when a given callback will execute.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptversioning?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Script Module Versioning 01/31/2025  At its foundation, all script modules use a common version numbering scheme known as Semantic Versioning (or semver). Semantic versions use a numeric version number of [major].[minor].[patch] with an optional suffix. Note that this version number is not connected to the overall Minecraft version numbering scheme (for example, 1.19.60); rather, these version numbers increment as changes occur to the API surface.  Minecraft API modules currently operate on three tracks:  a stable track (for example, version 1.1.0) a beta track (for example, version 1.3.0-beta) an internal track (for example, version 1.4.0-internal)  Also, as of 1.21.70 previews, we've also introduced 2.0.0-beta versions of scripting APIs. See the Scripting V2.0.0 Overview for more on changes incorporated into 2.0.0.  When specifying dependencies within manifest.json of a behavior pack, it is important to consider the impact of the versions of APIs that you wish to use. Where possible, try to use stable track APIs.  @minecraft/server script versions to product versions  For reference, @minecraft/server is our most frequently updating script module. It tends to increment in version number with every major release of Minecraft. Here are the mappings of @minecraft/server version to Minecraft product version:  Expand table @minecraft/server module version\tMinecraft product version 1.0.0\t1.19.70 1.1.0\t1.19.80 1.2.0\t1.20.0 1.3.0\t1.20.10 1.4.0\t1.20.20 1.5.0\t1.20.30 1.6.0\t1.20.40 1.7.0\t1.20.50 1.8.0\t1.20.60 1.9.0\t1.20.70 1.10.0\t1.20.80 1.11.0\t1.21.0 1.13.0\t1.21.20 1.14.0\t1.21.30 1.15.0\t1.21.40 1.16.0\t1.21.50 1.17.0\t1.21.60 Stable Track  API modules in the stable track are numbered with a version number like 1.1.0, and with no suffix on the end. These APIs are considered \"finished\" and should not change in functionality across releases where minor or patch versions are incremented. With stable APIs, Minecraft uses the rules of semantic versioning, which mean:  Major version increments (for example, 2.3.0 -> 3.0.0) imply changes that break backwards-compatibility, potentially in both API signature and functionality. Across major versions, a method signature might not change but it may work differently and impact the gameplay of worlds. Note that Minecraft may support multiple major versions of APIs in the future, so if a behavior pack has a dependency on an older major version of the API, it may still continue to work even if a newer major version of the script API module is available.  Minor and patch version increments could imply new functionality and API signature additions, but should be backwards-compatible within the same major version.  This implies that as minor versions increment, and even if additional \"minor releases\" feature new APIs, they must be fully backwards compatible with earlier minor versions of the API. For example, if a script module has a dependency on version 1.3.0 of the @minecraft/server API, it may actually have that dependency fulfilled with 1.8.0 of the @minecraft/server - and those script modules should continue to function as expected. For those familiar with NPM semantic versioning, this is similar to the ^ signifier within version dependencies.   Important  As you share or publish behavior packs that use stable APIs, please base your dependencies for APIs on the latest and highest version number that is supported within Minecraft at the time of your release.  As of version 1.19.70, only @minecraft/server has APIs that are in the stable track. See the following objects specifically:  World Dimension Entity  Note that only a subset of the members of these types are currently exposed in the stable track.  Beta Track  API modules in the beta track are labeled with the \"-beta\" suffix - for example, 1.2.0-beta. Beta APIs do not follow the rules of semantic versioning. With beta APIs, no backwards compatibility is implied, and even minor version increments can include backwards-compatibility breaking changes like the removal of properties or methods. Moreover, with every major release of Minecraft, it is likely that several -beta modules will increment their version number (for example, from 1.2.0-beta to 1.3.0-beta) without having an automatic upgrade from the old -beta version to the next. As a consequence, you may need to update the version number of manifest.json dependencies at every major release if you are using -beta APIs.   Important  In order to use -beta APIs, you must enable the \"Beta APIs\" experiment within worlds that use these behavior packs.  Internal Track  Internal APIs are not functional or supported for use in custom behavior packs. Their API signatures might change at any time.  Using versioned type definitions when scripting  For the definitive resource on APIs and types that are exposed in various versions, consider using the type definitions available through npm at npmjs.com. The @minecraft/server definitions contain different variants of type definitions for stable and beta tracks, as well as across both main and preview releases of Minecraft Bedrock Edition. See more on how to use these type definitions in this article  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptversioning?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Script Module Versioning 01/31/2025  At its foundation, all script modules use a common version numbering scheme known as Semantic Versioning (or semver). Semantic versions use a numeric version number of [major].[minor].[patch] with an optional suffix. Note that this version number is not connected to the overall Minecraft version numbering scheme (for example, 1.19.60); rather, these version numbers increment as changes occur to the API surface.  Minecraft API modules currently operate on three tracks:  a stable track (for example, version 1.1.0) a beta track (for example, version 1.3.0-beta) an internal track (for example, version 1.4.0-internal)  Also, as of 1.21.70 previews, we've also introduced 2.0.0-beta versions of scripting APIs. See the Scripting V2.0.0 Overview for more on changes incorporated into 2.0.0.  When specifying dependencies within manifest.json of a behavior pack, it is important to consider the impact of the versions of APIs that you wish to use. Where possible, try to use stable track APIs.  @minecraft/server script versions to product versions  For reference, @minecraft/server is our most frequently updating script module. It tends to increment in version number with every major release of Minecraft. Here are the mappings of @minecraft/server version to Minecraft product version:  Expand table @minecraft/server module version\tMinecraft product version 1.0.0\t1.19.70 1.1.0\t1.19.80 1.2.0\t1.20.0 1.3.0\t1.20.10 1.4.0\t1.20.20 1.5.0\t1.20.30 1.6.0\t1.20.40 1.7.0\t1.20.50 1.8.0\t1.20.60 1.9.0\t1.20.70 1.10.0\t1.20.80 1.11.0\t1.21.0 1.13.0\t1.21.20 1.14.0\t1.21.30 1.15.0\t1.21.40 1.16.0\t1.21.50 1.17.0\t1.21.60 Stable Track  API modules in the stable track are numbered with a version number like 1.1.0, and with no suffix on the end. These APIs are considered \"finished\" and should not change in functionality across releases where minor or patch versions are incremented. With stable APIs, Minecraft uses the rules of semantic versioning, which mean:  Major version increments (for example, 2.3.0 -> 3.0.0) imply changes that break backwards-compatibility, potentially in both API signature and functionality. Across major versions, a method signature might not change but it may work differently and impact the gameplay of worlds. Note that Minecraft may support multiple major versions of APIs in the future, so if a behavior pack has a dependency on an older major version of the API, it may still continue to work even if a newer major version of the script API module is available.  Minor and patch version increments could imply new functionality and API signature additions, but should be backwards-compatible within the same major version.  This implies that as minor versions increment, and even if additional \"minor releases\" feature new APIs, they must be fully backwards compatible with earlier minor versions of the API. For example, if a script module has a dependency on version 1.3.0 of the @minecraft/server API, it may actually have that dependency fulfilled with 1.8.0 of the @minecraft/server - and those script modules should continue to function as expected. For those familiar with NPM semantic versioning, this is similar to the ^ signifier within version dependencies.   Important  As you share or publish behavior packs that use stable APIs, please base your dependencies for APIs on the latest and highest version number that is supported within Minecraft at the time of your release.  As of version 1.19.70, only @minecraft/server has APIs that are in the stable track. See the following objects specifically:  World Dimension Entity  Note that only a subset of the members of these types are currently exposed in the stable track.  Beta Track  API modules in the beta track are labeled with the \"-beta\" suffix - for example, 1.2.0-beta. Beta APIs do not follow the rules of semantic versioning. With beta APIs, no backwards compatibility is implied, and even minor version increments can include backwards-compatibility breaking changes like the removal of properties or methods. Moreover, with every major release of Minecraft, it is likely that several -beta modules will increment their version number (for example, from 1.2.0-beta to 1.3.0-beta) without having an automatic upgrade from the old -beta version to the next. As a consequence, you may need to update the version number of manifest.json dependencies at every major release if you are using -beta APIs.   Important  In order to use -beta APIs, you must enable the \"Beta APIs\" experiment within worlds that use these behavior packs.  Internal Track  Internal APIs are not functional or supported for use in custom behavior packs. Their API signatures might change at any time.  Using versioned type definitions when scripting  For the definitive resource on APIs and types that are exposed in various versions, consider using the type definitions available through npm at npmjs.com. The @minecraft/server definitions contain different variants of type definitions for stable and beta tracks, as well as across both main and preview releases of Minecraft Bedrock Edition. See more on how to use these type definitions in this article  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptingv2.0.0overview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Scripting V2.0.0 Overview 04/04/2025  There is also a video verson available of this overview of Scripting API v2.0.0-beta:  What's new with Scripting API v2.0.0  Normally, when you hear about \"Version 2\" of your favorite pieces of software - it's cause for great excitement. A whole new.. thing! Everything is different and hopefully gets better! But the first thing to understand about Scripting API v2.0.0 is: it's not that different from Scripting v1.x.0 versions of Minecraft. Don't get us wrong: we're excited about the infrastructural improvements being made in Script API v2.0.0, but we also hope you'll agree it's not too different from before.  You see, script versions are intended to follow semver rules and semantics. Any time there is a change to versions that breaks backwards compatibility, you should increment the major version. That's what Scripting API v2.0.0 represents: a set of fixes to some issues with the API structure that are improvements, but can break existing code that was written targeting v1.0.0 if it is upgraded for v2.0.0. Periodically, we can expect to introduce a newer version of scripting that fixes and improves things, but that also isn't strictly backwards compatible with the current API \"contract\". For this reason, you should expect major version increments to Minecraft scripting API namespaces; for example, scripting API version 3.0.0 might not be too far off in the future.  All of your existing scripts and experiences that target v1.0.0 should continue to work as is as long as they are identified in your manifest.json as targeting 1.x.0 of Minecraft APIs. These will continue to be supported in Minecraft for many years to come. They will run in an environment that maximizes 1.0.0 semantic compatibility, and no changes should be required in any of your scripts. That said, when version 2.0.0 comes out of beta and into stable, it'll be beneficial to move any new or in-progress projects to take advantage of the more modern Scripting 2.0.0 environment, especially as newer APIs are released that target 2.0.0 only.   Important  Scripting V2.0.0 APIs are currently in experimental preview and require the \"Beta APIs\" experiment to use. They may undergo some changes before becoming stabilized and generally available.  On to the major changes with Scripting API 2.0:  Earlier Execution and Loading of the Scripting Environment  Scripting 1.0.0 environments, today, are loaded in a world only after Minecraft has loaded a bit of other infrastructure (things like the definitions of entities, and so on.) That said, even in Scripting 1.0.0, the first execution of scripting logic happens typically before even the first chunk has loaded, so the environment is still in a bit of a half-loaded state. It's typical to sometimes wait until later in the cycle - after the first number of ticks, or when a player has joined, or when blocks become available - to do \"true\" initialization logic for an add-on.  With scripting v2.0.0, script initialization has moved when script is first executed to be much earlier in the startup and load of a world. Most APIs -- even simple APIs like general world gamemode get property queries, are not ready to be accessed and worked with. This change was made so that script can be used to configure parts of the initialization of the server and world before additional content has been loaded. For example, an upcoming capability - custom components v2 - is now registered from script before block JSON files are loaded, to provide better error messages when errors are found in block JSON files.  To help make the behavior more predictable, we've added more protections to the APIs to prevent being called in an unloaded state (early execution privileges). There also have been a set of updates to events (a worldLoad event and a new startup event) so that you can run code later in the cycle when things have fully loaded.  Promise Resolution Changes  In scripting V2.0.0, promises can now resolve alongside after events and system tasks during end-of-tick flushing of queues of deferred runs or asynchronous functions. In previous versions of scripting, promises were resolved only once at the end of the tick. This change will allow promises to resolve more frequently and more immediately after the action they are waiting on has been completed. Additionally, promises are resolved once in early execution to allow for asynchronous imports to resolve before early execution is finished.  Scripting V2.0.0 Flushing Order  In scripting V1, the system will continuously flush after events and system tasks at the end of a tick until either the scripting watchdog times out or there is nothing left to flush. For scripting V2, promise resolution is now continuously flushed. Promises will be resolved during the flush by themselves, as well as after every after event type and every system task which was executed during the flush.  In general, the new flushing order of V1 and V2 scripting looks like the following:  Resolve V1 promises once at the end of the tick Flush until no more work needs to be done Resolve V2 promises Run system tasks (V1 and V2) After each task that executes, resolve v2 promises Run after events (V1 and V2) After each event type that executes, resolve v2 promises Examples TypeScript Copy new Promise<void>(resolve => {     resolve(); }).then(_ => {     console.error('Promise resolved'); });   In V1, the above example would print the log on the next tick. In V2, this will flush the promise within the same tick, which means it would print the log on the current tick.  TypeScript Copy await system.waitTicks(1); await system.waitTicks(0); // not possible in v1   Also new to V2 is the ability to await 0 ticks with the waitTicks function. Previously, in V1, it was not possible to wait 0 ticks since promises would not resolve until the next tick. Now that promises are flushed, it is possible to await 0 ticks and execute this tick.  Additional API-level Changes  In addition to the infrastructural changes to script load and promise resolution behavior, several APIs have also changed. The best way to see what has changed is to try your code with a 2.0.0-beta TypeScript definition (e.g., run npm i @minecraft/server@2.0.0-beta), and see what might have changed in your code editor of choice.  Entity:  applyKnockback method now takes a VectorXZ parameter for the knockback horizontal force (which includes the strength/magnitude), as well as a vertical strength parameter, in 2.0.0. To convert from V1, you should normalize your previous direction vector and multiply it by the old horizontal strength value. Vertical strength is the same as before.  Dimension:  Removed runCommandAsync as most commands did not actually run asynchronously. If you are looking to run a function asynchronously, please investigate using Jobs via System.runJob.  Entity Components:  getComponents, getComponent and hasComponent now throw if the Entity is invalid EntityComponent.getEntity method throws if the underlying entity is invalid (instead of return undefined previously). EntityInventoryComponent.containerproperty throws if the underlying entity is invalid (instead of return undefined previously).  isValid methods on various classes have been changed to read only properties  EffectType  getName method now always returns the minecraft: namespace prefix along with the name  Effect  typeId property now always returns the minecraft: namespace prefix along with the name  minecraft:air item has been removed (it is still a valid block, however)  Custom Components V2  \"Custom components V2\" is a new experiment which must be enabled along with the \"Beta APIs\" experiment to use the new features for custom components. With the experiment enabled:  minecraft:custom_components is deprecated in favor of flattened custom components Custom components now support parameters Flattening  In the previous version of custom components, components had to be listed inside the minecraft:custom_components component. This is no longer required and the minecraft:custom_components component is deprecated. Instead, you can write your custom components similar to any other Minecraft component. For example:  JSON Copy {     \"components\": {         \"minecraft:loot\": \"...\",         \"minecraft:collision_box\": {             \"enabled\": true         },         \"my_custom_component:name\": {},         \"my_custom_component:another_component\": {}     } }  Parameters  Along with flattening a custom component in JSON, you also can provide parameters to the component. The script bindings for custom components have been upgraded to support a second parameter, CustomComponentParameters, which grants access to the JSON parameter list for your component. The following example shows how to use custom component parameters in script:  JSON Copy {     \"components\": {         \"some_component:name\": {             \"first\": \"hello\",             \"second\": 4,             \"third\": [                 \"test\",                 \"example\"             ]         }     } }  TypeScript Copy type SomeComponentParams = {     first?: string;     second?: number;     third?: string[]; };  system.beforeEvents.startup.subscribe(init => {     init.blockComponentRegistry.registerCustomComponent('some_component:name', {         onStepOn: (e : BlockComponentStepOnEvent, p : CustomComponentParameters) : {             let params = p.params as SomeComponentParams;             ...         }     }); });  Upgrading to Scripting V2.0.0 Startup Events  Usages of world.afterEvents.worldInitialize should change to world.afterEvents.worldLoad without additional changes. This event was renamed with v2.0.0 of scripting.  Usage of world.beforeEvents.worldInitialize should change to system.beforeEvents.startup. The worldInitialize before event was removed in favor of the new startup event. However, the new startup event is also run with early execution enabled. This means that some code previously allowed in worldInitialize will no longer work in startup. Things like getting players, accessing actors and blocks in the world, should be moved to the world.afterEvents.worldLoad event.  The world Object  The biggest change with early execution is that most of the world object will cause an error if called in early execution phase of the script environment. Subscribing to events still works as it does not access the world state, but anything interacting with world state, entities, blocks, players, will be restricted until the first tick takes place.  Scripting Startup Flow  For backwards compatibility, scripting V1.x.x startup timing and capabilities has not been modified. Scripting v1.x.x does not use early execution and will be run at the same time as it is today. The general flow for loading the server with scripting:  V2 scripts are loaded and run with early execution V2 scripts promises are resolved with early execution V2 scripts receive the system.beforeEvents.startup event in early execution Wait for the world to finish loading and the game to start ... V1 scripts are loaded and run V1 scripts receive the world.beforeEvents.worldInitialize event First game tick takes place ... At the end of the tick, all scripts receive the world.afterEvents.worldLoad event (named worldInitialize for V1) What APIs are available in early execution?  The following are the initial APIs available in early execution mode for scripting v2.0.0-beta:  world.beforeEvents.*.subscribe world.beforeEvents.*.unsubscribe world.afterEvents.*.subscribe world.afterEvents.*.unsubscribe system.afterEvents.*.subscribe system.afterEvents.*.unsubscribe system.beforeEvents.*.subscribe system.beforeEvents.*.unsubscribe system.clearJob system.clearRun system.run system.runInterval system.runJob system.runTimeout system.waitTicks BlockComponentRegistry.registerCustomComponent ItemComponentRegistry.registerCustomComponent What do I do with code that is in the root context of my scripts that are not early executable?  If you have code using an API that is being run in the root context of a script file, it will need to be deferred to run either during or after the world.afterEvents.worldLoad event. There are a number of ways to organize your code to do so. Usage of classes or functions can assist with organizing startup of various systems that can be called within the event callback. Lazy getters can be made to call the API and cache the result only after the lazy getter is called. In many cases, you can simply wrap your \"root context\" scripts in a world.afterEvents.worldLoad call.  Summary  That's it! Stay tuned for more updates to the 2.0.0-beta APIs; in a few more places, over the coming weeks, we will change the signature of some methods and properties. As always, we appreciate your feedback and bugs while 2.0.0 is in beta. You can open those bugs at bugs.mojang.com.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptingv2.0.0overview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Scripting V2.0.0 Overview 04/04/2025  There is also a video verson available of this overview of Scripting API v2.0.0-beta:  What's new with Scripting API v2.0.0  Normally, when you hear about \"Version 2\" of your favorite pieces of software - it's cause for great excitement. A whole new.. thing! Everything is different and hopefully gets better! But the first thing to understand about Scripting API v2.0.0 is: it's not that different from Scripting v1.x.0 versions of Minecraft. Don't get us wrong: we're excited about the infrastructural improvements being made in Script API v2.0.0, but we also hope you'll agree it's not too different from before.  You see, script versions are intended to follow semver rules and semantics. Any time there is a change to versions that breaks backwards compatibility, you should increment the major version. That's what Scripting API v2.0.0 represents: a set of fixes to some issues with the API structure that are improvements, but can break existing code that was written targeting v1.0.0 if it is upgraded for v2.0.0. Periodically, we can expect to introduce a newer version of scripting that fixes and improves things, but that also isn't strictly backwards compatible with the current API \"contract\". For this reason, you should expect major version increments to Minecraft scripting API namespaces; for example, scripting API version 3.0.0 might not be too far off in the future.  All of your existing scripts and experiences that target v1.0.0 should continue to work as is as long as they are identified in your manifest.json as targeting 1.x.0 of Minecraft APIs. These will continue to be supported in Minecraft for many years to come. They will run in an environment that maximizes 1.0.0 semantic compatibility, and no changes should be required in any of your scripts. That said, when version 2.0.0 comes out of beta and into stable, it'll be beneficial to move any new or in-progress projects to take advantage of the more modern Scripting 2.0.0 environment, especially as newer APIs are released that target 2.0.0 only.   Important  Scripting V2.0.0 APIs are currently in experimental preview and require the \"Beta APIs\" experiment to use. They may undergo some changes before becoming stabilized and generally available.  On to the major changes with Scripting API 2.0:  Earlier Execution and Loading of the Scripting Environment  Scripting 1.0.0 environments, today, are loaded in a world only after Minecraft has loaded a bit of other infrastructure (things like the definitions of entities, and so on.) That said, even in Scripting 1.0.0, the first execution of scripting logic happens typically before even the first chunk has loaded, so the environment is still in a bit of a half-loaded state. It's typical to sometimes wait until later in the cycle - after the first number of ticks, or when a player has joined, or when blocks become available - to do \"true\" initialization logic for an add-on.  With scripting v2.0.0, script initialization has moved when script is first executed to be much earlier in the startup and load of a world. Most APIs -- even simple APIs like general world gamemode get property queries, are not ready to be accessed and worked with. This change was made so that script can be used to configure parts of the initialization of the server and world before additional content has been loaded. For example, an upcoming capability - custom components v2 - is now registered from script before block JSON files are loaded, to provide better error messages when errors are found in block JSON files.  To help make the behavior more predictable, we've added more protections to the APIs to prevent being called in an unloaded state (early execution privileges). There also have been a set of updates to events (a worldLoad event and a new startup event) so that you can run code later in the cycle when things have fully loaded.  Promise Resolution Changes  In scripting V2.0.0, promises can now resolve alongside after events and system tasks during end-of-tick flushing of queues of deferred runs or asynchronous functions. In previous versions of scripting, promises were resolved only once at the end of the tick. This change will allow promises to resolve more frequently and more immediately after the action they are waiting on has been completed. Additionally, promises are resolved once in early execution to allow for asynchronous imports to resolve before early execution is finished.  Scripting V2.0.0 Flushing Order  In scripting V1, the system will continuously flush after events and system tasks at the end of a tick until either the scripting watchdog times out or there is nothing left to flush. For scripting V2, promise resolution is now continuously flushed. Promises will be resolved during the flush by themselves, as well as after every after event type and every system task which was executed during the flush.  In general, the new flushing order of V1 and V2 scripting looks like the following:  Resolve V1 promises once at the end of the tick Flush until no more work needs to be done Resolve V2 promises Run system tasks (V1 and V2) After each task that executes, resolve v2 promises Run after events (V1 and V2) After each event type that executes, resolve v2 promises Examples TypeScript Copy new Promise<void>(resolve => {     resolve(); }).then(_ => {     console.error('Promise resolved'); });   In V1, the above example would print the log on the next tick. In V2, this will flush the promise within the same tick, which means it would print the log on the current tick.  TypeScript Copy await system.waitTicks(1); await system.waitTicks(0); // not possible in v1   Also new to V2 is the ability to await 0 ticks with the waitTicks function. Previously, in V1, it was not possible to wait 0 ticks since promises would not resolve until the next tick. Now that promises are flushed, it is possible to await 0 ticks and execute this tick.  Additional API-level Changes  In addition to the infrastructural changes to script load and promise resolution behavior, several APIs have also changed. The best way to see what has changed is to try your code with a 2.0.0-beta TypeScript definition (e.g., run npm i @minecraft/server@2.0.0-beta), and see what might have changed in your code editor of choice.  Entity:  applyKnockback method now takes a VectorXZ parameter for the knockback horizontal force (which includes the strength/magnitude), as well as a vertical strength parameter, in 2.0.0. To convert from V1, you should normalize your previous direction vector and multiply it by the old horizontal strength value. Vertical strength is the same as before.  Dimension:  Removed runCommandAsync as most commands did not actually run asynchronously. If you are looking to run a function asynchronously, please investigate using Jobs via System.runJob.  Entity Components:  getComponents, getComponent and hasComponent now throw if the Entity is invalid EntityComponent.getEntity method throws if the underlying entity is invalid (instead of return undefined previously). EntityInventoryComponent.containerproperty throws if the underlying entity is invalid (instead of return undefined previously).  isValid methods on various classes have been changed to read only properties  EffectType  getName method now always returns the minecraft: namespace prefix along with the name  Effect  typeId property now always returns the minecraft: namespace prefix along with the name  minecraft:air item has been removed (it is still a valid block, however)  Custom Components V2  \"Custom components V2\" is a new experiment which must be enabled along with the \"Beta APIs\" experiment to use the new features for custom components. With the experiment enabled:  minecraft:custom_components is deprecated in favor of flattened custom components Custom components now support parameters Flattening  In the previous version of custom components, components had to be listed inside the minecraft:custom_components component. This is no longer required and the minecraft:custom_components component is deprecated. Instead, you can write your custom components similar to any other Minecraft component. For example:  JSON Copy {     \"components\": {         \"minecraft:loot\": \"...\",         \"minecraft:collision_box\": {             \"enabled\": true         },         \"my_custom_component:name\": {},         \"my_custom_component:another_component\": {}     } }  Parameters  Along with flattening a custom component in JSON, you also can provide parameters to the component. The script bindings for custom components have been upgraded to support a second parameter, CustomComponentParameters, which grants access to the JSON parameter list for your component. The following example shows how to use custom component parameters in script:  JSON Copy {     \"components\": {         \"some_component:name\": {             \"first\": \"hello\",             \"second\": 4,             \"third\": [                 \"test\",                 \"example\"             ]         }     } }  TypeScript Copy type SomeComponentParams = {     first?: string;     second?: number;     third?: string[]; };  system.beforeEvents.startup.subscribe(init => {     init.blockComponentRegistry.registerCustomComponent('some_component:name', {         onStepOn: (e : BlockComponentStepOnEvent, p : CustomComponentParameters) : {             let params = p.params as SomeComponentParams;             ...         }     }); });  Upgrading to Scripting V2.0.0 Startup Events  Usages of world.afterEvents.worldInitialize should change to world.afterEvents.worldLoad without additional changes. This event was renamed with v2.0.0 of scripting.  Usage of world.beforeEvents.worldInitialize should change to system.beforeEvents.startup. The worldInitialize before event was removed in favor of the new startup event. However, the new startup event is also run with early execution enabled. This means that some code previously allowed in worldInitialize will no longer work in startup. Things like getting players, accessing actors and blocks in the world, should be moved to the world.afterEvents.worldLoad event.  The world Object  The biggest change with early execution is that most of the world object will cause an error if called in early execution phase of the script environment. Subscribing to events still works as it does not access the world state, but anything interacting with world state, entities, blocks, players, will be restricted until the first tick takes place.  Scripting Startup Flow  For backwards compatibility, scripting V1.x.x startup timing and capabilities has not been modified. Scripting v1.x.x does not use early execution and will be run at the same time as it is today. The general flow for loading the server with scripting:  V2 scripts are loaded and run with early execution V2 scripts promises are resolved with early execution V2 scripts receive the system.beforeEvents.startup event in early execution Wait for the world to finish loading and the game to start ... V1 scripts are loaded and run V1 scripts receive the world.beforeEvents.worldInitialize event First game tick takes place ... At the end of the tick, all scripts receive the world.afterEvents.worldLoad event (named worldInitialize for V1) What APIs are available in early execution?  The following are the initial APIs available in early execution mode for scripting v2.0.0-beta:  world.beforeEvents.*.subscribe world.beforeEvents.*.unsubscribe world.afterEvents.*.subscribe world.afterEvents.*.unsubscribe system.afterEvents.*.subscribe system.afterEvents.*.unsubscribe system.beforeEvents.*.subscribe system.beforeEvents.*.unsubscribe system.clearJob system.clearRun system.run system.runInterval system.runJob system.runTimeout system.waitTicks BlockComponentRegistry.registerCustomComponent ItemComponentRegistry.registerCustomComponent What do I do with code that is in the root context of my scripts that are not early executable?  If you have code using an API that is being run in the root context of a script file, it will need to be deferred to run either during or after the world.afterEvents.worldLoad event. There are a number of ways to organize your code to do so. Usage of classes or functions can assist with organizing startup of various systems that can be called within the event callback. Lazy getters can be made to call the API and cache the result only after the lazy getter is called. In many cases, you can simply wrap your \"root context\" scripts in a world.afterEvents.worldLoad call.  Summary  That's it! Stay tuned for more updates to the 2.0.0-beta APIs; in a few more places, over the coming weeks, we will change the signature of some methods and properties. As always, we appreciate your feedback and bugs while 2.0.0 is in beta. You can open those bugs at bugs.mojang.com.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptingservers?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Using script to add new capabilities to dedicated servers 09/21/2023  With version 1.19.0, Bedrock Dedicated Server gains new capabilities in conjunction with experimental JavaScript Beta APIs. It is now much easier to build deeply customized Bedrock Dedicated Server gameplay experiences by connecting your server to external services and sites. For example, you could use this functionality to connect a dedicated server to back-end infrastructure that powers a website-based leaderboard. Or you can build an advanced administrative console to give server administrators to more flexibility when managing players in a game.  In this article, we'll cover the foundation of everything you need to know about building extended experiences with script + dedicated server.  But first! A few warnings and notices on this topic before we get started:  Important: These APIs are experimental as part of the Beta APIs experiment. As with all experiments, you may see changes or even removals of functionality in updated Minecraft versions. Check the the Minecraft changelog for details on any changes to Beta APIs. We'll cover a few more advanced topics in this article, so you should be familiar with the basics of scripting and general Minecraft customization concepts. Make sure you back up worlds and files before you get deep into modifying and copying worlds around. These tips work only in conjunction with Bedrock Dedicated Server, available at Bedrock Server Download, that you can host on your own. This article does not apply to gameplay servers provided as part of Minecraft Realms. See more information on Bedrock Dedicated Server via this FAQ. Running a server  The first step in getting started with Dedicated Servers is to download the Dedicated Server zip from the Bedrock Server Download site.  After downloading the Bedrock Server zip file, extract it to a folder of your choosing, like C:\\MinecraftServer\\. As you work and iterate, you may have multiple copies of Bedrock Dedicated Server stored on your PC that you can choose to run, so you may want to consider a naming scheme for different iterations, like C:\\MinecraftServer\\1.19.0_1.  To run a Bedrock Dedicated Server, open a command prompt by opening the Start Menu and typing 'Command Prompt', or by using the Windows Terminal app from the Microsoft Store).  Use the cd command to change directories to where you unzipped the Bedrock Dedicated Server. For example, type cd \"C:\\MinecraftServer\\1.19.0_1\".  Then, enter bedrock_server.exe. This will start up the Bedrock Dedicated Server and have it start listening for joining players.  After the server is started by the steps above, you can type in commands on the console like op <playername> to grant operator privileges to a player. When you wish to stop the server, type stop on the Bedrock Dedicated Server command line.  Allow Bedrock Dedicated Server in Firewall  The first time you run a Bedrock Dedicated Server, your operating system may ask if you want to allow Bedrock Dedicated Server through the Firewall. Within Windows, the common options you select (Private or Public Networks) will depend on your networking preferences. But to allow players from other machines to join your server, you'll need to allow access for Bedrock Dedicated Server through your Firewall by at least one route (Private Networks or Public Networks), if not both. Depending on your configuration, you may need to do additional configuration on your networking router and machine to fully enable multiplayer play with your Bedrock Dedicated Server.  Initial run of a Bedrock Dedicated Server:   Enable Loopback in Minecraft  You'll probably want to connect to the world hosted by your machine from a Minecraft client running on that same exact machine. By default, the Minecraft and Minecraft Preview game on Windows cannot connect to local services, so you'll need to enable that first by \"Enabling Loopback\". To do this, stop your server if it is running and then run the following command if you wish to enable loopback for the main Minecraft app:  CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-1958404141-86561845-1752920682-3514627264-368642714-62675701-733520436  Run this command line if you wish to enable loopback for the Minecraft Preview app:  CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-424268864-5579737-879501358-346833251-474568803-887069379-4040235476  Test Minecraft Server To test your Minecraft Server, first restart the server by running bedrock_server.exe. Then, run the Minecraft app (if you are using the Preview version of the Minecraft Dedicated Server, you should use the Minecraft Preview app). Select Play. For the first time, you will need to add your local machine-hosted server. Select Add Server. a. For Server Name, enter \"My Local Computer\" or any name you want to give it. b. For Server Address, enter 127.0.0.1. This is the standard IP address that refers to \"localhost\" or \"the same computer that this app is running on.\" c. You can leave the port as 19132, which is the default port for a Bedrock Dedicated Server. After all that, select Save.  In the Server list, select the new Server entry and then select Join, which should allow you to enter the world. Within your Bedrock Server console, you should see that a new player has joined.  Troubleshooting server and client versioning  Did you get an \"Outdated client\" or \"Outdated server\" message when connecting Minecraft Bedrock Dedicated Server and Minecraft clients? This is because of a mismatch of versions between client and server. Minecraft clients and servers must support the same protocol version.  This protocol version is typically updated across minor and patch versions of the product – so 1.18.0 and 1.19.0 are not compatible with one another, protocol-wise. But also \"patch version\" differences (like 1.18.10 vs. 1.18.30) will have different protocol versions and therefore not be compatible with each other, either.  When using a Preview Dedicated Server, you'll want to make sure that the players who join your server use freshly updated versions of Minecraft Preview clients to connect to those servers. Protocol versions can change enough from one week to the next to cause a connectivity issue, and non-Preview versions of Minecraft will probably not be able to connect to Preview Dedicated Server either due to those same protocol version mismatches. So, it's best to have players download a new Preview client from the Microsoft Store right before they play.  Building out your server world  It is important for Server administrators to understand the content they are hosting via their server and should opt-in to using experimental capabilities. For this reason, by default, generated worlds in Bedrock Dedicated Server do not have the Beta APIs experiment turned on, and therefore do not run script. That's OK – you'll probably want to carefully build out your custom server world anyways, and as part of that, turn on the Beta APIs experiment in that world to enable custom scripts.  Here are the steps to creating your Minecraft world:  Use the Minecraft Client singleplayer to create and customize the world in the way that you like it. You can use whatever general Minecraft builder tips and techniques you'd like to build the world of your dreams. Enable the Beta APIs experiment in that world. Within this world, you will also need to add your behavior packs that use script. For building, those behavior packs should not use dedicated-server only modules like \"@minecraft/server-net\" or \"@minecraft/server-admin\" Then, when you're ready to use that world on a dedicated server, copy it from your Minecraft client's Worlds folder: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\minecraftWorlds Each subfolder is a world. Usually the last world you played in will have the most updated \"Date modified.\" Unfortunately, world subfolders don't have very friendly names (typically, something like \"fyqEYmKXAwA=\") to help you figure out which world is which. Copy the contents of this world subfolder over to your Bedrock Dedicated Server. By default, Bedrock Dedicated Server will load the world it uses from &lt;Bedrock Dedicated Server&gt;/worlds/Bedrock level, but you can customize the name of the world to something other than \"Bedrock level\" in the &lt;Bedrock Dedicated Server&gt;/server.properties file. When you run the Bedrock Dedicated Server executable, you should see it load up the world. It will also generate a log entry like the following:  [2022-05-20 07:00:06:619 INFO] Experiment(s) active: gtst  Where gtst is a code for the Beta APIs experiment, indicating experimental script APIs are now available in your world.  The Bedrock Dedicated Server configuration system  Now that you have a custom world up and running with a bit of JavaScript within it, we'll want to extend it to take advantage of the new capabilities.  By default, most server configuration is stored within the \"server.properties\" file in the root of your Minecraft Bedrock Dedicated Server folder. Here, you can configure default permissions for new players that enter the game, server ports, number of threads, and more. Much of the documentation is embedded in line within \"server.properties.\" To get started, open \"server.properties\" with your favorite text editor, like Notepad.  For scripting, configuration files are stored in the \"<Bedrock Dedicated Server>/config/\" folder. In that folder is the subfolder \"<Bedrock Dedicated Server>/config/default/\", which controls default settings for all script modules. Within the \"default\" folder is a \"permissions.json\" file, which controls the default set of Mojang scripting modules that are accessible to worlds, assuming they have the Beta APIs experiment enabled.  Note that the @minecraft/server-net module is not enabled by default for scripting maps.  Enable differentiated module permissions  You can set different permissions for different references to scripts that are embedded as modules within behavior packs.  Create a subfolder within the config folder next to the \"default\" folder and name it the same as the module identifier (UUID) of the scripting module. For example, you would create a folder named \"a8d43bd0-cffd-4988-949a-5105e14bb5f2\" for a scripting module with the following excerpt from its behavior pack's \"manifest.json\" file: JSON Copy   \"modules\": [     {       \"description\": \"Script resources\",       \"language\": \"javascript\",       \"type\": \"script\",       \"uuid\": \"a8d43bd0-cffd-4988-949a-5105e14bb5f2\",       \"version\": [0, 0, 1],       \"entry\": \"scripts/main.js\"     }   ],  Next, to customize the set of built in modules your behavior pack's script module can access, you can place a \"permissions.json\" file within that folder. (Yes, the UUID folder name is a bit clunky, but we hope to improve this in a future update). We strongly recommend keeping &lt;Bedrock Dedicated Server&gt;/config/default/permissions.json basic and minimal, while extending additional module permissions on an individual basis.  @minecraft/minecraft-server-net\" />  Variables and Secrets  You can also empower server administrators to further configure how script modules function. For example, maybe your script has alternate levels of difficulty by controlling mob spawn rate that you wish to let administrators configure. To do this, put a \"variables. json\" file within either your &lt;Bedrock Dedicated Server&gt;config/default/ folder or within a &lt;Bedrock Dedicated Server&gt;config/<module UUID>/ folder. By placing it in a JSON file, it makes it more clear to server administrators what they can configure, vs. requiring them to hand-edit your JavaScript. The variables JSON file can contain a basic JSON description. For example:  JSON Copy {   \"mobSpawnRate\": 22 }   Within your script, you can use the 'variables.get' method to retrieve that property using the @minecraft/server-admin module:  JavaScript Copy const spawnRate = variables.get(\"mobSpawnRate\");   There is a similar system for storing \"secrets\" – that is, more sensitive data that you want to ensure can be used only in very constrained ways. For example, secrets could be data like authentication tokens that you wish to pass to a web service. variables.json, secrets.json can be placed by a server administrator within either your &lt;Bedrock Dedicated Server&gt;config/default/ folder or within a &lt;Bedrock Dedicated Server&gt;config/<module UUID>/ folder. What makes secrets.json a little different is that it is not designed to let you get at the value of the secret in JavaScript – at least not directly. Instead, it returns an opaque ServerSecrets object that can be used in certain methods, like the \"@minecraft/server-net\" module's HttpHeader object constructor. See this sample in the ServerSecrets object for an example usage.  Building a process for working with your server  Your next step will probably be to build an automated process to make the application of your JavaScript updates – and debugging – easier with Dedicated Server while you work. You'll likely also want to make it easier to apply your world customizations to the Dedicated Server. These build processes are typically highly customized and will reflect your preferences and what you are comfortable with, but we also have an example of this available to give you some serving suggestions.  Familiarize yourself with the Build a gameplay experience with TypeScript article. This article shows how you can get started with a client-side development flow using TypeScript and a build process tool called gulp. It's worthwhile to do the entire example using the Minecraft app to get started.  After you've done that successfully, you can take advantage of the special \"Dedicated Server\" mode of that sample. To do this, edit your gulpfile.js and change two variables at the top of the file:  JavaScript Copy const useMinecraftDedicatedServer = true;  const dedicatedServerPath = \"C:/mc/bds/1.19.0/\";   Set the dedicated server path to match the location of the dedicated server that you'd like to develop with.  From there, when you run 'gulp', it will automatically output the behavior pack to your Bedrock Dedicated Server folder. Even better: running 'gulp serve' will automatically start your server and place it into debug mode, and otherwise tear down and restart your server as you make file updates. This creates a very quick debug loop to make changes to script or your behavior packs, and use dedicated server as a quick testing tool. But it's also just a sample, so customize and adapt it to your preferences.  Wrapping up  Now you have all the ingredients you need to build powerful dedicated servers that can connect to external web services to give you:  scripting via the GameTest Framework experiment connections to external web services via the \"@minecraft/server-net\" module configurations for your dedicated server to enable additional permissions and server configuration variables build processes for making working with your dedicated server a snap  Because these features are experimental, check the changelog for upcoming changes that may impact you. We'd also love to know if you have feedback or suggestions – please log them via our documentation issues.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/scriptingservers?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Using script to add new capabilities to dedicated servers 09/21/2023  With version 1.19.0, Bedrock Dedicated Server gains new capabilities in conjunction with experimental JavaScript Beta APIs. It is now much easier to build deeply customized Bedrock Dedicated Server gameplay experiences by connecting your server to external services and sites. For example, you could use this functionality to connect a dedicated server to back-end infrastructure that powers a website-based leaderboard. Or you can build an advanced administrative console to give server administrators to more flexibility when managing players in a game.  In this article, we'll cover the foundation of everything you need to know about building extended experiences with script + dedicated server.  But first! A few warnings and notices on this topic before we get started:  Important: These APIs are experimental as part of the Beta APIs experiment. As with all experiments, you may see changes or even removals of functionality in updated Minecraft versions. Check the the Minecraft changelog for details on any changes to Beta APIs. We'll cover a few more advanced topics in this article, so you should be familiar with the basics of scripting and general Minecraft customization concepts. Make sure you back up worlds and files before you get deep into modifying and copying worlds around. These tips work only in conjunction with Bedrock Dedicated Server, available at Bedrock Server Download, that you can host on your own. This article does not apply to gameplay servers provided as part of Minecraft Realms. See more information on Bedrock Dedicated Server via this FAQ. Running a server  The first step in getting started with Dedicated Servers is to download the Dedicated Server zip from the Bedrock Server Download site.  After downloading the Bedrock Server zip file, extract it to a folder of your choosing, like C:\\MinecraftServer\\. As you work and iterate, you may have multiple copies of Bedrock Dedicated Server stored on your PC that you can choose to run, so you may want to consider a naming scheme for different iterations, like C:\\MinecraftServer\\1.19.0_1.  To run a Bedrock Dedicated Server, open a command prompt by opening the Start Menu and typing 'Command Prompt', or by using the Windows Terminal app from the Microsoft Store).  Use the cd command to change directories to where you unzipped the Bedrock Dedicated Server. For example, type cd \"C:\\MinecraftServer\\1.19.0_1\".  Then, enter bedrock_server.exe. This will start up the Bedrock Dedicated Server and have it start listening for joining players.  After the server is started by the steps above, you can type in commands on the console like op <playername> to grant operator privileges to a player. When you wish to stop the server, type stop on the Bedrock Dedicated Server command line.  Allow Bedrock Dedicated Server in Firewall  The first time you run a Bedrock Dedicated Server, your operating system may ask if you want to allow Bedrock Dedicated Server through the Firewall. Within Windows, the common options you select (Private or Public Networks) will depend on your networking preferences. But to allow players from other machines to join your server, you'll need to allow access for Bedrock Dedicated Server through your Firewall by at least one route (Private Networks or Public Networks), if not both. Depending on your configuration, you may need to do additional configuration on your networking router and machine to fully enable multiplayer play with your Bedrock Dedicated Server.  Initial run of a Bedrock Dedicated Server:   Enable Loopback in Minecraft  You'll probably want to connect to the world hosted by your machine from a Minecraft client running on that same exact machine. By default, the Minecraft and Minecraft Preview game on Windows cannot connect to local services, so you'll need to enable that first by \"Enabling Loopback\". To do this, stop your server if it is running and then run the following command if you wish to enable loopback for the main Minecraft app:  CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-1958404141-86561845-1752920682-3514627264-368642714-62675701-733520436  Run this command line if you wish to enable loopback for the Minecraft Preview app:  CheckNetIsolation.exe LoopbackExempt -a -p=S-1-15-2-424268864-5579737-879501358-346833251-474568803-887069379-4040235476  Test Minecraft Server To test your Minecraft Server, first restart the server by running bedrock_server.exe. Then, run the Minecraft app (if you are using the Preview version of the Minecraft Dedicated Server, you should use the Minecraft Preview app). Select Play. For the first time, you will need to add your local machine-hosted server. Select Add Server. a. For Server Name, enter \"My Local Computer\" or any name you want to give it. b. For Server Address, enter 127.0.0.1. This is the standard IP address that refers to \"localhost\" or \"the same computer that this app is running on.\" c. You can leave the port as 19132, which is the default port for a Bedrock Dedicated Server. After all that, select Save.  In the Server list, select the new Server entry and then select Join, which should allow you to enter the world. Within your Bedrock Server console, you should see that a new player has joined.  Troubleshooting server and client versioning  Did you get an \"Outdated client\" or \"Outdated server\" message when connecting Minecraft Bedrock Dedicated Server and Minecraft clients? This is because of a mismatch of versions between client and server. Minecraft clients and servers must support the same protocol version.  This protocol version is typically updated across minor and patch versions of the product – so 1.18.0 and 1.19.0 are not compatible with one another, protocol-wise. But also \"patch version\" differences (like 1.18.10 vs. 1.18.30) will have different protocol versions and therefore not be compatible with each other, either.  When using a Preview Dedicated Server, you'll want to make sure that the players who join your server use freshly updated versions of Minecraft Preview clients to connect to those servers. Protocol versions can change enough from one week to the next to cause a connectivity issue, and non-Preview versions of Minecraft will probably not be able to connect to Preview Dedicated Server either due to those same protocol version mismatches. So, it's best to have players download a new Preview client from the Microsoft Store right before they play.  Building out your server world  It is important for Server administrators to understand the content they are hosting via their server and should opt-in to using experimental capabilities. For this reason, by default, generated worlds in Bedrock Dedicated Server do not have the Beta APIs experiment turned on, and therefore do not run script. That's OK – you'll probably want to carefully build out your custom server world anyways, and as part of that, turn on the Beta APIs experiment in that world to enable custom scripts.  Here are the steps to creating your Minecraft world:  Use the Minecraft Client singleplayer to create and customize the world in the way that you like it. You can use whatever general Minecraft builder tips and techniques you'd like to build the world of your dreams. Enable the Beta APIs experiment in that world. Within this world, you will also need to add your behavior packs that use script. For building, those behavior packs should not use dedicated-server only modules like \"@minecraft/server-net\" or \"@minecraft/server-admin\" Then, when you're ready to use that world on a dedicated server, copy it from your Minecraft client's Worlds folder: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\minecraftWorlds Each subfolder is a world. Usually the last world you played in will have the most updated \"Date modified.\" Unfortunately, world subfolders don't have very friendly names (typically, something like \"fyqEYmKXAwA=\") to help you figure out which world is which. Copy the contents of this world subfolder over to your Bedrock Dedicated Server. By default, Bedrock Dedicated Server will load the world it uses from &lt;Bedrock Dedicated Server&gt;/worlds/Bedrock level, but you can customize the name of the world to something other than \"Bedrock level\" in the &lt;Bedrock Dedicated Server&gt;/server.properties file. When you run the Bedrock Dedicated Server executable, you should see it load up the world. It will also generate a log entry like the following:  [2022-05-20 07:00:06:619 INFO] Experiment(s) active: gtst  Where gtst is a code for the Beta APIs experiment, indicating experimental script APIs are now available in your world.  The Bedrock Dedicated Server configuration system  Now that you have a custom world up and running with a bit of JavaScript within it, we'll want to extend it to take advantage of the new capabilities.  By default, most server configuration is stored within the \"server.properties\" file in the root of your Minecraft Bedrock Dedicated Server folder. Here, you can configure default permissions for new players that enter the game, server ports, number of threads, and more. Much of the documentation is embedded in line within \"server.properties.\" To get started, open \"server.properties\" with your favorite text editor, like Notepad.  For scripting, configuration files are stored in the \"<Bedrock Dedicated Server>/config/\" folder. In that folder is the subfolder \"<Bedrock Dedicated Server>/config/default/\", which controls default settings for all script modules. Within the \"default\" folder is a \"permissions.json\" file, which controls the default set of Mojang scripting modules that are accessible to worlds, assuming they have the Beta APIs experiment enabled.  Note that the @minecraft/server-net module is not enabled by default for scripting maps.  Enable differentiated module permissions  You can set different permissions for different references to scripts that are embedded as modules within behavior packs.  Create a subfolder within the config folder next to the \"default\" folder and name it the same as the module identifier (UUID) of the scripting module. For example, you would create a folder named \"a8d43bd0-cffd-4988-949a-5105e14bb5f2\" for a scripting module with the following excerpt from its behavior pack's \"manifest.json\" file: JSON Copy   \"modules\": [     {       \"description\": \"Script resources\",       \"language\": \"javascript\",       \"type\": \"script\",       \"uuid\": \"a8d43bd0-cffd-4988-949a-5105e14bb5f2\",       \"version\": [0, 0, 1],       \"entry\": \"scripts/main.js\"     }   ],  Next, to customize the set of built in modules your behavior pack's script module can access, you can place a \"permissions.json\" file within that folder. (Yes, the UUID folder name is a bit clunky, but we hope to improve this in a future update). We strongly recommend keeping &lt;Bedrock Dedicated Server&gt;/config/default/permissions.json basic and minimal, while extending additional module permissions on an individual basis.  @minecraft/minecraft-server-net\" />  Variables and Secrets  You can also empower server administrators to further configure how script modules function. For example, maybe your script has alternate levels of difficulty by controlling mob spawn rate that you wish to let administrators configure. To do this, put a \"variables. json\" file within either your &lt;Bedrock Dedicated Server&gt;config/default/ folder or within a &lt;Bedrock Dedicated Server&gt;config/<module UUID>/ folder. By placing it in a JSON file, it makes it more clear to server administrators what they can configure, vs. requiring them to hand-edit your JavaScript. The variables JSON file can contain a basic JSON description. For example:  JSON Copy {   \"mobSpawnRate\": 22 }   Within your script, you can use the 'variables.get' method to retrieve that property using the @minecraft/server-admin module:  JavaScript Copy const spawnRate = variables.get(\"mobSpawnRate\");   There is a similar system for storing \"secrets\" – that is, more sensitive data that you want to ensure can be used only in very constrained ways. For example, secrets could be data like authentication tokens that you wish to pass to a web service. variables.json, secrets.json can be placed by a server administrator within either your &lt;Bedrock Dedicated Server&gt;config/default/ folder or within a &lt;Bedrock Dedicated Server&gt;config/<module UUID>/ folder. What makes secrets.json a little different is that it is not designed to let you get at the value of the secret in JavaScript – at least not directly. Instead, it returns an opaque ServerSecrets object that can be used in certain methods, like the \"@minecraft/server-net\" module's HttpHeader object constructor. See this sample in the ServerSecrets object for an example usage.  Building a process for working with your server  Your next step will probably be to build an automated process to make the application of your JavaScript updates – and debugging – easier with Dedicated Server while you work. You'll likely also want to make it easier to apply your world customizations to the Dedicated Server. These build processes are typically highly customized and will reflect your preferences and what you are comfortable with, but we also have an example of this available to give you some serving suggestions.  Familiarize yourself with the Build a gameplay experience with TypeScript article. This article shows how you can get started with a client-side development flow using TypeScript and a build process tool called gulp. It's worthwhile to do the entire example using the Minecraft app to get started.  After you've done that successfully, you can take advantage of the special \"Dedicated Server\" mode of that sample. To do this, edit your gulpfile.js and change two variables at the top of the file:  JavaScript Copy const useMinecraftDedicatedServer = true;  const dedicatedServerPath = \"C:/mc/bds/1.19.0/\";   Set the dedicated server path to match the location of the dedicated server that you'd like to develop with.  From there, when you run 'gulp', it will automatically output the behavior pack to your Bedrock Dedicated Server folder. Even better: running 'gulp serve' will automatically start your server and place it into debug mode, and otherwise tear down and restart your server as you make file updates. This creates a very quick debug loop to make changes to script or your behavior packs, and use dedicated server as a quick testing tool. But it's also just a sample, so customize and adapt it to your preferences.  Wrapping up  Now you have all the ingredients you need to build powerful dedicated servers that can connect to external web services to give you:  scripting via the GameTest Framework experiment connections to external web services via the \"@minecraft/server-net\" module configurations for your dedicated server to enable additional permissions and server configuration variables build processes for making working with your dedicated server a snap  Because these features are experimental, check the changelog for upcoming changes that may impact you. We'd also love to know if you have feedback or suggestions – please log them via our documentation issues.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/lootandtradetablefunctions?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Loot and Trade Table Functions 03/06/2025  Both loot and trade tables share a similar same function set. While most work on both, some only work within a specific type. There are limitations to loot/trade tables in general: for instance, there isn't a way to add can_place_on or can_destroy onto an item through loot or trade tables. See below for the different functions available and an example on how they can be used.  In this tutorial you will learn the following:  There is a variety of loot and trade table functions and they can modify a player's loot experience. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Loot Tables Enchanting  These different enchanting functions allow you to set unique enchanting parameters.  enchant_book_for_trading (trade table only)  This function enchants a book using the algorithm for enchanting items sold by villagers. It takes four parameters: base_cost, base_random_cost, per_level_random_cost, and per_level_cost.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:book\",     \"quantity\": 1,     \"functions\": [         {             \"function\": \"enchant_book_for_trading\",             \"base_cost\": 2,             \"base_random_cost\": 5,             \"per_level_random_cost\": 10,             \"per_level_cost\": 3         }     ] }   At this time, defining these parameters won't affect the enchantment received. Currently, the default values above are hard-coded. In the future, you will be able to adjust these values to help narrow down what enchantments and enchantment levels this function results in.  enchant_random_gear  Enchants an item using the same algorithm used while enchanting equipment vanilla mobs spawn with. Takes a chance modifier to manipulate the algorithm. Note that a chance modifier of 1.0 doesn't mean a 100% chance that gear will become enchanted. Rather, the chance is modified based on the difficulty.  On Peaceful and Easy difficulties, the chance will always be 0% no matter what. On Hard difficulty, a chance of 1.0 will be 100%, but the chance is roughly 2/3 that on Normal difficulty.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:chainmail_boots\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"enchant_random_gear\",             \"chance\": 0.25         }     ] }   Increasing chance to a number higher than 1.0 can help to bypass the decrease in chance with Normal difficulty. For example, setting chance to 2.0 will always enchant the item on both Normal and Hard difficulty.  enchant_randomly  Generates a random enchantment that is compatible with the item. Supports the optional treasure boolean (true/false) to allow treasure enchantments to be toggled on and off. Treasure enchantments are enchantments that cannot be obtained through the enchanting table, including Frost Walker, Mending, Soul Speed, Curse of Binding, and Curse of Vanishing.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:leather_helmet\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"enchant_randomly\",             \"treasure\": true         }     ] }  enchant_with_levels  Applies an enchantment as if it were enchanted through an enchanting table using a minimum and maximum XP level defined through the levels parameter. The treasure boolean (true/false) will allow treasure-only enchantments to be used. Treasure enchantments are enchantments that cannot be obtained through the enchanting table, including Frost Walker, Mending, Soul Speed, Curse of Binding, and Curse of Vanishing.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:diamond_sword\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"enchant_with_levels\",             \"treasure\": true,             \"levels\": {                 \"min\": 20,                 \"max\": 39             }         }     ] }  set_potion  This function sets the potion type of compatible items with a potion ID.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:potion\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_potion\",             \"id\": \"strong_regeneration\"         }     ] }  specific_enchants  This function allows you to set a list of specific enchantments on an item. It also allows you to apply enchantments to items that wouldn't normally be enchantable in-game.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"specific_enchants\",           \"enchants\": [              \"knockback\",              \"fire_aspect\"           ]        }     ]  }   You can also define the enchantments as objects to specifically define an enchantment level. Max enchantment levels are hard-coded and can't be overwritten.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"specific_enchants\",           \"enchants\": [              {                 \"id\": \"knockback\",                 \"level\": 1              },              {                 \"id\": \"unbreaking\",                 \"level\": 3              }           ]        }     ] }  Modifying items  The following set of functions allow you to modify the results in different ways, such as setting how many of an item is returned, setting its data value, or even setting the name and lore of an item.  looting_enchant (loot table only)  This function allows you to modify the count of how many items are returned when an entity is killed by an item with the looting enchantment. Due to that, it only works with loot tables, and only if that loot table is called by the death of an entity.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"looting_enchant\",             \"count\": {                 \"min\": 0,                 \"max\": 1             }         }     ] }  random_aux_value  Similar to random_block_state, this allows you to pick a random auxiliary value for an item. The following example will result in a randomly-colored dye.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:dye\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"random_aux_value\",           \"values\": {             \"min\": 0,             \"max\": 15           }         }     ] }  random_block_state  This allows you to randomize the block state of the resulting item. This example is from the trade table for a shepherd to control what color wool they give.  JSON Copy {   \"item\": \"minecraft:wool\",   \"functions\": [     {       \"function\": \"random_block_state\",       \"block_state\": \"color\",       \"values\": {         \"min\": 0,         \"max\": 15       }     }   ] }  random_dye  This function affects the colors of the random leather items supplied by a leather worker.  Example:  JSON Copy \"gives\": [   {     \"item\": \"minecraft:leather_helmet\",     \"quantity\": 1,     \"functions\": [       {         \"function\": \"random_dye\"       }     ]   } ]  set_actor_id  This function only works with a spawn egg and is used to set the entity ID of that spawn egg.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stone\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_actor_id\",             \"id\": \"sample:cool_entity\"         }     ] }   You can also inherit the entity ID of the entity that's associated with that loot table (like making a rabbit drop a rabbit spawn egg) by omitting the id.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:spawn_egg\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_actor_id\"         }     ] }   Be aware that if you use set_actor_id on a chest's loot table and omit the id value, it will generate the spawn egg of whatever opens the chest (the player). A player spawn egg will spawn a \"player\" that just stands around and throws up Molang errors (because it's trying to use the player's behavior file as well as the player's controllers).  If you break a chest containing a loot table that uses an inherited ID from set_actor_id, it drops a default spawn egg that doesn't spawn anything.  set_banner_details  This function only works on banners and currently only supports a banner type of 1. A banner type of 1 results in an illager banner.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:banner\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_banner_details\",             \"type\": 1         }     ] }  set_book_contents  This function allows you to set the contents of a book.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:written_book\",     \"functions\": [         {             \"function\": \"set_book_contents\",             \"author\": \"Steve\",             \"title\": \"Creator Woes\",             \"pages\": [                 \"Once upon a time there were some marketplace partners that had to edit items using NBT. And it made them sad.\",                 \"Then the Bedrock team added the ability to customize items from JSON and everyone rejoiced!\"             ]         }     ] }   You can also use rawtext to localize the content of the book. When using rawtext, remember to always escape (\\) special characters like \" and \\.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:written_book\",     \"functions\": [         {             \"function\": \"set_book_contents\",             \"author\": \"Steve\",             \"title\": \"Creator Woes\",             \"pages\": [                 \"{\\\"rawtext\\\":[ {\\\"translate\\\":\\\"custom.book.page.1\\\"}]}\",                 \"{\\\"rawtext\\\":[ {\\\"translate\\\":\\\"custom.book.page.2\\\"}]}\"             ]         }     ] }   Be aware that you can only use rawtext on the book's contents (pages) at the timing of writing this — rawtext does not work for the author or title tags.  set_count  Sets the quantity of items returned by setting the count value. It could either be an exact number like this example:  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stone\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"set_count\",           \"count\": 5         }     ] }   ... or it can be within a min/max range:  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stone\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"set_count\",           \"count\": {             \"min\": 1,             \"max\": 6           }         }     ] }  set_damage  Sets the percentage of durability remaining for items that have durability by setting the damage value. 1.0 is 100% of durability remaining (undamaged) while 0.0 has no durability remaining.  You can either set it to an exact durability like in the following example where we set the item to have 50% durability remaining.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:iron_leggings\",     \"weight\": 1,     \"functions\": [       {         \"function\": \"set_damage\",         \"damage\": 0.5       }     ] }   You can also define a min/max range the game will use to pick a value.  This example sets the durability to somewhere between 30% and 90% remaining.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:iron_leggings\",     \"weight\": 1,     \"functions\": [       {         \"function\": \"set_damage\",         \"damage\": {           \"min\": 0.3,           \"max\": 0.9         }       }     ] }  set_data  Sets the data value of a block or item to an exact ID. This is useful for things like returning a specific potion or an item of a specific color.  The following example will result in a particular variant of suspicious stew.  JSON Copy   {     \"type\": \"item\",     \"name\": \"minecraft:suspicious_stew\",     \"weight\": 1,     \"functions\": [       {         \"function\": \"set_data\",         \"data\": 3       }     ]   }  set_data_from_color_index  Inherits the data value of the resulting item from the associated entity's color index. An in-game example would be a pink sheep dropping pink wool when you kill it or shear it. If the associated entity doesn't have a color index set (or if it's used inside a chest's loot table), it will always result in a data value of 0.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:wool\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_data_from_color_index\"         }     ] }  set_lore  This function allows you to set the lore of an item. Each line within the lore object represents a single line of text. There's currently no support for rawtext.  JSON Copy {   \"type\": \"item\",   \"name\": \"minecraft:stick\",   \"weight\": 1,   \"functions\": [       {           \"function\": \"set_lore\",           \"lore\": [               \"Big Stick has been handed down\",               \"for generations within the royal family\",               \"until it went missing four score years ago...\"           ]      }   ] }  set_name  This function allows you to set the name of an item. There's currently no support for rawtext.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_name\",             \"name\": \"Big Stick\"         }     ]  }  Miscellaneous  The following functions don't seem to fit anywhere else.  exploration_map  Transforms a normal map into a treasure map that marks the location of hidden treasure. The destination value defines what type of treasure map they receive.  JSON Copy   {       \"type\": \"item\",       \"name\": \"minecraft:map\",       \"weight\": 1,       \"functions\": [           {               \"function\": \"exploration_map\",               \"destination\": \"buriedtreasure\"           }       ]   }   These are the current destinations:  Expand table Destination buriedtreasure endcity fortress mansion mineshaft monument pillageroutpost ruins shipwreck stronghold temple village fill_container  This function allows you to define the loot table for a chest. When the item is generated and the player places it, it will be full of the contents defined inside the referenced loot table.  Loot tables for chests are generated at the time of opening or breaking. Consider it a Schrödinger's box. The content of the chest isn't decided until you look inside.  JSON Copy   {       \"type\": \"item\",       \"name\": \"minecraft:chest\",       \"functions\": [           {               \"function\": \"fill_container\",               \"loot_table\": \"loot_tables/chests/simple_dungeon.json\"           }       ]   }   It's advisable to always use set_name to give the chest a name when using fill_container. If you don't, the resulting chest won't look any different in the player's inventory than a normal empty chest would.  furnace_smelt (loot table only)  The \"furnace_smelt\" function can be called on the loot dropping from an entity. What this means is, if an entity is killed with fire (like if a player is hunting chickens with a sword that has a fire aspect enchantment), the dropped loot will be the cooked version of the item - as if you cooked the chicken in a furnace.  Logically, this function will not work in villager trades or with chests.  This is the part of the chicken loot table code that shows how the game calls the furnace_smelt function on the loot being dropped. This would be triggered by the enchantment on the weapon used by the player to kill the chicken.  JSON Copy {   \"type\": \"item\",   \"name\": \"minecraft:chicken\",   \"weight\": 1,   \"functions\": [     {       \"function\": \"furnace_smelt\",       \"conditions\": [         {           \"condition\": \"entity_properties\",           \"entity\": \"this\",           \"properties\": {           \"on_fire\": true           }         }       ]     }   ] }  trader_material_type  This function affects the type of items a fisherman wants to trade for other items, such as a boat.  JSON Copy \"wants\": [   {     \"item\": \"minecraft:boat\",     \"quantity\": 1,     \"price_multiplier\": 0.05,     \"functions\": [       {         \"function\": \"trader_material_type\"       }      ]   }   Multiple functions  Multiple functions can be defined. Here's an example of combining two functions together. In this example, this entry will return between one and three Potions of Healing.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:potion\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_count\",             \"count\": {               \"min\": 1,               \"max\": 3             }         },         {             \"function\": \"set_data\",             \"data\": 21         }     ] }   Multiple functions can even be multiple of the same function, but if there's a conflict between those functions, the last to be defined will win.  For example, using multiple set_count functions, like with the example below, will result in only the last of the duplicates being used, causing the item to have a count between 5 and 7 rather than between 1 and 3.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:potion\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_count\",             \"count\": {               \"min\": 1,               \"max\": 3             }         },         {             \"function\": \"set_count\",             \"count\": {               \"min\": 5,               \"max\": 7             }         }     ] }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/lootandtradetablefunctions?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Loot and Trade Table Functions 03/06/2025  Both loot and trade tables share a similar same function set. While most work on both, some only work within a specific type. There are limitations to loot/trade tables in general: for instance, there isn't a way to add can_place_on or can_destroy onto an item through loot or trade tables. See below for the different functions available and an example on how they can be used.  In this tutorial you will learn the following:  There is a variety of loot and trade table functions and they can modify a player's loot experience. Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Loot Tables Enchanting  These different enchanting functions allow you to set unique enchanting parameters.  enchant_book_for_trading (trade table only)  This function enchants a book using the algorithm for enchanting items sold by villagers. It takes four parameters: base_cost, base_random_cost, per_level_random_cost, and per_level_cost.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:book\",     \"quantity\": 1,     \"functions\": [         {             \"function\": \"enchant_book_for_trading\",             \"base_cost\": 2,             \"base_random_cost\": 5,             \"per_level_random_cost\": 10,             \"per_level_cost\": 3         }     ] }   At this time, defining these parameters won't affect the enchantment received. Currently, the default values above are hard-coded. In the future, you will be able to adjust these values to help narrow down what enchantments and enchantment levels this function results in.  enchant_random_gear  Enchants an item using the same algorithm used while enchanting equipment vanilla mobs spawn with. Takes a chance modifier to manipulate the algorithm. Note that a chance modifier of 1.0 doesn't mean a 100% chance that gear will become enchanted. Rather, the chance is modified based on the difficulty.  On Peaceful and Easy difficulties, the chance will always be 0% no matter what. On Hard difficulty, a chance of 1.0 will be 100%, but the chance is roughly 2/3 that on Normal difficulty.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:chainmail_boots\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"enchant_random_gear\",             \"chance\": 0.25         }     ] }   Increasing chance to a number higher than 1.0 can help to bypass the decrease in chance with Normal difficulty. For example, setting chance to 2.0 will always enchant the item on both Normal and Hard difficulty.  enchant_randomly  Generates a random enchantment that is compatible with the item. Supports the optional treasure boolean (true/false) to allow treasure enchantments to be toggled on and off. Treasure enchantments are enchantments that cannot be obtained through the enchanting table, including Frost Walker, Mending, Soul Speed, Curse of Binding, and Curse of Vanishing.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:leather_helmet\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"enchant_randomly\",             \"treasure\": true         }     ] }  enchant_with_levels  Applies an enchantment as if it were enchanted through an enchanting table using a minimum and maximum XP level defined through the levels parameter. The treasure boolean (true/false) will allow treasure-only enchantments to be used. Treasure enchantments are enchantments that cannot be obtained through the enchanting table, including Frost Walker, Mending, Soul Speed, Curse of Binding, and Curse of Vanishing.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:diamond_sword\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"enchant_with_levels\",             \"treasure\": true,             \"levels\": {                 \"min\": 20,                 \"max\": 39             }         }     ] }  set_potion  This function sets the potion type of compatible items with a potion ID.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:potion\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_potion\",             \"id\": \"strong_regeneration\"         }     ] }  specific_enchants  This function allows you to set a list of specific enchantments on an item. It also allows you to apply enchantments to items that wouldn't normally be enchantable in-game.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"specific_enchants\",           \"enchants\": [              \"knockback\",              \"fire_aspect\"           ]        }     ]  }   You can also define the enchantments as objects to specifically define an enchantment level. Max enchantment levels are hard-coded and can't be overwritten.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"specific_enchants\",           \"enchants\": [              {                 \"id\": \"knockback\",                 \"level\": 1              },              {                 \"id\": \"unbreaking\",                 \"level\": 3              }           ]        }     ] }  Modifying items  The following set of functions allow you to modify the results in different ways, such as setting how many of an item is returned, setting its data value, or even setting the name and lore of an item.  looting_enchant (loot table only)  This function allows you to modify the count of how many items are returned when an entity is killed by an item with the looting enchantment. Due to that, it only works with loot tables, and only if that loot table is called by the death of an entity.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"looting_enchant\",             \"count\": {                 \"min\": 0,                 \"max\": 1             }         }     ] }  random_aux_value  Similar to random_block_state, this allows you to pick a random auxiliary value for an item. The following example will result in a randomly-colored dye.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:dye\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"random_aux_value\",           \"values\": {             \"min\": 0,             \"max\": 15           }         }     ] }  random_block_state  This allows you to randomize the block state of the resulting item. This example is from the trade table for a shepherd to control what color wool they give.  JSON Copy {   \"item\": \"minecraft:wool\",   \"functions\": [     {       \"function\": \"random_block_state\",       \"block_state\": \"color\",       \"values\": {         \"min\": 0,         \"max\": 15       }     }   ] }  random_dye  This function affects the colors of the random leather items supplied by a leather worker.  Example:  JSON Copy \"gives\": [   {     \"item\": \"minecraft:leather_helmet\",     \"quantity\": 1,     \"functions\": [       {         \"function\": \"random_dye\"       }     ]   } ]  set_actor_id  This function only works with a spawn egg and is used to set the entity ID of that spawn egg.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stone\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_actor_id\",             \"id\": \"sample:cool_entity\"         }     ] }   You can also inherit the entity ID of the entity that's associated with that loot table (like making a rabbit drop a rabbit spawn egg) by omitting the id.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:spawn_egg\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_actor_id\"         }     ] }   Be aware that if you use set_actor_id on a chest's loot table and omit the id value, it will generate the spawn egg of whatever opens the chest (the player). A player spawn egg will spawn a \"player\" that just stands around and throws up Molang errors (because it's trying to use the player's behavior file as well as the player's controllers).  If you break a chest containing a loot table that uses an inherited ID from set_actor_id, it drops a default spawn egg that doesn't spawn anything.  set_banner_details  This function only works on banners and currently only supports a banner type of 1. A banner type of 1 results in an illager banner.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:banner\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_banner_details\",             \"type\": 1         }     ] }  set_book_contents  This function allows you to set the contents of a book.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:written_book\",     \"functions\": [         {             \"function\": \"set_book_contents\",             \"author\": \"Steve\",             \"title\": \"Creator Woes\",             \"pages\": [                 \"Once upon a time there were some marketplace partners that had to edit items using NBT. And it made them sad.\",                 \"Then the Bedrock team added the ability to customize items from JSON and everyone rejoiced!\"             ]         }     ] }   You can also use rawtext to localize the content of the book. When using rawtext, remember to always escape (\\) special characters like \" and \\.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:written_book\",     \"functions\": [         {             \"function\": \"set_book_contents\",             \"author\": \"Steve\",             \"title\": \"Creator Woes\",             \"pages\": [                 \"{\\\"rawtext\\\":[ {\\\"translate\\\":\\\"custom.book.page.1\\\"}]}\",                 \"{\\\"rawtext\\\":[ {\\\"translate\\\":\\\"custom.book.page.2\\\"}]}\"             ]         }     ] }   Be aware that you can only use rawtext on the book's contents (pages) at the timing of writing this — rawtext does not work for the author or title tags.  set_count  Sets the quantity of items returned by setting the count value. It could either be an exact number like this example:  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stone\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"set_count\",           \"count\": 5         }     ] }   ... or it can be within a min/max range:  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stone\",     \"weight\": 1,     \"functions\": [         {           \"function\": \"set_count\",           \"count\": {             \"min\": 1,             \"max\": 6           }         }     ] }  set_damage  Sets the percentage of durability remaining for items that have durability by setting the damage value. 1.0 is 100% of durability remaining (undamaged) while 0.0 has no durability remaining.  You can either set it to an exact durability like in the following example where we set the item to have 50% durability remaining.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:iron_leggings\",     \"weight\": 1,     \"functions\": [       {         \"function\": \"set_damage\",         \"damage\": 0.5       }     ] }   You can also define a min/max range the game will use to pick a value.  This example sets the durability to somewhere between 30% and 90% remaining.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:iron_leggings\",     \"weight\": 1,     \"functions\": [       {         \"function\": \"set_damage\",         \"damage\": {           \"min\": 0.3,           \"max\": 0.9         }       }     ] }  set_data  Sets the data value of a block or item to an exact ID. This is useful for things like returning a specific potion or an item of a specific color.  The following example will result in a particular variant of suspicious stew.  JSON Copy   {     \"type\": \"item\",     \"name\": \"minecraft:suspicious_stew\",     \"weight\": 1,     \"functions\": [       {         \"function\": \"set_data\",         \"data\": 3       }     ]   }  set_data_from_color_index  Inherits the data value of the resulting item from the associated entity's color index. An in-game example would be a pink sheep dropping pink wool when you kill it or shear it. If the associated entity doesn't have a color index set (or if it's used inside a chest's loot table), it will always result in a data value of 0.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:wool\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_data_from_color_index\"         }     ] }  set_lore  This function allows you to set the lore of an item. Each line within the lore object represents a single line of text. There's currently no support for rawtext.  JSON Copy {   \"type\": \"item\",   \"name\": \"minecraft:stick\",   \"weight\": 1,   \"functions\": [       {           \"function\": \"set_lore\",           \"lore\": [               \"Big Stick has been handed down\",               \"for generations within the royal family\",               \"until it went missing four score years ago...\"           ]      }   ] }  set_name  This function allows you to set the name of an item. There's currently no support for rawtext.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:stick\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_name\",             \"name\": \"Big Stick\"         }     ]  }  Miscellaneous  The following functions don't seem to fit anywhere else.  exploration_map  Transforms a normal map into a treasure map that marks the location of hidden treasure. The destination value defines what type of treasure map they receive.  JSON Copy   {       \"type\": \"item\",       \"name\": \"minecraft:map\",       \"weight\": 1,       \"functions\": [           {               \"function\": \"exploration_map\",               \"destination\": \"buriedtreasure\"           }       ]   }   These are the current destinations:  Expand table Destination buriedtreasure endcity fortress mansion mineshaft monument pillageroutpost ruins shipwreck stronghold temple village fill_container  This function allows you to define the loot table for a chest. When the item is generated and the player places it, it will be full of the contents defined inside the referenced loot table.  Loot tables for chests are generated at the time of opening or breaking. Consider it a Schrödinger's box. The content of the chest isn't decided until you look inside.  JSON Copy   {       \"type\": \"item\",       \"name\": \"minecraft:chest\",       \"functions\": [           {               \"function\": \"fill_container\",               \"loot_table\": \"loot_tables/chests/simple_dungeon.json\"           }       ]   }   It's advisable to always use set_name to give the chest a name when using fill_container. If you don't, the resulting chest won't look any different in the player's inventory than a normal empty chest would.  furnace_smelt (loot table only)  The \"furnace_smelt\" function can be called on the loot dropping from an entity. What this means is, if an entity is killed with fire (like if a player is hunting chickens with a sword that has a fire aspect enchantment), the dropped loot will be the cooked version of the item - as if you cooked the chicken in a furnace.  Logically, this function will not work in villager trades or with chests.  This is the part of the chicken loot table code that shows how the game calls the furnace_smelt function on the loot being dropped. This would be triggered by the enchantment on the weapon used by the player to kill the chicken.  JSON Copy {   \"type\": \"item\",   \"name\": \"minecraft:chicken\",   \"weight\": 1,   \"functions\": [     {       \"function\": \"furnace_smelt\",       \"conditions\": [         {           \"condition\": \"entity_properties\",           \"entity\": \"this\",           \"properties\": {           \"on_fire\": true           }         }       ]     }   ] }  trader_material_type  This function affects the type of items a fisherman wants to trade for other items, such as a boat.  JSON Copy \"wants\": [   {     \"item\": \"minecraft:boat\",     \"quantity\": 1,     \"price_multiplier\": 0.05,     \"functions\": [       {         \"function\": \"trader_material_type\"       }      ]   }   Multiple functions  Multiple functions can be defined. Here's an example of combining two functions together. In this example, this entry will return between one and three Potions of Healing.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:potion\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_count\",             \"count\": {               \"min\": 1,               \"max\": 3             }         },         {             \"function\": \"set_data\",             \"data\": 21         }     ] }   Multiple functions can even be multiple of the same function, but if there's a conflict between those functions, the last to be defined will win.  For example, using multiple set_count functions, like with the example below, will result in only the last of the duplicates being used, causing the item to have a count between 5 and 7 rather than between 1 and 3.  JSON Copy {     \"type\": \"item\",     \"name\": \"minecraft:potion\",     \"weight\": 1,     \"functions\": [         {             \"function\": \"set_count\",             \"count\": {               \"min\": 1,               \"max\": 3             }         },         {             \"function\": \"set_count\",             \"count\": {               \"min\": 5,               \"max\": 7             }         }     ] }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoloottables?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Loot Tables 03/06/2025  When you do something fun and get rewarded with loot in Minecraft, a loot table was involved.  With just a few lines of JSON, loot tables control what you find when you break a block, open a newly discovered chest, interact with an entity, and use differently enchanted items in typical gameplay.  Loot table files live in a directory (cleverly named loot_tables) at the root level of a behavior pack.  The five categories of loot tables in Vanilla Minecraft are blocks, chests, entities, equipment, and gameplay (such as fishing, milking a mooshroom, or watching your sniffer find seeds).  If you have more than one type of loot table in your behavior pack, it would be a good idea to put each type in its own subfolder. But this is not required.  A loot table file generally consists of three main sections collectively known as a \"pool.\" As a creator, you might want to have different pools so you can drop different loot to your players if they satisfy different loot table conditions.  Rolls Rolls dictate how many times the pool will be rolled to select an entry. This could be either an integer which will result in a set amount of rolls or a min/max range from which the number of rolls can be chosen. Loot Table Conditions These are optional requirements that must be met for the pool to be rolled. Some of the more interesting functions you might want in your gameplay include setting the lore on an item (set_lore) and putting your own content into a book (set_book_contents). Entries This is a list of objects the game will select from in this roll. It can be an item, a loot_table, or empty if you want a chance of nothing happening this roll.  As an example, here is the loot table for when you have a pet cat and it brings you a gift in the morning:  JSON Copy {   \"pools\": [     {       \"rolls\": 1,       \"entries\": [         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_hide\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_foot\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:chicken\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:feather\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rotten_flesh\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:string\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:phantom_membrane\",           \"weight\": 2         }       ]     }   ] }   As you can see, getting a phantom membrane is rarer than getting a bit of string or a chicken. Imagine a cat bringing down a phantom! Now you know why they avoid cats...  What's Next?  We suggest taking a look at loot table functions next, followed by conditions, then loot overloads. Once you've gotten comfortable with all of the intricacies of those topics, jump into the tutorial and create your own loot table!  Loot and Trade Table Functions Loot Table Conditions Loot Table Overloads Creating a Loot Table  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoloottables?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Loot Tables 03/06/2025  When you do something fun and get rewarded with loot in Minecraft, a loot table was involved.  With just a few lines of JSON, loot tables control what you find when you break a block, open a newly discovered chest, interact with an entity, and use differently enchanted items in typical gameplay.  Loot table files live in a directory (cleverly named loot_tables) at the root level of a behavior pack.  The five categories of loot tables in Vanilla Minecraft are blocks, chests, entities, equipment, and gameplay (such as fishing, milking a mooshroom, or watching your sniffer find seeds).  If you have more than one type of loot table in your behavior pack, it would be a good idea to put each type in its own subfolder. But this is not required.  A loot table file generally consists of three main sections collectively known as a \"pool.\" As a creator, you might want to have different pools so you can drop different loot to your players if they satisfy different loot table conditions.  Rolls Rolls dictate how many times the pool will be rolled to select an entry. This could be either an integer which will result in a set amount of rolls or a min/max range from which the number of rolls can be chosen. Loot Table Conditions These are optional requirements that must be met for the pool to be rolled. Some of the more interesting functions you might want in your gameplay include setting the lore on an item (set_lore) and putting your own content into a book (set_book_contents). Entries This is a list of objects the game will select from in this roll. It can be an item, a loot_table, or empty if you want a chance of nothing happening this roll.  As an example, here is the loot table for when you have a pet cat and it brings you a gift in the morning:  JSON Copy {   \"pools\": [     {       \"rolls\": 1,       \"entries\": [         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_hide\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rabbit_foot\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:chicken\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:feather\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:rotten_flesh\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:string\",           \"weight\": 10         },         {           \"type\": \"item\",           \"name\": \"minecraft:phantom_membrane\",           \"weight\": 2         }       ]     }   ] }   As you can see, getting a phantom membrane is rarer than getting a bit of string or a chicken. Imagine a cat bringing down a phantom! Now you know why they avoid cats...  What's Next?  We suggest taking a look at loot table functions next, followed by conditions, then loot overloads. Once you've gotten comfortable with all of the intricacies of those topics, jump into the tutorial and create your own loot table!  Loot and Trade Table Functions Loot Table Conditions Loot Table Overloads Creating a Loot Table  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/lootoverloads?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Loot Overloads 10/24/2024  Now that you understand how loot tables work and how to customize them, it's time to learn about loot overloads. Loot overloads are commands that may be used to access items from loot tables in a variety of ways. The loot overloads include:  /kill simulates the loot drop of an entity if it were killed normally /mine simulates the loot drop of a block if it were mined normally /loot replace block allows users to populate target containers with items from a specified loot source /loot replace entity allows user to populate target entities with items from a specified loot source /loot spawn drops the loot of any entity that has a defined loot table in the world Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Loot Tables Loot and Trade Table Functions  Let's take a look at the overloads in more detail, beginning with the /kill command.  Kill  /kill is a command that simulates the loot drop of a selected entity as if it were killed normally. This differs from /loot spawn in that some loot tables specify a condition of \"condition\": \"killed_by_player\" for specific loot to be dropped.  Syntax  kill <entity: target> [tool|mainhand|offhand] - Pulls items from the specified entity's loot table, as if it were killed it with the specified tool, or no tool if none is specified.  kill - Keyword to identify overload.  entity - Target specifying the entity whose loot table will be used.  [tool|mainhand|offhand] - (Optional) Tool with which to simulate killing a given entity. Default is an empty hand.  Output - Command returns an error message if no entity is found or if more than one entity is specified.  Mine  /mine is a command that simulates the loot drop of a selected block in the world as if it were mined normally.  Syntax  mine <position: x y z> [tool|mainhand|offhand] - Obtains item resource drops from the target block's loot table, taking into account the tool, or no tool if none is specified. Enchanted tools held in the mainhand when mainhand is specified will have their enchantment evaluated for dropping loot.  mine - Keyword to identify overload.  position - Position specifying the block in the world to mine for loot.  [tool|mainhand|offhand] - (Optional) Tool with which to simulate mining a given block. Default is an empty hand.  Output - If successful, the command returns a message saying how many items were dropped. The command returns an error message if the position is out of the world or if the position is not loaded.  Loot replace block  The /loot replace block overload allows users to directly target containers and populate slots with items from a specified loot source. This source could be a currently existing loot table in Minecraft, a custom loot table, or a loot table associated with an entity.  Syntax  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] <source: loot|kill|mine> <source parameter> [<tool>|mainhand|offhand]  Loot Replace Block Parameters  replace block - Keyword to identify overload.  position - Position specifying which container block will receive items.  slot.container - Slot type for container blocks.  slotId - Slot number in which to place the first item.  count - (Optional) Number of consecutive slots to be filled. If the count is 0, no items are dropped. If a count is not specified, as many slots as possible are filled.  source - loot (path to a loot table), kill (loot that drops from a killed entity), or mine (loot that drops from a block when mined)  Output  If successful, the loot replace block command returns a message saying how many items were replaced and over how many slots.  The command returns errors if:  The target block is not a container, or if the target block is either air or an Ender Chest  The items were unable to be distributed (invalid slotId)  The count specified is a negative number  The combined slotId and count exceed the container size  Loot replace entity  The /loot replace entity overload allows users to directly target entities and populate slots with items from a specified loot source. This source could be a currently existing loot table in Minecraft, a custom loot table, or a loot table associated with an entity.  Syntax  /loot replace entity <entity: target> <slotType: EntityEquipmentSlot> <slotId: int> [<count: int>] <source: loot|kill|mine> <source parameter> [<tool>|mainhand|offhand]  Loot Replace Entity Parameters  replace entity - Keyword to identify overload.  entity - Selector specifying which entity(s) will receive the items.  slotType - EntityEquipmentSlot to place the first item in. Different slot types have different valid slot numbers.  slotId - Slot number in which to place the first item. Different slot types have different slot numbers. If there is only a single slot, the slotId does not matter. Single slots include: mainhand, offhand, player armor slots (head, chest, legs, feet), saddle, and armor (used by the horse and llama entities).  count - (Optional) Number of consecutive slots to be filled. If the count is 0, no items are dropped. If a count is not specified, as many slots as possible are filled.  source - loot (path to a loot table), kill (loot that drops from a killed entity), or mine (loot that drops from a block when mined)  Output  If successful, the loot replace entity command returns a message saying how many items were replaced and over how many slots.  The command returns errors if:  No matching entities are found  The items were unable to be distributed (invalid slotType/slotId combination, or an entity does not have that slotType)  The count specified is a negative number  The combined slotId and count exceed the container size  Loot spawn  The /loot spawn command allows creators to drop the loot of any entity that has a defined loot table into the world. This can be done with custom loot tables as well. The command follows the \"standard\" rules of loot tables, so they go through all conditions and pools. For example, using /loot spawn on a cave spider will not drop spider eyes, because the condition for spider eyes to drop is \"killed by player.\"  Syntax Copy /loot spawn <position: x y z> loot <loot_table: string> [<tool>:mainhand:offhand: string]   spawn <position: x y z> - Spawns an item into the world at the given position.  spawn - Keyword to identify overload.  position - Position at which the item will be spawned, specified in x, y, z coordinates.  Output - If successful, the command returns a message saying how many items were dropped. The command returns an error message if the position is out of the world or if the position is not loaded.  loot <loot_table> [tool|mainhand|offhand] - Pulls items from the specified loot table as if you used the specified tool to obtain them or no tool if none is specified.  loot - Keyword to identify overload.  loot_table - Path of the loot table to use.  [tool|mainhand|offhand] - (Optional) Tool to simulate mining the given loot table. Default is an empty hand.  Output - Command returns an error message if the given loot table does not exist.  Source Parameter Variations  Certain loot overloads, such as loot replace block and loot replace entity have the option to use the loot, kill, and mine source parameter variations. The following details how these variations operate in the loot overloads.  loot  loot is used to specify that the source is a defined loot table (or even a custom loot table) that can be found at a given path. The path to the loot table must be surrounded by quotes.  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] loot \"loot_table\" [<tool>|mainhand|offhand]  The loot_table parameter is mandatory and it must be the path of the loot table to use, surrounded by quotation marks.  Examples:  In this example, slot 0 of the target container is filled with 1 item. The path specifies that the items will be pulled from the \"chests/abandoned_mineshaft\" loot table.  /loot replace block 0 0 0 slot.container 0 1 loot \"chests/abandoned_mineshaft\"  In this example, slots 2 through 5 of the target container will be filled. You can think of it like, \"starting with slot 2, fill 4 slots with loot.\" So, the affected slots are 2 3 4 5.  /loot replace block 0 0 0 slot.container 2 4 loot \"chests/abandoned_mineshaft\"  This variation, without a count specified, will fill the container starting from slot 2, until either the entire contents of the given loot table have been dropped or there are no more slots to fill.  /loot replace block 0 0 0 slot.container 2 loot \"chests/abandoned_mineshaft\"  kill   Note  The kill variation of a loot overload command is different from the /kill command. In the context of the /loot command, using the kill variation means that the dropped loot will end up in the target container's specified slot.  Using the kill variation specifies that the user wants to simulate killing a specific entity in the world and use the loot table attached to it as the source for the loot to be dropped.  The target entity must be present within the world or the command will return an error saying that no matching targets were found.  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] kill <entity: target> [<tool>|mainhand|offhand]  Example:  /loot replace block 0 0 0 slot.container 0 1 kill @e[type=blaze]  This will fill the target container slots 0 through 1 with items that would be dropped if the blaze was killed by a player. The count parameter works the same for the kill source variation as it does for the loot source variation.  mine  Using the mine variation specifies that the user wants to simulate mining a specific block in the world and use it's loot table as the source for the loot to be dropped.  The target block must be present and loaded within the world or the command will return an error saying that blocks outside the world cannot be accessed.  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] mine <position: x y z> [<tool>|mainhand|offhand]  Example:  /loot replace block 0 0 0 slot.container 0 1 mine 0 0 0 Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/lootoverloads?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Loot Overloads 10/24/2024  Now that you understand how loot tables work and how to customize them, it's time to learn about loot overloads. Loot overloads are commands that may be used to access items from loot tables in a variety of ways. The loot overloads include:  /kill simulates the loot drop of an entity if it were killed normally /mine simulates the loot drop of a block if it were mined normally /loot replace block allows users to populate target containers with items from a specified loot source /loot replace entity allows user to populate target entities with items from a specified loot source /loot spawn drops the loot of any entity that has a defined loot table in the world Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Loot Tables Loot and Trade Table Functions  Let's take a look at the overloads in more detail, beginning with the /kill command.  Kill  /kill is a command that simulates the loot drop of a selected entity as if it were killed normally. This differs from /loot spawn in that some loot tables specify a condition of \"condition\": \"killed_by_player\" for specific loot to be dropped.  Syntax  kill <entity: target> [tool|mainhand|offhand] - Pulls items from the specified entity's loot table, as if it were killed it with the specified tool, or no tool if none is specified.  kill - Keyword to identify overload.  entity - Target specifying the entity whose loot table will be used.  [tool|mainhand|offhand] - (Optional) Tool with which to simulate killing a given entity. Default is an empty hand.  Output - Command returns an error message if no entity is found or if more than one entity is specified.  Mine  /mine is a command that simulates the loot drop of a selected block in the world as if it were mined normally.  Syntax  mine <position: x y z> [tool|mainhand|offhand] - Obtains item resource drops from the target block's loot table, taking into account the tool, or no tool if none is specified. Enchanted tools held in the mainhand when mainhand is specified will have their enchantment evaluated for dropping loot.  mine - Keyword to identify overload.  position - Position specifying the block in the world to mine for loot.  [tool|mainhand|offhand] - (Optional) Tool with which to simulate mining a given block. Default is an empty hand.  Output - If successful, the command returns a message saying how many items were dropped. The command returns an error message if the position is out of the world or if the position is not loaded.  Loot replace block  The /loot replace block overload allows users to directly target containers and populate slots with items from a specified loot source. This source could be a currently existing loot table in Minecraft, a custom loot table, or a loot table associated with an entity.  Syntax  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] <source: loot|kill|mine> <source parameter> [<tool>|mainhand|offhand]  Loot Replace Block Parameters  replace block - Keyword to identify overload.  position - Position specifying which container block will receive items.  slot.container - Slot type for container blocks.  slotId - Slot number in which to place the first item.  count - (Optional) Number of consecutive slots to be filled. If the count is 0, no items are dropped. If a count is not specified, as many slots as possible are filled.  source - loot (path to a loot table), kill (loot that drops from a killed entity), or mine (loot that drops from a block when mined)  Output  If successful, the loot replace block command returns a message saying how many items were replaced and over how many slots.  The command returns errors if:  The target block is not a container, or if the target block is either air or an Ender Chest  The items were unable to be distributed (invalid slotId)  The count specified is a negative number  The combined slotId and count exceed the container size  Loot replace entity  The /loot replace entity overload allows users to directly target entities and populate slots with items from a specified loot source. This source could be a currently existing loot table in Minecraft, a custom loot table, or a loot table associated with an entity.  Syntax  /loot replace entity <entity: target> <slotType: EntityEquipmentSlot> <slotId: int> [<count: int>] <source: loot|kill|mine> <source parameter> [<tool>|mainhand|offhand]  Loot Replace Entity Parameters  replace entity - Keyword to identify overload.  entity - Selector specifying which entity(s) will receive the items.  slotType - EntityEquipmentSlot to place the first item in. Different slot types have different valid slot numbers.  slotId - Slot number in which to place the first item. Different slot types have different slot numbers. If there is only a single slot, the slotId does not matter. Single slots include: mainhand, offhand, player armor slots (head, chest, legs, feet), saddle, and armor (used by the horse and llama entities).  count - (Optional) Number of consecutive slots to be filled. If the count is 0, no items are dropped. If a count is not specified, as many slots as possible are filled.  source - loot (path to a loot table), kill (loot that drops from a killed entity), or mine (loot that drops from a block when mined)  Output  If successful, the loot replace entity command returns a message saying how many items were replaced and over how many slots.  The command returns errors if:  No matching entities are found  The items were unable to be distributed (invalid slotType/slotId combination, or an entity does not have that slotType)  The count specified is a negative number  The combined slotId and count exceed the container size  Loot spawn  The /loot spawn command allows creators to drop the loot of any entity that has a defined loot table into the world. This can be done with custom loot tables as well. The command follows the \"standard\" rules of loot tables, so they go through all conditions and pools. For example, using /loot spawn on a cave spider will not drop spider eyes, because the condition for spider eyes to drop is \"killed by player.\"  Syntax Copy /loot spawn <position: x y z> loot <loot_table: string> [<tool>:mainhand:offhand: string]   spawn <position: x y z> - Spawns an item into the world at the given position.  spawn - Keyword to identify overload.  position - Position at which the item will be spawned, specified in x, y, z coordinates.  Output - If successful, the command returns a message saying how many items were dropped. The command returns an error message if the position is out of the world or if the position is not loaded.  loot <loot_table> [tool|mainhand|offhand] - Pulls items from the specified loot table as if you used the specified tool to obtain them or no tool if none is specified.  loot - Keyword to identify overload.  loot_table - Path of the loot table to use.  [tool|mainhand|offhand] - (Optional) Tool to simulate mining the given loot table. Default is an empty hand.  Output - Command returns an error message if the given loot table does not exist.  Source Parameter Variations  Certain loot overloads, such as loot replace block and loot replace entity have the option to use the loot, kill, and mine source parameter variations. The following details how these variations operate in the loot overloads.  loot  loot is used to specify that the source is a defined loot table (or even a custom loot table) that can be found at a given path. The path to the loot table must be surrounded by quotes.  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] loot \"loot_table\" [<tool>|mainhand|offhand]  The loot_table parameter is mandatory and it must be the path of the loot table to use, surrounded by quotation marks.  Examples:  In this example, slot 0 of the target container is filled with 1 item. The path specifies that the items will be pulled from the \"chests/abandoned_mineshaft\" loot table.  /loot replace block 0 0 0 slot.container 0 1 loot \"chests/abandoned_mineshaft\"  In this example, slots 2 through 5 of the target container will be filled. You can think of it like, \"starting with slot 2, fill 4 slots with loot.\" So, the affected slots are 2 3 4 5.  /loot replace block 0 0 0 slot.container 2 4 loot \"chests/abandoned_mineshaft\"  This variation, without a count specified, will fill the container starting from slot 2, until either the entire contents of the given loot table have been dropped or there are no more slots to fill.  /loot replace block 0 0 0 slot.container 2 loot \"chests/abandoned_mineshaft\"  kill   Note  The kill variation of a loot overload command is different from the /kill command. In the context of the /loot command, using the kill variation means that the dropped loot will end up in the target container's specified slot.  Using the kill variation specifies that the user wants to simulate killing a specific entity in the world and use the loot table attached to it as the source for the loot to be dropped.  The target entity must be present within the world or the command will return an error saying that no matching targets were found.  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] kill <entity: target> [<tool>|mainhand|offhand]  Example:  /loot replace block 0 0 0 slot.container 0 1 kill @e[type=blaze]  This will fill the target container slots 0 through 1 with items that would be dropped if the blaze was killed by a player. The count parameter works the same for the kill source variation as it does for the loot source variation.  mine  Using the mine variation specifies that the user wants to simulate mining a specific block in the world and use it's loot table as the source for the loot to be dropped.  The target block must be present and loaded within the world or the command will return an error saying that blocks outside the world cannot be accessed.  /loot replace block <position: x y z> slot.container <slotId: int> [<count: int>] mine <position: x y z> [<tool>|mainhand|offhand]  Example:  /loot replace block 0 0 0 slot.container 0 1 mine 0 0 0 Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/loottableconditions?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Loot Table Conditions 04/30/2025  Conditions are a list of requirements that must be met before a pool can be used or an individual entry can be selected. All conditions are stored within the conditions list, and each condition runs one at a time. If any one condition in the list fails, the remaining conditions in the list will be ignored.  has_mark_variant  has_mark_variant specifies that there are different variations for the loot.  An example of this are the marked variants for which suspicious stew you might get from a mooshroom.  Example:  JSON Copy {   \"conditions\": [     {       \"condition\": \"has_mark_variant\",       \"value\": 7     }   ],   \"rolls\": 1,   \"entries\": [     {       \"type\": \"item\",       \"name\": \"minecraft:suspicious_stew\",       \"weight\": 1,       \"functions\": [         {           \"function\": \"set_data\",           \"data\": 7         }       ]     }   ] }  has_variant  has_variant specifies that there are different variations for the loot.  An example of this is when a frog kills a magma cube and drops either a verdant, ochre, or pearlescent froglight.  Example:  JSON Copy {   \"rolls\": 1,   \"entries\": [     {       \"type\": \"item\",       \"name\": \"minecraft:pearlescent_froglight\",        \"weight\": 1      }    ],    \"conditions\": [      {        \"condition\": \"has_variant\",        \"value\": 2      },      {        \"condition\": \"entity_killed\",        \"entity_type\": \"minecraft:magma_cube\"      }    ] }  killed_by_player_or_pets  The killed_by_player_or_petscondition can supply another way to customize a loot drop, depending on how the entity was killed. For example, if you make your pet wolf takes down a drowned zombie for you, then that entity's loot table takes that into consideration.  Example:  JSON Copy  \"conditions\": [     {       \"condition\": \"killed_by_player_or_pets\"     },  ]  random_chance  random_chance is a condition that applies a given value to the chances that loot will drop.  Example:  JSON Copy \"conditions\": [     {         \"condition\": \"random_chance\",         \"chance\": 0.2     } ]  random_chance_with_looting  The random_chance_with_looting condition is similar to the random_chance condition, but also includes a multiplier value.  The looting enchantment results in more dropped items from entities, like getting two or more raw chickens when you kill one chicken.  Example:  JSON Copy \"conditions\": [     {         \"condition\": \"killed_by_player\"     },     {         \"condition\": \"random_chance_with_looting\",         \"chance\": 0.11,         \"looting_multiplier\": 0.02     } ]  random_difficulty_chance  random_difficulty_chance is a condition that can control loot drops depending on the difficulty level.  Example:  JSON Copy \"conditions\": [     {         \"condition\": \"random_difficulty_chance\",         \"default_chance\": 0.5,         \"peaceful\": 0,         \"hard\": 0.6     } ],   random_regional_difficulty_chance  random_regional_difficulty_chance determines loot probability according to the region.  Example:  JSON Copy \"conditions\": [         {           \"condition\": \"random_regional_difficulty_chance\",           \"max_chance\": 0.15         }       ]   match_tool  match_tool checks whether the tool (or weapon/item the player is using) used to make the loot drop matches the modifier conditions provided.  The predicates used are: count, durability, enchantments, and item. match_tool also supports matching by item tag (including custom tags), which can be achieved using any combination of: minecraft:match_tool_filter_any, minecraft:match_tool_filter_all, and minecraft:match_tool_filter_none.  count: amount of the item range_max: the maximum value range_min: the minimum value durability: the durability of the item range_max: the maximum value range_min: the minimum value enchantments: list of enchantments enchantment: an enchantment ID levels: the level of the enchantment range_max: the maximum value range_min: the minimum value item: an item ID minecraft:match_tool_filter_any: list of item tags minecraft:match_tool_filter_all: list of item tags minecraft:match_tool_filter_none: list of item tags  Example:  JSON Copy  \"conditions\": [               {                 \"condition\": \"match_tool\",                 \"enchantments\": [                   {                     \"enchantment\": \"sharpness\",                     \"levels\": {                       \"range_max\": 6                     }                   }                 ],                 \"item\": \"minecraft:diamond_sword\",                 \"count\": 1,                 \"durability\": {                   \"range_min\": 1                 }               }             ]     Example 2 (Item tags):  JSON Copy \"conditions\": [               {               \"condition\": \"match_tool\",               \"minecraft:match_tool_filter_any\": [                 \"minecraft:iron_tier\",                 \"minecraft:golden_tier\",                 \"minecraft:diamond_tier\"               ],               \"minecraft:match_tool_filter_all\": [                 \"minecraft:is_tool\"               ],               \"minecraft:match_tool_filter_none\": [                 \"minecraft:is_shovel\"               ]             }           ]   This will match any tool that is iron, golden or diamond tier, except for shovels.  Pool conditions  Applying a condition to a pool allows you execute the entire pool based on the conditions defined.  The below example will only trigger if the entity calling it was killed by a skeleton resulting in either a diamond or piece of coal.  JSON Copy \"pools\": [     {         \"conditions\": [             {                 \"condition\": \"killed_by_entity\",                 \"entity_type\": \"minecraft:skeleton\"             }         ],         \"rolls\": 1,         \"entries\": [             {                 \"type\": \"item\",                 \"name\": \"minecraft:diamond\",                 \"weight\": 1             },             {                 \"type\": \"item\",                 \"name\": \"minecraft:coal\",                 \"weight\": 1             }         ]     } ]  Entry conditions  You can also apply conditions to specific entries within the roll. The following example will only return a diamond 50% of the time if the entity that called it was killed by the player. All other times it's called, it will return coal.  JSON Copy \"pools\": [     {         \"rolls\": 1,         \"entries\": [             {                 \"type\": \"item\",                 \"name\": \"minecraft:diamond\",                 \"weight\": 1,                 \"conditions\": [                     {                         \"condition\": \"killed_by_player\"                     }                 ]             },             {                 \"type\": \"item\",                 \"name\": \"minecraft:coal\",                 \"weight\": 1             }         ]     } ]   Exploring the different loot and trade table functions can allow creators to further customize the player experience.  From naming items and giving them lore to dropping resource crates full of supplies, or even creating written books for instructions or information, the possibilities truly are staggering!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/loottableconditions?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Loot Table Conditions 04/30/2025  Conditions are a list of requirements that must be met before a pool can be used or an individual entry can be selected. All conditions are stored within the conditions list, and each condition runs one at a time. If any one condition in the list fails, the remaining conditions in the list will be ignored.  has_mark_variant  has_mark_variant specifies that there are different variations for the loot.  An example of this are the marked variants for which suspicious stew you might get from a mooshroom.  Example:  JSON Copy {   \"conditions\": [     {       \"condition\": \"has_mark_variant\",       \"value\": 7     }   ],   \"rolls\": 1,   \"entries\": [     {       \"type\": \"item\",       \"name\": \"minecraft:suspicious_stew\",       \"weight\": 1,       \"functions\": [         {           \"function\": \"set_data\",           \"data\": 7         }       ]     }   ] }  has_variant  has_variant specifies that there are different variations for the loot.  An example of this is when a frog kills a magma cube and drops either a verdant, ochre, or pearlescent froglight.  Example:  JSON Copy {   \"rolls\": 1,   \"entries\": [     {       \"type\": \"item\",       \"name\": \"minecraft:pearlescent_froglight\",        \"weight\": 1      }    ],    \"conditions\": [      {        \"condition\": \"has_variant\",        \"value\": 2      },      {        \"condition\": \"entity_killed\",        \"entity_type\": \"minecraft:magma_cube\"      }    ] }  killed_by_player_or_pets  The killed_by_player_or_petscondition can supply another way to customize a loot drop, depending on how the entity was killed. For example, if you make your pet wolf takes down a drowned zombie for you, then that entity's loot table takes that into consideration.  Example:  JSON Copy  \"conditions\": [     {       \"condition\": \"killed_by_player_or_pets\"     },  ]  random_chance  random_chance is a condition that applies a given value to the chances that loot will drop.  Example:  JSON Copy \"conditions\": [     {         \"condition\": \"random_chance\",         \"chance\": 0.2     } ]  random_chance_with_looting  The random_chance_with_looting condition is similar to the random_chance condition, but also includes a multiplier value.  The looting enchantment results in more dropped items from entities, like getting two or more raw chickens when you kill one chicken.  Example:  JSON Copy \"conditions\": [     {         \"condition\": \"killed_by_player\"     },     {         \"condition\": \"random_chance_with_looting\",         \"chance\": 0.11,         \"looting_multiplier\": 0.02     } ]  random_difficulty_chance  random_difficulty_chance is a condition that can control loot drops depending on the difficulty level.  Example:  JSON Copy \"conditions\": [     {         \"condition\": \"random_difficulty_chance\",         \"default_chance\": 0.5,         \"peaceful\": 0,         \"hard\": 0.6     } ],   random_regional_difficulty_chance  random_regional_difficulty_chance determines loot probability according to the region.  Example:  JSON Copy \"conditions\": [         {           \"condition\": \"random_regional_difficulty_chance\",           \"max_chance\": 0.15         }       ]   match_tool  match_tool checks whether the tool (or weapon/item the player is using) used to make the loot drop matches the modifier conditions provided.  The predicates used are: count, durability, enchantments, and item. match_tool also supports matching by item tag (including custom tags), which can be achieved using any combination of: minecraft:match_tool_filter_any, minecraft:match_tool_filter_all, and minecraft:match_tool_filter_none.  count: amount of the item range_max: the maximum value range_min: the minimum value durability: the durability of the item range_max: the maximum value range_min: the minimum value enchantments: list of enchantments enchantment: an enchantment ID levels: the level of the enchantment range_max: the maximum value range_min: the minimum value item: an item ID minecraft:match_tool_filter_any: list of item tags minecraft:match_tool_filter_all: list of item tags minecraft:match_tool_filter_none: list of item tags  Example:  JSON Copy  \"conditions\": [               {                 \"condition\": \"match_tool\",                 \"enchantments\": [                   {                     \"enchantment\": \"sharpness\",                     \"levels\": {                       \"range_max\": 6                     }                   }                 ],                 \"item\": \"minecraft:diamond_sword\",                 \"count\": 1,                 \"durability\": {                   \"range_min\": 1                 }               }             ]     Example 2 (Item tags):  JSON Copy \"conditions\": [               {               \"condition\": \"match_tool\",               \"minecraft:match_tool_filter_any\": [                 \"minecraft:iron_tier\",                 \"minecraft:golden_tier\",                 \"minecraft:diamond_tier\"               ],               \"minecraft:match_tool_filter_all\": [                 \"minecraft:is_tool\"               ],               \"minecraft:match_tool_filter_none\": [                 \"minecraft:is_shovel\"               ]             }           ]   This will match any tool that is iron, golden or diamond tier, except for shovels.  Pool conditions  Applying a condition to a pool allows you execute the entire pool based on the conditions defined.  The below example will only trigger if the entity calling it was killed by a skeleton resulting in either a diamond or piece of coal.  JSON Copy \"pools\": [     {         \"conditions\": [             {                 \"condition\": \"killed_by_entity\",                 \"entity_type\": \"minecraft:skeleton\"             }         ],         \"rolls\": 1,         \"entries\": [             {                 \"type\": \"item\",                 \"name\": \"minecraft:diamond\",                 \"weight\": 1             },             {                 \"type\": \"item\",                 \"name\": \"minecraft:coal\",                 \"weight\": 1             }         ]     } ]  Entry conditions  You can also apply conditions to specific entries within the roll. The following example will only return a diamond 50% of the time if the entity that called it was killed by the player. All other times it's called, it will return coal.  JSON Copy \"pools\": [     {         \"rolls\": 1,         \"entries\": [             {                 \"type\": \"item\",                 \"name\": \"minecraft:diamond\",                 \"weight\": 1,                 \"conditions\": [                     {                         \"condition\": \"killed_by_player\"                     }                 ]             },             {                 \"type\": \"item\",                 \"name\": \"minecraft:coal\",                 \"weight\": 1             }         ]     } ]   Exploring the different loot and trade table functions can allow creators to further customize the player experience.  From naming items and giving them lore to dropping resource crates full of supplies, or even creating written books for instructions or information, the possibilities truly are staggering!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontostructureblocks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontostructureblocks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/StructureBlocksCommandTutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structures/StructureBlocksCommandTutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entitymodelingandanimation?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Modeling and Animation 04/16/2025  In this guide, we'll go through the basics of creating a model and animations for Minecraft: Bedrock Edition. As an example, we'll model and animate a small robot, which was started in the Introduction to Add Entity article.  In this tutorial you will learn the following:  How to create a model for an entity using Blockbench. How to apply textures and animations to a model. Requirements  It's recommended that the following be completed before beginning this tutorial.  Creating New Entity Types Model  Models in Minecraft use a specific format that uses JSON to define the shape. Each model uses a texture that can be assigned through render controllers.  To create the model and texture, we're going to use Blockbench, a 3D modeling program that can create models for the Bedrock Edition of Minecraft.   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering. Users should use at their own discretion.  Setting Up the Model  When you first open Blockbench, you'll see a list of available model formats. Select Bedrock Model. You'll see a dialog about the basic settings for the project.  The important part is Mob Geometry Name. Here, we'll enter a unique name for the model. The best practice is to use snake_case — so only lower case letters, numbers and underscores as well as dots. Spaces and other special characters aren't supported. For our model, we'll just input robot.  We can leave the field for the file name empty for now as we'll later define it when we export the model. The Box UV setting and the texture size can also be left at default because we'll change them later. The confirm button will save these settings.  Bone Structure  The first thing to consider when making a model is the bone structure. Bones are the part of the model that can be animated, and they can be arranged in an arbitrarily deep hierarchy. Each bone itself is invisible but can contain cubes that will shape the model.  A good practice is to use a root bone for each model and put everything else inside it. This means that you'll later be able to animate the entire model at once, as well as specific parts of it. Create a new group in Blockbench. \"Groups\" and \"Bones\" are essentially the same in this context.  You can right-click the group or press F2 to rename it. The name for a bone should be snake_case (so only including lower case letters, numbers, and underscores). Each bone name has to be unique for future reference through animations.  While we build up the model in the following steps, make sure the structure is set up correctly. You can drag around groups to change the order or drop them into other groups. This screenshot shows the correct bone structure of the finished model.  Shape  You can now start to create the shape of the model. Create new cubes and use the move, resize, and rotation tools to adjust it. A trick to add cubes faster is to select an already positioned cube and press Ctrl + D (duplicate) to get a copy.  You can move cubes more precisely by holding either shift, control, or both at the same time. Depending on the modeling style, it can make sense to completely stick to the grid or only move the cubes in half or quarter increments.  Bedrock Edition models use Box UV mapping by default. That means that the texture mapping will only use full numbers and will round down to a smaller number if necessary. To avoid stretched or invisible faces, make sure the size of cubes sticks to full numbers.  If you're working on symmetrical parts like limbs, create them on the right-hand side first and mirror them to the left later. You can either mirror them before or after creating the texture depending on whether you want the same texture on both sides.  When you're creating bones for moving parts of the model, always think about which point the part should rotate around. Select a bone and press P to get the Pivot tool. This tool allows you to move the pivot point of the bone. You can also use this tool on cubes if you want to rotate those around a specific point.  Texturing Templates  Once the shape of the model is done, you can create a texture template. The template is a texture that has a unique space for every cube and every face of the model. You can also UV map cubes manually, but creating a template does the work for you and finds the most space-efficient layout. Remember that Minecraft doesn't like high-resolution images.  When creating a texture, enter robot as the texture name and check the Template option. In the template dialog, select your resolution. 16x is the default resolution of Minecraft, but you can go higher if you want.  Base Color  Once the template is created, you can move to the Paint tab in Blockbench. This will reveal all the tools you have to modify the texture. Select the Paint Bucket tool and set the fill mode next to the tool to Cube. Select a color in the color panel on the right side. Now you can go over your cubes and color them in individual base colors.  Details  You can now start to work on the texture. If you're more comfortable with texturing in your image editing program, you can now save the texture by clicking on the save icon next to the texture. Then, you can open it in your image editor. Any changes will appear in Blockbench as soon as you save the texture. But, if you prefer to work directly on the model, you can use the built-in paint tools in Blockbench.  There are a few tricks to use the paintbrush in Blockbench more efficiently:  To paint larger areas, you can increase the brush size. You can paint directly in the 3D preview, or you can paint it in the UV editor on the left side. If you want to create a straight line, click on the beginning of the line, then hold shift on the end of the line. To make sure you don't miss covered spots that might be revealed through animations, you can hide cubes. Just click on the eye icon in the outliner. Animations  Animations can animate the shape of your model, but they can also play sounds and particle effects. In the following section, we'll take a look at how to add an animation to your entity, how to create your own animation in Blockbench, and finally, how to use animation controllers.  Using Default Animations  The vanilla resource pack contains generic animations that you can reference in your own pack without actually copying the files. These animations can be a good starting point for vanilla-like entities, but of course, custom animations are a lot more powerful. You can find all vanilla animations in the vanilla resource pack here.  In this example, we'll be using the look at animation. This animation will rotate the \"head\" bone. That's why it's important that the head of the model uses the exact same name.  Also, the entity will need a look at component in its behavior file. These are the looking components from the cow. You can play around with the numbers if you like.  JSON Copy   \"minecraft:behavior.look_at_player\": {     \"priority\": 7,     \"look_distance\": 6,     \"probability\": 0.02   },   \"minecraft:behavior.random_look_around\": {     \"priority\": 9   }   Now that the behavior is set up, we'll head to the client entity file. Make sure that the format version for this file is set to 1.10.0 or higher for this to work.  First, let's link the animation. This is done in the animations section in the description tag of the entity. The second part here (animation.common.look_at_target) is the global identifier of the animation. This name is defined in the animation file and is valid anywhere in this pack or any other pack. The first part (look_at_target) is the short name. This is how we reference the animation within the entity file, and it's only valid in the scope of this entity.  JSON Copy   \"animations\": {     \"look_at_target\": \"animation.common.look_at_target\"   }   Now, we need to play the animation. For simple animations that are always active while the entity exists, this is as simple as listing the short name in the scripts/animate array in the client entity file.  JSON Copy   \"scripts\": {     \"animate\": [\"look_at_target\"]   }   If you now test the robot in-game, you'll see that it will turn its head and look around.  Creating an Animation  In the guide to creating new entity types, we created a small driving animation for the robot. Let's now create an animation that plays when the robot loses the ground under its feet (wheel). Before creating an animation, always check if there's a way to trigger it. We can easily trigger a lose-balance animation for this because we can just use the Molang query query.is_on_ground to test when the robot no longer touches the ground.  Simple animations can be created in the text editor, but for more complex, keyframe-based animations, Blockbench makes this easier. Open the model and switch to the Animate tab in the top-right corner. Create a new animation in the Animations panel on the left side and name it animation.robot.sway. You can also choose a longer name or include a namespace to ensure compatibility with other addons. But please keep in mind that animation identifiers only support snake_case, strings and dots, but not colons or dashes.  Once you have set up the animation, you can start animating. Select the root bone of your entity. Move your time cursor in the timeline to 0 seconds and click the plus icon next to Rotation. This will create a new keyframe at the new position. Now move the cursor to about 0.2 seconds. Select the rotate tool and rotate the whole robot to the left slightly. This will automatically generate a new keyframe. On the left side of the screen, you can see the values. Rotate it to about 10 degrees.  Now move forward in time to about half a second and rotate the root bone to the other side. Finally, move to 1 second and rotate it back to 0.  If you now move the cursor to the beginning and press play, you'll see a short sway animation. Now that you know how to animate, you can refine the animation and, for example, let the antenna swing a bit.  Finally, press Ctrl + S to save the model and animation. Save the animation in the animations folder of the resource pack as robot.animation.json.  Now reference and play the animation in the client entity file as we've done with the look at animation. But now we'll only play the sway animation under the condition that the robot isn't on ground. This will look something like this:  JSON Copy   \"animations\": {       \"look_at_target\": \"animation.common.look_at_target\",       \"sway\": \"animation.robot.sway\"   },   \"scripts\": {     \"animate\": [       \"look_at_target\",       {\"sway\":\"!query.is_on_ground\"}     ]   }   If you now spawn a robot and push it down an edge, the animation will play. But it will only play once.  The reason for that is the fact that the query in the scripts section is only a blend value for the animation. It defines \"how much\" the animation plays, not when it plays and when it doesn't. That's why the animation will start playing once !query.is_on_ground is true/1, but it will never stop playing. It will just fade out once the value is false/0 again, and the next time it will fade into the animation again. It won't play from the start again.  We can use this behavior quite well for static or looping animations that have no beginning and no end. But if we want to start the animation every time the query changes, we need a different approach. This is where animation controllers come in.  Animation Controllers  Animation controllers work with states. An animation controller can have an unlimited number of states. Only one of these states is active at a time. The controller can transition to other states through Molang expressions. Each state can play a distinct set of animations, sounds, and particle effects.  Each time the entity is loaded by the client, for example, when joining a world, the animation controller starts in an initial state. This state is called default by default.  To set up the animation controller, create a new folder in the resource pack called animation_controllers. Inside the folder, create a new file called robot.animation_controllers.json. Create an animation controller like this:  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {     \"controller.animation.robot.ground\": {}   } }   Now, we need to create an initial state. This state is called default by default. The animation controller will always start in this state when the entity is loaded. For example, after rejoining the world.  The only job of this state is to transition to the swaying state once the entity is no longer on the ground. We'll use a transition for this. The controller will switch to that state as soon as the query.is_on_ground query is no longer true.  JSON Copy {   \"format_version\": \"1.10.0\",     \"animation_controllers\": {       \"controller.animation.robot.ground\": {         \"states\": {           \"default\": {             \"transitions\":[                {\"swaying\": \"!query.is_on_ground\"}             ]          }         }     }   } }   Now, we'll add the swaying state. This state will play the swaying animation and after that, reset the controller by going back to the default state. We can use the query query.all_animations_finished to only transition after the animation has played. This query will only return true once all animations of the current state have finished playing. In addition, we will test if the entity is on the ground again.  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {       \"controller.animation.robot.ground\": {         \"states\": {           \"default\": {              \"transitions\":[                 {\"swaying\": \"!query.is_on_ground\"}               ]           },           \"swaying\": {             \"animations\":[               \"sway\"             ],             \"transitions\":[               {\"default\": \"query.all_animations_finished && query.is_on_ground\"}             ]           }         }       }   } }   Now we need to link the animation controller to our entity. Animation controllers can be linked the same way as animations in the client entity file. The controller is linked in the animations section and played in scripts.  JSON Copy   \"animations\": {     \"look_at_target\": \"animation.common.look_at_target\",     \"sway\": \"animation.robot.sway\",     \"ground\": \"controller.animation.robot.ground\"   },   \"scripts\": {     \"animate\": [       \"look_at_target\",       \"ground\"     ]   }   If you test this in-game, the animation now works more than once. But, depending on the length of your animation, you might notice that if the robot loses the ground two times with a short interval, the second time it won't play the animation. That's because the first animation hasn't finished yet, so the controller hasn't been reset to the default state.  We'll take a look at a different solution that would solve this problem. By removing the all_animations_finished query, we'll quit the swaying state as soon as the entity lands again. If we test this again, the animation will stop very abruptly.  To prevent this, we can use the option blend_transition, which allows us to smoothly transition out of the animation in a set time. This is one of the most important properties of animation controllers and even allows us to create a simple transition between two fixed poses of an entity.  Ultimately, which solution is best depends on the use case. In this example, the animation fades out smoothly once the robot lands on the ground again.  JSON Copy   \"swaying\": {     \"animations\":[       \"sway\"     ],     \"transitions\":[       {\"default\": \"query.is_on_ground\"}     ],     \"blend_transition\":0.5   }  What's Next?  We've now learned how to create a model that's ready for animations and how to texture it. We've also linked an existing animation to the model and created our own animation in Blockbench.  If you want to add more functionality beyond the looks of the entity, then check out the tutorial on entity behaviors.  Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/entitymodelingandanimation?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Modeling and Animation 04/16/2025  In this guide, we'll go through the basics of creating a model and animations for Minecraft: Bedrock Edition. As an example, we'll model and animate a small robot, which was started in the Introduction to Add Entity article.  In this tutorial you will learn the following:  How to create a model for an entity using Blockbench. How to apply textures and animations to a model. Requirements  It's recommended that the following be completed before beginning this tutorial.  Creating New Entity Types Model  Models in Minecraft use a specific format that uses JSON to define the shape. Each model uses a texture that can be assigned through render controllers.  To create the model and texture, we're going to use Blockbench, a 3D modeling program that can create models for the Bedrock Edition of Minecraft.   Important  Blockbench is provided by external, third-party contributors and is not a Mojang/Microsoft offering. Users should use at their own discretion.  Setting Up the Model  When you first open Blockbench, you'll see a list of available model formats. Select Bedrock Model. You'll see a dialog about the basic settings for the project.  The important part is Mob Geometry Name. Here, we'll enter a unique name for the model. The best practice is to use snake_case — so only lower case letters, numbers and underscores as well as dots. Spaces and other special characters aren't supported. For our model, we'll just input robot.  We can leave the field for the file name empty for now as we'll later define it when we export the model. The Box UV setting and the texture size can also be left at default because we'll change them later. The confirm button will save these settings.  Bone Structure  The first thing to consider when making a model is the bone structure. Bones are the part of the model that can be animated, and they can be arranged in an arbitrarily deep hierarchy. Each bone itself is invisible but can contain cubes that will shape the model.  A good practice is to use a root bone for each model and put everything else inside it. This means that you'll later be able to animate the entire model at once, as well as specific parts of it. Create a new group in Blockbench. \"Groups\" and \"Bones\" are essentially the same in this context.  You can right-click the group or press F2 to rename it. The name for a bone should be snake_case (so only including lower case letters, numbers, and underscores). Each bone name has to be unique for future reference through animations.  While we build up the model in the following steps, make sure the structure is set up correctly. You can drag around groups to change the order or drop them into other groups. This screenshot shows the correct bone structure of the finished model.  Shape  You can now start to create the shape of the model. Create new cubes and use the move, resize, and rotation tools to adjust it. A trick to add cubes faster is to select an already positioned cube and press Ctrl + D (duplicate) to get a copy.  You can move cubes more precisely by holding either shift, control, or both at the same time. Depending on the modeling style, it can make sense to completely stick to the grid or only move the cubes in half or quarter increments.  Bedrock Edition models use Box UV mapping by default. That means that the texture mapping will only use full numbers and will round down to a smaller number if necessary. To avoid stretched or invisible faces, make sure the size of cubes sticks to full numbers.  If you're working on symmetrical parts like limbs, create them on the right-hand side first and mirror them to the left later. You can either mirror them before or after creating the texture depending on whether you want the same texture on both sides.  When you're creating bones for moving parts of the model, always think about which point the part should rotate around. Select a bone and press P to get the Pivot tool. This tool allows you to move the pivot point of the bone. You can also use this tool on cubes if you want to rotate those around a specific point.  Texturing Templates  Once the shape of the model is done, you can create a texture template. The template is a texture that has a unique space for every cube and every face of the model. You can also UV map cubes manually, but creating a template does the work for you and finds the most space-efficient layout. Remember that Minecraft doesn't like high-resolution images.  When creating a texture, enter robot as the texture name and check the Template option. In the template dialog, select your resolution. 16x is the default resolution of Minecraft, but you can go higher if you want.  Base Color  Once the template is created, you can move to the Paint tab in Blockbench. This will reveal all the tools you have to modify the texture. Select the Paint Bucket tool and set the fill mode next to the tool to Cube. Select a color in the color panel on the right side. Now you can go over your cubes and color them in individual base colors.  Details  You can now start to work on the texture. If you're more comfortable with texturing in your image editing program, you can now save the texture by clicking on the save icon next to the texture. Then, you can open it in your image editor. Any changes will appear in Blockbench as soon as you save the texture. But, if you prefer to work directly on the model, you can use the built-in paint tools in Blockbench.  There are a few tricks to use the paintbrush in Blockbench more efficiently:  To paint larger areas, you can increase the brush size. You can paint directly in the 3D preview, or you can paint it in the UV editor on the left side. If you want to create a straight line, click on the beginning of the line, then hold shift on the end of the line. To make sure you don't miss covered spots that might be revealed through animations, you can hide cubes. Just click on the eye icon in the outliner. Animations  Animations can animate the shape of your model, but they can also play sounds and particle effects. In the following section, we'll take a look at how to add an animation to your entity, how to create your own animation in Blockbench, and finally, how to use animation controllers.  Using Default Animations  The vanilla resource pack contains generic animations that you can reference in your own pack without actually copying the files. These animations can be a good starting point for vanilla-like entities, but of course, custom animations are a lot more powerful. You can find all vanilla animations in the vanilla resource pack here.  In this example, we'll be using the look at animation. This animation will rotate the \"head\" bone. That's why it's important that the head of the model uses the exact same name.  Also, the entity will need a look at component in its behavior file. These are the looking components from the cow. You can play around with the numbers if you like.  JSON Copy   \"minecraft:behavior.look_at_player\": {     \"priority\": 7,     \"look_distance\": 6,     \"probability\": 0.02   },   \"minecraft:behavior.random_look_around\": {     \"priority\": 9   }   Now that the behavior is set up, we'll head to the client entity file. Make sure that the format version for this file is set to 1.10.0 or higher for this to work.  First, let's link the animation. This is done in the animations section in the description tag of the entity. The second part here (animation.common.look_at_target) is the global identifier of the animation. This name is defined in the animation file and is valid anywhere in this pack or any other pack. The first part (look_at_target) is the short name. This is how we reference the animation within the entity file, and it's only valid in the scope of this entity.  JSON Copy   \"animations\": {     \"look_at_target\": \"animation.common.look_at_target\"   }   Now, we need to play the animation. For simple animations that are always active while the entity exists, this is as simple as listing the short name in the scripts/animate array in the client entity file.  JSON Copy   \"scripts\": {     \"animate\": [\"look_at_target\"]   }   If you now test the robot in-game, you'll see that it will turn its head and look around.  Creating an Animation  In the guide to creating new entity types, we created a small driving animation for the robot. Let's now create an animation that plays when the robot loses the ground under its feet (wheel). Before creating an animation, always check if there's a way to trigger it. We can easily trigger a lose-balance animation for this because we can just use the Molang query query.is_on_ground to test when the robot no longer touches the ground.  Simple animations can be created in the text editor, but for more complex, keyframe-based animations, Blockbench makes this easier. Open the model and switch to the Animate tab in the top-right corner. Create a new animation in the Animations panel on the left side and name it animation.robot.sway. You can also choose a longer name or include a namespace to ensure compatibility with other addons. But please keep in mind that animation identifiers only support snake_case, strings and dots, but not colons or dashes.  Once you have set up the animation, you can start animating. Select the root bone of your entity. Move your time cursor in the timeline to 0 seconds and click the plus icon next to Rotation. This will create a new keyframe at the new position. Now move the cursor to about 0.2 seconds. Select the rotate tool and rotate the whole robot to the left slightly. This will automatically generate a new keyframe. On the left side of the screen, you can see the values. Rotate it to about 10 degrees.  Now move forward in time to about half a second and rotate the root bone to the other side. Finally, move to 1 second and rotate it back to 0.  If you now move the cursor to the beginning and press play, you'll see a short sway animation. Now that you know how to animate, you can refine the animation and, for example, let the antenna swing a bit.  Finally, press Ctrl + S to save the model and animation. Save the animation in the animations folder of the resource pack as robot.animation.json.  Now reference and play the animation in the client entity file as we've done with the look at animation. But now we'll only play the sway animation under the condition that the robot isn't on ground. This will look something like this:  JSON Copy   \"animations\": {       \"look_at_target\": \"animation.common.look_at_target\",       \"sway\": \"animation.robot.sway\"   },   \"scripts\": {     \"animate\": [       \"look_at_target\",       {\"sway\":\"!query.is_on_ground\"}     ]   }   If you now spawn a robot and push it down an edge, the animation will play. But it will only play once.  The reason for that is the fact that the query in the scripts section is only a blend value for the animation. It defines \"how much\" the animation plays, not when it plays and when it doesn't. That's why the animation will start playing once !query.is_on_ground is true/1, but it will never stop playing. It will just fade out once the value is false/0 again, and the next time it will fade into the animation again. It won't play from the start again.  We can use this behavior quite well for static or looping animations that have no beginning and no end. But if we want to start the animation every time the query changes, we need a different approach. This is where animation controllers come in.  Animation Controllers  Animation controllers work with states. An animation controller can have an unlimited number of states. Only one of these states is active at a time. The controller can transition to other states through Molang expressions. Each state can play a distinct set of animations, sounds, and particle effects.  Each time the entity is loaded by the client, for example, when joining a world, the animation controller starts in an initial state. This state is called default by default.  To set up the animation controller, create a new folder in the resource pack called animation_controllers. Inside the folder, create a new file called robot.animation_controllers.json. Create an animation controller like this:  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {     \"controller.animation.robot.ground\": {}   } }   Now, we need to create an initial state. This state is called default by default. The animation controller will always start in this state when the entity is loaded. For example, after rejoining the world.  The only job of this state is to transition to the swaying state once the entity is no longer on the ground. We'll use a transition for this. The controller will switch to that state as soon as the query.is_on_ground query is no longer true.  JSON Copy {   \"format_version\": \"1.10.0\",     \"animation_controllers\": {       \"controller.animation.robot.ground\": {         \"states\": {           \"default\": {             \"transitions\":[                {\"swaying\": \"!query.is_on_ground\"}             ]          }         }     }   } }   Now, we'll add the swaying state. This state will play the swaying animation and after that, reset the controller by going back to the default state. We can use the query query.all_animations_finished to only transition after the animation has played. This query will only return true once all animations of the current state have finished playing. In addition, we will test if the entity is on the ground again.  JSON Copy {   \"format_version\": \"1.10.0\",   \"animation_controllers\": {       \"controller.animation.robot.ground\": {         \"states\": {           \"default\": {              \"transitions\":[                 {\"swaying\": \"!query.is_on_ground\"}               ]           },           \"swaying\": {             \"animations\":[               \"sway\"             ],             \"transitions\":[               {\"default\": \"query.all_animations_finished && query.is_on_ground\"}             ]           }         }       }   } }   Now we need to link the animation controller to our entity. Animation controllers can be linked the same way as animations in the client entity file. The controller is linked in the animations section and played in scripts.  JSON Copy   \"animations\": {     \"look_at_target\": \"animation.common.look_at_target\",     \"sway\": \"animation.robot.sway\",     \"ground\": \"controller.animation.robot.ground\"   },   \"scripts\": {     \"animate\": [       \"look_at_target\",       \"ground\"     ]   }   If you test this in-game, the animation now works more than once. But, depending on the length of your animation, you might notice that if the robot loses the ground two times with a short interval, the second time it won't play the animation. That's because the first animation hasn't finished yet, so the controller hasn't been reset to the default state.  We'll take a look at a different solution that would solve this problem. By removing the all_animations_finished query, we'll quit the swaying state as soon as the entity lands again. If we test this again, the animation will stop very abruptly.  To prevent this, we can use the option blend_transition, which allows us to smoothly transition out of the animation in a set time. This is one of the most important properties of animation controllers and even allows us to create a simple transition between two fixed poses of an entity.  Ultimately, which solution is best depends on the use case. In this example, the animation fades out smoothly once the robot lands on the ground again.  JSON Copy   \"swaying\": {     \"animations\":[       \"sway\"     ],     \"transitions\":[       {\"default\": \"query.is_on_ground\"}     ],     \"blend_transition\":0.5   }  What's Next?  We've now learned how to create a model that's ready for animations and how to texture it. We've also linked an existing animation to the model and created our own animation in Blockbench.  If you want to add more functionality beyond the looks of the entity, then check out the tutorial on entity behaviors.  Entity Behavior Introduction  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationsoverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Getting Started 02/22/2025 Overview of Animations in Minecraft: Bedrock Edition  Animation follows the current Minecraft JSON paradigms:  Fields should be lower-case and use underscores (no spaces). All JSON files in the definitions directory and subtree will be read into and interpreted by the animation system. Entity Definition  In order to define what animations an entity has, both an animations and a scripts/animate section must be added to the entity definition file.  Animations are specified as a short name, followed by their full resource name. The short name is used in animation controllers and the scripts/animate list, while the long name is used in the animations file.  In the scripts/animate section, list the animations to play and in which order. A blend expression may be specified, or an animation may be specified directly.  Entity Definition Example JSON Copy {   \"format_version\": \"1.10.0\",   \"minecraft:client_entity\": {     \"description\": {       \"identifier\": \"minecraft:pig\",       \"min_engine_version\": \"1.8.0\",       \"materials\": { \"default\": \"pig\" },       \"textures\": {         \"default\": \"textures/entity/pig/pig\",         \"saddled\": \"textures/entity/pig/pig_saddle\"       },       \"geometry\": {         \"default\": \"geometry.pig.v1.8\"       },       \"animations\": {         \"setup\": \"animation.pig.setup\",         \"walk\": \"animation.quadruped.walk\",         \"look_at_target\": \"animation.common.look_at_target\",         \"baby_transform\": \"animation.pig.baby_transform\"       },       \"scripts\": {         \"animate\": [           \"setup\",           { \"walk\": \"query.modified_move_speed\" },           \"look_at_target\",           { \"baby_transform\": \"query.is_baby\" }         ]       },       \"render_controllers\": [ \"controller.render.pig\" ],       \"spawn_egg\": {         \"texture\": \"spawn_egg\",         \"texture_index\": 2       }     }   } }  Animation Hierarchy  Animations are channel based (rotation, position, or scale), and within that are key-framed:  Copy EntityAnimation: animation name   BoneAnimation[]: bone name for this animation     AnimationChannel[]: rotation, scale, or translation to animate       KeyFrame[]: the value for the channel to have at a specific time  Animation Controller  Controlling how and when animations are played, and how they interact with other animations, is incredibly important. While many items can be managed in the entity definition scripts/animate section, animation controllers provide the functionality of a state machine into states, and allow the user to control them as a block. Animations in an animation controller state can be animation controllers themselves, allowing for complex animation hierarchies.  Example of Animation Controller JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.my_mob.move\": {       \"initial_state\": \"moving\",       \"states\": {         \"moving\": {           \"animations\": [             \"wag_tail\",             \"wiggle_ears\",             { \"walk\": \"query.modified_move_speed\" }           ],           \"transitions\": [             { \"grazing\": \"query.is_grazing\" }           ]         },         \"grazing\": {           \"animations\": [ \"grazing\" ],           \"transitions\": [             { \"moving\": \"query.all_animations_finished\" }           ]         }       }     }   } }   To learn more about Animation Controllers, please visit the Animation Controllers reference page.  Animations  At the beginning of each frame, the skeleton is reset to its default pose from its geometry definition and then animations are applied per-channel additively in order. Please note that the channels (x, y, and z) are added separately across animations first! They are then converted to a transform once all animations have been cumulatively applied.  Animation data can be either raw data:  JSON Copy \"rotation\": [90.0, 0.0, 0.0]   or a run-time interpreted script:  JSON Copy \"rotation\": [\"cos(query.anim_pos * 38.17) * 80.0 * query.anim_speed\", 0.0, 0.0]    Note  By default, rotations are in degrees, in X-then-Y-then-Z format.  Example from quadruped.animation.json in the vanilla resource pack's animation folder JSON Copy {   \"format_version\": \"1.8.0\",   \"animations\": {     \"animation.quadruped.walk\": {       \"anim_time_update\": \"query.modified_distance_moved\",       \"loop\": true,       \"bones\": {         \"leg0\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) *  80.0\", 0.0, 0.0 ] },         \"leg1\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) * -80.0\", 0.0, 0.0 ] },         \"leg2\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) * -80.0\", 0.0, 0.0 ] },         \"leg3\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) *  80.0\", 0.0, 0.0 ] }       }     }   } }  Names  All names (animations, bones, states, so on) must begin with a letter and contain only alphanumerics, underscores, and periods. It is recommended to use all lower-caps for names.  In the key frame examples below, \"head\" is used as the name of the bone.  Key Frames  A key frame defines two values for a channel-specific transform to a specific bone at a specified time, one as time approaches the key frame time, and the second from the key frame time onwards. As such, when interpolating between two key frames, one can define the slope of the animation curve in either a continuous or discontinuous manner.   Note  Interpolation, in an animation scenario, is used to calculate the movement between 2 key frames.  If a key frame is set on the first frame at a value of 0, and a key frame is set on the tenth frame at a value of 1, then the frames in-between will be interpolated in order to smoothly move the value from 0 to 1 over each frame until it gets to frame 10.  Continuous Example JSON Copy \"head\": {   \"rotation\": {     \"0.0\":[0, 0, 0],     \"0.5\": [ 0, 180, 0],     \"1.0\": [0, 360, 0]   } }  Discontinuous Example  To scale the 'head' bone:  From 0 to 0.5 seconds (in the \"pre\" tag), the head bone is set to a scale of 1 in all dimensions [X, Y, Z] At 0.5 seconds, the bone will instantly scale up to 2 times its normal size From 0.5 to 1 second (\"post\"), the bone will re-scale back to the scale of 1 in all dimensions   Note  \"Pre\" and \"post\" can also be defined by a Molang expression that calculates the value at runtime, allowing for a mathematically defined, as opposed to a purely linear, curve.  JSON Copy \"head\": {   \"scale\": {     \"0.5\": {       \"pre\": [1, 1, 1],       \"post\": 2.0     },     \"1.0\": [ 1.0 ]   } }  Transforms  Transformations in Animation are made up of three components - location in three dimensional space, rotation, and scale.  Some key concepts on how Transforms work within Minecraft:Bedrock Edition:  Order of operations: vertices are translated, rotated, then scaled. Animation data is assumed to be hierarchical, and is applied to a bone by name matching the bone name in the animation data to the targeted geometry's skeleton. Not every bone needs to be animated. Bones that don't exist in the targeted geometry can be animated (missing bones are ignored). Scale, rotation, and position can be set individually or uniformly with a single value. For example, these values are equivalent: JSON Copy \"scale\": [2.0, 2.0, 2.0] \"scale\": 2.0 \"scale\": [2.0]  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationsoverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Getting Started 02/22/2025 Overview of Animations in Minecraft: Bedrock Edition  Animation follows the current Minecraft JSON paradigms:  Fields should be lower-case and use underscores (no spaces). All JSON files in the definitions directory and subtree will be read into and interpreted by the animation system. Entity Definition  In order to define what animations an entity has, both an animations and a scripts/animate section must be added to the entity definition file.  Animations are specified as a short name, followed by their full resource name. The short name is used in animation controllers and the scripts/animate list, while the long name is used in the animations file.  In the scripts/animate section, list the animations to play and in which order. A blend expression may be specified, or an animation may be specified directly.  Entity Definition Example JSON Copy {   \"format_version\": \"1.10.0\",   \"minecraft:client_entity\": {     \"description\": {       \"identifier\": \"minecraft:pig\",       \"min_engine_version\": \"1.8.0\",       \"materials\": { \"default\": \"pig\" },       \"textures\": {         \"default\": \"textures/entity/pig/pig\",         \"saddled\": \"textures/entity/pig/pig_saddle\"       },       \"geometry\": {         \"default\": \"geometry.pig.v1.8\"       },       \"animations\": {         \"setup\": \"animation.pig.setup\",         \"walk\": \"animation.quadruped.walk\",         \"look_at_target\": \"animation.common.look_at_target\",         \"baby_transform\": \"animation.pig.baby_transform\"       },       \"scripts\": {         \"animate\": [           \"setup\",           { \"walk\": \"query.modified_move_speed\" },           \"look_at_target\",           { \"baby_transform\": \"query.is_baby\" }         ]       },       \"render_controllers\": [ \"controller.render.pig\" ],       \"spawn_egg\": {         \"texture\": \"spawn_egg\",         \"texture_index\": 2       }     }   } }  Animation Hierarchy  Animations are channel based (rotation, position, or scale), and within that are key-framed:  Copy EntityAnimation: animation name   BoneAnimation[]: bone name for this animation     AnimationChannel[]: rotation, scale, or translation to animate       KeyFrame[]: the value for the channel to have at a specific time  Animation Controller  Controlling how and when animations are played, and how they interact with other animations, is incredibly important. While many items can be managed in the entity definition scripts/animate section, animation controllers provide the functionality of a state machine into states, and allow the user to control them as a block. Animations in an animation controller state can be animation controllers themselves, allowing for complex animation hierarchies.  Example of Animation Controller JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.my_mob.move\": {       \"initial_state\": \"moving\",       \"states\": {         \"moving\": {           \"animations\": [             \"wag_tail\",             \"wiggle_ears\",             { \"walk\": \"query.modified_move_speed\" }           ],           \"transitions\": [             { \"grazing\": \"query.is_grazing\" }           ]         },         \"grazing\": {           \"animations\": [ \"grazing\" ],           \"transitions\": [             { \"moving\": \"query.all_animations_finished\" }           ]         }       }     }   } }   To learn more about Animation Controllers, please visit the Animation Controllers reference page.  Animations  At the beginning of each frame, the skeleton is reset to its default pose from its geometry definition and then animations are applied per-channel additively in order. Please note that the channels (x, y, and z) are added separately across animations first! They are then converted to a transform once all animations have been cumulatively applied.  Animation data can be either raw data:  JSON Copy \"rotation\": [90.0, 0.0, 0.0]   or a run-time interpreted script:  JSON Copy \"rotation\": [\"cos(query.anim_pos * 38.17) * 80.0 * query.anim_speed\", 0.0, 0.0]    Note  By default, rotations are in degrees, in X-then-Y-then-Z format.  Example from quadruped.animation.json in the vanilla resource pack's animation folder JSON Copy {   \"format_version\": \"1.8.0\",   \"animations\": {     \"animation.quadruped.walk\": {       \"anim_time_update\": \"query.modified_distance_moved\",       \"loop\": true,       \"bones\": {         \"leg0\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) *  80.0\", 0.0, 0.0 ] },         \"leg1\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) * -80.0\", 0.0, 0.0 ] },         \"leg2\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) * -80.0\", 0.0, 0.0 ] },         \"leg3\": { \"rotation\": [ \"Math.cos(query.anim_time * 38.17) *  80.0\", 0.0, 0.0 ] }       }     }   } }  Names  All names (animations, bones, states, so on) must begin with a letter and contain only alphanumerics, underscores, and periods. It is recommended to use all lower-caps for names.  In the key frame examples below, \"head\" is used as the name of the bone.  Key Frames  A key frame defines two values for a channel-specific transform to a specific bone at a specified time, one as time approaches the key frame time, and the second from the key frame time onwards. As such, when interpolating between two key frames, one can define the slope of the animation curve in either a continuous or discontinuous manner.   Note  Interpolation, in an animation scenario, is used to calculate the movement between 2 key frames.  If a key frame is set on the first frame at a value of 0, and a key frame is set on the tenth frame at a value of 1, then the frames in-between will be interpolated in order to smoothly move the value from 0 to 1 over each frame until it gets to frame 10.  Continuous Example JSON Copy \"head\": {   \"rotation\": {     \"0.0\":[0, 0, 0],     \"0.5\": [ 0, 180, 0],     \"1.0\": [0, 360, 0]   } }  Discontinuous Example  To scale the 'head' bone:  From 0 to 0.5 seconds (in the \"pre\" tag), the head bone is set to a scale of 1 in all dimensions [X, Y, Z] At 0.5 seconds, the bone will instantly scale up to 2 times its normal size From 0.5 to 1 second (\"post\"), the bone will re-scale back to the scale of 1 in all dimensions   Note  \"Pre\" and \"post\" can also be defined by a Molang expression that calculates the value at runtime, allowing for a mathematically defined, as opposed to a purely linear, curve.  JSON Copy \"head\": {   \"scale\": {     \"0.5\": {       \"pre\": [1, 1, 1],       \"post\": 2.0     },     \"1.0\": [ 1.0 ]   } }  Transforms  Transformations in Animation are made up of three components - location in three dimensional space, rotation, and scale.  Some key concepts on how Transforms work within Minecraft:Bedrock Edition:  Order of operations: vertices are translated, rotated, then scaled. Animation data is assumed to be hierarchical, and is applied to a bone by name matching the bone name in the animation data to the targeted geometry's skeleton. Not every bone needs to be animated. Bones that don't exist in the targeted geometry can be animated (missing bones are ignored). Scale, rotation, and position can be set individually or uniformly with a single value. For example, these values are equivalent: JSON Copy \"scale\": [2.0, 2.0, 2.0] \"scale\": 2.0 \"scale\": [2.0]  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationupgrade?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Upgrading Animation Scripts 02/22/2025  If you are updating your Animation scripts to the latest version of Minecraft: Bedrock Edition, there are a few steps needed depending on what version of Minecraft they were written in.  Upgrade from v1.17.30 to v1.18.10  The major change with 1.18.10 is:  Fixed an issue where animation controller events defined in the default state would get skipped if the controller immediately transitioned to another state. Upgrade from v1.10 to v1.17.30 Molang expressions inside transitions that contain capital letters are properly evaluated now. Strings inside such expressions are not forced to lowercase anymore and work as expected. Upgrade from v1.8 Beta to v1.10  Some things to keep in mind when upgrading from 1.8 to 1.10 onward:  The ability to have animations reference other animations in an arbitrarily deep hierarchy. The parameters section of animation controllers has been replaced with the variables section. In the entity definition file, animation controllers are now listed in the animations section, and a scriptAnimate section has been added to define which root animations to play. The v1.8 file format is backwards-compatible with v1.10 so you don't need to change anything (although we recommend refactoring your files in the spirit of v1.10 as there is a slight performance win with the new format, as well as it being simpler to understand.) Upgrade from v1.18.10 to v1.18.20  The major change with 1.18.20 is:  Molang expressions inside animation scripts for actor resource definition (pre_animation and initialize) that contain capital letters are properly evaluated now. Strings inside such expressions are not forced to lowercase anymore and work as expected. Upgrade from v1.7 Beta to v1.8  To upgrade previous scripts, you'll want to do the following steps to all of your Molang scripts in the order listed:  entity.flags.foo --> query.foo entity.member.foo --> query.foo entity.foo --> variable.foo params.foo --> global.foo The general rule is that 'query' represents read-only values from the entity the script is running on, and 'variable' represents read-write data created by the user. We've adopted snake_case for all names of things. You are welcome to use upper-case letters if you wish as we are case-insensitive, however we recommend snake_case in general. Several variables previously set on mobs have been changed to use the query.foo format. Look through the updated list below to see what has been added and changed. Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationupgrade?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Upgrading Animation Scripts 02/22/2025  If you are updating your Animation scripts to the latest version of Minecraft: Bedrock Edition, there are a few steps needed depending on what version of Minecraft they were written in.  Upgrade from v1.17.30 to v1.18.10  The major change with 1.18.10 is:  Fixed an issue where animation controller events defined in the default state would get skipped if the controller immediately transitioned to another state. Upgrade from v1.10 to v1.17.30 Molang expressions inside transitions that contain capital letters are properly evaluated now. Strings inside such expressions are not forced to lowercase anymore and work as expected. Upgrade from v1.8 Beta to v1.10  Some things to keep in mind when upgrading from 1.8 to 1.10 onward:  The ability to have animations reference other animations in an arbitrarily deep hierarchy. The parameters section of animation controllers has been replaced with the variables section. In the entity definition file, animation controllers are now listed in the animations section, and a scriptAnimate section has been added to define which root animations to play. The v1.8 file format is backwards-compatible with v1.10 so you don't need to change anything (although we recommend refactoring your files in the spirit of v1.10 as there is a slight performance win with the new format, as well as it being simpler to understand.) Upgrade from v1.18.10 to v1.18.20  The major change with 1.18.20 is:  Molang expressions inside animation scripts for actor resource definition (pre_animation and initialize) that contain capital letters are properly evaluated now. Strings inside such expressions are not forced to lowercase anymore and work as expected. Upgrade from v1.7 Beta to v1.8  To upgrade previous scripts, you'll want to do the following steps to all of your Molang scripts in the order listed:  entity.flags.foo --> query.foo entity.member.foo --> query.foo entity.foo --> variable.foo params.foo --> global.foo The general rule is that 'query' represents read-only values from the entity the script is running on, and 'variable' represents read-write data created by the user. We've adopted snake_case for all names of things. You are welcome to use upper-case letters if you wish as we are case-insensitive, however we recommend snake_case in general. Several variables previously set on mobs have been changed to use the query.foo format. Look through the updated list below to see what has been added and changed. Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationcontroller?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Animation Controllers 02/22/2025  Animation controllers decide which animations to play and when. Each controller contains a list of states that play one or more animations, each of which can be blended by a Molang expression if so desired. Controller files are stored as JSON in the animation_controllers folder.  Animation Controller Format JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.sheep.move\": {       \"states\": {         \"default\": {           \"animations\": [             { \"walk\": \"query.modified_move_speed\" }           ],           \"transitions\": [             { \"grazing\": \"query.is_grazing\" }           ]         },         \"grazing\": {           \"animations\": [ \"grazing\" ],           \"transitions\": [             { \"default\": \"query.all_animations_finished\" }           ]         }       }     }   } }  Animation Controller Parameters Expand table Name\tType\tOptional or Required\tDefault\tDescription loop\tBoolean\tOptional\tFalse\tShould the animation loop back to t=0.0 when it finishes? blend_weight\tValue or expression\tOptional\t1.0\tHow much this animation is blended with the others. 0.0 = off. 1.0 = fully apply all transforms. Can be an expression animation_length\tFloat\tOptional\tTime of last key frame.\tAt what time does the system consider this animation finished? override_previous_animation\tBoolean\tOptional\tfalse\tShould the animation pose of the bone be set to the bind pose before applying this animation, thereby overriding any previous animations to this point? bones\tArray of objects.\tRequired\tnot set\tThe bone in the geometry section and various settings. Omitting a channel skips that channel for this animation of this bone. Any of these values can be expressions or values. position\tFloat or array of three floats representing x, y, and z values\tRequired\tnot set\tThe position of a bone in space. scale\tFloat or array of one float\tRequired\tnot set\tThe scale of the bones. rotation\tObject with float values representing key frames\tRequired\tnot set\tThe set of key frames that might be specified during an animation to create greater granularity. states\tObject\tOptional\tnot set\tThe group of animations to process. May include variables to create more dynamic states. May include a transitions value to allow state blending between animations, such as querying the current state. Variables may be set by the game or user defined in a custom entity file. States  A state defines a group of animations to process (each of which can have its blend value). Each state has an optional variables section, listing any number of variables that referenced animations can use. Each state also has one or more animations, using the name given in the entity's definition JSON.  State Blending  If you would like there to be a cross-fade between states when transitioning, simply set blend_transition to the time you would like the system to take in blending between the two states. This is done as a simple lerp between the two states over the time specified.  Example of State Blending JSON Copy \"controller.animation.tiger.move\": {   \"states\": {     \"default\": {       \"animations\": [ \"base_pose\", \"walk\" ],       \"transitions\": [         { \"angry\": \"query.is_angry\" } // transition to angry state if query.is_angry returns true       ],       \"blend_transition\": 0.2          // when transitioning away from this state, cross-fade over 0.2 seconds     },     \"angry\": {       \"animations\": [ \"roar\", \"extend_claws\" ],       \"transitions\": [         { \"default\": \"query.any_animation_finished\" } // transition back to default state when either the roar animation or extend_claws animation finishes       ]     }   } }  State Transitions  A state can specify any number of transition scripts, listed in order. Each transition has a target state to switch to, and a script for whether it should switch or not. For each transition in order, evaluate the script, and if it returns non-zero, switch to the specified state immediately.  Below, we use the crouch and stuck portions of the fox animation controller as an example that uses complex queries to define the animation state transitions.   Note  Only one transition will be processed per frame.  JSON Copy \"animation_controllers\" : {   \"controller.animation.fox.move\" : {    \"initial_state\" : \"default\",    \"states\" : {     \"crouch\" : {      \"animations\" : [       \"look_at_target\",       \"crouch\",       {        \"walk\" : \"query.modified_move_speed\"       }      ],      \"blend_transition\" : 0.4,      \"transitions\" : [       {        \"default\" : \"!query.is_stalking && !query.is_interested\"       },       {        \"wiggle\" : \"query.is_interested\"       }      ]     },     \"stuck\" : {      \"animations\" : [       \"stuck\",       {        \"walk\" : \"math.cos(query.life_time * 20.0 * 53.7)\"       }      ],      \"blend_transition\" : 0.2,      \"transitions\" : [       {        \"default\" : \"!query.is_stunned\"       }      ]     },    }   }  }  Example of State Transitions JSON Copy \"controller.animation.tiger.move\": {   \"states\": {     \"default\": {       \"animations\": [ \"base_pose\", \"walk\" ],       \"transitions\": [         { \"angry\": \"query.is_angry\" }, // transition to angry state if query.is_angry returns true         { \"tired\": \"variable.is_tired\" } // transition to tired state if variable.is_tired returns true       ]     },     \"angry\": {       \"animations\": [ \"roar\", \"extend_claws\" ],       \"transitions\": [         { \"default\": \"query.any_animation_finished\" } // transition back to default state when either the roar animation or extend_claws animation finishes       ]     },     \"tired\": {       \"animations\": [ \"yawn\", \"stretch\" ],       \"transitions\": [         { \"default\": \"query.all_animations_finished\" } // transition back to default state when the yawn and stretch animations have both finished       ]     }   } }  State Variables  Variables are either set by the game or by a user-defined script that can be found in the entity definition JSON found in definitions/entity/<entity_name>.json. Variables have their value set by a Molang Expression. They can also have their value remapped via a linearly-interpolated curve.  State Variables Example  This defines a controller with a single state. It will create a variable variable.ground_speed_curve that lives on the entity only while processing the animation controller for that frame. It will take the value of query.ground_speed, then remap it to between 0.2 and 0.7 based on the value of query.ground_speed going from 0.0 to 1.0It will play one animation walk that will blend from 0.0 to 1.0 as the ground speed increases from stopped to 2.3 m/s. The remap curve can have any number of entries. The animation controller will then play the entity-referenced wiggle_nose animations, followed by the walk animation, scaling the latter by the value of variable.ground_speed_curve.  JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.sheep.move\": {       \"states\": {         \"default\": {           \"variables\": {             \"ground_speed_curve\": {               \"input\": \"query.ground_speed\",               \"remap_curve\": {                 \"0.0\": 0.2,                 \"1.0\": 0.7               }             }           },           \"animations\": [             \"wiggle_nose\",             { \"walk\": \"variable.ground_speed_curve\" }           ]         }       }     }   } }  User-Defined Script Example  This script will set foo to the result of the sine of query.life_time to later be used in the animation or animation controller.   Note  pre_animation tells the script to figure out the values of those variables once a frame before animation occurs so that the animation can use those values in its formulas. If a variable didn't exist, it will create a new variable and its default value will be 0.0.  In definitions\\entity\\tiger.json:  JSON Copy {   \"custom:tiger\":{     \"scripts\":{       \"pre_animation\": {         \"variable.foo = math.sin(query.life_time);\"       }     }   } }   Because foo is equal to a sin wave, its values will range from -1 to 1. This means that you will have a period from 0 to -1 to 0 where only base_pose will play and then an equal amount of time where walk will play on top of base_pose as foo goes from 0 to 1 back to 0. base_pose will have a blend value of 1.0.  JSON Copy \"controller.animation.tiger.move\": {   \"states\": {     \"default\": {       \"animations\": [         \"base_pose\",         { \"walk\": \"variable.foo > 0.0\" }       ]     }   } }  Channels (Rotation, Position, Scale)  The engine tracks the animation of rotation, position, and scale separately. Within a channel, one or more keyframes are specified at arbitrary times, in seconds, from the start of the animation. If no keyframes are specified, a single keyframe is created at t=0.0 and all channel data is stored within that keyframe.  Channels sample  Listed below are common examples of how the Animation format is written in JSON. In the geometry format, units are in 1/16ths of meters.  This sample shows using integers for the leftarm rotation. The root bone uses a more complex Molang expression with calculations which allows a more complex and refined animation.  JSON Copy \"animation.player.swim\" : {    \"animation_length\" : 1.3,    \"loop\" : true,    \"override_previous_animation\" : true,    \"bones\" : {     \"leftarm\" : {      \"rotation\" : {       \"0\" : [ 0.0, 180.0, 180.0 ],       \"0.7\" : [ 0.0, 180.0, 287.2 ],       \"1.1\" : [ 90.0, 180.0, 180.0 ],       \"1.3\" : [ 0.0, 180.0, 180.0 ]      }     },     \"rightarm\" : {      \"rotation\" : {       \"0\" : [ 0.0, 180.0, -180.0 ],       \"0.7\" : [ 0.0, 180.0, -287.2 ],       \"1.1\" : [ 90.0, 180.0, -180.0 ],       \"1.3\" : [ 0.0, 180.0, -180.0 ]      }     },     \"root\" : {      \"position\" : [ 0.0, \"(math.sin(query.target_x_rotation) * 24.0 + 3.0) * variable.swim_amount\", \"(math.cos(query.target_x_rotation) * 24.0 + 9.0) * variable.swim_amount\" ],      \"rotation\" : [ \"variable.swim_amount * (90 + query.target_x_rotation)\", 0.0, 0.0 ]     }    } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationcontroller?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Animation Controllers 02/22/2025  Animation controllers decide which animations to play and when. Each controller contains a list of states that play one or more animations, each of which can be blended by a Molang expression if so desired. Controller files are stored as JSON in the animation_controllers folder.  Animation Controller Format JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.sheep.move\": {       \"states\": {         \"default\": {           \"animations\": [             { \"walk\": \"query.modified_move_speed\" }           ],           \"transitions\": [             { \"grazing\": \"query.is_grazing\" }           ]         },         \"grazing\": {           \"animations\": [ \"grazing\" ],           \"transitions\": [             { \"default\": \"query.all_animations_finished\" }           ]         }       }     }   } }  Animation Controller Parameters Expand table Name\tType\tOptional or Required\tDefault\tDescription loop\tBoolean\tOptional\tFalse\tShould the animation loop back to t=0.0 when it finishes? blend_weight\tValue or expression\tOptional\t1.0\tHow much this animation is blended with the others. 0.0 = off. 1.0 = fully apply all transforms. Can be an expression animation_length\tFloat\tOptional\tTime of last key frame.\tAt what time does the system consider this animation finished? override_previous_animation\tBoolean\tOptional\tfalse\tShould the animation pose of the bone be set to the bind pose before applying this animation, thereby overriding any previous animations to this point? bones\tArray of objects.\tRequired\tnot set\tThe bone in the geometry section and various settings. Omitting a channel skips that channel for this animation of this bone. Any of these values can be expressions or values. position\tFloat or array of three floats representing x, y, and z values\tRequired\tnot set\tThe position of a bone in space. scale\tFloat or array of one float\tRequired\tnot set\tThe scale of the bones. rotation\tObject with float values representing key frames\tRequired\tnot set\tThe set of key frames that might be specified during an animation to create greater granularity. states\tObject\tOptional\tnot set\tThe group of animations to process. May include variables to create more dynamic states. May include a transitions value to allow state blending between animations, such as querying the current state. Variables may be set by the game or user defined in a custom entity file. States  A state defines a group of animations to process (each of which can have its blend value). Each state has an optional variables section, listing any number of variables that referenced animations can use. Each state also has one or more animations, using the name given in the entity's definition JSON.  State Blending  If you would like there to be a cross-fade between states when transitioning, simply set blend_transition to the time you would like the system to take in blending between the two states. This is done as a simple lerp between the two states over the time specified.  Example of State Blending JSON Copy \"controller.animation.tiger.move\": {   \"states\": {     \"default\": {       \"animations\": [ \"base_pose\", \"walk\" ],       \"transitions\": [         { \"angry\": \"query.is_angry\" } // transition to angry state if query.is_angry returns true       ],       \"blend_transition\": 0.2          // when transitioning away from this state, cross-fade over 0.2 seconds     },     \"angry\": {       \"animations\": [ \"roar\", \"extend_claws\" ],       \"transitions\": [         { \"default\": \"query.any_animation_finished\" } // transition back to default state when either the roar animation or extend_claws animation finishes       ]     }   } }  State Transitions  A state can specify any number of transition scripts, listed in order. Each transition has a target state to switch to, and a script for whether it should switch or not. For each transition in order, evaluate the script, and if it returns non-zero, switch to the specified state immediately.  Below, we use the crouch and stuck portions of the fox animation controller as an example that uses complex queries to define the animation state transitions.   Note  Only one transition will be processed per frame.  JSON Copy \"animation_controllers\" : {   \"controller.animation.fox.move\" : {    \"initial_state\" : \"default\",    \"states\" : {     \"crouch\" : {      \"animations\" : [       \"look_at_target\",       \"crouch\",       {        \"walk\" : \"query.modified_move_speed\"       }      ],      \"blend_transition\" : 0.4,      \"transitions\" : [       {        \"default\" : \"!query.is_stalking && !query.is_interested\"       },       {        \"wiggle\" : \"query.is_interested\"       }      ]     },     \"stuck\" : {      \"animations\" : [       \"stuck\",       {        \"walk\" : \"math.cos(query.life_time * 20.0 * 53.7)\"       }      ],      \"blend_transition\" : 0.2,      \"transitions\" : [       {        \"default\" : \"!query.is_stunned\"       }      ]     },    }   }  }  Example of State Transitions JSON Copy \"controller.animation.tiger.move\": {   \"states\": {     \"default\": {       \"animations\": [ \"base_pose\", \"walk\" ],       \"transitions\": [         { \"angry\": \"query.is_angry\" }, // transition to angry state if query.is_angry returns true         { \"tired\": \"variable.is_tired\" } // transition to tired state if variable.is_tired returns true       ]     },     \"angry\": {       \"animations\": [ \"roar\", \"extend_claws\" ],       \"transitions\": [         { \"default\": \"query.any_animation_finished\" } // transition back to default state when either the roar animation or extend_claws animation finishes       ]     },     \"tired\": {       \"animations\": [ \"yawn\", \"stretch\" ],       \"transitions\": [         { \"default\": \"query.all_animations_finished\" } // transition back to default state when the yawn and stretch animations have both finished       ]     }   } }  State Variables  Variables are either set by the game or by a user-defined script that can be found in the entity definition JSON found in definitions/entity/<entity_name>.json. Variables have their value set by a Molang Expression. They can also have their value remapped via a linearly-interpolated curve.  State Variables Example  This defines a controller with a single state. It will create a variable variable.ground_speed_curve that lives on the entity only while processing the animation controller for that frame. It will take the value of query.ground_speed, then remap it to between 0.2 and 0.7 based on the value of query.ground_speed going from 0.0 to 1.0It will play one animation walk that will blend from 0.0 to 1.0 as the ground speed increases from stopped to 2.3 m/s. The remap curve can have any number of entries. The animation controller will then play the entity-referenced wiggle_nose animations, followed by the walk animation, scaling the latter by the value of variable.ground_speed_curve.  JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.sheep.move\": {       \"states\": {         \"default\": {           \"variables\": {             \"ground_speed_curve\": {               \"input\": \"query.ground_speed\",               \"remap_curve\": {                 \"0.0\": 0.2,                 \"1.0\": 0.7               }             }           },           \"animations\": [             \"wiggle_nose\",             { \"walk\": \"variable.ground_speed_curve\" }           ]         }       }     }   } }  User-Defined Script Example  This script will set foo to the result of the sine of query.life_time to later be used in the animation or animation controller.   Note  pre_animation tells the script to figure out the values of those variables once a frame before animation occurs so that the animation can use those values in its formulas. If a variable didn't exist, it will create a new variable and its default value will be 0.0.  In definitions\\entity\\tiger.json:  JSON Copy {   \"custom:tiger\":{     \"scripts\":{       \"pre_animation\": {         \"variable.foo = math.sin(query.life_time);\"       }     }   } }   Because foo is equal to a sin wave, its values will range from -1 to 1. This means that you will have a period from 0 to -1 to 0 where only base_pose will play and then an equal amount of time where walk will play on top of base_pose as foo goes from 0 to 1 back to 0. base_pose will have a blend value of 1.0.  JSON Copy \"controller.animation.tiger.move\": {   \"states\": {     \"default\": {       \"animations\": [         \"base_pose\",         { \"walk\": \"variable.foo > 0.0\" }       ]     }   } }  Channels (Rotation, Position, Scale)  The engine tracks the animation of rotation, position, and scale separately. Within a channel, one or more keyframes are specified at arbitrary times, in seconds, from the start of the animation. If no keyframes are specified, a single keyframe is created at t=0.0 and all channel data is stored within that keyframe.  Channels sample  Listed below are common examples of how the Animation format is written in JSON. In the geometry format, units are in 1/16ths of meters.  This sample shows using integers for the leftarm rotation. The root bone uses a more complex Molang expression with calculations which allows a more complex and refined animation.  JSON Copy \"animation.player.swim\" : {    \"animation_length\" : 1.3,    \"loop\" : true,    \"override_previous_animation\" : true,    \"bones\" : {     \"leftarm\" : {      \"rotation\" : {       \"0\" : [ 0.0, 180.0, 180.0 ],       \"0.7\" : [ 0.0, 180.0, 287.2 ],       \"1.1\" : [ 90.0, 180.0, 180.0 ],       \"1.3\" : [ 0.0, 180.0, 180.0 ]      }     },     \"rightarm\" : {      \"rotation\" : {       \"0\" : [ 0.0, 180.0, -180.0 ],       \"0.7\" : [ 0.0, 180.0, -287.2 ],       \"1.1\" : [ 90.0, 180.0, -180.0 ],       \"1.3\" : [ 0.0, 180.0, -180.0 ]      }     },     \"root\" : {      \"position\" : [ 0.0, \"(math.sin(query.target_x_rotation) * 24.0 + 3.0) * variable.swim_amount\", \"(math.cos(query.target_x_rotation) * 24.0 + 9.0) * variable.swim_amount\" ],      \"rotation\" : [ \"variable.swim_amount * (90 + query.target_x_rotation)\", 0.0, 0.0 ]     }    } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationrendercontroller?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Render Controllers 02/22/2025  The Render Controller needs an identifier and needs to follow the format of \"controller.render.<name>\". This name needs to match the name set in the Client Entity Definitions JSON.  Render Controllers are a way for the player to determine what renders on the entity. Players can set the geometry, materials, textures, and part visibility of the entity. In addition to setting the keys directly, players can use arrays to have the entity choose between different options.  Getting Started  To begin, create a new folder named \"render_controllers\" in the root of the Resource Pack you want to add the new Render Controller JSON inside.  Example render controllers JSON for the ocelot entity JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {   \"controller.render.ocelot\": {     //Declarations of arrays     \"arrays\": {       //Declarations of texture arrays       \"textures\": {         //Property name is the array identifier, followed by a list of textures references (see entity/textures)         \"Array.skins\": [\"Texture.wild\", \"Texture.black\", \"Texture.red\", \"Texture.siamese\"]       }     },     //Tells the rendering to using geometries references (see entity/geometries)     \"geometry\": \"Geometry.default\",     //Tells the rendering what material to use on which bones, * is used for wildcards, using material references (see entity/material)     \"materials\": [{ \"*\": \"Material.default\" }],     //Tells the rendering what textures to use on and in which layer, using textures references (see entity/textures) or in this case a reference to the declared array of textures     \"textures\": [\"Array.skins[query.variant]\"]   } }  Examples  In the following examples, you will see how Render Controllers can be used to drive geometry, materials and textures for different entities. Each example shows a use case that is being used by a vanilla entity.  Example Array for geometry from the sheep JSON JSON Copy \"arrays\": {   \"geometries\": {     \"Array.geos\": [\"Geometry.default\", \"Geometry.sheared\"]   } }, \"geometry\": \"Array.geos[query.is_sheared]\",   Example Array for materials from the spider JSON JSON Copy \"arrays\": {   \"materials\": {     \"Array.materials\": [\"Material.default\", \"Material.invisible\"]   } }, \"materials\": [{ \"*\": \"Array.materials[query.is_invisible]\" }],   Example Array for textures from the villager JSON JSON Copy \"arrays\": {   \"textures\": {     \"Array.skins\": [\"Texture.farmer\", \"Texture.librarian\", \"Texture.priest\", \"Texture.smith\", \"Texture.butcher\"]   } }, \"textures\": [\"Array.skins[query.variant]\"]   Example with color for tinting of parts from Armor 1.0 render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.armor.chest.v1.0\": {         \"arrays\": {             \"materials\": {                 \"array.armor_material\": [                     \"material.armor\",                     \"material.armor_enchanted\",                     \"material.armor_leather\",                     \"material.armor_leather_enchanted\"                     ]                 },             \"textures\": {                 \"array.armor_texture\": [                     \"texture.leather\",                     \"texture.chain\",                     \"texture.iron\",                     \"texture.diamond\",                     \"texture.gold\"                     ]                 }             },         \"geometry\": \"geometry.armor\",         \"materials\" : [             { \"body\": \"array.armor_material[query.armor_material_slot(1)]\" },             { \"leftarm\": \"array.armor_material[query.armor_material_slot(1)]\" },             { \"rightarm\": \"array.armor_material[query.armor_material_slot(1)]\" }             ],         \"part_visibility\" : [             { \"*\": 0 },             { \"body\": \"query.has_armor_slot(1)\" },             { \"leftarm\": \"query.has_armor_slot(1)\" },             { \"rightarm\": \"query.has_armor_slot(1)\" }             ],         \"color\": {             \"r\": \"query.armor_color_slot(1, 0)\",             \"g\": \"query.armor_color_slot(1, 1)\",             \"b\": \"query.armor_color_slot(1, 2)\",             \"a\": \"query.armor_color_slot(1, 3)\"             },         \"textures\": [\"array.armor_texture[query.armor_texture_slot(1)]\", \"texture.enchanted\"]     } }  Example with is_hurt_color from Creeper render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.creeper\": {     \"geometry\" : \"Geometry.default\",     \"materials\" : [{ \"*\": \"Material.default\" }],     \"textures\" : \"Texture.default\",     \"is_hurt_color\" : {         \"r\": 0.0,         \"g\": 0.0,         \"b\": 1.0,         \"a\": 0.5,     }   } }  Example with on_fire_color from Fireball render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.fireball\": {     \"geometry\" : \"Geometry.default\",     \"materials\" : [{ \"*\": \"Material.default\" }],     \"textures\" : \"Texture.default\",     \"on_fire_color\" : {         \"r\": 0.0,         \"g\": 0.0,         \"b\": 0.0,         \"a\": 0.0,         }     } }  Example with overlay_color from Wither Boss render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.wither_boss\": {     \"arrays\": {         \"textures\": {             \"Array.wither_state\": [\"Texture.invulnerable\", \"Texture.default\"]         }     },     \"geometry\" : \"Geometry.default\",     \"materials\" : [{ \"*\": \"Material.default\" }],     \"textures\" : [\"Array.wither_state[variable.display_normal_skin]\"],     \"overlay_color\" : {         \"r\": \"variable.is_invulnerable ? 1.0 : this\",         \"g\": \"variable.is_invulnerable ? 1.0 : this\",         \"b\": \"variable.is_invulnerable ? 1.0 : this\",         \"a\": \"variable.is_invulnerable ? query.overlay_alpha : this\"         }     } }  Example with part_visibility for turning on and off visibility of parts from Llama JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {   \"controller.render.llama\": {     \"arrays\": {       \"textures\": {         \"Array.base\": [             \"Texture.creamy\",             \"Texture.white\",             \"Texture.brown\",             \"Texture.gray\"         ],         \"Array.decor\": [             \"Texture.decor_none\",             \"Texture.decor_white\",             \"Texture.decor_orange\",             \"Texture.decor_magenta\",             \"Texture.decor_light_blue\",             \"Texture.decor_yellow\",             \"Texture.decor_lime\",             \"Texture.decor_pink\",             \"Texture.decor_gray\",             \"Texture.decor_silver\",             \"Texture.decor_cyan\",             \"Texture.decor_purple\",             \"Texture.decor_blue\",             \"Texture.decor_brown\",             \"Texture.decor_green\",             \"Texture.decor_red\",             \"Texture.decor_black\"             ]         }     },     \"geometry\": \"Geometry.default\",     \"part_visibility\": [{ \"chest*\": \"query.is_chested\" }],     \"materials\": [{ \"*\": \"Material.default\" }],     \"textures\": [       \"Array.base[query.variant]\",       \"Array.decor[variable.decor_texture_index]\",       \"Texture.decor_none\"     ]   } }  Material array example from Horse render controllers  Saddle will override Mane, which will override TailA, etc.  JSON Copy \"materials\": [   { \"*\": \"Material.default\" },   { \"TailA\": \"Material.horse_hair\" },   { \"Mane\": \"Material.horse_hair\" },   { \"*Saddle*\": \"Material.horse_saddle\" } ],  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animations/animationrendercontroller?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animation Documentation - Render Controllers 02/22/2025  The Render Controller needs an identifier and needs to follow the format of \"controller.render.<name>\". This name needs to match the name set in the Client Entity Definitions JSON.  Render Controllers are a way for the player to determine what renders on the entity. Players can set the geometry, materials, textures, and part visibility of the entity. In addition to setting the keys directly, players can use arrays to have the entity choose between different options.  Getting Started  To begin, create a new folder named \"render_controllers\" in the root of the Resource Pack you want to add the new Render Controller JSON inside.  Example render controllers JSON for the ocelot entity JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {   \"controller.render.ocelot\": {     //Declarations of arrays     \"arrays\": {       //Declarations of texture arrays       \"textures\": {         //Property name is the array identifier, followed by a list of textures references (see entity/textures)         \"Array.skins\": [\"Texture.wild\", \"Texture.black\", \"Texture.red\", \"Texture.siamese\"]       }     },     //Tells the rendering to using geometries references (see entity/geometries)     \"geometry\": \"Geometry.default\",     //Tells the rendering what material to use on which bones, * is used for wildcards, using material references (see entity/material)     \"materials\": [{ \"*\": \"Material.default\" }],     //Tells the rendering what textures to use on and in which layer, using textures references (see entity/textures) or in this case a reference to the declared array of textures     \"textures\": [\"Array.skins[query.variant]\"]   } }  Examples  In the following examples, you will see how Render Controllers can be used to drive geometry, materials and textures for different entities. Each example shows a use case that is being used by a vanilla entity.  Example Array for geometry from the sheep JSON JSON Copy \"arrays\": {   \"geometries\": {     \"Array.geos\": [\"Geometry.default\", \"Geometry.sheared\"]   } }, \"geometry\": \"Array.geos[query.is_sheared]\",   Example Array for materials from the spider JSON JSON Copy \"arrays\": {   \"materials\": {     \"Array.materials\": [\"Material.default\", \"Material.invisible\"]   } }, \"materials\": [{ \"*\": \"Array.materials[query.is_invisible]\" }],   Example Array for textures from the villager JSON JSON Copy \"arrays\": {   \"textures\": {     \"Array.skins\": [\"Texture.farmer\", \"Texture.librarian\", \"Texture.priest\", \"Texture.smith\", \"Texture.butcher\"]   } }, \"textures\": [\"Array.skins[query.variant]\"]   Example with color for tinting of parts from Armor 1.0 render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.armor.chest.v1.0\": {         \"arrays\": {             \"materials\": {                 \"array.armor_material\": [                     \"material.armor\",                     \"material.armor_enchanted\",                     \"material.armor_leather\",                     \"material.armor_leather_enchanted\"                     ]                 },             \"textures\": {                 \"array.armor_texture\": [                     \"texture.leather\",                     \"texture.chain\",                     \"texture.iron\",                     \"texture.diamond\",                     \"texture.gold\"                     ]                 }             },         \"geometry\": \"geometry.armor\",         \"materials\" : [             { \"body\": \"array.armor_material[query.armor_material_slot(1)]\" },             { \"leftarm\": \"array.armor_material[query.armor_material_slot(1)]\" },             { \"rightarm\": \"array.armor_material[query.armor_material_slot(1)]\" }             ],         \"part_visibility\" : [             { \"*\": 0 },             { \"body\": \"query.has_armor_slot(1)\" },             { \"leftarm\": \"query.has_armor_slot(1)\" },             { \"rightarm\": \"query.has_armor_slot(1)\" }             ],         \"color\": {             \"r\": \"query.armor_color_slot(1, 0)\",             \"g\": \"query.armor_color_slot(1, 1)\",             \"b\": \"query.armor_color_slot(1, 2)\",             \"a\": \"query.armor_color_slot(1, 3)\"             },         \"textures\": [\"array.armor_texture[query.armor_texture_slot(1)]\", \"texture.enchanted\"]     } }  Example with is_hurt_color from Creeper render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.creeper\": {     \"geometry\" : \"Geometry.default\",     \"materials\" : [{ \"*\": \"Material.default\" }],     \"textures\" : \"Texture.default\",     \"is_hurt_color\" : {         \"r\": 0.0,         \"g\": 0.0,         \"b\": 1.0,         \"a\": 0.5,     }   } }  Example with on_fire_color from Fireball render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.fireball\": {     \"geometry\" : \"Geometry.default\",     \"materials\" : [{ \"*\": \"Material.default\" }],     \"textures\" : \"Texture.default\",     \"on_fire_color\" : {         \"r\": 0.0,         \"g\": 0.0,         \"b\": 0.0,         \"a\": 0.0,         }     } }  Example with overlay_color from Wither Boss render controller JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {     \"controller.render.wither_boss\": {     \"arrays\": {         \"textures\": {             \"Array.wither_state\": [\"Texture.invulnerable\", \"Texture.default\"]         }     },     \"geometry\" : \"Geometry.default\",     \"materials\" : [{ \"*\": \"Material.default\" }],     \"textures\" : [\"Array.wither_state[variable.display_normal_skin]\"],     \"overlay_color\" : {         \"r\": \"variable.is_invulnerable ? 1.0 : this\",         \"g\": \"variable.is_invulnerable ? 1.0 : this\",         \"b\": \"variable.is_invulnerable ? 1.0 : this\",         \"a\": \"variable.is_invulnerable ? query.overlay_alpha : this\"         }     } }  Example with part_visibility for turning on and off visibility of parts from Llama JSON JSON Copy \"format_version\": \"1.8.0\", \"render_controllers\": {   \"controller.render.llama\": {     \"arrays\": {       \"textures\": {         \"Array.base\": [             \"Texture.creamy\",             \"Texture.white\",             \"Texture.brown\",             \"Texture.gray\"         ],         \"Array.decor\": [             \"Texture.decor_none\",             \"Texture.decor_white\",             \"Texture.decor_orange\",             \"Texture.decor_magenta\",             \"Texture.decor_light_blue\",             \"Texture.decor_yellow\",             \"Texture.decor_lime\",             \"Texture.decor_pink\",             \"Texture.decor_gray\",             \"Texture.decor_silver\",             \"Texture.decor_cyan\",             \"Texture.decor_purple\",             \"Texture.decor_blue\",             \"Texture.decor_brown\",             \"Texture.decor_green\",             \"Texture.decor_red\",             \"Texture.decor_black\"             ]         }     },     \"geometry\": \"Geometry.default\",     \"part_visibility\": [{ \"chest*\": \"query.is_chested\" }],     \"materials\": [{ \"*\": \"Material.default\" }],     \"textures\": [       \"Array.base[query.variant]\",       \"Array.decor[variable.decor_texture_index]\",       \"Texture.decor_none\"     ]   } }  Material array example from Horse render controllers  Saddle will override Mane, which will override TailA, etc.  JSON Copy \"materials\": [   { \"*\": \"Material.default\" },   { \"TailA\": \"Material.horse_hair\" },   { \"Mane\": \"Material.horse_hair\" },   { \"*Saddle*\": \"Material.horse_saddle\" } ],  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoanimationcontrollers?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Animation Controllers 01/09/2025  In Minecraft, animation controllers do pretty much what they say: manage animations for blocks and entities. Animation controllers allow you to define when different animations play based on an entity's condition and current state. Animation controllers are very important because they help define the gameplay experience. Not only can you use them for basic things, such as making sure an entity plays the walking animation while they move (instead of hovering over the ground in a T-pose!), but you can also use animation controllers to create customized experiences based on your world and the things that happen in it. For example, you could create a custom werewolf entity that transforms during the full moon, or a block that glows in the dark!  In this guide, we will cover what animation controllers are and what they do and how to use them effectively. For specific information, such as code samples and in-depth definitions, we'll refer to the Animation Controllers Reference Doc   Note  This guide will not cover how to create custom animations. You can use programs like Blockbench to create custom animations to add flavor to your custom blocks and entities, but for this guide, we will only cover how to use animation controllers and how to transition between animations. For more information on creating animations, see Animation Documentation - Getting Started.  Key Concepts  Let's define some key concepts for animation controllers:  States: States are the modes that an entity or block can be in at any given time. States can change based on player input (ex.: moving your character), behavior, or changes to the environment. Animations are typicallly tied to a state and we use transitions between states to change an entity's animations. Some example states are default (idle), attacking, and transforming. Blocks can also have states - such as waterlogged - that can affect their animations and appearance. Transitions: When an entity moves from one state to another. For example, when an entity changes from an idle state to a walking state or from a walking state to a running state. Transitions are typically when animations will change. Conditions: A set of criteria that determine whether a transition can occur. Conditions can check an entity's speed, health, player inputs, or other attributes to decide if it should transition and which state it should move to. Triggers: Specific events that cause transitions. For example, pressing the W key could cause the player entity to transition from the default state to the walking state. Creating an Animation Controller  Next let's look at the parts of an animation controller and learn how to create one. We'll use this sample animation controller and break it down so that we can understand what each part is and how it affects the sheep entity's animation.  JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.sheep.move\": {       \"states\": {         \"default\": {           \"animations\": [             { \"walk\": \"query.modified_move_speed\" }           ],           \"transitions\": [             { \"grazing\": \"query.is_grazing\" }           ]         },         \"grazing\": {           \"animations\": [ \"grazing\" ],           \"transitions\": [             { \"default\": \"query.all_animations_finished\" }           ]         }       }     }   } }  animation_controllers - This is the main section where all of our animation controllers will be defined. Each animation controller will be defined by a unique name. controller.animation.sheep.move - This is a unique animation controller related to the movement of the sheep entity. states - This section defines the different states that the sheep can be in. Each state can have its own animations and transitions.  So these are the basics of an animation controller. Now, let's look at the various states for our custom sheep and how they affect its animation:  default - This is a state for the sheep. In this case, it is the primary, or \"idle\", state that is active when no other state conditions are met. animations - The list of animations that should play when the sheep is in this state. In this example, the walk animation is triggered when query.modified_move_speed returns true, meaning that the sheep is moving. transitions - This section defines the conditions that can cause the sheep to move to a different state. In this case, if query.is_grazing returns true, the sheep will move to the grazing state.  Great! We've defined a great base state for our sheep and we've even given it the ability to walk and start grazing! Now, let's look at the grazing state to see how we can give our sheep even more flavor:  animations - Like the default state, the grazing state gets its own animations. In this case, the grazing animation. transitions - Here, we use \"default\": \"query.all_animations_finished\" to check if the sheep has completed any animations that are played by its current state. In this case, once the grazing animation has played once, it will transition the sheep back to the default state.  So we've now created a nice little animation loop that takes the sheep from an idle state (default) to a grazing state that adds flavor to the entity. This helps create a better environment and atmosphere by allowing the sheep to do more than just stand or walk around. You can bet creative and use animation controllers to move entities and blocks through many different states, creating customized experiences or better ambiance for your world.  Deploy an Animation Controller  To use your new animation controller, we'll place it in the Behavior Pack of your add-on. Create a folder in your Behavior Pack called animations. Place your new animation controller file in this folder.   Important  Make sure you define your animation controller under the modules section of your manifest.json file. See Introduction to Behavior Packs (from Scratch) for more information.  Conclusion  Now that you know how to create and deploy an animation controller, try playing around with states and conditions to create customized experiences in your world. Animation controllers can create simple effects for ambiance, such as making a villager yawn when they're tired, or world-changing events, such as an incubator that turns on when four magic gems are inserted and hatches a whole brood of ender dragons! If you manage them correctly, you can tell a whole story through animation controllers and the effects they have on the entities and blocks in your world.  For more information on Animations and Animation controllers, including detailed information on states and other concepts, check out our reference documentation.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoanimationcontrollers?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Animation Controllers 01/09/2025  In Minecraft, animation controllers do pretty much what they say: manage animations for blocks and entities. Animation controllers allow you to define when different animations play based on an entity's condition and current state. Animation controllers are very important because they help define the gameplay experience. Not only can you use them for basic things, such as making sure an entity plays the walking animation while they move (instead of hovering over the ground in a T-pose!), but you can also use animation controllers to create customized experiences based on your world and the things that happen in it. For example, you could create a custom werewolf entity that transforms during the full moon, or a block that glows in the dark!  In this guide, we will cover what animation controllers are and what they do and how to use them effectively. For specific information, such as code samples and in-depth definitions, we'll refer to the Animation Controllers Reference Doc   Note  This guide will not cover how to create custom animations. You can use programs like Blockbench to create custom animations to add flavor to your custom blocks and entities, but for this guide, we will only cover how to use animation controllers and how to transition between animations. For more information on creating animations, see Animation Documentation - Getting Started.  Key Concepts  Let's define some key concepts for animation controllers:  States: States are the modes that an entity or block can be in at any given time. States can change based on player input (ex.: moving your character), behavior, or changes to the environment. Animations are typicallly tied to a state and we use transitions between states to change an entity's animations. Some example states are default (idle), attacking, and transforming. Blocks can also have states - such as waterlogged - that can affect their animations and appearance. Transitions: When an entity moves from one state to another. For example, when an entity changes from an idle state to a walking state or from a walking state to a running state. Transitions are typically when animations will change. Conditions: A set of criteria that determine whether a transition can occur. Conditions can check an entity's speed, health, player inputs, or other attributes to decide if it should transition and which state it should move to. Triggers: Specific events that cause transitions. For example, pressing the W key could cause the player entity to transition from the default state to the walking state. Creating an Animation Controller  Next let's look at the parts of an animation controller and learn how to create one. We'll use this sample animation controller and break it down so that we can understand what each part is and how it affects the sheep entity's animation.  JSON Copy {   \"format_version\": \"1.17.30\",   \"animation_controllers\": {     \"controller.animation.sheep.move\": {       \"states\": {         \"default\": {           \"animations\": [             { \"walk\": \"query.modified_move_speed\" }           ],           \"transitions\": [             { \"grazing\": \"query.is_grazing\" }           ]         },         \"grazing\": {           \"animations\": [ \"grazing\" ],           \"transitions\": [             { \"default\": \"query.all_animations_finished\" }           ]         }       }     }   } }  animation_controllers - This is the main section where all of our animation controllers will be defined. Each animation controller will be defined by a unique name. controller.animation.sheep.move - This is a unique animation controller related to the movement of the sheep entity. states - This section defines the different states that the sheep can be in. Each state can have its own animations and transitions.  So these are the basics of an animation controller. Now, let's look at the various states for our custom sheep and how they affect its animation:  default - This is a state for the sheep. In this case, it is the primary, or \"idle\", state that is active when no other state conditions are met. animations - The list of animations that should play when the sheep is in this state. In this example, the walk animation is triggered when query.modified_move_speed returns true, meaning that the sheep is moving. transitions - This section defines the conditions that can cause the sheep to move to a different state. In this case, if query.is_grazing returns true, the sheep will move to the grazing state.  Great! We've defined a great base state for our sheep and we've even given it the ability to walk and start grazing! Now, let's look at the grazing state to see how we can give our sheep even more flavor:  animations - Like the default state, the grazing state gets its own animations. In this case, the grazing animation. transitions - Here, we use \"default\": \"query.all_animations_finished\" to check if the sheep has completed any animations that are played by its current state. In this case, once the grazing animation has played once, it will transition the sheep back to the default state.  So we've now created a nice little animation loop that takes the sheep from an idle state (default) to a grazing state that adds flavor to the entity. This helps create a better environment and atmosphere by allowing the sheep to do more than just stand or walk around. You can bet creative and use animation controllers to move entities and blocks through many different states, creating customized experiences or better ambiance for your world.  Deploy an Animation Controller  To use your new animation controller, we'll place it in the Behavior Pack of your add-on. Create a folder in your Behavior Pack called animations. Place your new animation controller file in this folder.   Important  Make sure you define your animation controller under the modules section of your manifest.json file. See Introduction to Behavior Packs (from Scratch) for more information.  Conclusion  Now that you know how to create and deploy an animation controller, try playing around with states and conditions to create customized experiences in your world. Animation controllers can create simple effects for ambiance, such as making a villager yawn when they're tired, or world-changing events, such as an incubator that turns on when four magic gems are inserted and hatches a whole brood of ender dragons! If you manage them correctly, you can tell a whole story through animation controllers and the effects they have on the entities and blocks in your world.  For more information on Animations and Animation controllers, including detailed information on states and other concepts, check out our reference documentation.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animationsvscontrollers?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animations vs Animation Controllers 01/09/2025  In Minecraft: Bedrock Edition, animations and animation controllers are two parts of the system that helps entities display movement and interact with the world. Though they sound very similar and are both part of a resource pack and behavior pack, they serve very different functions and it's essential to understand how they interact.  First, let's start by describing each part of the entity animation system.  Major Differences  Animations in Minecraft define the raw animation data for an entity. Animation files contain keyframe data that shows how the game should manipulate the bones, properties, or other components of an entity's model over a specific period of time (in frames). You can use animations to define specific sequences, such as walking, attacking, or idle poses that the entity should repeat when performing certain actions. For more specific information on animations, check out Animation Documentation - Getting Started.   Note  Animations can also use Molang expressions to determine changes to an entity model (e.g., a rotating bone) over time. Sometimes Molang expressions can even be used instead of explicit keyframes. To learn more about Molang expressions, see A first look at Molang  Animation controllers add logic to an entity to manage and trigger animations at the appropriate time or in response to an appropriate event. Animation controllers define when different animations play based on an entity's condition and current state. To learn more about animation controllers, see Introduction to Animation Controllers.  Here's a table that helps to illustrate the differences between animations and animation controllers:  Expand table Feature\tAnimations\tAnimation Controllers Primary use\tDefines the visual movement of entity parts, bone rotations, etc.\tExecutes animations based on game events Contains logic\tNo\tYes Handles transitions\tNo\tYes Tied to entity state and/or conditions\tNo\tYes Moves an entity's body\tYes\tNo Example Use Case  Let's take a look at the wolf entity for an example to see how this works. When you tame a wolf in Minecraft, you can command it to sit by pressing the use button on them, then command it to stand by pressing the use button on them again. Whether the wolf is sitting or standing is managed by the wolf's state. In the vanilla resource pack, the wolf entity has animations (wolf.animations.json) and an animation controller (wolf.animation_controllers.json) that work together to make this behavior work.  In the animations file, we can see that the wolf has animations for sitting:  JSON Copy \"animation.wolf.sitting\" : {     \"loop\" : true,     \"bones\" : {         \"body\" : {             \"position\" : [ \"-this\", \"-18 - this\", \"-this\" ],             \"rotation\" : [ \"45.0 - this\", 0.0, 0.0 ]         },         \"leg0\" : {             \"position\" : [ \"-2.5 - this\", \"-22 - this\", \"2 - this\" ],             \"rotation\" : [ \"270 - this\", 0.0, 0.0 ]         },         \"leg1\" : {             \"position\" : [ \"0.5 - this\", \"-22 - this\", \"2 - this\" ],             \"rotation\" : [ \"270 - this\", 0.0, 0.0 ]         },         \"leg2\" : {             \"position\" : [ \"-2.49 - this\", \"-17 - this\", \"-4 - this\" ],             \"rotation\" : [ \"333 - this\", 0.0, 0.0 ]         },         \"leg3\" : {             \"position\" : [ \"0.51 - this\", \"-17 - this\", \"-4 - this\" ],             \"rotation\" : [ \"333 - this\", 0.0, 0.0 ]         },         \"tail\" : {             \"position\" : [ \"-1.0 - this\", \"-21 - this\", \"6.0 - this\" ]         },         \"upperbody\" : {             \"position\" : [ \"-1.0 - this\", \"-16 - this\", \"-3.0 - this\" ],             \"rotation\" : [ \"72 - this\", \"-this\", 0.0 ]         }     } },   This animation defines the movements of the wolf's body when it sits, telling the game how to move each part. This is essential in order to visually represent the wolf's sitting state in the game - without this code, the wolf's state will change to reflect that it is sitting, but you will not see any visual change for the wolf itself.  Now let's take a look at the animation controller file:  JSON Copy \"controller.animation.wolf.sitting\" : { \t\t\t\"initial_state\" : \"default\", \t\t\t\"states\" : { \t\t\t\t\"default\" : { \t\t\t\t\t\"animations\" : [ \"wolf_leg_default\" ], \t\t\t\t\t\"transitions\" : [ \t\t\t\t\t\t{ \t\t\t\t\t\t\t\"sitting\" : \"query.is_sitting\" \t\t\t\t\t\t} \t\t\t\t\t] \t\t\t\t}, \t\t\t\t\"sitting\" : { \t\t\t\t\t\"animations\" : [ \"wolf_sitting\" ], \t\t\t\t\t\"transitions\" : [ \t\t\t\t\t\t{ \t\t\t\t\t\t\t\"default\" : \"!query.is_sitting\" \t\t\t\t\t\t} \t\t\t\t\t] \t\t\t\t} \t\t\t} \t\t},   We can see that the corresponding animation controller determines the state of the wolf, which animations to play, and how to transition the wolf from one animation to the next. In the controller.animation.wolf.sitting animation controller, we can see that:  The controller sets the initial state of the wolf to default. In the default state, the controller plays the wolf_leg_default animation (also defined in the vanilla resource pack). When the player commands the wolf to sit, the controller then transitions the wolf into the sitting state. In the sitting state, the wolf plays the wolf_sitting animation. The controller then transitions the wolf back to the default state if the query to check whether the wolf is still sitting returns false. Using Animations and Animation Controllers  Now that you know the difference between these two essential parts of the entity movement system, you can start using them to create or enhance your resource packs in Minecraft. For more information on using animations and animation controllers, see our guides on each of these topics:  Animation Guides Entity Modeling and Animation Animation Documentation - Getting Started Animation Controller Guides Introduction to Animation Controllers Animation Documentation - Animation Controllers Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/animationsvscontrollers?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Animations vs Animation Controllers 01/09/2025  In Minecraft: Bedrock Edition, animations and animation controllers are two parts of the system that helps entities display movement and interact with the world. Though they sound very similar and are both part of a resource pack and behavior pack, they serve very different functions and it's essential to understand how they interact.  First, let's start by describing each part of the entity animation system.  Major Differences  Animations in Minecraft define the raw animation data for an entity. Animation files contain keyframe data that shows how the game should manipulate the bones, properties, or other components of an entity's model over a specific period of time (in frames). You can use animations to define specific sequences, such as walking, attacking, or idle poses that the entity should repeat when performing certain actions. For more specific information on animations, check out Animation Documentation - Getting Started.   Note  Animations can also use Molang expressions to determine changes to an entity model (e.g., a rotating bone) over time. Sometimes Molang expressions can even be used instead of explicit keyframes. To learn more about Molang expressions, see A first look at Molang  Animation controllers add logic to an entity to manage and trigger animations at the appropriate time or in response to an appropriate event. Animation controllers define when different animations play based on an entity's condition and current state. To learn more about animation controllers, see Introduction to Animation Controllers.  Here's a table that helps to illustrate the differences between animations and animation controllers:  Expand table Feature\tAnimations\tAnimation Controllers Primary use\tDefines the visual movement of entity parts, bone rotations, etc.\tExecutes animations based on game events Contains logic\tNo\tYes Handles transitions\tNo\tYes Tied to entity state and/or conditions\tNo\tYes Moves an entity's body\tYes\tNo Example Use Case  Let's take a look at the wolf entity for an example to see how this works. When you tame a wolf in Minecraft, you can command it to sit by pressing the use button on them, then command it to stand by pressing the use button on them again. Whether the wolf is sitting or standing is managed by the wolf's state. In the vanilla resource pack, the wolf entity has animations (wolf.animations.json) and an animation controller (wolf.animation_controllers.json) that work together to make this behavior work.  In the animations file, we can see that the wolf has animations for sitting:  JSON Copy \"animation.wolf.sitting\" : {     \"loop\" : true,     \"bones\" : {         \"body\" : {             \"position\" : [ \"-this\", \"-18 - this\", \"-this\" ],             \"rotation\" : [ \"45.0 - this\", 0.0, 0.0 ]         },         \"leg0\" : {             \"position\" : [ \"-2.5 - this\", \"-22 - this\", \"2 - this\" ],             \"rotation\" : [ \"270 - this\", 0.0, 0.0 ]         },         \"leg1\" : {             \"position\" : [ \"0.5 - this\", \"-22 - this\", \"2 - this\" ],             \"rotation\" : [ \"270 - this\", 0.0, 0.0 ]         },         \"leg2\" : {             \"position\" : [ \"-2.49 - this\", \"-17 - this\", \"-4 - this\" ],             \"rotation\" : [ \"333 - this\", 0.0, 0.0 ]         },         \"leg3\" : {             \"position\" : [ \"0.51 - this\", \"-17 - this\", \"-4 - this\" ],             \"rotation\" : [ \"333 - this\", 0.0, 0.0 ]         },         \"tail\" : {             \"position\" : [ \"-1.0 - this\", \"-21 - this\", \"6.0 - this\" ]         },         \"upperbody\" : {             \"position\" : [ \"-1.0 - this\", \"-16 - this\", \"-3.0 - this\" ],             \"rotation\" : [ \"72 - this\", \"-this\", 0.0 ]         }     } },   This animation defines the movements of the wolf's body when it sits, telling the game how to move each part. This is essential in order to visually represent the wolf's sitting state in the game - without this code, the wolf's state will change to reflect that it is sitting, but you will not see any visual change for the wolf itself.  Now let's take a look at the animation controller file:  JSON Copy \"controller.animation.wolf.sitting\" : { \t\t\t\"initial_state\" : \"default\", \t\t\t\"states\" : { \t\t\t\t\"default\" : { \t\t\t\t\t\"animations\" : [ \"wolf_leg_default\" ], \t\t\t\t\t\"transitions\" : [ \t\t\t\t\t\t{ \t\t\t\t\t\t\t\"sitting\" : \"query.is_sitting\" \t\t\t\t\t\t} \t\t\t\t\t] \t\t\t\t}, \t\t\t\t\"sitting\" : { \t\t\t\t\t\"animations\" : [ \"wolf_sitting\" ], \t\t\t\t\t\"transitions\" : [ \t\t\t\t\t\t{ \t\t\t\t\t\t\t\"default\" : \"!query.is_sitting\" \t\t\t\t\t\t} \t\t\t\t\t] \t\t\t\t} \t\t\t} \t\t},   We can see that the corresponding animation controller determines the state of the wolf, which animations to play, and how to transition the wolf from one animation to the next. In the controller.animation.wolf.sitting animation controller, we can see that:  The controller sets the initial state of the wolf to default. In the default state, the controller plays the wolf_leg_default animation (also defined in the vanilla resource pack). When the player commands the wolf to sit, the controller then transitions the wolf into the sitting state. In the sitting state, the wolf plays the wolf_sitting animation. The controller then transitions the wolf back to the default state if the query to check whether the wolf is still sitting returns false. Using Animations and Animation Controllers  Now that you know the difference between these two essential parts of the entity movement system, you can start using them to create or enhance your resource packs in Minecraft. For more information on using animations and animation controllers, see our guides on each of these topics:  Animation Guides Entity Modeling and Animation Animation Documentation - Getting Started Animation Controller Guides Introduction to Animation Controllers Animation Documentation - Animation Controllers Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/behaviorpackfromscratch?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Behavior Packs (from Scratch) 10/04/2024  Before building your first Add-On for Minecraft: Bedrock Edition, you will need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A behavior pack is a folder structure that contains files that drive entity behaviors, loot drops, spawn rules, items, recipes, and trade tables. This tutorial covers how behavior packs are created and how to add behaviors to an in-game cow entity to make it aggressive.  Tutorial Overview  In this tutorial, you will learn the following:  That it's possible to change an entity's behavior in Minecraft: Bedrock Edition. How to link a Behavior Pack to a Resource Pack. Sample Behavior Pack  There is a sample behavior pack available at the Microsoft samples GitHub. It may be used to understand the structure of behavior packs and to check your work after the tutorial.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Getting Started with Add-On Development Introduction To Resource Packs Building the Behavior Pack  A behavior pack contains files that creators use to add, remove, or alter gameplay behavior of entities within Minecraft. An entity's behavior file is what makes each entity do certain actions, like how a chicken follows a player who's holding seeds.  For Minecraft to find and use your behavior files, you have to set up the folders and files in a particular structure. This tutorial will guide you through creating this folder and file structure.  Create a folder  In this section, you will create a folder called My_BEHAVIOR_Pack. Well, actually you don't have to call it that. In fact, you can name this folder anything you want, but the other folders have to be named exactly like this tutorial says so that Minecraft knows where to look.  Open your com.mojang folder. Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.  Open the development_behavior_packs folder.  Inside the development_behavior_packs folder, create a new folder and name it My_BEHAVIOR_Pack.  Open the My_BEHAVIOR_Pack folder.  Create the manifest file  To load a behavior pack into Minecraft, you will need to create a manifest file. The behavior pack manifest file is similar to the one created for the resource pack, but it has two additional sections.  modules: Defines the pack so that Minecraft knows how to apply it to the world. Behavior packs use the data type. dependencies - Creates a link between behavior packs and resource packs to add custom textures and visuals to Minecraft.   Note  To learn more about how a manifest.json file works, see the Add-ons Reference manifest.json documentation.  Create a new document in your My_BEHAVIOR_Pack folder and name it manifest.json.  You will need to change the file extension from .txt to .json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab.  Double-click the manifest.json file to open it in a text editor.  Copy and paste the following code into your file.  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"My attack cow behavior pack Add-On!\",     \"name\": \"My Behavior Pack\",     \"uuid\":\"<FIRST GENERATED UUID>\",     \"version\": [1, 0, 0],     \"min_engine_version\": [1, 16, 0]   },   \"modules\":     [       {         \"description\": \"My First Add-On!\",           \"type\": \"data\",           \"uuid\": \"<SECOND GENERATED UUID>\",           \"version\": [1, 0, 0]       }     ],   \"dependencies\": [     {      \"uuid\":\"UUID from the header section of manifest.json in My_RESOURCE_Pack\",       \"version\":[1,0,0]     }  ] }  Enter UUIDs  Similar to the resource pack manifest file, you will need to generate two different 'Universally Unique Identifiers (UUIDs)' for the header and module sections of your manifest file. You can get UUIDs from an online generator such as https://www.uuidgenerator.net/.  Copy and paste a UUID into the header section. The UUID will need to be pasted in the \"uuid\" field between the quotation (\"\") marks to be read correctly. Refresh the webpage to generate a new UUID for use in the modules section. Copy and paste the new UUID into the modules section in the \"uuid\" field between the quotation marks. Create the dependency  There is a third section in the behavior pack's manifest.json file called 'dependencies' that is used to create a link between a resource pack and a behavior pack. This link is created when the UUID located in the header section of the resource pack's manifest.json file is the same as the UUID in the dependencies section of the behavior pack's manifest.json file. You do not need to have a resource pack to use a behavior pack, and you do not need to have a behavior pack to use a resource pack. If you do have both, you can use this solution to link them together so that when you load a behavior pack into a world, it automatically loads and activates the linked resource pack.  Open the manifest.json file located in the My_RESOURCE_Pack folder in the development_resource_packs folder. Copy the UUID from the header section of the resource pack manifest.json file. Go to the manifest.json file located in the *My_BEHAVIOR_Pack folder in the development_behavior_packs folder. Paste the UUID into the \"uuid\" field in the dependencies section. Make sure everything between the quotes matches exactly. Save the behavior pack manifest.json file.  Create the Entities Folder and Add a Cow  Every entity's behaviors are defined in its JSON file that lives inside the code that makes Minecraft work. You're going to create a new cow behavior file that Minecraft will use instead of its usual \"vanilla\" one.  In the My_BEHAVIOR_Pack folder, create a folder and name it entities. Create a text file in the entities folder and name it cow.json. Copy and paste the following code into your cow.json file. After you save the file, you're ready to go!   Note  This is the entire edited cow.json file. It's big because cows do a lot!  JSON Copy {     \"format_version\": \"1.16.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\": \"minecraft:cow\",             \"is_spawnable\": true,             \"is_summonable\": true,             \"is_experimental\": false         },         \"component_groups\": {             \"minecraft:cow_baby\": {                 \"minecraft:is_baby\": {},                 \"minecraft:scale\": {                     \"value\": 0.5                 },                 \"minecraft:ageable\": {                     \"duration\": 1200,                     \"feed_items\": \"wheat\",                     \"grow_up\": {                         \"event\": \"minecraft:ageable_grow_up\",                         \"target\": \"self\"                     }                 },                 \"minecraft:behavior.follow_parent\": {                     \"priority\": 6,                     \"speed_multiplier\": 1.1                 }             },             \"minecraft:cow_adult\": {                 \"minecraft:experience_reward\": {                     \"on_bred\": \"Math.Random(1,7)\",                     \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"                 },                 \"minecraft:loot\": {                     \"table\": \"loot_tables/entities/cow.json\"                 },                 \"minecraft:behavior.breed\": {                     \"priority\": 3,                     \"speed_multiplier\": 1.0                 },                 \"minecraft:breedable\": {                     \"require_tame\": false,                     \"breed_items\": \"wheat\",                     \"breeds_with\": {                         \"mate_type\": \"minecraft:cow\",                         \"baby_type\": \"minecraft:cow\",                         \"breed_event\": {                             \"event\": \"minecraft:entity_born\",                             \"target\": \"baby\"                         }                     }                 },                 \"minecraft:interact\": {                     \"interactions\": [                         {                             \"on_interact\": {                                 \"filters\": {                                     \"all_of\": [                                         {                                             \"test\": \"is_family\",                                             \"subject\": \"other\",                                             \"value\": \"player\"                                         },                                         {                                             \"test\": \"has_equipment\",                                             \"domain\": \"hand\",                                             \"subject\": \"other\",                                             \"value\": \"bucket:0\"                                         }                                     ]                                 }                             },                             \"use_item\": true,                             \"transform_to_item\": \"bucket:1\",                             \"play_sounds\": \"milk\",                             \"interact_text\": \"action.interact.milk\"                         }                     ]                 }             }         },         \"components\": {             \"minecraft:is_hidden_when_invisible\": {},             \"minecraft:type_family\": {                 \"family\": [                     \"cow\",                     \"mob\"                 ]             },             \"minecraft:breathable\": {                 \"total_supply\": 15,                 \"suffocate_time\": 0             },             \"minecraft:navigation.walk\": {                 \"can_path_over_water\": true,                 \"avoid_water\": true,                 \"avoid_damage_blocks\": true             },             \"minecraft:movement.basic\": {},             \"minecraft:jump.static\": {},             \"minecraft:can_climb\": {},             \"minecraft:collision_box\": {                 \"width\": 0.9,                 \"height\": 1.3             },             \"minecraft:nameable\": {},             \"minecraft:health\": {                 \"value\": 10,                 \"max\": 10             },             \"minecraft:hurt_on_condition\": {                 \"damage_conditions\": [                     {                         \"filters\": {                             \"test\": \"in_lava\",                             \"subject\": \"self\",                             \"operator\": \"==\",                             \"value\": true                         },                         \"cause\": \"lava\",                         \"damage_per_tick\": 4                     }                 ]             },             \"minecraft:movement\": {                 \"value\": 0.25             },             \"minecraft:despawn\": {                 \"despawn_from_distance\": {}             },             \"minecraft:behavior.float\": {                 \"priority\": 0             },             \"minecraft:behavior.panic\": {                 \"priority\": 1,                 \"speed_multiplier\": 1.25             },             \"minecraft:behavior.mount_pathing\": {                 \"priority\": 2,                 \"speed_multiplier\": 1.5,                 \"target_dist\": 0.0,                 \"track_target\": true             },             \"minecraft:behavior.breed\": {                 \"priority\": 3,                 \"speed_multiplier\": 1.0             },             \"minecraft:behavior.tempt\": {                 \"priority\": 4,                 \"speed_multiplier\": 1.25,                 \"items\": [                     \"wheat\"                 ]             },             \"minecraft:behavior.follow_parent\": {                 \"priority\": 5,                 \"speed_multiplier\": 1.1             },             \"minecraft:behavior.random_stroll\": {                 \"priority\": 6,                 \"speed_multiplier\": 0.8             },             \"minecraft:behavior.look_at_player\": {                 \"priority\": 7,                 \"look_distance\": 6.0,                 \"probability\": 0.02             },             \"minecraft:behavior.random_look_around\": {                 \"priority\": 9             },             \"minecraft:leashable\": {                 \"soft_distance\": 4.0,                 \"hard_distance\": 6.0,                 \"max_distance\": 10.0             },             \"minecraft:balloonable\": {},             \"minecraft:rideable\": {                 \"seat_count\": 1,                 \"family_types\": [                     \"zombie\"                 ],                 \"seats\": {                     \"position\": [                         0.0,                         1.105,                         0.0                     ]                 }             },             \"minecraft:physics\": {},             \"minecraft:pushable\": {                 \"is_pushable\": true,                 \"is_pushable_by_piston\": true             },             \"minecraft:conditional_bandwidth_optimization\": {},             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             }         },         \"events\": {             \"minecraft:entity_spawned\": {                 \"randomize\": [                     {                         \"weight\": 95,                         \"trigger\": \"minecraft:spawn_adult\"                     },                     {                         \"weight\": 5,                         \"add\": {                             \"component_groups\": [                                 \"minecraft:cow_baby\"                             ]                         }                     }                 ]             },             \"minecraft:entity_born\": {                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_baby\"                     ]                 }             },             \"minecraft:entity_transformed\": {                 \"remove\": {},                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_adult\"                     ]                 }             },             \"minecraft:ageable_grow_up\": {                 \"remove\": {                     \"component_groups\": [                         \"minecraft:cow_baby\"                     ]                 },                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_adult\"                     ]                 }             },             \"minecraft:spawn_adult\": {                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_adult\"                     ]                 }             }         }     } }  What changed  This is that code that, when added to the components section of a cow.json file, turns cows into aggressive killing machines:  JSON Copy             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             }  Testing the Pack  Now that the behavior pack has both a manifest file and a cow entity, it is time to launch Minecraft and test your new Add-On. As stated in the resource pack tutorial, Pack Stacking will work for behavior packs as well. This means that when content is loaded, vanilla content is loaded first, followed by any Add-Ons. Because all cows are controlled by the cow.json behavior file, all cows that spawn into your world will have the new behavior.  Launch Minecraft and select Play. Select Create New World. Under Settings, scroll down to the Add-Ons section. Click on Behavior Packs to see all available packs. Click the MY PACKS drop-down to open it. Select My BEHAVIOR Pack and click Activate to add the behavior pack to the world. Click Create to create your world. Go find a cow. Troubleshooting  Behavior pack woes? Troubleshooting is a normal part of any development process. Here are some places to begin troubleshooting a behavior pack.  You can use the sample behavior pack on the Minecraft samples GitHub to check the structure of your behavior pack.  Behavior Pack Does Not Appear in Minecraft  If your resource pack does not appear in the Add-Ons section, something is wrong with the manifest.json file. Let's start there.  Are there two different UUIDs in the manifest.json header and modules section? See the UUID section for more information. Have you turned on file extensions and paths? manifest.json may not be just manifest.json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab. Double-check JSON curly braces and brackets. JSON linting tools can help. If there's an issue with an active behavior pack, there will be a red exclamation point under Behavior Packs in the Add-Ons section. The behavior pack will have more information. It may alert a missing dependency, or run diagnostics on other issues. Behavior Pack Shows Up, Content Doesn't Work Check that the entities folder is in the right place, and spelled correctly. Then check all spellings of cow. Make sure that the UUID in the dependencies section matches an existing resource pack (and that it's working too). Move your pack above others to ensure your behavior pack is loaded first. Pack stacking may cause your changes to not appear. What's Next?  Now that you have seen a behavior pack in action, you can learn more about how they work and what else you can do with them.  Creating New Entity Types Entity JSON Documentation  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/behaviorpackfromscratch?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Behavior Packs (from Scratch) 10/04/2024  Before building your first Add-On for Minecraft: Bedrock Edition, you will need to create a pack to hold your custom content. There are two types of packs that a creator can make: resource packs and behavior packs. A behavior pack is a folder structure that contains files that drive entity behaviors, loot drops, spawn rules, items, recipes, and trade tables. This tutorial covers how behavior packs are created and how to add behaviors to an in-game cow entity to make it aggressive.  Tutorial Overview  In this tutorial, you will learn the following:  That it's possible to change an entity's behavior in Minecraft: Bedrock Edition. How to link a Behavior Pack to a Resource Pack. Sample Behavior Pack  There is a sample behavior pack available at the Microsoft samples GitHub. It may be used to understand the structure of behavior packs and to check your work after the tutorial.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Getting Started with Add-On Development Introduction To Resource Packs Building the Behavior Pack  A behavior pack contains files that creators use to add, remove, or alter gameplay behavior of entities within Minecraft. An entity's behavior file is what makes each entity do certain actions, like how a chicken follows a player who's holding seeds.  For Minecraft to find and use your behavior files, you have to set up the folders and files in a particular structure. This tutorial will guide you through creating this folder and file structure.  Create a folder  In this section, you will create a folder called My_BEHAVIOR_Pack. Well, actually you don't have to call it that. In fact, you can name this folder anything you want, but the other folders have to be named exactly like this tutorial says so that Minecraft knows where to look.  Open your com.mojang folder. Press Win+R to open Run. If you are using main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.  Open the development_behavior_packs folder.  Inside the development_behavior_packs folder, create a new folder and name it My_BEHAVIOR_Pack.  Open the My_BEHAVIOR_Pack folder.  Create the manifest file  To load a behavior pack into Minecraft, you will need to create a manifest file. The behavior pack manifest file is similar to the one created for the resource pack, but it has two additional sections.  modules: Defines the pack so that Minecraft knows how to apply it to the world. Behavior packs use the data type. dependencies - Creates a link between behavior packs and resource packs to add custom textures and visuals to Minecraft.   Note  To learn more about how a manifest.json file works, see the Add-ons Reference manifest.json documentation.  Create a new document in your My_BEHAVIOR_Pack folder and name it manifest.json.  You will need to change the file extension from .txt to .json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab.  Double-click the manifest.json file to open it in a text editor.  Copy and paste the following code into your file.  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"My attack cow behavior pack Add-On!\",     \"name\": \"My Behavior Pack\",     \"uuid\":\"<FIRST GENERATED UUID>\",     \"version\": [1, 0, 0],     \"min_engine_version\": [1, 16, 0]   },   \"modules\":     [       {         \"description\": \"My First Add-On!\",           \"type\": \"data\",           \"uuid\": \"<SECOND GENERATED UUID>\",           \"version\": [1, 0, 0]       }     ],   \"dependencies\": [     {      \"uuid\":\"UUID from the header section of manifest.json in My_RESOURCE_Pack\",       \"version\":[1,0,0]     }  ] }  Enter UUIDs  Similar to the resource pack manifest file, you will need to generate two different 'Universally Unique Identifiers (UUIDs)' for the header and module sections of your manifest file. You can get UUIDs from an online generator such as https://www.uuidgenerator.net/.  Copy and paste a UUID into the header section. The UUID will need to be pasted in the \"uuid\" field between the quotation (\"\") marks to be read correctly. Refresh the webpage to generate a new UUID for use in the modules section. Copy and paste the new UUID into the modules section in the \"uuid\" field between the quotation marks. Create the dependency  There is a third section in the behavior pack's manifest.json file called 'dependencies' that is used to create a link between a resource pack and a behavior pack. This link is created when the UUID located in the header section of the resource pack's manifest.json file is the same as the UUID in the dependencies section of the behavior pack's manifest.json file. You do not need to have a resource pack to use a behavior pack, and you do not need to have a behavior pack to use a resource pack. If you do have both, you can use this solution to link them together so that when you load a behavior pack into a world, it automatically loads and activates the linked resource pack.  Open the manifest.json file located in the My_RESOURCE_Pack folder in the development_resource_packs folder. Copy the UUID from the header section of the resource pack manifest.json file. Go to the manifest.json file located in the *My_BEHAVIOR_Pack folder in the development_behavior_packs folder. Paste the UUID into the \"uuid\" field in the dependencies section. Make sure everything between the quotes matches exactly. Save the behavior pack manifest.json file.  Create the Entities Folder and Add a Cow  Every entity's behaviors are defined in its JSON file that lives inside the code that makes Minecraft work. You're going to create a new cow behavior file that Minecraft will use instead of its usual \"vanilla\" one.  In the My_BEHAVIOR_Pack folder, create a folder and name it entities. Create a text file in the entities folder and name it cow.json. Copy and paste the following code into your cow.json file. After you save the file, you're ready to go!   Note  This is the entire edited cow.json file. It's big because cows do a lot!  JSON Copy {     \"format_version\": \"1.16.0\",     \"minecraft:entity\": {         \"description\": {             \"identifier\": \"minecraft:cow\",             \"is_spawnable\": true,             \"is_summonable\": true,             \"is_experimental\": false         },         \"component_groups\": {             \"minecraft:cow_baby\": {                 \"minecraft:is_baby\": {},                 \"minecraft:scale\": {                     \"value\": 0.5                 },                 \"minecraft:ageable\": {                     \"duration\": 1200,                     \"feed_items\": \"wheat\",                     \"grow_up\": {                         \"event\": \"minecraft:ageable_grow_up\",                         \"target\": \"self\"                     }                 },                 \"minecraft:behavior.follow_parent\": {                     \"priority\": 6,                     \"speed_multiplier\": 1.1                 }             },             \"minecraft:cow_adult\": {                 \"minecraft:experience_reward\": {                     \"on_bred\": \"Math.Random(1,7)\",                     \"on_death\": \"query.last_hit_by_player ? Math.Random(1,3) : 0\"                 },                 \"minecraft:loot\": {                     \"table\": \"loot_tables/entities/cow.json\"                 },                 \"minecraft:behavior.breed\": {                     \"priority\": 3,                     \"speed_multiplier\": 1.0                 },                 \"minecraft:breedable\": {                     \"require_tame\": false,                     \"breed_items\": \"wheat\",                     \"breeds_with\": {                         \"mate_type\": \"minecraft:cow\",                         \"baby_type\": \"minecraft:cow\",                         \"breed_event\": {                             \"event\": \"minecraft:entity_born\",                             \"target\": \"baby\"                         }                     }                 },                 \"minecraft:interact\": {                     \"interactions\": [                         {                             \"on_interact\": {                                 \"filters\": {                                     \"all_of\": [                                         {                                             \"test\": \"is_family\",                                             \"subject\": \"other\",                                             \"value\": \"player\"                                         },                                         {                                             \"test\": \"has_equipment\",                                             \"domain\": \"hand\",                                             \"subject\": \"other\",                                             \"value\": \"bucket:0\"                                         }                                     ]                                 }                             },                             \"use_item\": true,                             \"transform_to_item\": \"bucket:1\",                             \"play_sounds\": \"milk\",                             \"interact_text\": \"action.interact.milk\"                         }                     ]                 }             }         },         \"components\": {             \"minecraft:is_hidden_when_invisible\": {},             \"minecraft:type_family\": {                 \"family\": [                     \"cow\",                     \"mob\"                 ]             },             \"minecraft:breathable\": {                 \"total_supply\": 15,                 \"suffocate_time\": 0             },             \"minecraft:navigation.walk\": {                 \"can_path_over_water\": true,                 \"avoid_water\": true,                 \"avoid_damage_blocks\": true             },             \"minecraft:movement.basic\": {},             \"minecraft:jump.static\": {},             \"minecraft:can_climb\": {},             \"minecraft:collision_box\": {                 \"width\": 0.9,                 \"height\": 1.3             },             \"minecraft:nameable\": {},             \"minecraft:health\": {                 \"value\": 10,                 \"max\": 10             },             \"minecraft:hurt_on_condition\": {                 \"damage_conditions\": [                     {                         \"filters\": {                             \"test\": \"in_lava\",                             \"subject\": \"self\",                             \"operator\": \"==\",                             \"value\": true                         },                         \"cause\": \"lava\",                         \"damage_per_tick\": 4                     }                 ]             },             \"minecraft:movement\": {                 \"value\": 0.25             },             \"minecraft:despawn\": {                 \"despawn_from_distance\": {}             },             \"minecraft:behavior.float\": {                 \"priority\": 0             },             \"minecraft:behavior.panic\": {                 \"priority\": 1,                 \"speed_multiplier\": 1.25             },             \"minecraft:behavior.mount_pathing\": {                 \"priority\": 2,                 \"speed_multiplier\": 1.5,                 \"target_dist\": 0.0,                 \"track_target\": true             },             \"minecraft:behavior.breed\": {                 \"priority\": 3,                 \"speed_multiplier\": 1.0             },             \"minecraft:behavior.tempt\": {                 \"priority\": 4,                 \"speed_multiplier\": 1.25,                 \"items\": [                     \"wheat\"                 ]             },             \"minecraft:behavior.follow_parent\": {                 \"priority\": 5,                 \"speed_multiplier\": 1.1             },             \"minecraft:behavior.random_stroll\": {                 \"priority\": 6,                 \"speed_multiplier\": 0.8             },             \"minecraft:behavior.look_at_player\": {                 \"priority\": 7,                 \"look_distance\": 6.0,                 \"probability\": 0.02             },             \"minecraft:behavior.random_look_around\": {                 \"priority\": 9             },             \"minecraft:leashable\": {                 \"soft_distance\": 4.0,                 \"hard_distance\": 6.0,                 \"max_distance\": 10.0             },             \"minecraft:balloonable\": {},             \"minecraft:rideable\": {                 \"seat_count\": 1,                 \"family_types\": [                     \"zombie\"                 ],                 \"seats\": {                     \"position\": [                         0.0,                         1.105,                         0.0                     ]                 }             },             \"minecraft:physics\": {},             \"minecraft:pushable\": {                 \"is_pushable\": true,                 \"is_pushable_by_piston\": true             },             \"minecraft:conditional_bandwidth_optimization\": {},             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             }         },         \"events\": {             \"minecraft:entity_spawned\": {                 \"randomize\": [                     {                         \"weight\": 95,                         \"trigger\": \"minecraft:spawn_adult\"                     },                     {                         \"weight\": 5,                         \"add\": {                             \"component_groups\": [                                 \"minecraft:cow_baby\"                             ]                         }                     }                 ]             },             \"minecraft:entity_born\": {                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_baby\"                     ]                 }             },             \"minecraft:entity_transformed\": {                 \"remove\": {},                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_adult\"                     ]                 }             },             \"minecraft:ageable_grow_up\": {                 \"remove\": {                     \"component_groups\": [                         \"minecraft:cow_baby\"                     ]                 },                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_adult\"                     ]                 }             },             \"minecraft:spawn_adult\": {                 \"add\": {                     \"component_groups\": [                         \"minecraft:cow_adult\"                     ]                 }             }         }     } }  What changed  This is that code that, when added to the components section of a cow.json file, turns cows into aggressive killing machines:  JSON Copy             \"minecraft:behavior.nearest_attackable_target\": {                 \"priority\": 2,                 \"must_see\": true,                 \"reselect_targets\": true,                 \"within_radius\": 25.0,                 \"entity_types\": [                     {                         \"filters\": {                             \"test\": \"is_family\",                             \"subject\": \"other\",                             \"value\": \"player\"                         },                         \"max_dist\": 32                     }                 ]             },             \"minecraft:behavior.melee_attack\": {                 \"priority\": 3             },             \"minecraft:attack\": {                 \"damage\": 3             }  Testing the Pack  Now that the behavior pack has both a manifest file and a cow entity, it is time to launch Minecraft and test your new Add-On. As stated in the resource pack tutorial, Pack Stacking will work for behavior packs as well. This means that when content is loaded, vanilla content is loaded first, followed by any Add-Ons. Because all cows are controlled by the cow.json behavior file, all cows that spawn into your world will have the new behavior.  Launch Minecraft and select Play. Select Create New World. Under Settings, scroll down to the Add-Ons section. Click on Behavior Packs to see all available packs. Click the MY PACKS drop-down to open it. Select My BEHAVIOR Pack and click Activate to add the behavior pack to the world. Click Create to create your world. Go find a cow. Troubleshooting  Behavior pack woes? Troubleshooting is a normal part of any development process. Here are some places to begin troubleshooting a behavior pack.  You can use the sample behavior pack on the Minecraft samples GitHub to check the structure of your behavior pack.  Behavior Pack Does Not Appear in Minecraft  If your resource pack does not appear in the Add-Ons section, something is wrong with the manifest.json file. Let's start there.  Are there two different UUIDs in the manifest.json header and modules section? See the UUID section for more information. Have you turned on file extensions and paths? manifest.json may not be just manifest.json. If your Explorer window does not show file extensions, you can enable File Name Extensions under the View tab. Double-check JSON curly braces and brackets. JSON linting tools can help. If there's an issue with an active behavior pack, there will be a red exclamation point under Behavior Packs in the Add-Ons section. The behavior pack will have more information. It may alert a missing dependency, or run diagnostics on other issues. Behavior Pack Shows Up, Content Doesn't Work Check that the entities folder is in the right place, and spelled correctly. Then check all spellings of cow. Make sure that the UUID in the dependencies section matches an existing resource pack (and that it's working too). Move your pack above others to ensure your behavior pack is loaded first. Pack stacking may cause your changes to not appear. What's Next?  Now that you have seen a behavior pack in action, you can learn more about how they work and what else you can do with them.  Creating New Entity Types Entity JSON Documentation  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoentityfamilies?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Family 08/16/2024  An entity's family is like a tag that helps group similar entities together and is defined by the minecraft: type_family component. For example, skeletons, zombies, and creepers are all a part of the monster family.  Entities can have more than one family, which will become important later.  Customize Behavior with Entity Families  So what can we do with family tags? At a basic level, we can use family tags as an attribute for target selection. Using the family argument after a target selector will allow us to specify which families to target for a specific behavior. For example, we can use the @e family=monster selector and our entity will only target entities that are alive and have the monster family tag. This is a broad filter and works great if you want to create a player companion entity that will help fight off enemies, but you can also get more specific.  For example, you could create a UFO entity that only abducts cows! Or you could create a hoglin nanny that protects and brings food to hoglin babies, but not adult hoglins! Because entities can have multiple family tags you can get very specific when using tags and create really interesting behaviors.  For more information on how to use components to affect entity behavior, see Entity Behavior Introduction.  List of Entity Families  Here is a list of the current entity families in Minecraft Bedrock Edition:  Expand table Family\tEntities in this Family allay\tAllay armor_stand\tArmor Stand axolotl\tAxolotl bat\tBat bee\tBee blaze\tBlaze boat\tBoat cat\tCat cavespider\tCave Spider chicken\tChicken cod\tCod cow\tCow creeper\tCreeper dolphin\tDolphin donkey\tDonkey dragon\tEnder Dragon drowned\tDrowned enderman\tEnderman endermite\tEndermite evocation_illager\tEvoker fox\tFox frog\tFrog ghast\tGhast goat\tGoat guardian\tGuardian guardian_elder\tElder Guardian hoglin\tHoglin horse\tHorse husk\tHusk irongolem\tIron Golem lightning\tLightning Bold llama\tLlama magmacube\tMagma Cube mule\tMule mushroomcow\tMooshroom npc\tNPC ocelot\tOcelot panda\tPanda phantom\tPhantom pig\tPig piglin_brute\tPiglin Brute pillager\tPillager player\tPlayer polarbear\tPolar Bear pufferfish\tPufferfish rabbit\tRabbit ravager\tRavager salmon\tSalmon sheep\tSheep shulker\tShulker silverfish\tSilverfish skeletonhorse\tSkeleton Horse slime\tSlime snowgolem\tSnow Golem spider\tSpider stray\tStray strider\tStrider tadpole\tTadpole tnt\tTNT tripodcamera\tCamera tropicalfish\tTropical Fish turtle\tTurtle vex\tVex villager\tVillager vindicator\tVindicator wandering_trader\tWandering Trader warden\tWarden witch\tWitch wolf\tWolf zoglin\tZoglin zombie_pigman\tZombie Pigman zombie_villager\tZombie Villager zombiehorse\tZombie Horse hoglin_adult\tHoglin adult_piglin\tPiglin Brute strider_adult\tStrider zoglin_adult\tZoglin animal\tGoat armorer\tVillager, Zombie Villager arthropod\tBee, Cave Spider, Endermite, Silverfish, Spider artisan\tVillager hoglin_baby\tHoglin strider_baby\tStrider zoglin_baby\tZoglin blacksmith\tVillager butcher\tVillager, Zombie Villager lightweight\tEndermite, Fox, Rabbit, Silverfish cartographer\tVillager, Zombie Villager cleric\tVillager, Zombie Villager wandering_trader_despawning\tWandering Trader farmer\tVillager, Zombie Villager fisherman\tVillager, Zombie Villager fletcher\tVillager, Zombie Villager monster\tBlaze, Cave Spider, Creeper, Drowned, Elder Guardian, Enderman, Endermite, Evoker, Ghast, Guardian, Husk, Magma Cube, Phantom, Piglin, Piglin Brute, Pillager, Ravager, Shulker, Silverfish, Skeleton, Slime, Spider, Stray, Vex, Vindicator, Warden, Witch, Wither, Wither Skeleton, Zombie, Zombie Pigman, Zombie Villager hoglin_huntable\tHoglin illager\tEvoker, Pillager, Ravager, Vindicator inanimate\tArmor Stand, Boat, Camera, Minecart, Minecart with Chest, Minecart with Command Block, Minecart with Hopper, Minecart with TNT, TNT leatherworker\tVillager, Zombie Villager librarian\tVillager, Zombie Villager stone_mason\tVillager, Zombie Villager minecart\tMinecart, Minecart with Chest, Minecart with Command Block, Minecart with Hopper, Minecart with TNT mob\tAllay, Armor Stand, Axolotl, Bat, Bee, Blaze, Camera, Cat, Cave Spider, Chicken, Cow, Creeper, Dolphin, Elder Guardian, Ender Dragon, Enderman, Endermite, Evoker, Fox, Frog, Ghast, Glow Squid, Guardian, Hoglin, Horse, Husk, Iron Golem, Llama, Magma Cube, Mooshroom, Mule, NPC, Ocelot, Panda, Parrot, Phantom, Pig, Pillager, Polar Bear, Rabbit, Ravager, Sheep, Shulker, Silverfish, Skeleton, Skeleton Horse, Slime, Snow Golem, Spider, Squid, Stray, Strider, Tadpole, Turtle, Vex, Villager, Vindicator, Wandering Trader, Warden, Witch, Wither, Wither Skeleton, Wolf, Zoglin, Zombie, Zombie Horse, Zombie Pigman, Zombie Villager nitwit\tVillager, Zombie Villager peasant\tVillager piglin\tPiglin, Piglin Brute piglin_hunter\tPiglin priest\tVillage shepherd\tVillager, Zombie Villager skeleton\tSkeleton, Stray, Wither, Wither Skeleton fish\tCod, Pufferfish, Salmon, Tropical Fish squid\tGlow Squid, Squid parrot_tame\tParrot pacified\tBee toolsmith\tVillager, Zombie Villager undead\tDrowned, Husk, Phantom, Skeleton, Skeleton Horse, Stray, Wither, Wither Skeleton, Zoglin, Zombie, Zombie Horse, Zombie Pigman, Zombie Villager unskilled\tZombie Villager weaponsmith\tVillager, Zombie Villager parrot_wild\tParrot wither\tWither, Wither Skeleton panda_aggressive\tPanda zombie\tDrowned, Husk, Zombie, Zombie Villager Adding Custom Entity Families  Believe it or not, all of that was just the beginning! You can also create your own custom entity families and really take the customization to another level. With entities in a custom family, you can create unique behaviors (or even whole game modes!) based on the relationships between the entities in your world.  Keep in mind that you cannot directly add an entity family to an existing entity. If you want to achieve this, the best thing to do is to create a custom entity that is identical to the vanilla entity, but with your custom family tag included.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoentityfamilies?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Entity Family 08/16/2024  An entity's family is like a tag that helps group similar entities together and is defined by the minecraft: type_family component. For example, skeletons, zombies, and creepers are all a part of the monster family.  Entities can have more than one family, which will become important later.  Customize Behavior with Entity Families  So what can we do with family tags? At a basic level, we can use family tags as an attribute for target selection. Using the family argument after a target selector will allow us to specify which families to target for a specific behavior. For example, we can use the @e family=monster selector and our entity will only target entities that are alive and have the monster family tag. This is a broad filter and works great if you want to create a player companion entity that will help fight off enemies, but you can also get more specific.  For example, you could create a UFO entity that only abducts cows! Or you could create a hoglin nanny that protects and brings food to hoglin babies, but not adult hoglins! Because entities can have multiple family tags you can get very specific when using tags and create really interesting behaviors.  For more information on how to use components to affect entity behavior, see Entity Behavior Introduction.  List of Entity Families  Here is a list of the current entity families in Minecraft Bedrock Edition:  Expand table Family\tEntities in this Family allay\tAllay armor_stand\tArmor Stand axolotl\tAxolotl bat\tBat bee\tBee blaze\tBlaze boat\tBoat cat\tCat cavespider\tCave Spider chicken\tChicken cod\tCod cow\tCow creeper\tCreeper dolphin\tDolphin donkey\tDonkey dragon\tEnder Dragon drowned\tDrowned enderman\tEnderman endermite\tEndermite evocation_illager\tEvoker fox\tFox frog\tFrog ghast\tGhast goat\tGoat guardian\tGuardian guardian_elder\tElder Guardian hoglin\tHoglin horse\tHorse husk\tHusk irongolem\tIron Golem lightning\tLightning Bold llama\tLlama magmacube\tMagma Cube mule\tMule mushroomcow\tMooshroom npc\tNPC ocelot\tOcelot panda\tPanda phantom\tPhantom pig\tPig piglin_brute\tPiglin Brute pillager\tPillager player\tPlayer polarbear\tPolar Bear pufferfish\tPufferfish rabbit\tRabbit ravager\tRavager salmon\tSalmon sheep\tSheep shulker\tShulker silverfish\tSilverfish skeletonhorse\tSkeleton Horse slime\tSlime snowgolem\tSnow Golem spider\tSpider stray\tStray strider\tStrider tadpole\tTadpole tnt\tTNT tripodcamera\tCamera tropicalfish\tTropical Fish turtle\tTurtle vex\tVex villager\tVillager vindicator\tVindicator wandering_trader\tWandering Trader warden\tWarden witch\tWitch wolf\tWolf zoglin\tZoglin zombie_pigman\tZombie Pigman zombie_villager\tZombie Villager zombiehorse\tZombie Horse hoglin_adult\tHoglin adult_piglin\tPiglin Brute strider_adult\tStrider zoglin_adult\tZoglin animal\tGoat armorer\tVillager, Zombie Villager arthropod\tBee, Cave Spider, Endermite, Silverfish, Spider artisan\tVillager hoglin_baby\tHoglin strider_baby\tStrider zoglin_baby\tZoglin blacksmith\tVillager butcher\tVillager, Zombie Villager lightweight\tEndermite, Fox, Rabbit, Silverfish cartographer\tVillager, Zombie Villager cleric\tVillager, Zombie Villager wandering_trader_despawning\tWandering Trader farmer\tVillager, Zombie Villager fisherman\tVillager, Zombie Villager fletcher\tVillager, Zombie Villager monster\tBlaze, Cave Spider, Creeper, Drowned, Elder Guardian, Enderman, Endermite, Evoker, Ghast, Guardian, Husk, Magma Cube, Phantom, Piglin, Piglin Brute, Pillager, Ravager, Shulker, Silverfish, Skeleton, Slime, Spider, Stray, Vex, Vindicator, Warden, Witch, Wither, Wither Skeleton, Zombie, Zombie Pigman, Zombie Villager hoglin_huntable\tHoglin illager\tEvoker, Pillager, Ravager, Vindicator inanimate\tArmor Stand, Boat, Camera, Minecart, Minecart with Chest, Minecart with Command Block, Minecart with Hopper, Minecart with TNT, TNT leatherworker\tVillager, Zombie Villager librarian\tVillager, Zombie Villager stone_mason\tVillager, Zombie Villager minecart\tMinecart, Minecart with Chest, Minecart with Command Block, Minecart with Hopper, Minecart with TNT mob\tAllay, Armor Stand, Axolotl, Bat, Bee, Blaze, Camera, Cat, Cave Spider, Chicken, Cow, Creeper, Dolphin, Elder Guardian, Ender Dragon, Enderman, Endermite, Evoker, Fox, Frog, Ghast, Glow Squid, Guardian, Hoglin, Horse, Husk, Iron Golem, Llama, Magma Cube, Mooshroom, Mule, NPC, Ocelot, Panda, Parrot, Phantom, Pig, Pillager, Polar Bear, Rabbit, Ravager, Sheep, Shulker, Silverfish, Skeleton, Skeleton Horse, Slime, Snow Golem, Spider, Squid, Stray, Strider, Tadpole, Turtle, Vex, Villager, Vindicator, Wandering Trader, Warden, Witch, Wither, Wither Skeleton, Wolf, Zoglin, Zombie, Zombie Horse, Zombie Pigman, Zombie Villager nitwit\tVillager, Zombie Villager peasant\tVillager piglin\tPiglin, Piglin Brute piglin_hunter\tPiglin priest\tVillage shepherd\tVillager, Zombie Villager skeleton\tSkeleton, Stray, Wither, Wither Skeleton fish\tCod, Pufferfish, Salmon, Tropical Fish squid\tGlow Squid, Squid parrot_tame\tParrot pacified\tBee toolsmith\tVillager, Zombie Villager undead\tDrowned, Husk, Phantom, Skeleton, Skeleton Horse, Stray, Wither, Wither Skeleton, Zoglin, Zombie, Zombie Horse, Zombie Pigman, Zombie Villager unskilled\tZombie Villager weaponsmith\tVillager, Zombie Villager parrot_wild\tParrot wither\tWither, Wither Skeleton panda_aggressive\tPanda zombie\tDrowned, Husk, Zombie, Zombie Villager Adding Custom Entity Families  Believe it or not, all of that was just the beginning! You can also create your own custom entity families and really take the customization to another level. With entities in a custom family, you can create unique behaviors (or even whole game modes!) based on the relationships between the entities in your world.  Keep in mind that you cannot directly add an entity family to an existing entity. If you want to achieve this, the best thing to do is to create a custom entity that is identical to the vanilla entity, but with your custom family tag included.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkeroverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - Overview 04/16/2025  Many mapmakers like to create maps using Minecraft: Java Edition because of the wide range of community-made tools and plugins. This article introduces you to Chunker and explains how it can be used to convert worlds between different editions and versions of the game.   Important  Chunker is provided by external, third-party contributors and is not a Mojang/Microsoft offering. Users should use at their own discretion.  In this tutorial you will learn the following:  What Chunker is and how to access it. How to convert a world between Minecraft editions with Chunker. Chunker overview  Chunker is both an application you can run from a command-line as well as run as a standalone application on Windows, Mac, and Linux devices. It is also an open source project, meaning that its code is available on GitHub and the tool will improve based on contributions (bug reports and new features) submitted via the community. The goal of Chunker is to provide an easily accessible interface to convert worlds between Minecraft: Bedrock Edition and Minecraft: Java Edition.  Although advanced options and settings exist, most worlds will not require any changes to successfully convert from one edition to another.  Chunker can currently convert:  Level settings World data (blocks, biomes, and tile entities) Multiple dimensions Container & items In-game maps  Chunker cannot currently convert:  Entities Player inventories  The feature set of Chunker will expand as it is developed further.   Note  Chunker will keep entities and player inventories if editing a world (outputting to source world version).  How to access Chunker  You can download Chunker from https://github.com/HiveGamesOSS/Chunker/releases. Your world is converted and worked with locally on your machine.  There are two versions of Chunker that you can download, the app version and the command line interface (CLI) version.  For this tutorial, we'll be working with the app version. Instructions for how to use the CLI version can be found here.  Converting a world with Chunker  It's simple to convert a world with Chunker. Loading Chunker will present you with the Upload World screen.  Choosing a world  There are two options to choose from:  Choose world folder allows you to select the root folder of either a Bedrock Edition or Java Edition world. The root folder is where the level.dat is located. More information on where you can find where worlds are stored can be found in the Getting Started with Add-On Development for Bedrock Edition article.  Select archive allows you to select either a zip, or an mcworld. Mcworlds are the files generated by Bedrock Edition with the export world functionality on the edit world screen.  You can also drag and drop a folder, zip, or mcworld, and Chunker will automatically detect the right mode to proceed with your upload.  Selecting a target output  After you have successfully uploaded your world, Chunker will show you all the available output options. Chunker can convert to other editions of the game and different versions of the source worlds format.  Depending on your needs, after selecting an output version, you can either instantly Convert or enter Advanced Mode to tweak the conversion settings.  More information on \"Advanced Mode\" and the features within it can be found in the advanced mode tutorial.  Conversion process  Chunker will now process all the data and convert your world to the desired output.  Depending on the size of your world, this may take a while. Most worlds, however, will be done and ready to download within a few minutes.  Save your world  Chunker will tell you when your world is converted. If any errors were encountered during conversion, these will also be displayed. You can use these anonymous error identifiers to report issues to the Chunker development team.  Click the Save button to save your converted world in the selected Output folder. If you want to distribute your converted world, you can upload it to a service such as OneDrive and share it.  You can now enjoy your freshly converted world. If you have converted to a Bedrock Edition format, it's as simple as opening the mcworld file - Minecraft will do the rest. To open a Java Edition world, you'll have to copy the folder to the saves directory.  What's Next?  Chunker can do more than simply convert a world. Read on to the next article which utilizes Advanced Mode.  Chunker - Advanced Mode  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkeroverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - Overview 04/16/2025  Many mapmakers like to create maps using Minecraft: Java Edition because of the wide range of community-made tools and plugins. This article introduces you to Chunker and explains how it can be used to convert worlds between different editions and versions of the game.   Important  Chunker is provided by external, third-party contributors and is not a Mojang/Microsoft offering. Users should use at their own discretion.  In this tutorial you will learn the following:  What Chunker is and how to access it. How to convert a world between Minecraft editions with Chunker. Chunker overview  Chunker is both an application you can run from a command-line as well as run as a standalone application on Windows, Mac, and Linux devices. It is also an open source project, meaning that its code is available on GitHub and the tool will improve based on contributions (bug reports and new features) submitted via the community. The goal of Chunker is to provide an easily accessible interface to convert worlds between Minecraft: Bedrock Edition and Minecraft: Java Edition.  Although advanced options and settings exist, most worlds will not require any changes to successfully convert from one edition to another.  Chunker can currently convert:  Level settings World data (blocks, biomes, and tile entities) Multiple dimensions Container & items In-game maps  Chunker cannot currently convert:  Entities Player inventories  The feature set of Chunker will expand as it is developed further.   Note  Chunker will keep entities and player inventories if editing a world (outputting to source world version).  How to access Chunker  You can download Chunker from https://github.com/HiveGamesOSS/Chunker/releases. Your world is converted and worked with locally on your machine.  There are two versions of Chunker that you can download, the app version and the command line interface (CLI) version.  For this tutorial, we'll be working with the app version. Instructions for how to use the CLI version can be found here.  Converting a world with Chunker  It's simple to convert a world with Chunker. Loading Chunker will present you with the Upload World screen.  Choosing a world  There are two options to choose from:  Choose world folder allows you to select the root folder of either a Bedrock Edition or Java Edition world. The root folder is where the level.dat is located. More information on where you can find where worlds are stored can be found in the Getting Started with Add-On Development for Bedrock Edition article.  Select archive allows you to select either a zip, or an mcworld. Mcworlds are the files generated by Bedrock Edition with the export world functionality on the edit world screen.  You can also drag and drop a folder, zip, or mcworld, and Chunker will automatically detect the right mode to proceed with your upload.  Selecting a target output  After you have successfully uploaded your world, Chunker will show you all the available output options. Chunker can convert to other editions of the game and different versions of the source worlds format.  Depending on your needs, after selecting an output version, you can either instantly Convert or enter Advanced Mode to tweak the conversion settings.  More information on \"Advanced Mode\" and the features within it can be found in the advanced mode tutorial.  Conversion process  Chunker will now process all the data and convert your world to the desired output.  Depending on the size of your world, this may take a while. Most worlds, however, will be done and ready to download within a few minutes.  Save your world  Chunker will tell you when your world is converted. If any errors were encountered during conversion, these will also be displayed. You can use these anonymous error identifiers to report issues to the Chunker development team.  Click the Save button to save your converted world in the selected Output folder. If you want to distribute your converted world, you can upload it to a service such as OneDrive and share it.  You can now enjoy your freshly converted world. If you have converted to a Bedrock Edition format, it's as simple as opening the mcworld file - Minecraft will do the rest. To open a Java Edition world, you'll have to copy the folder to the saves directory.  What's Next?  Chunker can do more than simply convert a world. Read on to the next article which utilizes Advanced Mode.  Chunker - Advanced Mode  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkeradvancedmode?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - Advanced Mode 04/16/2025  Sometimes you need to perform more complex actions when converting your world. This article will explain some of the advanced functionality within Chunker.  Before converting, you can enter Advanced Mode to tweak conversion settings and perform more complex actions on your world. To use the Advanced Mode tools, click the tabs on the left side of the Chunker interface.  World Preview  World preview gives you a top-down view of the world you are about to convert. You can switch between different dimensions using the layers icon in the bottom right of the map. The map will also show you your pruning selection when using the prune chunks option.  The icons in the top-right detail how far along the conversion process you are. The icons represent the stages of conversion as follows:  The hopper represents the upload process The repeating command block represents the settings phase The furnace represents the conversion process The dispenser indicates that the conversion has finished and your world is ready to download World Settings  The World Settings tab provides an intuitive interface to edit the settings for your exported world. By default, Chunker will load the settings from the uploaded world and remap them to the platform equivalent where required.  Settings are grouped by their purpose. Use the tabs at the top of the Chunker interface to switch between settings groups. A full list of available world settings and their descriptions can be found here.   Important  Chunker allows you to edit settings and values that can cause unintended behavior, world corruption, or unstable gameplay if incorrectly set. Use caution when changing values.  Dimensions/Pruning  Chunker allows you to both remap and prune dimensions to a specific region of chunks.  Dimension Remapping  Remapping allows you to move data to a different dimension or drop the data altogether. To remap a dimension:  Select the tab of the dimension you want to modify. Select output dimension or none. Convert the world once you've finished with your conversion settings  Selecting none will exclude this dimension from the output world, wiping all data. For example, this can be used to clear The Nether to regenerate chunks with the new 1.16 nether biomes. A tutorial for clearing the Nether can be found here.   An example of the Overworld being remapped to The Nether. Spooky!  Chunk Pruning  Sometimes worlds will have excess data that you want to remove during the conversion process. This is particularly helpful in making survival spawns or other worlds you want to utilize seamless world generation.  Check out the survival spawn creation article for an in-depth tutorial into using Chunker to make survival spawns.  To prune a chunk, follow these instructions:  Enable Prune chunks outside of a region.  Enter the region coordinates of the chunks you want to keep. Any chunks outside of these coordinates will be excluded from the output world.  After you have input the coordinates, the world preview screen will visually show the region you have selected.  Convert the world once you've finished with your conversion settings.   Note  Chunker expects chunk coordinates. The easiest way to locate chunk coordinates is by using the Chunker world preview. Chunk coordinates are in the bottom left of the preview in brackets.  Converter Settings  Converter settings allow you to enable/disable features of Chunker. It's recommended to leave these as the default values.  Expand table Setting\tDescription Identifier Validation\tExperimental. Whether Chunker should ensure all block identifiers are valid Minecraft blocks. Do not enable this if you are using custom blocks. Calculate Block Connections\tWhether Chunker should emulate block connections. Disabling this may result in blocks, such as fences, not connecting to surrounding blocks. Convert Items\tWhether Chunker should convert the items in the world. If disabled, items in chests, block inventories, and item frames will not be converted. Convert Structure Loot Tables\tWhether Chunker should attempt to remap loot tables. In-Game Map Conversion\tWhether Chunker should convert the held maps to the new world. Enable Compact (Bedrock Edition only)\tWhether Chunker should run LevelDB compact after the conversion. This will reduce file-size but may cause the conversion to take longer. What's Next?  The Chunker - World Settings article covers a wide variety of world settings. If you have a Nether dimension that you want to reset in order to have up-to-date generation features, Chunker can be used to do that with Advanced Mode.  Chunker - World Settings Chunker - How to Clear The Nether  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkeradvancedmode?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - Advanced Mode 04/16/2025  Sometimes you need to perform more complex actions when converting your world. This article will explain some of the advanced functionality within Chunker.  Before converting, you can enter Advanced Mode to tweak conversion settings and perform more complex actions on your world. To use the Advanced Mode tools, click the tabs on the left side of the Chunker interface.  World Preview  World preview gives you a top-down view of the world you are about to convert. You can switch between different dimensions using the layers icon in the bottom right of the map. The map will also show you your pruning selection when using the prune chunks option.  The icons in the top-right detail how far along the conversion process you are. The icons represent the stages of conversion as follows:  The hopper represents the upload process The repeating command block represents the settings phase The furnace represents the conversion process The dispenser indicates that the conversion has finished and your world is ready to download World Settings  The World Settings tab provides an intuitive interface to edit the settings for your exported world. By default, Chunker will load the settings from the uploaded world and remap them to the platform equivalent where required.  Settings are grouped by their purpose. Use the tabs at the top of the Chunker interface to switch between settings groups. A full list of available world settings and their descriptions can be found here.   Important  Chunker allows you to edit settings and values that can cause unintended behavior, world corruption, or unstable gameplay if incorrectly set. Use caution when changing values.  Dimensions/Pruning  Chunker allows you to both remap and prune dimensions to a specific region of chunks.  Dimension Remapping  Remapping allows you to move data to a different dimension or drop the data altogether. To remap a dimension:  Select the tab of the dimension you want to modify. Select output dimension or none. Convert the world once you've finished with your conversion settings  Selecting none will exclude this dimension from the output world, wiping all data. For example, this can be used to clear The Nether to regenerate chunks with the new 1.16 nether biomes. A tutorial for clearing the Nether can be found here.   An example of the Overworld being remapped to The Nether. Spooky!  Chunk Pruning  Sometimes worlds will have excess data that you want to remove during the conversion process. This is particularly helpful in making survival spawns or other worlds you want to utilize seamless world generation.  Check out the survival spawn creation article for an in-depth tutorial into using Chunker to make survival spawns.  To prune a chunk, follow these instructions:  Enable Prune chunks outside of a region.  Enter the region coordinates of the chunks you want to keep. Any chunks outside of these coordinates will be excluded from the output world.  After you have input the coordinates, the world preview screen will visually show the region you have selected.  Convert the world once you've finished with your conversion settings.   Note  Chunker expects chunk coordinates. The easiest way to locate chunk coordinates is by using the Chunker world preview. Chunk coordinates are in the bottom left of the preview in brackets.  Converter Settings  Converter settings allow you to enable/disable features of Chunker. It's recommended to leave these as the default values.  Expand table Setting\tDescription Identifier Validation\tExperimental. Whether Chunker should ensure all block identifiers are valid Minecraft blocks. Do not enable this if you are using custom blocks. Calculate Block Connections\tWhether Chunker should emulate block connections. Disabling this may result in blocks, such as fences, not connecting to surrounding blocks. Convert Items\tWhether Chunker should convert the items in the world. If disabled, items in chests, block inventories, and item frames will not be converted. Convert Structure Loot Tables\tWhether Chunker should attempt to remap loot tables. In-Game Map Conversion\tWhether Chunker should convert the held maps to the new world. Enable Compact (Bedrock Edition only)\tWhether Chunker should run LevelDB compact after the conversion. This will reduce file-size but may cause the conversion to take longer. What's Next?  The Chunker - World Settings article covers a wide variety of world settings. If you have a Nether dimension that you want to reset in order to have up-to-date generation features, Chunker can be used to do that with Advanced Mode.  Chunker - World Settings Chunker - How to Clear The Nether  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkerworldsettings?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - World Settings 04/16/2025  Chunker allows you to change various world settings when converting worlds. This article gives a brief description of these options and how they affect gameplay.   Important  Editing these values can cause unintended behavior, world corruption, or unstable gameplay if set incorrectly. Use caution when changing values.  In this tutorial you will learn the following:  Various settings available when using Chunker to convert worlds. Requirements  It's recommended that the following be completed before beginning this tutorial.  Chunker - Advanced Mode World Settings Expand table Settings\tDescription Difficulty\tDifficulty of the world. Gamemode\tDefault game mode of the world. Players will default to this game mode on first join. Generator\tGenerator used for generating new chunks in this world. Setting to void will automatically create the custom layer rules to generate empty chunks. World Name\tFriendly name of this world (i.e \"Steve and Alex Super Survival\"). World Seed\tSeed provided to the generator to generate the world. Spawn X\tX coordinate of the default spawn for players. Spawn Y\tY coordinate of the default spawn for players. Spawn Z\tZ coordinate of the default spawn for players. Time\tCurrent time of the world (in ticks). Experimental Gameplay\t(Bedrock Edition only) Whether experimental game features are enabled in this world. Bonus Chest Enabled\t(Bedrock Edition only) Whether a bonus chest is enabled for this world. Bonus Chest Spawned\t(Bedrock Edition only) Has the bonus chest been spawned in the world? If set to false, the game will attempt to place a bonus chest on next load. Spawn Mobs\t(Bedrock Edition only) Whether this world should spawn mobs. Nether Scale\t(Bedrock Edition only) The scale of the Nether compared to the Overworld, which defaults to 8 in vanilla. If this value is set to 8, then every block moved in the Nether will equate to 8 blocks moved in the Overworld. Game Rules  Game rules are settings that can be modified in-game by operators using the /gamerule command or in-game menu.  Expand table Setting\tDescription Command Block Output\tWhether command blocks should output to chat for online operators. Command Blocks Enabled\tWhether command blocks are enabled in this world. Setting to false will cause command blocks to not execute. Commands Enabled\tWhether commands (commonly referred to as cheats) should be allowed in this world. Do Daylight Cycle\tWhether the time of day should cycle. If disabled, the time of day will not change. Do Entity Drops\tWhether items can be removed from an entity. For example, if disabled, players will not be able to remove items from an item frame. Do Fire Tick\tWhether fire should spread within this world. If disabled, fire will not spread to nearby flammable materials. Do Immediate Respawn\tIf enabled, players will instantly respawn without seeing the traditional respawn screen. Do Insomnia\tIf disabled, phantoms will not spawn during the night. Do Mob Loot\tWhether mobs should drop their loot when killed. Do Mob Spawning\tWhether mobs should spawn naturally in the world. Do Tile Drops\tWhether tiles (blocks) should drop their items when destroyed. Do Weather Cycle\tWhether the world should cycle weather. If disabled, the weather in the world will not change. Drowning Damage\tWhether entities can take damage from running out of air (drowning). Fall Damage\tWhether entities will take damage from falling from heights. Fire Damage\t(Bedrock Edition only) Whether entities will be damaged when ignited. Force Gamemode\tIf enabled, all players will be forced to remain in the worlds default game mode. Function Command Limit\tThe maximum number of simultaneous commands that can be executed by a function file. Keep Inventory\tWhether players should keep their inventory on death. Mob Griefing\tWhether mobs can grief the world (destroy/place blocks). Natural Regeneration\tWhether a player will naturally regenerate health when hunger is full. Random Tick Speed\tHow often Minecraft will tick world functionality. Set to 0 to disable functionality such as grass spread and leaf decay. Send Command Feedback\tWhether a command will send output in chat to the executor and online operators. Show Coordinates\t(Bedrock Edition only) Whether the client should show a UI element informing the player of their current coordinates. Show Death Messages\tWhether a message should be displayed in chat when an entity dies. TNT Explodes\t(Bedrock Edition only) Whether TNT will explode, causing world damage. Spawn Radius\tThe radius from the spawn used to pick a safe spawn location. Max Command Chain Length\tThe maximum amount of chain command blocks that can run in a single tick. Restrictions Expand table Setting\tDescription Confirmed Platform Locked Content\t(Bedrock Edition only) Whether this content is platform locked. Has Been Loaded In Creative\t(Bedrock Edition only) Whether this world has been loaded in creative mode. Has Locked Behavior Pack\t(Bedrock Edition only) Whether the behavior pack is locked. Has Locked Resource Pack\t(Bedrock Edition only) Whether the resource pack is locked. Immutable World\t(Bedrock Edition only) Indicates that the world cannot be modified, effectively making it read-only. Is From Locked Template\t(Bedrock Edition only) Whether this world was created from a locked template. Is From World Template\t(Bedrock Edition only) Whether this world was created from a world template. Is World Template Option Locked\t(Bedrock Edition only) Whether the options for this world are currently locked using the settings from the source world template. LAN Broadcast\t(Bedrock Edition only) Whether this world should broadcast its availability to devices on the local network. Limited World Origin X,Y,Z\t(Bedrock Edition only) Legacy. Used to indicate where limited world generation started. Texture Packs Required\t(Bedrock Edition only) Whether behavior and resource packs are required to join the world. Use MSA Gamertags Only\t(Bedrock Edition only) Whether the world is restricted to Microsoft Accounts only (players must be signed in). Weather Expand table Setting\tDescription Lightning Level\tDetermines how heavy the lightning is. Lightning Time\tNumber of ticks until lightning will be triggered. Rain Level\tDetermines how heavy the rain is. Rain Time\tNumber of ticks until rain will be triggered. Misc Expand table Setting\tDescription Center Maps To Origin\t(Bedrock Edition only) Whether maps (items) should be centered to the origin of the map. Education Features\t(Bedrock Edition only) Whether this world has Minecraft Education features enabled. EDU Level\t(Bedrock Edition only) The level of the EDU features to use. Server Chunk Tick Range\t(Bedrock Edition only) The distance of chunks around a player to tick server-side. Setting this to a high number can negatively impact performance. Start With Map Enabled\t(Bedrock Edition only) Whether new players start with a map. World Start Count\t(Bedrock Edition only) The number of times the world has been started. This is used to generate entity (actor) ids. What's Next?  If you have a Nether dimension that you want to reset in order to have up-to-date generation features, Chunker can be used to do that with Advanced Mode.  Chunker - How to Clear The Nether  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkerworldsettings?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - World Settings 04/16/2025  Chunker allows you to change various world settings when converting worlds. This article gives a brief description of these options and how they affect gameplay.   Important  Editing these values can cause unintended behavior, world corruption, or unstable gameplay if set incorrectly. Use caution when changing values.  In this tutorial you will learn the following:  Various settings available when using Chunker to convert worlds. Requirements  It's recommended that the following be completed before beginning this tutorial.  Chunker - Advanced Mode World Settings Expand table Settings\tDescription Difficulty\tDifficulty of the world. Gamemode\tDefault game mode of the world. Players will default to this game mode on first join. Generator\tGenerator used for generating new chunks in this world. Setting to void will automatically create the custom layer rules to generate empty chunks. World Name\tFriendly name of this world (i.e \"Steve and Alex Super Survival\"). World Seed\tSeed provided to the generator to generate the world. Spawn X\tX coordinate of the default spawn for players. Spawn Y\tY coordinate of the default spawn for players. Spawn Z\tZ coordinate of the default spawn for players. Time\tCurrent time of the world (in ticks). Experimental Gameplay\t(Bedrock Edition only) Whether experimental game features are enabled in this world. Bonus Chest Enabled\t(Bedrock Edition only) Whether a bonus chest is enabled for this world. Bonus Chest Spawned\t(Bedrock Edition only) Has the bonus chest been spawned in the world? If set to false, the game will attempt to place a bonus chest on next load. Spawn Mobs\t(Bedrock Edition only) Whether this world should spawn mobs. Nether Scale\t(Bedrock Edition only) The scale of the Nether compared to the Overworld, which defaults to 8 in vanilla. If this value is set to 8, then every block moved in the Nether will equate to 8 blocks moved in the Overworld. Game Rules  Game rules are settings that can be modified in-game by operators using the /gamerule command or in-game menu.  Expand table Setting\tDescription Command Block Output\tWhether command blocks should output to chat for online operators. Command Blocks Enabled\tWhether command blocks are enabled in this world. Setting to false will cause command blocks to not execute. Commands Enabled\tWhether commands (commonly referred to as cheats) should be allowed in this world. Do Daylight Cycle\tWhether the time of day should cycle. If disabled, the time of day will not change. Do Entity Drops\tWhether items can be removed from an entity. For example, if disabled, players will not be able to remove items from an item frame. Do Fire Tick\tWhether fire should spread within this world. If disabled, fire will not spread to nearby flammable materials. Do Immediate Respawn\tIf enabled, players will instantly respawn without seeing the traditional respawn screen. Do Insomnia\tIf disabled, phantoms will not spawn during the night. Do Mob Loot\tWhether mobs should drop their loot when killed. Do Mob Spawning\tWhether mobs should spawn naturally in the world. Do Tile Drops\tWhether tiles (blocks) should drop their items when destroyed. Do Weather Cycle\tWhether the world should cycle weather. If disabled, the weather in the world will not change. Drowning Damage\tWhether entities can take damage from running out of air (drowning). Fall Damage\tWhether entities will take damage from falling from heights. Fire Damage\t(Bedrock Edition only) Whether entities will be damaged when ignited. Force Gamemode\tIf enabled, all players will be forced to remain in the worlds default game mode. Function Command Limit\tThe maximum number of simultaneous commands that can be executed by a function file. Keep Inventory\tWhether players should keep their inventory on death. Mob Griefing\tWhether mobs can grief the world (destroy/place blocks). Natural Regeneration\tWhether a player will naturally regenerate health when hunger is full. Random Tick Speed\tHow often Minecraft will tick world functionality. Set to 0 to disable functionality such as grass spread and leaf decay. Send Command Feedback\tWhether a command will send output in chat to the executor and online operators. Show Coordinates\t(Bedrock Edition only) Whether the client should show a UI element informing the player of their current coordinates. Show Death Messages\tWhether a message should be displayed in chat when an entity dies. TNT Explodes\t(Bedrock Edition only) Whether TNT will explode, causing world damage. Spawn Radius\tThe radius from the spawn used to pick a safe spawn location. Max Command Chain Length\tThe maximum amount of chain command blocks that can run in a single tick. Restrictions Expand table Setting\tDescription Confirmed Platform Locked Content\t(Bedrock Edition only) Whether this content is platform locked. Has Been Loaded In Creative\t(Bedrock Edition only) Whether this world has been loaded in creative mode. Has Locked Behavior Pack\t(Bedrock Edition only) Whether the behavior pack is locked. Has Locked Resource Pack\t(Bedrock Edition only) Whether the resource pack is locked. Immutable World\t(Bedrock Edition only) Indicates that the world cannot be modified, effectively making it read-only. Is From Locked Template\t(Bedrock Edition only) Whether this world was created from a locked template. Is From World Template\t(Bedrock Edition only) Whether this world was created from a world template. Is World Template Option Locked\t(Bedrock Edition only) Whether the options for this world are currently locked using the settings from the source world template. LAN Broadcast\t(Bedrock Edition only) Whether this world should broadcast its availability to devices on the local network. Limited World Origin X,Y,Z\t(Bedrock Edition only) Legacy. Used to indicate where limited world generation started. Texture Packs Required\t(Bedrock Edition only) Whether behavior and resource packs are required to join the world. Use MSA Gamertags Only\t(Bedrock Edition only) Whether the world is restricted to Microsoft Accounts only (players must be signed in). Weather Expand table Setting\tDescription Lightning Level\tDetermines how heavy the lightning is. Lightning Time\tNumber of ticks until lightning will be triggered. Rain Level\tDetermines how heavy the rain is. Rain Time\tNumber of ticks until rain will be triggered. Misc Expand table Setting\tDescription Center Maps To Origin\t(Bedrock Edition only) Whether maps (items) should be centered to the origin of the map. Education Features\t(Bedrock Edition only) Whether this world has Minecraft Education features enabled. EDU Level\t(Bedrock Edition only) The level of the EDU features to use. Server Chunk Tick Range\t(Bedrock Edition only) The distance of chunks around a player to tick server-side. Setting this to a high number can negatively impact performance. Start With Map Enabled\t(Bedrock Edition only) Whether new players start with a map. World Start Count\t(Bedrock Edition only) The number of times the world has been started. This is used to generate entity (actor) ids. What's Next?  If you have a Nether dimension that you want to reset in order to have up-to-date generation features, Chunker can be used to do that with Advanced Mode.  Chunker - How to Clear The Nether  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkerthenether?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - How to Clear The Nether 04/16/2025  When Minecraft world generation is updated, only freshly generated chunks will use the updated generator. This guide explains how you can use Chunker to reset The Nether in your survival world.  The Nether Update saw The Nether transformed into a world with varying biomes, interesting new blocks, and marvelous new creatures. In this tutorial, we'll explain how you can bring the new Nether features into your existing survival world.  In this tutorial you will learn the following:  How to use Chunker to reset The Nether to obtain up-to-date generation features. Requirements  It's recommended that the following be completed before beginning this tutorial.  Chunker - Overview Chunker - Advanced Mode Chunker - World Settings Pick the world you want to upgrade  Find the survival world you want to bring up to date with the new Nether. We'll be using a world from Minecraft: Bedrock Edition.   Our current Nether, originally generated in Bedrock Edition 1.14.  Back up your world  When you are doing anything potentially destructive to a world, it's highly recommended you make a backup.  Information on how to back up your worlds can be found on the Mojang support website.  Load Chunker  Open the Chunker app. If you don't have Chunker, see Chunker - Overview.  Choose your world  Since we're using Bedrock Edition on Windows 10, we're going to use the built-in Export World functionality. This can be found at the bottom of the Edit World screen. After exporting, you'll have a .mcworld file that Chunker can understand.  In Chunker, click Select Archive. Navigate to the file you exported and select it. Click Start to load your world in Chunker.  Choose an export version  Because we only want to modify our world, select the version marked as Source Version. Selecting an output different to the source will cause Chunker to rebuild the world.  Once you've selected your source version, click the Advanced Mode button to continue.  Tell Chunker to remove The Nether  Chunker Advanced Mode allows you to modify conversion settings. To tell Chunker to remove The Nether, do the following:  Select the Dimensions/Pruning menu. Select the dimension you want to modify. In this case, Nether. Under Output Dimension, select None.  Convert  You can now click Convert, and Chunker will get to work on preparing your modified world. After a few moments a successful conversion screen should appear.  Save  Click Save to save your newly converted world.  Import World  As we used a Bedrock Edition world, importing is easy. Open the downloaded file, and Minecraft will import the world for you. After a few moments, your new world will appear on your world list ready to be played.   Note  This does not overwrite your current world. Your newly converted world will appear as a new world with the same name.  Enjoy your new Nether!  Open your world and jump into The Nether. If you followed all the above steps, The Nether should regenerate using the newest and greatest world generator.   Our new Nether! Taken from the same position as seen in step 1. Time to explore!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/chunkerthenether?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Chunker - How to Clear The Nether 04/16/2025  When Minecraft world generation is updated, only freshly generated chunks will use the updated generator. This guide explains how you can use Chunker to reset The Nether in your survival world.  The Nether Update saw The Nether transformed into a world with varying biomes, interesting new blocks, and marvelous new creatures. In this tutorial, we'll explain how you can bring the new Nether features into your existing survival world.  In this tutorial you will learn the following:  How to use Chunker to reset The Nether to obtain up-to-date generation features. Requirements  It's recommended that the following be completed before beginning this tutorial.  Chunker - Overview Chunker - Advanced Mode Chunker - World Settings Pick the world you want to upgrade  Find the survival world you want to bring up to date with the new Nether. We'll be using a world from Minecraft: Bedrock Edition.   Our current Nether, originally generated in Bedrock Edition 1.14.  Back up your world  When you are doing anything potentially destructive to a world, it's highly recommended you make a backup.  Information on how to back up your worlds can be found on the Mojang support website.  Load Chunker  Open the Chunker app. If you don't have Chunker, see Chunker - Overview.  Choose your world  Since we're using Bedrock Edition on Windows 10, we're going to use the built-in Export World functionality. This can be found at the bottom of the Edit World screen. After exporting, you'll have a .mcworld file that Chunker can understand.  In Chunker, click Select Archive. Navigate to the file you exported and select it. Click Start to load your world in Chunker.  Choose an export version  Because we only want to modify our world, select the version marked as Source Version. Selecting an output different to the source will cause Chunker to rebuild the world.  Once you've selected your source version, click the Advanced Mode button to continue.  Tell Chunker to remove The Nether  Chunker Advanced Mode allows you to modify conversion settings. To tell Chunker to remove The Nether, do the following:  Select the Dimensions/Pruning menu. Select the dimension you want to modify. In this case, Nether. Under Output Dimension, select None.  Convert  You can now click Convert, and Chunker will get to work on preparing your modified world. After a few moments a successful conversion screen should appear.  Save  Click Save to save your newly converted world.  Import World  As we used a Bedrock Edition world, importing is easy. Open the downloaded file, and Minecraft will import the world for you. After a few moments, your new world will appear on your world list ready to be played.   Note  This does not overwrite your current world. Your newly converted world will appear as a new world with the same name.  Enjoy your new Nether!  Open your world and jump into The Nether. If you followed all the above steps, The Nether should regenerate using the newest and greatest world generator.   Our new Nether! Taken from the same position as seen in step 1. Time to explore!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/editingnbtsafely?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editing NBT Safely 09/20/2023  This article introduces you to Named Binary Tag (NBT) editing -- the use of tools to edit data strings stored in entities, items, and some blocks -- and how to avoid editing it in such a way that's likely to break in the future.  In this tutorial you will learn the following:  What NBT data is and how it is used. Why NBT data might need to be edited. Best practices for editing NBT data. Requirements  It's recommended that the following be completed before beginning this tutorial.  Commonly Used Tools  For years, it's been a common practice for Minecraft map makers to use external tools to edit \"NBT,\" the data stored within entities, items, and some blocks that stores information such as names, damage values, or age. NBT is essentially a list of tags and corresponding values. For example, a zombie pigman would contain, among many others, an ID tag with a value of zombie_pigman. Using tools such as MCEdit or MCCToolChest to edit NBT can have powerful results and save creators a great deal of time. For instance, you might use a tool to edit the name of a mob by simply changing the value of its CustomName tag rather than having to use a name tag and anvil in-game.  However, there are cases where NBT editing has led to problems when Minecraft updates in a way that changes how a particular tag is written or read by the game. Most features in Minecraft are built to be played, not edited with external tools. Those tools simulate playing the game. You could change a chest's content in game, and a tool such as MCCToolChest writes data to the NBT as if you had done just that. However, problems often arise when map makers use tools to edit NBT in a way that couldn't theoretically be accomplished in-game.   Important  The golden rule is this: If you change things in a way that the game could never have written itself, you're at risk. If the game can't tell the difference between whether an NBT value was saved by the game itself or if it was hand-edited, you're generally safe.  Editing the NBT of a written book to change its text is fine; editing the NBT to exceed a book's in-game character limit isn't. Changing a cat's CatType to 5 makes it a calico; Changing it to 5000 is probably a bad idea.  Minecraft's developers can only expect their code to be edited in the ways they programmed it to be edited. You may find that editing an NBT tag in a certain way allows you to do something cool, but there's no guarantee that how that tag is handled won't be changed in the future since it wasn't intended to be edited that way in the first place.  For example, map creators used to make custom villager trades by editing several of a villager's NBT tags. One such change was often setting the TradeTier tag to a negative number so the villager would never unlock new trades like they do in survival Minecraft. Since Minecraft's developers never intended trades to work like that, they fundamentally changed the way the TradeTier tag works in the \"Village and Pillage\" update, breaking many custom villagers in maps. Today, custom trades are typically handled using loot table functions, a feature developed specifically for such a purpose.  Exceptions to this rule are usually due to years of creators editing NBT in a certain way in which Minecraft's developers had to build in support for them. For example, there's no way to write an item's lore tag in-game, but it's generally considered safe to do so in an editor.  This advice may extend to more than just NBT editing -- behaviors, commands, scripts, and other features of the game may all produce interesting results when you use them in a way they weren't intended. Minecraft is a living game and features are constantly being changed. While its developers clearly make every effort not to break your content, they can only be expected to know about the features they intentionally programmed. When creators rely on these unexpected \"tricks,\" and content breaks because of it, a burden is placed on the creator, their players, and the Microsoft developers who have to try to find ways around it. When in doubt, always test your content on new updates to check for content-breaking changes.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/editingnbtsafely?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editing NBT Safely 09/20/2023  This article introduces you to Named Binary Tag (NBT) editing -- the use of tools to edit data strings stored in entities, items, and some blocks -- and how to avoid editing it in such a way that's likely to break in the future.  In this tutorial you will learn the following:  What NBT data is and how it is used. Why NBT data might need to be edited. Best practices for editing NBT data. Requirements  It's recommended that the following be completed before beginning this tutorial.  Commonly Used Tools  For years, it's been a common practice for Minecraft map makers to use external tools to edit \"NBT,\" the data stored within entities, items, and some blocks that stores information such as names, damage values, or age. NBT is essentially a list of tags and corresponding values. For example, a zombie pigman would contain, among many others, an ID tag with a value of zombie_pigman. Using tools such as MCEdit or MCCToolChest to edit NBT can have powerful results and save creators a great deal of time. For instance, you might use a tool to edit the name of a mob by simply changing the value of its CustomName tag rather than having to use a name tag and anvil in-game.  However, there are cases where NBT editing has led to problems when Minecraft updates in a way that changes how a particular tag is written or read by the game. Most features in Minecraft are built to be played, not edited with external tools. Those tools simulate playing the game. You could change a chest's content in game, and a tool such as MCCToolChest writes data to the NBT as if you had done just that. However, problems often arise when map makers use tools to edit NBT in a way that couldn't theoretically be accomplished in-game.   Important  The golden rule is this: If you change things in a way that the game could never have written itself, you're at risk. If the game can't tell the difference between whether an NBT value was saved by the game itself or if it was hand-edited, you're generally safe.  Editing the NBT of a written book to change its text is fine; editing the NBT to exceed a book's in-game character limit isn't. Changing a cat's CatType to 5 makes it a calico; Changing it to 5000 is probably a bad idea.  Minecraft's developers can only expect their code to be edited in the ways they programmed it to be edited. You may find that editing an NBT tag in a certain way allows you to do something cool, but there's no guarantee that how that tag is handled won't be changed in the future since it wasn't intended to be edited that way in the first place.  For example, map creators used to make custom villager trades by editing several of a villager's NBT tags. One such change was often setting the TradeTier tag to a negative number so the villager would never unlock new trades like they do in survival Minecraft. Since Minecraft's developers never intended trades to work like that, they fundamentally changed the way the TradeTier tag works in the \"Village and Pillage\" update, breaking many custom villagers in maps. Today, custom trades are typically handled using loot table functions, a feature developed specifically for such a purpose.  Exceptions to this rule are usually due to years of creators editing NBT in a certain way in which Minecraft's developers had to build in support for them. For example, there's no way to write an item's lore tag in-game, but it's generally considered safe to do so in an editor.  This advice may extend to more than just NBT editing -- behaviors, commands, scripts, and other features of the game may all produce interesting results when you use them in a way they weren't intended. Minecraft is a living game and features are constantly being changed. While its developers clearly make every effort not to break your content, they can only be expected to know about the features they intentionally programmed. When creators rely on these unexpected \"tricks,\" and content breaks because of it, a burden is placed on the creator, their players, and the Microsoft developers who have to try to find ways around it. When in doubt, always test your content on new updates to check for content-breaking changes.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/designinggameplayforvariousdevices?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Designing Gameplay for Various Devices 01/19/2024  When creating content, it's important to consider that it will be played on many different devices varying wildly in control scheme, screen size, and processing power. Only a small percentage of Bedrock Edition users play on a PC, while the rest use the variety of cell phones and consoles that the engine supports. This means that, although content development likely takes place almost entirely on a PC, keyboard-and-mouse users are statistically the last group you should be designing around.  This article outlines some common problems creators may run into in the multi-platform ecosystem, but is by no means an exhaustive list. Ultimately, your biggest takeaway should be that you are developing content for an ever-expanding platform which will be interacted with in a multitude of ways. Integrate the design concepts of playability and flexibility into the core of your development process.  Performance  Bedrock Edition is available on most cell phones, and obviously these devices have a harder time running more intensive content, such as mini games with multiple commands or adventure maps with custom models. One important skill as a creator is balancing the complexity and quality of the content required to meet your vision while keeping in mind that as content becomes more complex, it becomes less playable for certain audiences.  Render Distance  Users on low-performance devices may be restricted to a shorter maximum render distance than what you develop with. For example, low-end devices may only be able to render a six or eight-chunk radius. Keep in mind when you're designing and building worlds that players may have limited vision. Whenever possible, design vital information to be visible from the shortest possible render distance. Rather than telling your players to walk towards a beacon in the far distance, give them \"breadcrumbs\" to follow, such as a pathway or a series of beacons so the path can be followed from short render distances. This extends to building style as well. Consider how your map looks to players on short render distances.  Sound  People use their cell phones almost everywhere, and it's common when playing a mobile game to mute your phone; keep this in mind when designing sounds.  In general, players should never be stuck because they couldn't or didn't hear something. In most cases, such as voice acting or important sound effects, you can simply mirror what's heard with a chat message. This is a basic concept in good, inclusive game design. If a player forgets what an NPC said, they should be able to check the chat or open a quest book to double-check. Captioning your audio not only helps users who choose to mute their game, it ensures your content is accessible to players with hearing loss or disabilities which should always be a consideration.  Interactions and Controls  A big difference in the way different control schemes interact with the world is how users interact with entities. On touchscreen devices interactions like breeding, feeding, and trading use a secondary button that appears on the screen when the player looks at the entity. This raises a few special considerations for creators.  First, be sure to should use the interact_text or equivalent parameter on any interaction components in custom entity behaviors to set the text that appears on the interaction button when touchscreen players look at the entity. This is vital for letting players know that an entity can be interacted with, and allows you to clearly communicate what happens when they do interact with it.  Second, consider building your custom entities with touch-friendly behaviors in mind. For example, if a mob can be interacted with using a certain item, consider giving the mob a high-priority goal to move towards players when they are holding that item type. This keeps the entity from unexpectedly walking away while the player is reaching for the interact button and accidentally punching the entity.  Touchscreen devices present another unique situation to creators as they have fewer buttons than other devices. For example, players using a keyboard press Q (by default) to drop a held item on the ground, while players on touchscreens must press and hold on the item in their hotbar for over two seconds to drop an item. Players on touchscreen devices also have no pick block button like console or mouse-and-keyboard players.  Fine Motor Controls  Map elements that require exact timing, such as difficult parkour courses, can be more challenging than expected when played on a touch screen or console. As a general rule, if something is \"difficult\" with a mouse and keyboard, it's nearly impossible for users on a touchscreen.  This is obviously a generalization, and many touchscreen or console users are incredible with their respective devices. A touchscreen isn't an inherently worse device, just one with a potentially steeper learning curve to reach the level of accuracy a PC player might take for granted. This is where testing on multiple devices is critical. Most creators will be surprised what you take for granted when you experience the game in a different way than usual.  Consider the difficulty some players may have with jumps that require pixel-perfect timing, turning corners mid-air, or other difficult maneuvers. Complex combat situations, like a player fighting a large number of enemies at once, may also prove difficult depending on control scheme.  In the end, of course, the content you design is completely up to you. No one's going to stop you from making \"Max-Distance Parkour on Glass Panes Over the Void: The Map,\" but we want to make sure you're cautious about decisions that may alienate portions of your player base.  What's Next?  These are a small sampling of the considerations to keep in mind when designing content for Bedrock Edition. Incorporating cross-platform design decisions is a key skill to developing content that's fun and engaging for all players. Pick up some devices to test on and get to work!  There are many next steps towards making content, from using command blocks for increased interaction with the game world to controlling a variety of entity actions with behavior packs. There are also plenty of tools to help you create your content. Coincidentally, here are some links to articles detailing all of those ideas!  Introduction to Command Blocks  Introduction to Resource Packs  Introduction to Behavior Packs  Commonly Used Tools  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/designinggameplayforvariousdevices?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Designing Gameplay for Various Devices 01/19/2024  When creating content, it's important to consider that it will be played on many different devices varying wildly in control scheme, screen size, and processing power. Only a small percentage of Bedrock Edition users play on a PC, while the rest use the variety of cell phones and consoles that the engine supports. This means that, although content development likely takes place almost entirely on a PC, keyboard-and-mouse users are statistically the last group you should be designing around.  This article outlines some common problems creators may run into in the multi-platform ecosystem, but is by no means an exhaustive list. Ultimately, your biggest takeaway should be that you are developing content for an ever-expanding platform which will be interacted with in a multitude of ways. Integrate the design concepts of playability and flexibility into the core of your development process.  Performance  Bedrock Edition is available on most cell phones, and obviously these devices have a harder time running more intensive content, such as mini games with multiple commands or adventure maps with custom models. One important skill as a creator is balancing the complexity and quality of the content required to meet your vision while keeping in mind that as content becomes more complex, it becomes less playable for certain audiences.  Render Distance  Users on low-performance devices may be restricted to a shorter maximum render distance than what you develop with. For example, low-end devices may only be able to render a six or eight-chunk radius. Keep in mind when you're designing and building worlds that players may have limited vision. Whenever possible, design vital information to be visible from the shortest possible render distance. Rather than telling your players to walk towards a beacon in the far distance, give them \"breadcrumbs\" to follow, such as a pathway or a series of beacons so the path can be followed from short render distances. This extends to building style as well. Consider how your map looks to players on short render distances.  Sound  People use their cell phones almost everywhere, and it's common when playing a mobile game to mute your phone; keep this in mind when designing sounds.  In general, players should never be stuck because they couldn't or didn't hear something. In most cases, such as voice acting or important sound effects, you can simply mirror what's heard with a chat message. This is a basic concept in good, inclusive game design. If a player forgets what an NPC said, they should be able to check the chat or open a quest book to double-check. Captioning your audio not only helps users who choose to mute their game, it ensures your content is accessible to players with hearing loss or disabilities which should always be a consideration.  Interactions and Controls  A big difference in the way different control schemes interact with the world is how users interact with entities. On touchscreen devices interactions like breeding, feeding, and trading use a secondary button that appears on the screen when the player looks at the entity. This raises a few special considerations for creators.  First, be sure to should use the interact_text or equivalent parameter on any interaction components in custom entity behaviors to set the text that appears on the interaction button when touchscreen players look at the entity. This is vital for letting players know that an entity can be interacted with, and allows you to clearly communicate what happens when they do interact with it.  Second, consider building your custom entities with touch-friendly behaviors in mind. For example, if a mob can be interacted with using a certain item, consider giving the mob a high-priority goal to move towards players when they are holding that item type. This keeps the entity from unexpectedly walking away while the player is reaching for the interact button and accidentally punching the entity.  Touchscreen devices present another unique situation to creators as they have fewer buttons than other devices. For example, players using a keyboard press Q (by default) to drop a held item on the ground, while players on touchscreens must press and hold on the item in their hotbar for over two seconds to drop an item. Players on touchscreen devices also have no pick block button like console or mouse-and-keyboard players.  Fine Motor Controls  Map elements that require exact timing, such as difficult parkour courses, can be more challenging than expected when played on a touch screen or console. As a general rule, if something is \"difficult\" with a mouse and keyboard, it's nearly impossible for users on a touchscreen.  This is obviously a generalization, and many touchscreen or console users are incredible with their respective devices. A touchscreen isn't an inherently worse device, just one with a potentially steeper learning curve to reach the level of accuracy a PC player might take for granted. This is where testing on multiple devices is critical. Most creators will be surprised what you take for granted when you experience the game in a different way than usual.  Consider the difficulty some players may have with jumps that require pixel-perfect timing, turning corners mid-air, or other difficult maneuvers. Complex combat situations, like a player fighting a large number of enemies at once, may also prove difficult depending on control scheme.  In the end, of course, the content you design is completely up to you. No one's going to stop you from making \"Max-Distance Parkour on Glass Panes Over the Void: The Map,\" but we want to make sure you're cautious about decisions that may alienate portions of your player base.  What's Next?  These are a small sampling of the considerations to keep in mind when designing content for Bedrock Edition. Incorporating cross-platform design decisions is a key skill to developing content that's fun and engaging for all players. Pick up some devices to test on and get to work!  There are many next steps towards making content, from using command blocks for increased interaction with the game world to controlling a variety of entity actions with behavior packs. There are also plenty of tools to help you create your content. Coincidentally, here are some links to articles detailing all of those ideas!  Introduction to Command Blocks  Introduction to Resource Packs  Introduction to Behavior Packs  Commonly Used Tools  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/basegameversioning?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn World Templates and Base Game Versioning 02/16/2024  If a world template relies on the behavior of certain entities, the world template may break if Minecraft is updated in a way that changes those behaviors. Base game versioning is a method of keeping current or future changes in Vanilla Minecraft: Bedrock Edition from causing unexpected changes to your world files, and allowing you to lock your world template to a specific Minecraft version. Base game versioning does not affect texture packs or skin packs.  For example, when running a version 1.18 client while the base_game_version of a world template is set to 1.15, the game will load the resources for all versions up to 1.15 and will skip any new resources implemented in 1.16 through 1.18.  Finally, the base game version can be updated at any time, including after content has been uploaded to the Minecraft Marketplace. Updating the base game version of a Marketplace world template will affect not only new world created from the template, but all worlds previously created from the template as well.   Important  Base game versioning was introduced in 1.13, and is the earliest version of the game that supports base game versioning. Do not try to set your base_game_version below 1.13.  Requirements  It's recommended that the following be completed before reviewing this article:  Creating a World Template Setup  In the header of your world template's manifest, you will need to specify the Minecraft version your world template was created for using the base_game_version field.  If your content doesn't depend on version features, like a simple map that is unlikely to break from future updates, you can use a \"wildcard\" in the field: \"base_game_version\": \"*\".  Example  The following example shows a world template using a base_game_version of [1, 13, 0]. If using this example, remember to update the header and module UUIDs.  JSON Copy {     \"format_version\": 2,     \"header\": {         \"name\": \"pack.name\",         \"description\": \"pack.description\",         \"version\": [ 1, 0, 0],         \"lock_template_options\": true,         \"base_game_version\": [ 1, 13, 0],         \"uuid\": \"<FIRST GENERATED UUID>\"     },     \"modules\": [         {         \"version\": [ 1, 0, 0],         \"type\": \"world_template\",         \"uuid\": \"<SECOND GENERATED UUID>\"         }     ],     \"metadata\": {         \"authors\": [\"Author Name\"]     } }   While specifying a version makes a world less likely to break due to updates, base game versioning can't replace testing and maintenance of your content for the best results.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/basegameversioning?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn World Templates and Base Game Versioning 02/16/2024  If a world template relies on the behavior of certain entities, the world template may break if Minecraft is updated in a way that changes those behaviors. Base game versioning is a method of keeping current or future changes in Vanilla Minecraft: Bedrock Edition from causing unexpected changes to your world files, and allowing you to lock your world template to a specific Minecraft version. Base game versioning does not affect texture packs or skin packs.  For example, when running a version 1.18 client while the base_game_version of a world template is set to 1.15, the game will load the resources for all versions up to 1.15 and will skip any new resources implemented in 1.16 through 1.18.  Finally, the base game version can be updated at any time, including after content has been uploaded to the Minecraft Marketplace. Updating the base game version of a Marketplace world template will affect not only new world created from the template, but all worlds previously created from the template as well.   Important  Base game versioning was introduced in 1.13, and is the earliest version of the game that supports base game versioning. Do not try to set your base_game_version below 1.13.  Requirements  It's recommended that the following be completed before reviewing this article:  Creating a World Template Setup  In the header of your world template's manifest, you will need to specify the Minecraft version your world template was created for using the base_game_version field.  If your content doesn't depend on version features, like a simple map that is unlikely to break from future updates, you can use a \"wildcard\" in the field: \"base_game_version\": \"*\".  Example  The following example shows a world template using a base_game_version of [1, 13, 0]. If using this example, remember to update the header and module UUIDs.  JSON Copy {     \"format_version\": 2,     \"header\": {         \"name\": \"pack.name\",         \"description\": \"pack.description\",         \"version\": [ 1, 0, 0],         \"lock_template_options\": true,         \"base_game_version\": [ 1, 13, 0],         \"uuid\": \"<FIRST GENERATED UUID>\"     },     \"modules\": [         {         \"version\": [ 1, 0, 0],         \"type\": \"world_template\",         \"uuid\": \"<SECOND GENERATED UUID>\"         }     ],     \"metadata\": {         \"authors\": [\"Author Name\"]     } }   While specifying a version makes a world less likely to break due to updates, base game versioning can't replace testing and maintenance of your content for the best results.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxgettingstarted?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Ray Tracing 06/11/2025   Tip  While ray tracing is still supported, it's largely been superseded by Vibrant Visuals.  Minecraft: Bedrock Edition has cutting-edge path-traced ray tracing, enabling gamers and world builders to craft incredible new sights and immersive environments. Physically-based textures have been introduced for creating more complex and realistic (or fabulously unrealistic!) block textures. To further enhance the visual experience of RTX, creators can also define their own settings for fog via resource packs.  With these new features, creators can dramatically change the look and feel of the game. Immerse players in volumetric fog or use a cutting-edge, dynamic lighting system to make a world more vibrant.   Ray Tracing Off with Physically-Based Textures   Ray Tracing On with Physically-Based Textures  By the end of this series, you will learn:  How ray tracing can be used Minecraft. How to enable ray tracing in Minecraft. How to create a physically-based texture resource pack. Requirements  It's recommended that you have the following when working with ray tracing in Minecraft: Bedrock Edition:  Operating System (OS): Windows 64-bit GPU: DirectX hardware ray tracing capable GPU like NVIDIA GeForce® RTX 20 Series and higher, and AMD Radeon RX 6000 Series and higher Hardware: PC CPU: Intel Core i5 or equivalent RAM: At least 8 GB of RAM Minecraft: version 1.16.200 or higher   Important  Virtual Reality (VR) headsets and Mixed Reality (MR) headsets are not supported.  Ray Tracing Examples in Minecraft  Ray tracing makes Minecraft look more like the real world. Rays of light shine from different sources onto block textures that can reflect, absorb, and scatter light in different ways. The result is a highly realistic depiction of the way light behaves, creating dramatic effects.  Expand table Features\tExample Sunbeams and atmospherics - Directional shafts of light typically occur at sunrise and sunset when sunlight passes through particles in the atmosphere or underwater.\t Dynamic shadows - More realistic shadows that change as lighting conditions change.\t Ambient Occlusion - shadows cast in corners or crevices where light rays cannot escape\t Reflections - Light bounces off surfaces, both casting and picking up color as it travels. Bouncing light hits smooth surfaces and maintains a spread depending on the material. This can create diffuse reflections or very sharp ones.\t Refraction - As light passes through translucent materials, it bends and bounces. The image you see may be distorted, refracted, and its color will be affected by the translucent material.\t Explore a Ray Tracing World in Minecraft  If you meet the minimum requirements and you are on the Windows version of the game, you can check out a ray tracing world now. Many free worlds featuring PBR and ray tracing are available in the Minecraft Marketplace, with more to come. You can find all the content supporting ray tracing in the Marketplace by selecting the blue icon.  Next, we will create PBR textures as a resource pack and you can enable it in the downloaded ray tracing world.  What's Next? Introduction to Physically Based Rendering  You will learn about each new texture map creators can use to build and design photorealistic materials and lighting effects, and you will learn how to use texture maps to create a mirror in-game.  Introduction to Physically Based Rendering  Fog in Resources  Along with ray tracing, fog in Minecraft has been updated to use a similar JSON structure that allows you to create and control its in-game appearance.  Fog in Resource Packs  Feedback  Was this page helpful?  Yes No Additional resources  Documentation  Physically Based Rendering Tutorial  A guide to creating textures using RTX Physically Based Rendering with Adobe Photoshop  Fog in Resource Packs  A guide detailing the way in which fogs are established in resource packs  Actor Storage in Minecraft - Bedrock Edition  How actor data is organized in the LevelDB on disk  Show 3 more  Training  Learning path  Get Started with Azure Remote Rendering - Training  Learn the fundamentals of rendering 3D models with Azure Remote Rendering."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxgettingstarted?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Ray Tracing 06/11/2025   Tip  While ray tracing is still supported, it's largely been superseded by Vibrant Visuals.  Minecraft: Bedrock Edition has cutting-edge path-traced ray tracing, enabling gamers and world builders to craft incredible new sights and immersive environments. Physically-based textures have been introduced for creating more complex and realistic (or fabulously unrealistic!) block textures. To further enhance the visual experience of RTX, creators can also define their own settings for fog via resource packs.  With these new features, creators can dramatically change the look and feel of the game. Immerse players in volumetric fog or use a cutting-edge, dynamic lighting system to make a world more vibrant.   Ray Tracing Off with Physically-Based Textures   Ray Tracing On with Physically-Based Textures  By the end of this series, you will learn:  How ray tracing can be used Minecraft. How to enable ray tracing in Minecraft. How to create a physically-based texture resource pack. Requirements  It's recommended that you have the following when working with ray tracing in Minecraft: Bedrock Edition:  Operating System (OS): Windows 64-bit GPU: DirectX hardware ray tracing capable GPU like NVIDIA GeForce® RTX 20 Series and higher, and AMD Radeon RX 6000 Series and higher Hardware: PC CPU: Intel Core i5 or equivalent RAM: At least 8 GB of RAM Minecraft: version 1.16.200 or higher   Important  Virtual Reality (VR) headsets and Mixed Reality (MR) headsets are not supported.  Ray Tracing Examples in Minecraft  Ray tracing makes Minecraft look more like the real world. Rays of light shine from different sources onto block textures that can reflect, absorb, and scatter light in different ways. The result is a highly realistic depiction of the way light behaves, creating dramatic effects.  Expand table Features\tExample Sunbeams and atmospherics - Directional shafts of light typically occur at sunrise and sunset when sunlight passes through particles in the atmosphere or underwater.\t Dynamic shadows - More realistic shadows that change as lighting conditions change.\t Ambient Occlusion - shadows cast in corners or crevices where light rays cannot escape\t Reflections - Light bounces off surfaces, both casting and picking up color as it travels. Bouncing light hits smooth surfaces and maintains a spread depending on the material. This can create diffuse reflections or very sharp ones.\t Refraction - As light passes through translucent materials, it bends and bounces. The image you see may be distorted, refracted, and its color will be affected by the translucent material.\t Explore a Ray Tracing World in Minecraft  If you meet the minimum requirements and you are on the Windows version of the game, you can check out a ray tracing world now. Many free worlds featuring PBR and ray tracing are available in the Minecraft Marketplace, with more to come. You can find all the content supporting ray tracing in the Marketplace by selecting the blue icon.  Next, we will create PBR textures as a resource pack and you can enable it in the downloaded ray tracing world.  What's Next? Introduction to Physically Based Rendering  You will learn about each new texture map creators can use to build and design photorealistic materials and lighting effects, and you will learn how to use texture maps to create a mirror in-game.  Introduction to Physically Based Rendering  Fog in Resources  Along with ray tracing, fog in Minecraft has been updated to use a similar JSON structure that allows you to create and control its in-game appearance.  Fog in Resource Packs  Feedback  Was this page helpful?  Yes No Additional resources  Documentation  Physically Based Rendering Tutorial  A guide to creating textures using RTX Physically Based Rendering with Adobe Photoshop  Fog in Resource Packs  A guide detailing the way in which fogs are established in resource packs  Actor Storage in Minecraft - Bedrock Edition  How actor data is organized in the LevelDB on disk  Show 3 more  Training  Learning path  Get Started with Azure Remote Rendering - Training  Learn the fundamentals of rendering 3D models with Azure Remote Rendering."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxpbrintro?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Overview of Physically Based Rendering 06/11/2025  Physically Based Rendering, or PBR, simulates how materials would react to realistic light behavior. Metallic surfaces cast reflections; light bends and refracts through different types of glass. For objects you create to take advantage of PBR, you'll need to create special textures that capture properties of the material, such as metallic properties, emissive properties, and roughness (often abbreviated together as \"MER\").  By the end of this overview, you'll learn:  The new texture maps available in Minecraft: Bedrock Edition. The basic workflows when designing PBR textures for Minecraft. How to create a mirror texture set using roughness and metallic maps. Prerequisites  It'll be helpful to have read the Introduction to Resource Packs before reading this document. You'll need a ready-to-go Resource Pack with the textures/blocks folder structure set up.  While we'll provide textures to download, you'll need to have some digital painting software that has layers to create your textures, such as the Windows 11 version of Microsoft Paint, Adobe Photoshop, or PaintTool SAI.  What makes a PBR texture?  In Minecraft, 3D blocks are given detail by applying 2D images to them using a common rendering method called Texture Mapping. Standard Minecraft blocks use a single texture map, an image with four color channels: Red, Blue, Green, and Alpha (RGBA). Most image editors work with RGBA images: the first three channels provide the color for each image pixel, while the alpha channel controls that pixel's transparency level.  PBR introduces five new maps for textures that set values for different kinds of properties for each pixel in the color map:  Metalness Map Emissive Map Roughness Map Normal Map Height Map  Together, these maps give you a great deal of control over how blocks you add to your resource packs are rendered when placed in the world. Let's look at each kind of map in turn.   Important  Not all PBR texture sets require all maps. Leaving empty maps will cause the texture set to use the default value.  Metalness map  A Metalness map is a grayscale texture that determines which areas of a texture map look like metal. The brighter the pixel is, the more metallic it will look.  A pixel set to pure black is completely non-metallic, with a value of 0.0. Grass, dirt, and tree bark are completely non-metallic objects. A pixel set to pure white is completely metallic, with a value of 1.0. Iron, gold, and copper are examples of completely metallic objects. Pixels between pure black and pure white will look more or less metallic, depending on how bright or dark they are.  The above image uses the following metalness map:  Emissive map  An Emissive map is a grayscale texture that determines which areas of a texture map emit light.  A pixel set to pure black is completely non-emissive (dark), with a value of 0.0. A pixel set to pure white is completely emissive (glowing at its brightest), with a value of 1.0. Pixels between pure black and pure white will glow more or less brightly, depending on how bright or dark they are.  The above image uses the following emissive map:  Roughness map  A Roughness map is a grayscale texture that determines which areas of the texture map are smooth and which are rough.  A pixel set to pure black is as smooth as possible, with a value of 0.0. Smooth marble, glass, or smooth plastic are very smooth. A pixel set to pure white is as rough as possible, with a value of 1.0. Brick, tree bark, and stones are very rough. Pixels between pure black and pure white will look more or less rough, depending on how bright or dark they are.  The above image uses the following roughness map:  Normal map  A Normal map is an RGB texture (not grayscale) that controls the depth and how light behaves when a light ray hits the texture. \"Normal\" refers to the concept of a surface normal in geometry, and the R, G, and B elements in the normal map correspond to the X, Y, and Z coordinates of the surface. Values of R (X) 128, G (Y) 128, and B (Z) 255 result in a flat appearance of the pixel.   Caution  Unless you have experience with creating Normal maps, it's recommended that you do not create Normal maps by hand. Third-party software is available to assist with creating Normal maps.  Height map  A Height map is a grayscale texture that controls depth of a texture. Height maps act as an alternative to Normal maps, but are not as efficient and cannot represent as many textures.  A pixel set to pure black extrudes inward as much as possible, with a value of 0.0. A pixel set to pure white extrudes outward as much as possible, with a value of 1.0. A pixel midway between pure black and pure white (127, 127, 127), with a value of 0.5, does not extrude in or out.  The above image uses the following height map:  Make a mirror  Let's create a mirror texture for an existing vanilla block by creating a Texture Set JSON file and using a provided texture file.  Make a texture set JSON  For the Texture Set to work properly, you will need to define a JSON file to load the textures. This tutorial is a mirror example working with the iron_block block.   Tip  To learn more about texture sets, please read Introduction to Texture Sets.  In your behavior pack, navigate to the textures/blocks folder. Create a new .JSON file and name it iron_block.texture_set.json. Double-click on iron_block.texture_set.json to edit the contents. Copy the following example into the file: JSON Copy {     \"format_version\": \"1.16.100\",     \"minecraft:texture_set\": {     \"color\": \"iron_block\",     \"metalness_emissive_roughness\": \"iron_block_mer\"     } }  Save and close the file.  With the JSON file set up, you can now configure the textures for the color values and the metalness_emissive_roughness values.  Add the PBR capability  The manifest.json file for the pack requires the value \"pbr\" to be added in a capabilities section below your existing header and modules:  JSON Copy {     \"format_version\": 1,     \"header\": {         \"name\": \"RTX Sample Resources\",         \"description\": \"\",         \"uuid\": \"58d4560c-106d-4b0c-9847-eee47417fb05\",         \"min_engine_version\": [1, 12, 0],         \"version\": [1, 0, 0]     },     \"modules\": [         {             \"description\": \"\",             \"type\": \"resources\",             \"uuid\": \"2d3df25b-856a-406d-9a57-c87b9a4d7af8\",             \"version\": [0, 0, 1]         }     ],     \"capabilities\" : [         \"pbr\"     ] }  Add the textures  To create a mirror in a PBR workflow, you need a Roughness map and a Metalness map. A Roughness map with a value of 0.0, or solid black, will create a smooth surface for light to reflect off. A Metalness map set to a value of 1.0, or solid white, will render the block like reflective metal.  Download these two PNG files, iron_block.png (the color texture map) and iron_block_mer.png (the MER texture map), by right-clicking them and selecting Save image as:   iron_block.png  iron_block_mer.png  Copy and paste both .png files into the textures/blocks folder.  Run the texture pack  With the JSON file properly set up and both textures in place, you can now load in your texture pack to test in Minecraft.  What's next? Learn how to use Blockbench to create MER-mapped models. Learn about Lighting Customization. Control the in-game appearance of Fog using a similar JSON structure. Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxpbrintro?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Overview of Physically Based Rendering 06/11/2025  Physically Based Rendering, or PBR, simulates how materials would react to realistic light behavior. Metallic surfaces cast reflections; light bends and refracts through different types of glass. For objects you create to take advantage of PBR, you'll need to create special textures that capture properties of the material, such as metallic properties, emissive properties, and roughness (often abbreviated together as \"MER\").  By the end of this overview, you'll learn:  The new texture maps available in Minecraft: Bedrock Edition. The basic workflows when designing PBR textures for Minecraft. How to create a mirror texture set using roughness and metallic maps. Prerequisites  It'll be helpful to have read the Introduction to Resource Packs before reading this document. You'll need a ready-to-go Resource Pack with the textures/blocks folder structure set up.  While we'll provide textures to download, you'll need to have some digital painting software that has layers to create your textures, such as the Windows 11 version of Microsoft Paint, Adobe Photoshop, or PaintTool SAI.  What makes a PBR texture?  In Minecraft, 3D blocks are given detail by applying 2D images to them using a common rendering method called Texture Mapping. Standard Minecraft blocks use a single texture map, an image with four color channels: Red, Blue, Green, and Alpha (RGBA). Most image editors work with RGBA images: the first three channels provide the color for each image pixel, while the alpha channel controls that pixel's transparency level.  PBR introduces five new maps for textures that set values for different kinds of properties for each pixel in the color map:  Metalness Map Emissive Map Roughness Map Normal Map Height Map  Together, these maps give you a great deal of control over how blocks you add to your resource packs are rendered when placed in the world. Let's look at each kind of map in turn.   Important  Not all PBR texture sets require all maps. Leaving empty maps will cause the texture set to use the default value.  Metalness map  A Metalness map is a grayscale texture that determines which areas of a texture map look like metal. The brighter the pixel is, the more metallic it will look.  A pixel set to pure black is completely non-metallic, with a value of 0.0. Grass, dirt, and tree bark are completely non-metallic objects. A pixel set to pure white is completely metallic, with a value of 1.0. Iron, gold, and copper are examples of completely metallic objects. Pixels between pure black and pure white will look more or less metallic, depending on how bright or dark they are.  The above image uses the following metalness map:  Emissive map  An Emissive map is a grayscale texture that determines which areas of a texture map emit light.  A pixel set to pure black is completely non-emissive (dark), with a value of 0.0. A pixel set to pure white is completely emissive (glowing at its brightest), with a value of 1.0. Pixels between pure black and pure white will glow more or less brightly, depending on how bright or dark they are.  The above image uses the following emissive map:  Roughness map  A Roughness map is a grayscale texture that determines which areas of the texture map are smooth and which are rough.  A pixel set to pure black is as smooth as possible, with a value of 0.0. Smooth marble, glass, or smooth plastic are very smooth. A pixel set to pure white is as rough as possible, with a value of 1.0. Brick, tree bark, and stones are very rough. Pixels between pure black and pure white will look more or less rough, depending on how bright or dark they are.  The above image uses the following roughness map:  Normal map  A Normal map is an RGB texture (not grayscale) that controls the depth and how light behaves when a light ray hits the texture. \"Normal\" refers to the concept of a surface normal in geometry, and the R, G, and B elements in the normal map correspond to the X, Y, and Z coordinates of the surface. Values of R (X) 128, G (Y) 128, and B (Z) 255 result in a flat appearance of the pixel.   Caution  Unless you have experience with creating Normal maps, it's recommended that you do not create Normal maps by hand. Third-party software is available to assist with creating Normal maps.  Height map  A Height map is a grayscale texture that controls depth of a texture. Height maps act as an alternative to Normal maps, but are not as efficient and cannot represent as many textures.  A pixel set to pure black extrudes inward as much as possible, with a value of 0.0. A pixel set to pure white extrudes outward as much as possible, with a value of 1.0. A pixel midway between pure black and pure white (127, 127, 127), with a value of 0.5, does not extrude in or out.  The above image uses the following height map:  Make a mirror  Let's create a mirror texture for an existing vanilla block by creating a Texture Set JSON file and using a provided texture file.  Make a texture set JSON  For the Texture Set to work properly, you will need to define a JSON file to load the textures. This tutorial is a mirror example working with the iron_block block.   Tip  To learn more about texture sets, please read Introduction to Texture Sets.  In your behavior pack, navigate to the textures/blocks folder. Create a new .JSON file and name it iron_block.texture_set.json. Double-click on iron_block.texture_set.json to edit the contents. Copy the following example into the file: JSON Copy {     \"format_version\": \"1.16.100\",     \"minecraft:texture_set\": {     \"color\": \"iron_block\",     \"metalness_emissive_roughness\": \"iron_block_mer\"     } }  Save and close the file.  With the JSON file set up, you can now configure the textures for the color values and the metalness_emissive_roughness values.  Add the PBR capability  The manifest.json file for the pack requires the value \"pbr\" to be added in a capabilities section below your existing header and modules:  JSON Copy {     \"format_version\": 1,     \"header\": {         \"name\": \"RTX Sample Resources\",         \"description\": \"\",         \"uuid\": \"58d4560c-106d-4b0c-9847-eee47417fb05\",         \"min_engine_version\": [1, 12, 0],         \"version\": [1, 0, 0]     },     \"modules\": [         {             \"description\": \"\",             \"type\": \"resources\",             \"uuid\": \"2d3df25b-856a-406d-9a57-c87b9a4d7af8\",             \"version\": [0, 0, 1]         }     ],     \"capabilities\" : [         \"pbr\"     ] }  Add the textures  To create a mirror in a PBR workflow, you need a Roughness map and a Metalness map. A Roughness map with a value of 0.0, or solid black, will create a smooth surface for light to reflect off. A Metalness map set to a value of 1.0, or solid white, will render the block like reflective metal.  Download these two PNG files, iron_block.png (the color texture map) and iron_block_mer.png (the MER texture map), by right-clicking them and selecting Save image as:   iron_block.png  iron_block_mer.png  Copy and paste both .png files into the textures/blocks folder.  Run the texture pack  With the JSON file properly set up and both textures in place, you can now load in your texture pack to test in Minecraft.  What's next? Learn how to use Blockbench to create MER-mapped models. Learn about Lighting Customization. Control the in-game appearance of Fog using a similar JSON structure. Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Vibrant Visuals  Tutorials and references for Vibrant Visuals in Minecraft: Bedrock Edition.  Get Started OVERVIEW Intro to Vibrant Visuals Overview of Physically Based Rendering GET STARTED Vibrant Visuals Resource Packs Use Blockbench to Create Vibrant Visuals Models Customize Your Lighting REFERENCE Light Sources Atmospheric Effects Volumetric Fog and Light Shafts Shadows Water Effects Color Grading and Tone Mapping Subsurface Scattering Per-Biome Customization Key Frame JSON Syntax"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Vibrant Visuals  Tutorials and references for Vibrant Visuals in Minecraft: Bedrock Edition.  Get Started OVERVIEW Intro to Vibrant Visuals Overview of Physically Based Rendering GET STARTED Vibrant Visuals Resource Packs Use Blockbench to Create Vibrant Visuals Models Customize Your Lighting REFERENCE Light Sources Atmospheric Effects Volumetric Fog and Light Shafts Shadows Water Effects Color Grading and Tone Mapping Subsurface Scattering Per-Biome Customization Key Frame JSON Syntax"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/introvibrantvisuals?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Vibrant Visuals 06/11/2025  Minecraft: Bedrock Edition's new Vibrant Visuals feature is a sweeping new upgrade to Minecraft's rendering capabilities, offering directional lighting, volumetric fog, atmospheric effects, and more.  Vibrant Visuals affects Minecraft's graphics, but makes no changes to gameplay, so the change is completely backwards-compatible. It runs entirely locally, so players can choose whether to enable it on their machine or not.  The Vibrant Visuals system is built around a Physically Based Rendering (PBR) pipeline used for deferred lighting and ray tracing. The pipeline combines modeling texture-mapped surface details as well as multiple illumination sources into a lighting model that accurately reflects light and shadows across all times of day. By taking advantage of Vibrant Visuals, you'll unlock new creative control over the mood and lighting conditions of your entire scene.  For example, you can control the intensity and color of the sun and moon, affecting how they contribute to the scene through aspects like direct lighting, bloom activation, exposure sensitivity, and shadow angle.  Additionally, new properties for describing the atmosphere of your world enable a new level of control over your skies! All these customization points coupled with the new key frame JSON syntax allow you to change any detail of your lighting over the course of the in-game day-night cycle.  Enabling Vibrant Visuals  Launch Minecraft and go to the Settings screen. Select Video settings, and select the Graphics Mode drop-down.  The UI element will change to a checklist with an option for Vibrant Visuals. Check this option, and your world will be rendered with the new Vibrant Visuals mode!  Adding Vibrant Visuals to your creations  To take advantage of physically-based rendering in your resource packs, they'll need to have the \"pbr\" capability string added to their manifest.json file. Resource packs built for RTX raytracing, with the \"raytracing\" capability, should also work with the new pipeline, but you'll likely want to add more features to make full use of PBR.   Note  New capabilities are NOT backwards-compatible with the RTX pipeline.  All newly added lighting capabilities are opt-in, and appropriate defaults will be used if any parameters aren't supplied by a resource pack. These properties are also designed to complement and extend the existing Texture Set capabilities found in RTX resource packs. (Texture Sets are no longer restricted to RTX-only packs.)  Overview of Physically Based Rendering Vibrant Visuals Resource Packs  Feedback  Was this page helpful?  Yes No Additional resources  Training  Module  Minecraft 101: Craft a game-based learning classroom - Training  Understand teaching and learning with games with Minecraft Education. Gain skills to integrate Minecraft into teaching and enhance lessons."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/introvibrantvisuals?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Vibrant Visuals 06/11/2025  Minecraft: Bedrock Edition's new Vibrant Visuals feature is a sweeping new upgrade to Minecraft's rendering capabilities, offering directional lighting, volumetric fog, atmospheric effects, and more.  Vibrant Visuals affects Minecraft's graphics, but makes no changes to gameplay, so the change is completely backwards-compatible. It runs entirely locally, so players can choose whether to enable it on their machine or not.  The Vibrant Visuals system is built around a Physically Based Rendering (PBR) pipeline used for deferred lighting and ray tracing. The pipeline combines modeling texture-mapped surface details as well as multiple illumination sources into a lighting model that accurately reflects light and shadows across all times of day. By taking advantage of Vibrant Visuals, you'll unlock new creative control over the mood and lighting conditions of your entire scene.  For example, you can control the intensity and color of the sun and moon, affecting how they contribute to the scene through aspects like direct lighting, bloom activation, exposure sensitivity, and shadow angle.  Additionally, new properties for describing the atmosphere of your world enable a new level of control over your skies! All these customization points coupled with the new key frame JSON syntax allow you to change any detail of your lighting over the course of the in-game day-night cycle.  Enabling Vibrant Visuals  Launch Minecraft and go to the Settings screen. Select Video settings, and select the Graphics Mode drop-down.  The UI element will change to a checklist with an option for Vibrant Visuals. Check this option, and your world will be rendered with the new Vibrant Visuals mode!  Adding Vibrant Visuals to your creations  To take advantage of physically-based rendering in your resource packs, they'll need to have the \"pbr\" capability string added to their manifest.json file. Resource packs built for RTX raytracing, with the \"raytracing\" capability, should also work with the new pipeline, but you'll likely want to add more features to make full use of PBR.   Note  New capabilities are NOT backwards-compatible with the RTX pipeline.  All newly added lighting capabilities are opt-in, and appropriate defaults will be used if any parameters aren't supplied by a resource pack. These properties are also designed to complement and extend the existing Texture Set capabilities found in RTX resource packs. (Texture Sets are no longer restricted to RTX-only packs.)  Overview of Physically Based Rendering Vibrant Visuals Resource Packs  Feedback  Was this page helpful?  Yes No Additional resources  Training  Module  Minecraft 101: Craft a game-based learning classroom - Training  Understand teaching and learning with games with Minecraft Education. Gain skills to integrate Minecraft into teaching and enhance lessons."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/vvresourcepacks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Vibrant Visuals Resource Packs 06/11/2025  Vibrant Visuals use the same rules for Physically Based Rendering (PBR) texture sets that are used for ray tracing (RTX). If you're not familiar with PBR texture sets, read the overview; there's more detail on creating texture sets in the reference section Introduction to Texture Sets.  The new pipeline supports both Height Map and Normal Map inputs for bump mapping. In addition, you can now set PBR textures for not just blocks but entities, mobs, particles, and items! They follow the same texture set rules as blocks; you just need to add them to the correct folder in your resource pack: textures/entity, textures/particle, or textures/items.  Vibrant Visuals also supports a new texture set property that describes a material's subsurface scattering properties in addition to its metallic, emissive, and roughness (MER) properties. For more details, read about Subsurface Scattering customization, or consult the Texture Sets documentation.  To let Minecraft know your resource pack includes Vibrant Visuals assets, you need to add the \"pbr\" capability to the capabilities array of your pack's manifest.json file:  JSON Copy {    \"format_version\": 1,   \"header\": {     ...   },    \"modules\": [     ...   ],    \"capabilities\": [     \"pbr\"   ] }   Because the assets required for RTX raytracing are a subset of the assets needed for Vibrant Visuals, a pack with the \"raytraced\" capability also activates Vibrant Visuals. However, it's recommended that you use the \"pbr\" string for your Vibrant Visuals packs; Vibrant Visuals is cross-platform, while RTX raytracing is restricted to RTX-only devices.  Vibrant Visuals JSON files  Texture Sets define the surface properties of individual blocks or entities, but global lighting properties are defined with Keyframe JSON files. The folder structure for a Vibrant Visuals resource pack with all possible PBR and lighting JSON files looks like this:  Feedback  Was this page helpful?  Yes No Additional resources  Training  Learning path  Deploy and manage resources in Azure by using JSON ARM templates - Training  Learn how JSON ARM templates enable you to manage both basic and complex infrastructure deployments on Azure."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/vvresourcepacks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Vibrant Visuals Resource Packs 06/11/2025  Vibrant Visuals use the same rules for Physically Based Rendering (PBR) texture sets that are used for ray tracing (RTX). If you're not familiar with PBR texture sets, read the overview; there's more detail on creating texture sets in the reference section Introduction to Texture Sets.  The new pipeline supports both Height Map and Normal Map inputs for bump mapping. In addition, you can now set PBR textures for not just blocks but entities, mobs, particles, and items! They follow the same texture set rules as blocks; you just need to add them to the correct folder in your resource pack: textures/entity, textures/particle, or textures/items.  Vibrant Visuals also supports a new texture set property that describes a material's subsurface scattering properties in addition to its metallic, emissive, and roughness (MER) properties. For more details, read about Subsurface Scattering customization, or consult the Texture Sets documentation.  To let Minecraft know your resource pack includes Vibrant Visuals assets, you need to add the \"pbr\" capability to the capabilities array of your pack's manifest.json file:  JSON Copy {    \"format_version\": 1,   \"header\": {     ...   },    \"modules\": [     ...   ],    \"capabilities\": [     \"pbr\"   ] }   Because the assets required for RTX raytracing are a subset of the assets needed for Vibrant Visuals, a pack with the \"raytraced\" capability also activates Vibrant Visuals. However, it's recommended that you use the \"pbr\" string for your Vibrant Visuals packs; Vibrant Visuals is cross-platform, while RTX raytracing is restricted to RTX-only devices.  Vibrant Visuals JSON files  Texture Sets define the surface properties of individual blocks or entities, but global lighting properties are defined with Keyframe JSON files. The folder structure for a Vibrant Visuals resource pack with all possible PBR and lighting JSON files looks like this:  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/pbroverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Overview of Physically Based Rendering 06/11/2025  Physically Based Rendering, or PBR, simulates how materials would react to realistic light behavior. Metallic surfaces cast reflections; light bends and refracts through different types of glass. For objects you create to take advantage of PBR, you'll need to create special textures that capture properties of the material, such as metallic properties, emissive properties, and roughness (often abbreviated together as \"MER\").  By the end of this overview, you'll learn:  The new texture maps available in Minecraft: Bedrock Edition. The basic workflows when designing PBR textures for Minecraft. How to create a mirror texture set using roughness and metallic maps. Prerequisites  It'll be helpful to have read the Introduction to Resource Packs before reading this document. You'll need a ready-to-go Resource Pack with the textures/blocks folder structure set up.  While we'll provide textures to download, you'll need to have some digital painting software that has layers to create your textures, such as the Windows 11 version of Microsoft Paint, Adobe Photoshop, or PaintTool SAI.  What makes a PBR texture?  In Minecraft, 3D blocks are given detail by applying 2D images to them using a common rendering method called Texture Mapping. Standard Minecraft blocks use a single texture map, an image with four color channels: Red, Blue, Green, and Alpha (RGBA). Most image editors work with RGBA images: the first three channels provide the color for each image pixel, while the alpha channel controls that pixel's transparency level.  PBR introduces five new maps for textures that set values for different kinds of properties for each pixel in the color map:  Metalness Map Emissive Map Roughness Map Normal Map Height Map  Together, these maps give you a great deal of control over how blocks you add to your resource packs are rendered when placed in the world. Let's look at each kind of map in turn.   Important  Not all PBR texture sets require all maps. Leaving empty maps will cause the texture set to use the default value.  Metalness map  A Metalness map is a grayscale texture that determines which areas of a texture map look like metal. The brighter the pixel is, the more metallic it will look.  A pixel set to pure black is completely non-metallic, with a value of 0.0. Grass, dirt, and tree bark are completely non-metallic objects. A pixel set to pure white is completely metallic, with a value of 1.0. Iron, gold, and copper are examples of completely metallic objects. Pixels between pure black and pure white will look more or less metallic, depending on how bright or dark they are.  The above image uses the following metalness map:  Emissive map  An Emissive map is a grayscale texture that determines which areas of a texture map emit light.  A pixel set to pure black is completely non-emissive (dark), with a value of 0.0. A pixel set to pure white is completely emissive (glowing at its brightest), with a value of 1.0. Pixels between pure black and pure white will glow more or less brightly, depending on how bright or dark they are.  The above image uses the following emissive map:  Roughness map  A Roughness map is a grayscale texture that determines which areas of the texture map are smooth and which are rough.  A pixel set to pure black is as smooth as possible, with a value of 0.0. Smooth marble, glass, or smooth plastic are very smooth. A pixel set to pure white is as rough as possible, with a value of 1.0. Brick, tree bark, and stones are very rough. Pixels between pure black and pure white will look more or less rough, depending on how bright or dark they are.  The above image uses the following roughness map:  Normal map  A Normal map is an RGB texture (not grayscale) that controls the depth and how light behaves when a light ray hits the texture. \"Normal\" refers to the concept of a surface normal in geometry, and the R, G, and B elements in the normal map correspond to the X, Y, and Z coordinates of the surface. Values of R (X) 128, G (Y) 128, and B (Z) 255 result in a flat appearance of the pixel.   Caution  Unless you have experience with creating Normal maps, it's recommended that you do not create Normal maps by hand. Third-party software is available to assist with creating Normal maps.  Height map  A Height map is a grayscale texture that controls depth of a texture. Height maps act as an alternative to Normal maps, but are not as efficient and cannot represent as many textures.  A pixel set to pure black extrudes inward as much as possible, with a value of 0.0. A pixel set to pure white extrudes outward as much as possible, with a value of 1.0. A pixel midway between pure black and pure white (127, 127, 127), with a value of 0.5, does not extrude in or out.  The above image uses the following height map:  Make a mirror  Let's create a mirror texture for an existing vanilla block by creating a Texture Set JSON file and using a provided texture file.  Make a texture set JSON  For the Texture Set to work properly, you will need to define a JSON file to load the textures. This tutorial is a mirror example working with the iron_block block.   Tip  To learn more about texture sets, please read Introduction to Texture Sets.  In your behavior pack, navigate to the textures/blocks folder. Create a new .JSON file and name it iron_block.texture_set.json. Double-click on iron_block.texture_set.json to edit the contents. Copy the following example into the file: JSON Copy {     \"format_version\": \"1.16.100\",     \"minecraft:texture_set\": {     \"color\": \"iron_block\",     \"metalness_emissive_roughness\": \"iron_block_mer\"     } }  Save and close the file.  With the JSON file set up, you can now configure the textures for the color values and the metalness_emissive_roughness values.  Add the PBR capability  The manifest.json file for the pack requires the value \"pbr\" to be added in a capabilities section below your existing header and modules:  JSON Copy {     \"format_version\": 1,     \"header\": {         \"name\": \"RTX Sample Resources\",         \"description\": \"\",         \"uuid\": \"58d4560c-106d-4b0c-9847-eee47417fb05\",         \"min_engine_version\": [1, 12, 0],         \"version\": [1, 0, 0]     },     \"modules\": [         {             \"description\": \"\",             \"type\": \"resources\",             \"uuid\": \"2d3df25b-856a-406d-9a57-c87b9a4d7af8\",             \"version\": [0, 0, 1]         }     ],     \"capabilities\" : [         \"pbr\"     ] }  Add the textures  To create a mirror in a PBR workflow, you need a Roughness map and a Metalness map. A Roughness map with a value of 0.0, or solid black, will create a smooth surface for light to reflect off. A Metalness map set to a value of 1.0, or solid white, will render the block like reflective metal.  Download these two PNG files, iron_block.png (the color texture map) and iron_block_mer.png (the MER texture map), by right-clicking them and selecting Save image as:   iron_block.png  iron_block_mer.png  Copy and paste both .png files into the textures/blocks folder.  Run the texture pack  With the JSON file properly set up and both textures in place, you can now load in your texture pack to test in Minecraft.  What's next? Learn how to use Blockbench to create MER-mapped models. Learn about Lighting Customization. Control the in-game appearance of Fog using a similar JSON structure. Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/pbroverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Overview of Physically Based Rendering 06/11/2025  Physically Based Rendering, or PBR, simulates how materials would react to realistic light behavior. Metallic surfaces cast reflections; light bends and refracts through different types of glass. For objects you create to take advantage of PBR, you'll need to create special textures that capture properties of the material, such as metallic properties, emissive properties, and roughness (often abbreviated together as \"MER\").  By the end of this overview, you'll learn:  The new texture maps available in Minecraft: Bedrock Edition. The basic workflows when designing PBR textures for Minecraft. How to create a mirror texture set using roughness and metallic maps. Prerequisites  It'll be helpful to have read the Introduction to Resource Packs before reading this document. You'll need a ready-to-go Resource Pack with the textures/blocks folder structure set up.  While we'll provide textures to download, you'll need to have some digital painting software that has layers to create your textures, such as the Windows 11 version of Microsoft Paint, Adobe Photoshop, or PaintTool SAI.  What makes a PBR texture?  In Minecraft, 3D blocks are given detail by applying 2D images to them using a common rendering method called Texture Mapping. Standard Minecraft blocks use a single texture map, an image with four color channels: Red, Blue, Green, and Alpha (RGBA). Most image editors work with RGBA images: the first three channels provide the color for each image pixel, while the alpha channel controls that pixel's transparency level.  PBR introduces five new maps for textures that set values for different kinds of properties for each pixel in the color map:  Metalness Map Emissive Map Roughness Map Normal Map Height Map  Together, these maps give you a great deal of control over how blocks you add to your resource packs are rendered when placed in the world. Let's look at each kind of map in turn.   Important  Not all PBR texture sets require all maps. Leaving empty maps will cause the texture set to use the default value.  Metalness map  A Metalness map is a grayscale texture that determines which areas of a texture map look like metal. The brighter the pixel is, the more metallic it will look.  A pixel set to pure black is completely non-metallic, with a value of 0.0. Grass, dirt, and tree bark are completely non-metallic objects. A pixel set to pure white is completely metallic, with a value of 1.0. Iron, gold, and copper are examples of completely metallic objects. Pixels between pure black and pure white will look more or less metallic, depending on how bright or dark they are.  The above image uses the following metalness map:  Emissive map  An Emissive map is a grayscale texture that determines which areas of a texture map emit light.  A pixel set to pure black is completely non-emissive (dark), with a value of 0.0. A pixel set to pure white is completely emissive (glowing at its brightest), with a value of 1.0. Pixels between pure black and pure white will glow more or less brightly, depending on how bright or dark they are.  The above image uses the following emissive map:  Roughness map  A Roughness map is a grayscale texture that determines which areas of the texture map are smooth and which are rough.  A pixel set to pure black is as smooth as possible, with a value of 0.0. Smooth marble, glass, or smooth plastic are very smooth. A pixel set to pure white is as rough as possible, with a value of 1.0. Brick, tree bark, and stones are very rough. Pixels between pure black and pure white will look more or less rough, depending on how bright or dark they are.  The above image uses the following roughness map:  Normal map  A Normal map is an RGB texture (not grayscale) that controls the depth and how light behaves when a light ray hits the texture. \"Normal\" refers to the concept of a surface normal in geometry, and the R, G, and B elements in the normal map correspond to the X, Y, and Z coordinates of the surface. Values of R (X) 128, G (Y) 128, and B (Z) 255 result in a flat appearance of the pixel.   Caution  Unless you have experience with creating Normal maps, it's recommended that you do not create Normal maps by hand. Third-party software is available to assist with creating Normal maps.  Height map  A Height map is a grayscale texture that controls depth of a texture. Height maps act as an alternative to Normal maps, but are not as efficient and cannot represent as many textures.  A pixel set to pure black extrudes inward as much as possible, with a value of 0.0. A pixel set to pure white extrudes outward as much as possible, with a value of 1.0. A pixel midway between pure black and pure white (127, 127, 127), with a value of 0.5, does not extrude in or out.  The above image uses the following height map:  Make a mirror  Let's create a mirror texture for an existing vanilla block by creating a Texture Set JSON file and using a provided texture file.  Make a texture set JSON  For the Texture Set to work properly, you will need to define a JSON file to load the textures. This tutorial is a mirror example working with the iron_block block.   Tip  To learn more about texture sets, please read Introduction to Texture Sets.  In your behavior pack, navigate to the textures/blocks folder. Create a new .JSON file and name it iron_block.texture_set.json. Double-click on iron_block.texture_set.json to edit the contents. Copy the following example into the file: JSON Copy {     \"format_version\": \"1.16.100\",     \"minecraft:texture_set\": {     \"color\": \"iron_block\",     \"metalness_emissive_roughness\": \"iron_block_mer\"     } }  Save and close the file.  With the JSON file set up, you can now configure the textures for the color values and the metalness_emissive_roughness values.  Add the PBR capability  The manifest.json file for the pack requires the value \"pbr\" to be added in a capabilities section below your existing header and modules:  JSON Copy {     \"format_version\": 1,     \"header\": {         \"name\": \"RTX Sample Resources\",         \"description\": \"\",         \"uuid\": \"58d4560c-106d-4b0c-9847-eee47417fb05\",         \"min_engine_version\": [1, 12, 0],         \"version\": [1, 0, 0]     },     \"modules\": [         {             \"description\": \"\",             \"type\": \"resources\",             \"uuid\": \"2d3df25b-856a-406d-9a57-c87b9a4d7af8\",             \"version\": [0, 0, 1]         }     ],     \"capabilities\" : [         \"pbr\"     ] }  Add the textures  To create a mirror in a PBR workflow, you need a Roughness map and a Metalness map. A Roughness map with a value of 0.0, or solid black, will create a smooth surface for light to reflect off. A Metalness map set to a value of 1.0, or solid white, will render the block like reflective metal.  Download these two PNG files, iron_block.png (the color texture map) and iron_block_mer.png (the MER texture map), by right-clicking them and selecting Save image as:   iron_block.png  iron_block_mer.png  Copy and paste both .png files into the textures/blocks folder.  Run the texture pack  With the JSON file properly set up and both textures in place, you can now load in your texture pack to test in Minecraft.  What's next? Learn how to use Blockbench to create MER-mapped models. Learn about Lighting Customization. Control the in-game appearance of Fog using a similar JSON structure. Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/useblockbenchtocreatemodelswithtextures?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Use Blockbench to Create Vibrant Visuals Models 06/11/2025  You can use Blockbench to create models for Vibrant Visuals, including MER and other textures. Blockbench includes several tools to make working with these additional textures easy. In this tutorial, we'll use these tools to create a shiny panda.  Create our starter mob using the Minecraft Entity Wizard  To get started, download Blockbench to your computer. If you haven't already, install the Entity Wizard plugin.  Next, we'll use the Minecraft Entity Wizard to create our starter Panda. On the first step of the wizard, give your mob a name like \"Shiny Panda\".  Throughout the rest of the wizard, select the defaults. For your mob, pick the panda.  At the last step of the Blockbench Wizard, give your pack a name of ShinyPanda, and select Export to Folder. This will place the pack in your Minecraft Preview development_resource_packs and development_behavior_packs folders.  Add a MER texture to your panda  To get started and add custom Metalness, Emissive, and Roughness texture to your panda, we're first going to create a material out of your texture. Click Edit Model in Blockbench if you're still at the export screen; otherwise, open the model from the File menu.  In the Blockbench Textures list, right-click on shiny_panda, and select Create Material. This will create a texture_set.json file for your texture with metadata on how MER, height, and normal map textures are specified.  Right click on shiny_panda.texture_set.json, and select Generate PBR map.  In PBR Channel, select Metalness and click Confirm. This results in creating your MER texture file.  Repeat the above steps to generate Emissive and Roughness maps. These won't create new files, but will add additional colored layers into your MER texture.  While we're here, enable material preview, so you can see a preview of your shiny panda as you work. In the upper right hand corner, select the View button and select Material Preview.  Now you should have all three colors as layers in your MER texture.  In an MER texture, Metalness is represented by the red channel, Emissiveness by the green channel, and Roughness by the blue channel.  Metalness (M) has the red channel, Emissive (E) has the green channel, and Roughness (R) has the blue channel. Select the Paint \"mode\" tab, and notice the three different color textures in the Layers palette.  We want to make the panda shiny, so we want to give it a high metalness. To do that, we'll focus on the metal layer and hide the roughness and emissive layers. Using a red-only color, we'll fill in all the darker portions of the panda texture. That should mean that those portions of the texture are high in metalness.  Make sure you now save out your textures! Press Ctrl+S. You'll be given the option to save out your new PNG as a separate file (shiny_panda_mer).  Enable Vibrant Visuals in the resource pack  We need to set the resource pack that Blockbench generated as being compatible with Vibrant Visuals. It should be in your development resource pack folder. If you saved your new pack to the regular version of Minecraft: Bedrock Edition, the folder path will be:  %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\development_resource_packs\\ShinyPanda  Inside the ShinyPanda folder, open manifest.json with Visual Studio code or another text editor. At the bottom of the manifest, under the \"modules\" array, add a \"capabilities\" array with the \"pbr\" capability specified:  JSON Copy \"capabilities\": [     \"pbr\" ]   Next, we need to apply a basic resource pack with fundamental basic settings of Vibrant Visuals. To do this, get the deferred lighting sample settings from https://github.com/microsoft/minecraft-samples/tree/main/deferred_lighting_starter. Follow the instructions in that README to deploy the settings to Minecraft as a resource pack. (You'll want to download the folder, run npm i to install dependencies, and then npm run local-deploy to deploy it to Minecraft.)  Finally, create your world! Select the Experiments tab and ensure the \"Render Dragon Features for Creators\" option is turned on.  Under resource packs, activate both your Shiny Panda pack and the Deferred Lighting Starter Settings pack you deployed.  Under resource packs, select your Shiny Panda there, too.  Now create your world, and summon a panda. Note how the reflections and shadows off the trees will now reflect off certain portions of your now-shiny panda.  It's hard to see in the image above, but you can see the reflections of the trees on our shiny panda! Amazing. The new lighting capabilities in Vibrant Visuals open up untold options for new, stunning looks for mobs and other scene elements!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/useblockbenchtocreatemodelswithtextures?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Use Blockbench to Create Vibrant Visuals Models 06/11/2025  You can use Blockbench to create models for Vibrant Visuals, including MER and other textures. Blockbench includes several tools to make working with these additional textures easy. In this tutorial, we'll use these tools to create a shiny panda.  Create our starter mob using the Minecraft Entity Wizard  To get started, download Blockbench to your computer. If you haven't already, install the Entity Wizard plugin.  Next, we'll use the Minecraft Entity Wizard to create our starter Panda. On the first step of the wizard, give your mob a name like \"Shiny Panda\".  Throughout the rest of the wizard, select the defaults. For your mob, pick the panda.  At the last step of the Blockbench Wizard, give your pack a name of ShinyPanda, and select Export to Folder. This will place the pack in your Minecraft Preview development_resource_packs and development_behavior_packs folders.  Add a MER texture to your panda  To get started and add custom Metalness, Emissive, and Roughness texture to your panda, we're first going to create a material out of your texture. Click Edit Model in Blockbench if you're still at the export screen; otherwise, open the model from the File menu.  In the Blockbench Textures list, right-click on shiny_panda, and select Create Material. This will create a texture_set.json file for your texture with metadata on how MER, height, and normal map textures are specified.  Right click on shiny_panda.texture_set.json, and select Generate PBR map.  In PBR Channel, select Metalness and click Confirm. This results in creating your MER texture file.  Repeat the above steps to generate Emissive and Roughness maps. These won't create new files, but will add additional colored layers into your MER texture.  While we're here, enable material preview, so you can see a preview of your shiny panda as you work. In the upper right hand corner, select the View button and select Material Preview.  Now you should have all three colors as layers in your MER texture.  In an MER texture, Metalness is represented by the red channel, Emissiveness by the green channel, and Roughness by the blue channel.  Metalness (M) has the red channel, Emissive (E) has the green channel, and Roughness (R) has the blue channel. Select the Paint \"mode\" tab, and notice the three different color textures in the Layers palette.  We want to make the panda shiny, so we want to give it a high metalness. To do that, we'll focus on the metal layer and hide the roughness and emissive layers. Using a red-only color, we'll fill in all the darker portions of the panda texture. That should mean that those portions of the texture are high in metalness.  Make sure you now save out your textures! Press Ctrl+S. You'll be given the option to save out your new PNG as a separate file (shiny_panda_mer).  Enable Vibrant Visuals in the resource pack  We need to set the resource pack that Blockbench generated as being compatible with Vibrant Visuals. It should be in your development resource pack folder. If you saved your new pack to the regular version of Minecraft: Bedrock Edition, the folder path will be:  %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang\\development_resource_packs\\ShinyPanda  Inside the ShinyPanda folder, open manifest.json with Visual Studio code or another text editor. At the bottom of the manifest, under the \"modules\" array, add a \"capabilities\" array with the \"pbr\" capability specified:  JSON Copy \"capabilities\": [     \"pbr\" ]   Next, we need to apply a basic resource pack with fundamental basic settings of Vibrant Visuals. To do this, get the deferred lighting sample settings from https://github.com/microsoft/minecraft-samples/tree/main/deferred_lighting_starter. Follow the instructions in that README to deploy the settings to Minecraft as a resource pack. (You'll want to download the folder, run npm i to install dependencies, and then npm run local-deploy to deploy it to Minecraft.)  Finally, create your world! Select the Experiments tab and ensure the \"Render Dragon Features for Creators\" option is turned on.  Under resource packs, activate both your Shiny Panda pack and the Deferred Lighting Starter Settings pack you deployed.  Under resource packs, select your Shiny Panda there, too.  Now create your world, and summon a panda. Note how the reflections and shadows off the trees will now reflect off certain portions of your now-shiny panda.  It's hard to see in the image above, but you can see the reflections of the trees on our shiny panda! Amazing. The new lighting capabilities in Vibrant Visuals open up untold options for new, stunning looks for mobs and other scene elements!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/lightingcustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Light Sources 06/11/2025  The flip side of customizing materials in Minecraft: Bedrock Edition with texture maps is customizing the lighting in your world. You can use lighting JSON schemas to define the light from directional lights (celestial bodies), point lights (torches, lamps, and other light-emitting blocks), and various kinds of ambient light, for full control over your scenes.  Three JSON files define lighting in Vibrant Visuals:  lighting/global.json defines directional lights, a global desaturation value for emissive lights, ambient lighting, and sky lighting. point_lights/global.json assigns light colors to specific block types such as torches. pbr/global.json sets default fallback values when texture set details isn't provided for a block, entity, particle, or item. Global lighting  This covers the \"directional lights\", \"emissive\", \"ambient\", and \"sky\" objects in lighting/global.json.  Directional lights  The \"directional_lights\" object is split into the \"orbital\" section, which contains properties for the sun and moon, and the \"flash\" section, which contains properties for the End light flash. These properties affect how strong their respective light contributions are, what colors they cast on surfaces they illuminate, and the angle at which they cast shadows. (They also influence the color of the sky by way of atmospheric scattering calculations; see Atmospheric Effects for more.)  The sun and the moon are assumed to be at opposite points in their orbit in the sky at all times. When both celestial bodies are visible, they both contribute light to the scene. The End flash is a celestial light that's exclusive to the End dimension, and has no real-world counterpart. It disappears and reappears at random locations, and the illuminance it contributes to the scene scales accordingly, appearing as a flash of light.  The Vibrant Visuals pipeline handles illuminance values that correspond to real world values. For instance, the sun at noon on a clear day measures upwards of 100,000 lux, while the moon registers less than one. In the case of the End light flash, the value provided determines the maximum illuminance of the flashes it produces. Tone mapping and auto-exposure will appropriately rebalance drastic differences in light intensities.  Color values can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string like an HTML/CSS color specifier. These values can be individually key-framed when providing values for the sun and the moon; see Key Frame JSON Syntax for details.  Emissive light sources  The \"emissive\" property allows for some control over how emissive light sources behave. This can be especially useful for fine-tuning emissive light sources for certain types of tone mapping.  Currently, emissive light sources have only one property, \"desaturation\". This is a factor from 0.0 to 1.0 that controls how much the albedo of a given pixel is desaturated when computing the color of emissive light. A value of 0.0 results in no desaturation, while a value of 1.0 results in full desaturation of the albedo color.  Ambient light  The \"ambient\" object controls how surfaces are lit when there are no other sensible light sources available. Imagine a scene with no direct or indirect light sources, like a dark cavern with no torches or lava. Absent any light source, the player would be left in complete darkness. Another common case is when no indirect specular contribution is available. This often happens in underground scenes, where there is no exposure to the sky and when SSR can't be calculated for one reason or another. The ambient object allows packs to specify a minimum, fallback light source to provide for both cases.  As with orbital lights, the \"color\" value can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string.  The \"illuminance\" value corresponds to the strength, in lux (lx), of the ambient light, and should be kept quite low in general. The allowed range for this value is 0.0 - 5.0.  If not provided, a default color of #FFFFFF and illuminance of 0.02 will be used.  Sky  The \"sky\" object controls some properties of the sky in terms of its contribution as a light source. The sky contributes significantly to indirect lighting, both diffuse (bouncing light from the sky) and specular (reflections of the sky and clouds).  The sky's \"intensity\" value is a factor from 0.1 to 1.0 that controls how much sky light is factored into the indirect term for both diffuse and specular. A value of 1.0 causes the sky to contribute more to indirect light, and will result in shadows being less dark; a value of 0.1 will result in darker shadows, because less indirect light is contributed from the sky. The default value, if not provided, is 1.0.  Point lights  The \"point_lights\" object allows you to specify which blocks should be considered point lights and what color they should emit.  The difference between a traditional light-emitting block and a point light block is that point lights emit light from a single point at the center of the block, thus the name \"point\" light. Like directional lights, they produce sophisticated lighting effects such as diffuse and specular highlights. This modeling works well for blocks such as torches, but isn't as good for conveying blocks with larger, discrete shapes, such as lava blocks or campfires. Blocks that emit light from a surface \"area\" rather than a single \"point\" should use the Emissive properties of Texture Sets and lightEmission block components to control their light levels. You can always combine point lights and Emissive texture data in the same block to achieve your desired look.  Feel free to experiment, but beware that point lights are considerably more resource-intensive than light produced by other means, so employ them with care. For instance, while you technically can turn lava blocks into point lights, it's not recommended simply because of the sheer amount of point lights that could be generated in common scenes.  By default, the game will treat the following blocks as point lights. This functionality can't be changed. However, you can override their default color if you include an entry for that block in your pack's point_lights/global.json file:  minecraft:torch as #EFE39D minecraft:redstone_torch as #FF0000 minecraft:end_rod as #FFFFFF minecraft:lantern as #CE8133 minecraft:soul_lantern as #00FFFF minecraft:soul_torch as #00FFFF  To change the strength of a point light, refer to the documentation for lightEmission block components. Note that this lightEmission value is a separate concept from the \"Emissive\" value described in PBR or Texture Set documentation.  The \"color\" value can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string.  PBR uniforms  The \"pbr\" object complements the larger Texture Set functionality by acting as a default or fallback value when texture set detail isn't provided for particular blocks, entities, particles, or items. For example, if you provide texture sets for pigs and creepers, but no other entities, then when a cow is rendered in game, the \"global_metalness_emissive_roughness_subsurface\" value defined in pbr/global.json will be applied uniformly across the entire surface of the cow. This allows you to quickly provide a general art direction without having to author textures for every single game object initially, and iteratively add more detail to the blocks/entities as you see fit.  Values can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string.  Reflections  Vibrant Visuals calculates reflections using image-based lighting (IBL) and screen-space reflections (SSR). The majority of surfaces will be able to convey convincing reflections, whether underground, above ground, or even in the Nether. Certain scenarios, such as reflecting off-screen objects or first-person mirrors, are still not possible. Also, with the exception of water, transparent geometry such as glass will not receive SSR.  While you can't control reflection properties directly, you can make use of roughness and metalness parameters in texture sets to control how different materials elicit reflections. Default PBR values for blocks, actors, particles, and items defined in pbr/global.json will also impact this property for objects with no texture set.  Lighting JSON schemas  File location: lighting/global.json  Expand table Schema Version\tUpdates 1.21.80\tAdded support for controlling the End light flash 1.21.70\tAdded a new object for controlling the sky intensity 1.21.60\tChanged the data type for sun and moon colors from RGBA to RGB 1.21.40\tN/A JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these lighting settings.     object \"minecraft:lighting_settings\"     {         object \"description\"         {             string \"identifier\" // The identifier for these lighting settings. The identifier must include a namespace.         },         object \"directional_lights\"         {             object \"orbital\" {                 object \"sun\"                 {                     float \"illuminance\" : optkeyframe, // How bright the sun is, measured in lux (lx)                     color \"color\" : optkeyframe // The RGB color that the sun contributes to direct surface lighting; supports RGB array or HEX string                 },                 object \"moon\"                 {                     float \"illuminance\" : optkeyframe,  // How bright the moon is; measured in lux (lx)                     color \"color\" : optkeyframe // The RGB color that the moon contributes to direct surface lighting; supports RGB array or HEX string                 },                 float \"orbital_offset_degrees\" : optkeyframe // The rotational offset of the sun and moon from their standard orbital axis; measured in degrees             },             object \"flash\" {                 float \"illuminance\", // The peak brightness of the End flash, measured in lux (lx)                 color \"color\" // The RGB color that the End flash contributes to surface lighting; supports RGB array or HEX string             }         },         object \"emissive\"         {             float \"desaturation\" // The amount of desaturation to apply to albedo color values during emissive light calculation; values range from [0.0, 1.0]         },         object \"ambient\"         {             float \"illuminance\",  // How bright the ambient light is; measured in lux (lx)             color \"color\" // The RGB color that the ambient light contributes to surface lighting; supports RGB array or HEX string         },         object \"sky\"         {             float \"intensity\" // Scales how much energy the sky contributes to lighting; values range from [0.1, 1.0]         }     } }   File location: point_lights/global.json  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these point light settings.     object \"minecraft:point_light_settings\"     {         object \"colors\" // List of key-value pairs where the key is a namespace-qualified block name and the value is a color (supports RGB array or HEX string)         {             string: color,              ...             string: color          }      } }   File location: pbr/global.json  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these pbr fallback settings.     object \"minecraft:pbr_fallback_settings\"     {         object \"blocks\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for blocks when not defined via textureset; supports RGBA array or HEX string         },         object \"actors\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for actors/mobs when not defined via textureset; supports RGBA array or HEX string         },         object \"particles\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for particles when not defined via textureset; supports RGBA array or HEX string         },         object \"items\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for items when not defined via textureset; supports RGBA array or HEX string         }     } }  lighting/global.json JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:lighting_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_lighting\"         },         \"directional_lights\": {             \"orbital\": {                 \"sun\": {                     \"illuminance\": {                         \"0.0\": 109880.0,                         \"0.25\": 20000.0,                         \"0.35\": 400.0,                         \"0.5\": 1.0,                         \"0.65\": 400.0,                         \"0.75\": 20000.0,                         \"1.0\": 109880.0                     },                     \"color\": [ 255.0, 255.0, 255.0 ]                 },                 \"moon\": {                      \"illuminance\": 0.27,                     \"color\": \"#ffffff\"                 },                  \"orbital_offset_degrees\": 3.0             },             \"flash\": {                 \"illuminance\": 5.0,                 \"color\": [ 255.0, 255.0, 255.0 ]             }         },         \"emissive\": {             \"desaturation\": 0.1         },         \"ambient\": {             \"illuminance\": 0.02,             \"color\": \"#ffffff\"         },         \"sky\": {             \"intensity\": 1.0         }     } }  point_lights/global.json JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:minecraft:point_light_settings\": {         \"colors\": {             \"minecraft:soul_torch\": \"#FFFFFF\"         }     } }  pbr/global.json JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:pbr_fallback_settings\": {         \"blocks\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         },         \"actors\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         },         \"particles\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         },         \"items\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/lightingcustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Light Sources 06/11/2025  The flip side of customizing materials in Minecraft: Bedrock Edition with texture maps is customizing the lighting in your world. You can use lighting JSON schemas to define the light from directional lights (celestial bodies), point lights (torches, lamps, and other light-emitting blocks), and various kinds of ambient light, for full control over your scenes.  Three JSON files define lighting in Vibrant Visuals:  lighting/global.json defines directional lights, a global desaturation value for emissive lights, ambient lighting, and sky lighting. point_lights/global.json assigns light colors to specific block types such as torches. pbr/global.json sets default fallback values when texture set details isn't provided for a block, entity, particle, or item. Global lighting  This covers the \"directional lights\", \"emissive\", \"ambient\", and \"sky\" objects in lighting/global.json.  Directional lights  The \"directional_lights\" object is split into the \"orbital\" section, which contains properties for the sun and moon, and the \"flash\" section, which contains properties for the End light flash. These properties affect how strong their respective light contributions are, what colors they cast on surfaces they illuminate, and the angle at which they cast shadows. (They also influence the color of the sky by way of atmospheric scattering calculations; see Atmospheric Effects for more.)  The sun and the moon are assumed to be at opposite points in their orbit in the sky at all times. When both celestial bodies are visible, they both contribute light to the scene. The End flash is a celestial light that's exclusive to the End dimension, and has no real-world counterpart. It disappears and reappears at random locations, and the illuminance it contributes to the scene scales accordingly, appearing as a flash of light.  The Vibrant Visuals pipeline handles illuminance values that correspond to real world values. For instance, the sun at noon on a clear day measures upwards of 100,000 lux, while the moon registers less than one. In the case of the End light flash, the value provided determines the maximum illuminance of the flashes it produces. Tone mapping and auto-exposure will appropriately rebalance drastic differences in light intensities.  Color values can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string like an HTML/CSS color specifier. These values can be individually key-framed when providing values for the sun and the moon; see Key Frame JSON Syntax for details.  Emissive light sources  The \"emissive\" property allows for some control over how emissive light sources behave. This can be especially useful for fine-tuning emissive light sources for certain types of tone mapping.  Currently, emissive light sources have only one property, \"desaturation\". This is a factor from 0.0 to 1.0 that controls how much the albedo of a given pixel is desaturated when computing the color of emissive light. A value of 0.0 results in no desaturation, while a value of 1.0 results in full desaturation of the albedo color.  Ambient light  The \"ambient\" object controls how surfaces are lit when there are no other sensible light sources available. Imagine a scene with no direct or indirect light sources, like a dark cavern with no torches or lava. Absent any light source, the player would be left in complete darkness. Another common case is when no indirect specular contribution is available. This often happens in underground scenes, where there is no exposure to the sky and when SSR can't be calculated for one reason or another. The ambient object allows packs to specify a minimum, fallback light source to provide for both cases.  As with orbital lights, the \"color\" value can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string.  The \"illuminance\" value corresponds to the strength, in lux (lx), of the ambient light, and should be kept quite low in general. The allowed range for this value is 0.0 - 5.0.  If not provided, a default color of #FFFFFF and illuminance of 0.02 will be used.  Sky  The \"sky\" object controls some properties of the sky in terms of its contribution as a light source. The sky contributes significantly to indirect lighting, both diffuse (bouncing light from the sky) and specular (reflections of the sky and clouds).  The sky's \"intensity\" value is a factor from 0.1 to 1.0 that controls how much sky light is factored into the indirect term for both diffuse and specular. A value of 1.0 causes the sky to contribute more to indirect light, and will result in shadows being less dark; a value of 0.1 will result in darker shadows, because less indirect light is contributed from the sky. The default value, if not provided, is 1.0.  Point lights  The \"point_lights\" object allows you to specify which blocks should be considered point lights and what color they should emit.  The difference between a traditional light-emitting block and a point light block is that point lights emit light from a single point at the center of the block, thus the name \"point\" light. Like directional lights, they produce sophisticated lighting effects such as diffuse and specular highlights. This modeling works well for blocks such as torches, but isn't as good for conveying blocks with larger, discrete shapes, such as lava blocks or campfires. Blocks that emit light from a surface \"area\" rather than a single \"point\" should use the Emissive properties of Texture Sets and lightEmission block components to control their light levels. You can always combine point lights and Emissive texture data in the same block to achieve your desired look.  Feel free to experiment, but beware that point lights are considerably more resource-intensive than light produced by other means, so employ them with care. For instance, while you technically can turn lava blocks into point lights, it's not recommended simply because of the sheer amount of point lights that could be generated in common scenes.  By default, the game will treat the following blocks as point lights. This functionality can't be changed. However, you can override their default color if you include an entry for that block in your pack's point_lights/global.json file:  minecraft:torch as #EFE39D minecraft:redstone_torch as #FF0000 minecraft:end_rod as #FFFFFF minecraft:lantern as #CE8133 minecraft:soul_lantern as #00FFFF minecraft:soul_torch as #00FFFF  To change the strength of a point light, refer to the documentation for lightEmission block components. Note that this lightEmission value is a separate concept from the \"Emissive\" value described in PBR or Texture Set documentation.  The \"color\" value can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string.  PBR uniforms  The \"pbr\" object complements the larger Texture Set functionality by acting as a default or fallback value when texture set detail isn't provided for particular blocks, entities, particles, or items. For example, if you provide texture sets for pigs and creepers, but no other entities, then when a cow is rendered in game, the \"global_metalness_emissive_roughness_subsurface\" value defined in pbr/global.json will be applied uniformly across the entire surface of the cow. This allows you to quickly provide a general art direction without having to author textures for every single game object initially, and iteratively add more detail to the blocks/entities as you see fit.  Values can be expressed either as an array of three numerical values in the range of 0–255, or as a six-digit hexadecimal string.  Reflections  Vibrant Visuals calculates reflections using image-based lighting (IBL) and screen-space reflections (SSR). The majority of surfaces will be able to convey convincing reflections, whether underground, above ground, or even in the Nether. Certain scenarios, such as reflecting off-screen objects or first-person mirrors, are still not possible. Also, with the exception of water, transparent geometry such as glass will not receive SSR.  While you can't control reflection properties directly, you can make use of roughness and metalness parameters in texture sets to control how different materials elicit reflections. Default PBR values for blocks, actors, particles, and items defined in pbr/global.json will also impact this property for objects with no texture set.  Lighting JSON schemas  File location: lighting/global.json  Expand table Schema Version\tUpdates 1.21.80\tAdded support for controlling the End light flash 1.21.70\tAdded a new object for controlling the sky intensity 1.21.60\tChanged the data type for sun and moon colors from RGBA to RGB 1.21.40\tN/A JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these lighting settings.     object \"minecraft:lighting_settings\"     {         object \"description\"         {             string \"identifier\" // The identifier for these lighting settings. The identifier must include a namespace.         },         object \"directional_lights\"         {             object \"orbital\" {                 object \"sun\"                 {                     float \"illuminance\" : optkeyframe, // How bright the sun is, measured in lux (lx)                     color \"color\" : optkeyframe // The RGB color that the sun contributes to direct surface lighting; supports RGB array or HEX string                 },                 object \"moon\"                 {                     float \"illuminance\" : optkeyframe,  // How bright the moon is; measured in lux (lx)                     color \"color\" : optkeyframe // The RGB color that the moon contributes to direct surface lighting; supports RGB array or HEX string                 },                 float \"orbital_offset_degrees\" : optkeyframe // The rotational offset of the sun and moon from their standard orbital axis; measured in degrees             },             object \"flash\" {                 float \"illuminance\", // The peak brightness of the End flash, measured in lux (lx)                 color \"color\" // The RGB color that the End flash contributes to surface lighting; supports RGB array or HEX string             }         },         object \"emissive\"         {             float \"desaturation\" // The amount of desaturation to apply to albedo color values during emissive light calculation; values range from [0.0, 1.0]         },         object \"ambient\"         {             float \"illuminance\",  // How bright the ambient light is; measured in lux (lx)             color \"color\" // The RGB color that the ambient light contributes to surface lighting; supports RGB array or HEX string         },         object \"sky\"         {             float \"intensity\" // Scales how much energy the sky contributes to lighting; values range from [0.1, 1.0]         }     } }   File location: point_lights/global.json  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these point light settings.     object \"minecraft:point_light_settings\"     {         object \"colors\" // List of key-value pairs where the key is a namespace-qualified block name and the value is a color (supports RGB array or HEX string)         {             string: color,              ...             string: color          }      } }   File location: pbr/global.json  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these pbr fallback settings.     object \"minecraft:pbr_fallback_settings\"     {         object \"blocks\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for blocks when not defined via textureset; supports RGBA array or HEX string         },         object \"actors\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for actors/mobs when not defined via textureset; supports RGBA array or HEX string         },         object \"particles\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for particles when not defined via textureset; supports RGBA array or HEX string         },         object \"items\"         {             color \"global_metalness_emissive_roughness_subsurface\" // The default MERS value to use for items when not defined via textureset; supports RGBA array or HEX string         }     } }  lighting/global.json JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:lighting_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_lighting\"         },         \"directional_lights\": {             \"orbital\": {                 \"sun\": {                     \"illuminance\": {                         \"0.0\": 109880.0,                         \"0.25\": 20000.0,                         \"0.35\": 400.0,                         \"0.5\": 1.0,                         \"0.65\": 400.0,                         \"0.75\": 20000.0,                         \"1.0\": 109880.0                     },                     \"color\": [ 255.0, 255.0, 255.0 ]                 },                 \"moon\": {                      \"illuminance\": 0.27,                     \"color\": \"#ffffff\"                 },                  \"orbital_offset_degrees\": 3.0             },             \"flash\": {                 \"illuminance\": 5.0,                 \"color\": [ 255.0, 255.0, 255.0 ]             }         },         \"emissive\": {             \"desaturation\": 0.1         },         \"ambient\": {             \"illuminance\": 0.02,             \"color\": \"#ffffff\"         },         \"sky\": {             \"intensity\": 1.0         }     } }  point_lights/global.json JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:minecraft:point_light_settings\": {         \"colors\": {             \"minecraft:soul_torch\": \"#FFFFFF\"         }     } }  pbr/global.json JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:pbr_fallback_settings\": {         \"blocks\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         },         \"actors\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         },         \"particles\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         },         \"items\": {             \"global_metalness_emissive_roughness_subsurface\": [0.0, 0.0, 255.0, 0.0]         } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/atmosphericscustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Atmospheric Effects 06/11/2025  Vibrant Visuals allows you to customize atmospheric effects using the atmospherics/atmospherics.json file. This uses the following format:  JSON Copy {   string \"format_version\", // The 3-part schema version for parsing these atmosphere settings.   object \"minecraft:atmosphere_settings\"   {     object \"description\"     {       string \"identifier\" // The identifier for these atmosphere settings. The identifier must include a namespace.     },     object \"horizon_blend_stops\" // How the atmosphere is divided up     {       float \"min\" : optkeyframe, // The minimum horizon height       float \"start\" : optkeyframe, // The height relative to the horizon where the zenith contribution will take over       float \"mie_start\" : optkeyframe, // The height relative to the horizon where mie scattering begins       float \"max\" : optkeyframe // The maximum horizon height     }     float \"rayleigh_strength\" : optkeyframe, // How strong the atmosphere's rayleigh scattering term is     float \"sun_mie_strength\" : optkeyframe, // How strong the sun's mie scattering term is     float \"moon_mie_strength\" : optkeyframe, // How strong the moon's mie scattering term is     float \"sun_glare_shape\" : optkeyframe, // How the lobe of the mie scattering is shaped     color \"sky_zenith_color\" : optkeyframe, // The RGB color of the zenith region of the atmosphere; supports RGB array or HEX string     color \"sky_horizon_color\" : optkeyframe // The RGB color of the horizon region of the atmosphere; supports RGB array or HEX string   } }   Any of these values can be individually key framed; see Key Frame JSON Syntax for more details.  Note that the colors defined for the sun and moon directional lights in lighting/global.json will also be used in the calculation of the atmosphere and thus will have a significant impact on the final sky color. This is especially true with both the Rayleigh and Mie scattering terms.  You can get a sample project starter for various Vibrant Visuals lighting settings at https://github.com/microsoft/minecraft-samples/tree/main/deferred_lighting_starter.  Example atmospherics/atmospherics.json JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:atmosphere_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_atmospherics\"         },         \"horizon_blend_stops\":{             \"min\": {                  \"0.0\": 0.0,                  \"0.1962499916553497\": 0.008,                  \"0.25\": 0.0,                  \"0.34\": 0.11,                  \"0.6\": 0.027,                  \"0.6750000119209290\": 0.01332983374595642,                  \"0.7487499713897705\": 0.0,                  \"0.8174999952316284\": 0.0              },              \"start\": {                  \"0.0\": 0.25,                  \"0.1962499916553497\": 0.4179066121578217,                  \"0.25\": 0.213,                  \"0.34\": 0.401,                  \"0.6\": 0.23,                  \"0.6750000119209290\": 0.2143078744411469,                  \"0.7487499713897705\": 0.1990064233541489,                  \"0.8174999952316284\": 0.6179999709129333              },              \"mie_start\": {                 \"0.0\": 0.5,                 \"0.1962499916553497\": 1.172000050544739,                 \"0.25\": 0.5,                 \"0.34\": 0.5009999871253967,                 \"0.6\": 0.167,                 \"0.6750000119209290\": 0.15,                 \"0.7487499713897705\": 0.55,                 \"0.8174999952316284\": 0.79             },              \"max\": {                  \"0.0\": 0.25,                  \"0.1962499916553497\": 0.137,                  \"0.25\": 0.0,                  \"0.34\": 0.467,                  \"0.6\": 0.2,                 \"0.6750000119209290\": 0.1919008344411850,                  \"0.7487499713897705\": 0.214,                  \"0.8174999952316284\": 0.0              }         },         \"rayleigh_strength\": {              \"0.0\": 1.026124954,              \"0.25\": 0.1624998152,              \"0.3\": 0.1624998152,              \"0.3037499785423279\": 0.1624998152,              \"0.3249999880790710\": 0.1624998152,              \"0.6\": 0.5,              \"0.7074999809265137\": 0.1982535422,              \"0.75\": 0.125         },          \"sun_mie_strength\": {              \"0.0\": 1.0,              \"0.25\": 3.0,              \"0.3\": 3.0,              \"0.3037499785423279\": 2.878501892089844,              \"0.3249999880790710\": 1.0,              \"0.6\": 1.0,              \"0.7074999809265137\": 1.0,              \"0.75\": 1.0          },          \"moon_mie_strength\": {              \"0.0\": 0.0,              \"0.25\": 0.0,              \"0.3\": 0.0,              \"0.3037499785423279\": 0.114,              \"0.3249999880790710\": 1.0,              \"0.6\": 1.0,              \"0.7074999809265137\": 0.0,              \"0.75\": 0.0          },          \"sun_glare_shape\": {              \"0.0\": 15.89900016784668,              \"0.25\": 15.89900016784668,              \"0.3\": 15.89900016784668,              \"0.3037499785423279\": 15.84438705444336,              \"0.3249999880790710\": 15.0,              \"0.6\": 4.0,              \"0.7074999809265137\": 4.0,              \"0.75\": 4.0          },          \"sky_zenith_color\": {              \"0.0\": [0, 125, 164],              \"0.25\": [11, 55, 97],              \"0.5\": [7, 10, 36],              \"0.75\": [50, 88, 170]          },          \"sky_horizon_color\": {              \"0.0\": [255, 255, 254],             \"0.171875\": [196, 133, 102],              \"0.25\": [255, 85, 85],              \"0.305\": [173, 60, 67],              \"0.35\": [168, 76, 140],              \"0.4174999892711639\": [130, 99, 169],              \"0.47\": [66, 98, 238],              \"0.6030000448226929\": [66, 98, 238],              \"0.6474999785423279\": [168, 99, 162],              \"0.75\": [238, 144, 124],              \"0.84\": [242, 168, 152]          }     } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/atmosphericscustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Atmospheric Effects 06/11/2025  Vibrant Visuals allows you to customize atmospheric effects using the atmospherics/atmospherics.json file. This uses the following format:  JSON Copy {   string \"format_version\", // The 3-part schema version for parsing these atmosphere settings.   object \"minecraft:atmosphere_settings\"   {     object \"description\"     {       string \"identifier\" // The identifier for these atmosphere settings. The identifier must include a namespace.     },     object \"horizon_blend_stops\" // How the atmosphere is divided up     {       float \"min\" : optkeyframe, // The minimum horizon height       float \"start\" : optkeyframe, // The height relative to the horizon where the zenith contribution will take over       float \"mie_start\" : optkeyframe, // The height relative to the horizon where mie scattering begins       float \"max\" : optkeyframe // The maximum horizon height     }     float \"rayleigh_strength\" : optkeyframe, // How strong the atmosphere's rayleigh scattering term is     float \"sun_mie_strength\" : optkeyframe, // How strong the sun's mie scattering term is     float \"moon_mie_strength\" : optkeyframe, // How strong the moon's mie scattering term is     float \"sun_glare_shape\" : optkeyframe, // How the lobe of the mie scattering is shaped     color \"sky_zenith_color\" : optkeyframe, // The RGB color of the zenith region of the atmosphere; supports RGB array or HEX string     color \"sky_horizon_color\" : optkeyframe // The RGB color of the horizon region of the atmosphere; supports RGB array or HEX string   } }   Any of these values can be individually key framed; see Key Frame JSON Syntax for more details.  Note that the colors defined for the sun and moon directional lights in lighting/global.json will also be used in the calculation of the atmosphere and thus will have a significant impact on the final sky color. This is especially true with both the Rayleigh and Mie scattering terms.  You can get a sample project starter for various Vibrant Visuals lighting settings at https://github.com/microsoft/minecraft-samples/tree/main/deferred_lighting_starter.  Example atmospherics/atmospherics.json JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:atmosphere_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_atmospherics\"         },         \"horizon_blend_stops\":{             \"min\": {                  \"0.0\": 0.0,                  \"0.1962499916553497\": 0.008,                  \"0.25\": 0.0,                  \"0.34\": 0.11,                  \"0.6\": 0.027,                  \"0.6750000119209290\": 0.01332983374595642,                  \"0.7487499713897705\": 0.0,                  \"0.8174999952316284\": 0.0              },              \"start\": {                  \"0.0\": 0.25,                  \"0.1962499916553497\": 0.4179066121578217,                  \"0.25\": 0.213,                  \"0.34\": 0.401,                  \"0.6\": 0.23,                  \"0.6750000119209290\": 0.2143078744411469,                  \"0.7487499713897705\": 0.1990064233541489,                  \"0.8174999952316284\": 0.6179999709129333              },              \"mie_start\": {                 \"0.0\": 0.5,                 \"0.1962499916553497\": 1.172000050544739,                 \"0.25\": 0.5,                 \"0.34\": 0.5009999871253967,                 \"0.6\": 0.167,                 \"0.6750000119209290\": 0.15,                 \"0.7487499713897705\": 0.55,                 \"0.8174999952316284\": 0.79             },              \"max\": {                  \"0.0\": 0.25,                  \"0.1962499916553497\": 0.137,                  \"0.25\": 0.0,                  \"0.34\": 0.467,                  \"0.6\": 0.2,                 \"0.6750000119209290\": 0.1919008344411850,                  \"0.7487499713897705\": 0.214,                  \"0.8174999952316284\": 0.0              }         },         \"rayleigh_strength\": {              \"0.0\": 1.026124954,              \"0.25\": 0.1624998152,              \"0.3\": 0.1624998152,              \"0.3037499785423279\": 0.1624998152,              \"0.3249999880790710\": 0.1624998152,              \"0.6\": 0.5,              \"0.7074999809265137\": 0.1982535422,              \"0.75\": 0.125         },          \"sun_mie_strength\": {              \"0.0\": 1.0,              \"0.25\": 3.0,              \"0.3\": 3.0,              \"0.3037499785423279\": 2.878501892089844,              \"0.3249999880790710\": 1.0,              \"0.6\": 1.0,              \"0.7074999809265137\": 1.0,              \"0.75\": 1.0          },          \"moon_mie_strength\": {              \"0.0\": 0.0,              \"0.25\": 0.0,              \"0.3\": 0.0,              \"0.3037499785423279\": 0.114,              \"0.3249999880790710\": 1.0,              \"0.6\": 1.0,              \"0.7074999809265137\": 0.0,              \"0.75\": 0.0          },          \"sun_glare_shape\": {              \"0.0\": 15.89900016784668,              \"0.25\": 15.89900016784668,              \"0.3\": 15.89900016784668,              \"0.3037499785423279\": 15.84438705444336,              \"0.3249999880790710\": 15.0,              \"0.6\": 4.0,              \"0.7074999809265137\": 4.0,              \"0.75\": 4.0          },          \"sky_zenith_color\": {              \"0.0\": [0, 125, 164],              \"0.25\": [11, 55, 97],              \"0.5\": [7, 10, 36],              \"0.75\": [50, 88, 170]          },          \"sky_horizon_color\": {              \"0.0\": [255, 255, 254],             \"0.171875\": [196, 133, 102],              \"0.25\": [255, 85, 85],              \"0.305\": [173, 60, 67],              \"0.35\": [168, 76, 140],              \"0.4174999892711639\": [130, 99, 169],              \"0.47\": [66, 98, 238],              \"0.6030000448226929\": [66, 98, 238],              \"0.6474999785423279\": [168, 99, 162],              \"0.75\": [238, 144, 124],              \"0.84\": [242, 168, 152]          }     } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/volumetricfoglightshaftscustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Volumetric Fog and Light Shafts 06/11/2025  Minecraft already supports fog effects in resource packs. Vibrant Visuals extends that with volumetric fog and light shafts. These effects rely on a terrain-aware volumetric representation of the world, allowing for complex fog that changes depending on the environment.  Rather than defining new JSON files, volumetric fog takes advantage of existing resource pack capabilities for Fog and Volumes. You can define fog properties for specific biomes, discrete regions in your world, whether the player is under water or above water, and much more!  Differences with Vibrant Visuals enabled Tinted absorption  Vibrant Visuals does not fully support tinted absorption in media coefficients. While the \"absorption\" property takes an RGB value to describe how much light the fog will absorb with per-channel granularity, in Vibrant Visuals, volumes only operate at a single channel of granularity, and the engine calculates the standard luminance of the specified RGB value and uses that for absorption. Luminance is calculated as follows:  𝐿 𝑢 𝑚 𝑖 𝑛 𝑎 𝑛 𝑐 𝑒 = 0.2126 × 𝑅 𝑒 𝑑 + 0.7152 × 𝐺 𝑟 𝑒 𝑒 𝑛 + 0.0722 × 𝐵 𝑙 𝑢 𝑒  The following example is a good place to start: fogs/default_fog_settings.json  JSON Copy {   \"format_version\": \"1.16.100\",    \"minecraft:fog_settings\": {      \"description\": {          \"identifier\": \"pbr:fog_default\"      },     \"volumetric\": {          \"density\": {            \"water\": {              \"max_density\": 0.25,              \"uniform\": true            },            \"air\": {              \"max_density\": 0.01,              \"zero_density_height\": 150.0,              \"max_density_height\": 50.0            }         },          \"media_coefficients\": {            \"water\": {              \"scattering\": [0.01811, 0.02126, 0.027953],              \"absorption\": [0.2, 0.07874, 0.083465]            },            \"air\": {              \"scattering\": [0.02, 0.02, 0.02],              \"absorption\": [0.0, 0.0, 0.0]            }         }       }   } }  Support for Henyey-Greenstein phase function  Vibrant Visuals can use the Henyey-Greenstein phase function for calculating light scattering in air and water. See Henyey-Greenstein G for more specifics.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/volumetricfoglightshaftscustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Volumetric Fog and Light Shafts 06/11/2025  Minecraft already supports fog effects in resource packs. Vibrant Visuals extends that with volumetric fog and light shafts. These effects rely on a terrain-aware volumetric representation of the world, allowing for complex fog that changes depending on the environment.  Rather than defining new JSON files, volumetric fog takes advantage of existing resource pack capabilities for Fog and Volumes. You can define fog properties for specific biomes, discrete regions in your world, whether the player is under water or above water, and much more!  Differences with Vibrant Visuals enabled Tinted absorption  Vibrant Visuals does not fully support tinted absorption in media coefficients. While the \"absorption\" property takes an RGB value to describe how much light the fog will absorb with per-channel granularity, in Vibrant Visuals, volumes only operate at a single channel of granularity, and the engine calculates the standard luminance of the specified RGB value and uses that for absorption. Luminance is calculated as follows:  𝐿 𝑢 𝑚 𝑖 𝑛 𝑎 𝑛 𝑐 𝑒 = 0.2126 × 𝑅 𝑒 𝑑 + 0.7152 × 𝐺 𝑟 𝑒 𝑒 𝑛 + 0.0722 × 𝐵 𝑙 𝑢 𝑒  The following example is a good place to start: fogs/default_fog_settings.json  JSON Copy {   \"format_version\": \"1.16.100\",    \"minecraft:fog_settings\": {      \"description\": {          \"identifier\": \"pbr:fog_default\"      },     \"volumetric\": {          \"density\": {            \"water\": {              \"max_density\": 0.25,              \"uniform\": true            },            \"air\": {              \"max_density\": 0.01,              \"zero_density_height\": 150.0,              \"max_density_height\": 50.0            }         },          \"media_coefficients\": {            \"water\": {              \"scattering\": [0.01811, 0.02126, 0.027953],              \"absorption\": [0.2, 0.07874, 0.083465]            },            \"air\": {              \"scattering\": [0.02, 0.02, 0.02],              \"absorption\": [0.0, 0.0, 0.0]            }         }       }   } }  Support for Henyey-Greenstein phase function  Vibrant Visuals can use the Henyey-Greenstein phase function for calculating light scattering in air and water. See Henyey-Greenstein G for more specifics.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/colorgradingtonemappingcustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Color Grading and Tone Mapping 06/11/2025  Vibrant Visuals gives you new data-driven capabilities for color grading and tone mapping! With these tools, resource packs can convey unique moods and themes using industry-standard color correction controls.  Color grading  Minecraft's color grading system allows for many degrees of customization of the final image. You can control the saturation, contrast, gain, and offset of pixels per RGB channel. This can be done on a global scale regardless of pixel luminance, or it can be done on a more fine-grained scale with unique sets of parameters for shadows, midtones, and highlights. The highlight parameters are applied to the brightest pixels, the shadow parameters applied to the darkest pixels, and the midtone parameters applied to the pixels with luminance close to the average luminance of the scene.  In order to enable highlight and/or shadow grading, set the corresponding \"enabled\" parameter to true along with any actual grading parameters for that luminance range; simply specifying a Shadow Max or Highlight Min is not enough. The Minecraft Bedrock Editor is a great way to see the effects of these parameters in real-time.  Unless highlights or shadows are specified, midtones will be applied to all pixels. Think of midtones as global settings, and highlights and shadows as refining the bright or dark regions of the image.  Saturation: Determines the hue intensity of colors. A value of 1.0 results in no change in saturation to the original image. A value of 0.0 results in a grayscale image. Values > 1.0 will increase the intensity of colors.  Contrast: Describes the tonal range, the difference in luminance between the bright and dark pixels in an image. An image with high contrast will have pixels with a wide range of luminance values, whereas an image with low contrast will have pixels of a relatively small luminance range. A value of 1.0 results in no change in contrast to the original image. A value of 0.0 results in a completely washed-out, gray image. Values > 1.0 increase the brightness of highlights while darkening the shadows in the final image.  Gain: A multiplication factor applied to each color channel to adjust the overall luminance intensity of the image. A value of 1.0 results in no change to the original image. Values < 1.0 will darken the image while values > 1.0 will brighten it. A value of 0.0 cancels out that color channel completely. Gain is multiplicative and therefore has a stronger affect on brighter pixels than darker pixels.  Gamma: An exponential factor applied to the final color after both color grading and tone mapping to adjust the overall luminance intensity of the image. The standard value for gamma is 2.2. Lower values darken the final image, whereas higher values brighten it. Too high a gamma will cause the final image to appear washed-out.  Offset: An additive factor that is multiplied by the average luminance of the scene and then added to a given color channel to adjust the overall luminance intensity of the image. A value of 0.0 results in no change to the original image. Values > 0.0 will brighten the image, while values < 0.0 will darken it. Offset is additive and therefore has a stronger effect on darker pixels than brighter pixels.  Shadow Max: A factor multiplied by the average luminance of the scene to determine which pixels are considered shadows. Pixels with luminance less than ShadowMax * AverageLuminance will have the shadows set of color grading values applied. A value of 1.0 indicates shadows occupy the entire range of values including and up to the average luminance. Lower values will cause the maximum required luminance value for a pixel to be considered a shadow to drop. This value should not be equal to Highlight Min.  Highlight Min: A factor multiplied by the average luminance of the scene to determine which pixels are considered highlights. Pixels with luminance greater than HighlightMin * AverageLuminance will have the highlights set of color grading values applied. A value of 1.0 indicates highlights occupy the entire range of values including and above the average luminance. Higher values will cause the minimum required luminance value for a pixel to be considered a highlight to rise. This value should not be equal to Shadow Max.  Temperature grading  Temperature-based color grading, added in version 1.21.90, allows you to globally adjust how \"warm\" or \"cool\" the scene is. Warmer temperatures cause the scene to become more yellow/orange, while cooler temperatures make the scene more blue.  Temperature: The overall image temperature measured in Kelvin. The default value is 6500.0, the standard \"daylight\" illumination.  Type: For artistic preference, the temperature scale can be inverted using the type field. A value of \"color_temperature\" will cause higher temperature values to result in a warmer image, while lower temperature values will result in a cooler image. A value of \"white_balance\" will behave in the inverse, i.e., higher temperature values will correspond to a cooler image, while lower temperature values will result in a warmer image. The default, if not provided, is \"white_balance\".  Tone mapping  Tone mapping determines how a color is remapped from HDR-space to SDR-space for display on modern televisions and monitors. For tone mapping, you can choose from the following operators:  Expand table Tone Map\tDescription Reinhard\tA low-cost tone mapping operator [3, eq. 3] that remaps HDR color values in the range [0, ∞) to [0, 1). This operator looks especially good when applied to low-contrast scenes whose values are already within the range of [0, 1), but tends to mute higher luminance values. Reinhard Luma\tAn extended version of the Reinhard operator [3, eq. 4] that comes at a slightly higher cost, but it preserves details in low dynamic range regions of an image that would otherwise be lost by the standard Reinhard operator. Reinhard Luminance\tA version of the extended Reinhard operator [3, eq. 4] modified to adjust the luminance of the input colors. It comes at a slightly higher cost, but it preserves colors in high luminance regions of an image that would otherwise be washed out by the standard Reinhard operator. Hable\tA filmic tone mapping operator meant to emulate the behaviors of real-life film, developed and shared by John Hable at a GDC talk from 2010 titled \"Uncharted 2: HDR Lighting\". [1] Academy Color Encoding System (ACES)\tA filmic tone mapping operator meant to emulate the behaviors of real-life film, specifically following the ACES standard used in television and film. [2] Generic\tA generic tone mapping curve that has been hand-tuned by Mojang's artists. It is similar to the other filmic operators but preserves a bit more hue saturation at high luminance regions. Filmic tone mapping operators  Because filmic tone mapping operators are designed to emulate real-life film, they tend to look best when remapping HDR scene values that were produced from other real-life, physically accurate values, such as the intensity of the sun or the strength of Rayleigh scattering in the atmosphere.  For instance, the relative difference in luminous power between a torch and an Earth-based sun is orders of magnitudes different at noon. Filmic operators are designed to preserve subtle differences in extremely dark and extremely bright areas (like low luminance and high luminance) for this reason, but they come at a higher performance cost compared to the non-filmic variants. There is currently no way for creators to alter the properties of the filmic curves.  Schema  Color grading configurations are JSON files located in the color_grading directory in a resource pack. They follow this format:  JSON Copy {   string \"format_version\", // The 3-part schema version for parsing these color grading settings.   object \"minecraft:color_grading_settings\"   {     object \"description\"     {       string \"identifier\" // The identifier for these color grading settings. The identifier must include a namespace.     }     object \"color_grading\" : opt     {       object \"midtones\" // Color grading parameters for midtones, and for when highlights or shadows are not specified.       {         float[3] \"contrast\" <0.0-4.0> : opt         float[3] \"gain\" <0.0-10.0> : opt         float[3] \"gamma\" <0.0-4.0> : opt         float[3] \"offset\" <-1.0-1.0> : opt         float[3] \"saturation\" <0.0-10.0> : opt       },       object \"highlights\" : opt // Optional color grading parameters for highlights.       {         bool \"enabled\" <true | false>         float \"highlightsMin\" <1.0 - 4.0> : opt         float[3] \"contrast\" <0.0-4.0> : opt         float[3] \"gain\" <0.0-10.0> : opt         float[3] \"gamma\" <0.0-4.0> : opt         float[3] \"offset\" <-1.0-1.0> : opt         float[3] \"saturation\" <0.0-10.0> : opt       },       object \"shadows\" : opt // Optional color grading parameters for shadows.       {         bool \"enabled\" <true | false>         float \"shadowsMax\" <0.1 - 1.0> : opt         float[3] \"contrast\" <0.0-4.0> : opt         float[3] \"gain\" <0.0-10.0> : opt         float[3] \"gamma\" <0.0-4.0> : opt         float[3] \"offset\" <-1.0-1.0> : opt         float[3] \"saturation\" <0.0-10.0> : opt       },       object \"temperature\": opt // Optional parameters for temperature based color grading.       {         bool \"enabled\" <true | false>         float \"temperature\" <1000.0-15000.0> : opt         string \"type\" <\"white_balance\" | \"color_temperature\"> : opt       }     },     object \"tone_mapping\" : opt     {       string \"operator\" <\"reinhard\"|\"reinhard_luma\"|\"reinhard_luminance\"|\"hable\"|\"aces\"|\"generic\">     }   } }   This sample color_grading/color_grading.json file can be used as a starting point. You can also download a sample at https://github.com/microsoft/minecraft-samples/tree/main/deferred_lighting_starter.  JSON Copy {   \"format_version\": \"1.21.40\",   \"minecraft:color_grading_settings\": {     \"description\": {       \"identifier\": \"my_pack:default_color_grading\"     },     \"color_grading\": {       \"midtones\": {           \"contrast\": [1.3, 1.3, 1.3],           \"gain\": [1.0, 1.0, 1.0],           \"gamma\": [2.2, 2.2, 2.2],           \"offset\": [0.0, 0.0, 0.0],           \"saturation\": [1.05, 1.05, 1.05]         }     },     \"tone_mapping\": {       \"operator\": \"reinhard_luminance\"     }   } }  JSON Copy {   \"format_version\": \"1.21.90\",   \"minecraft:color_grading_settings\": {     \"description\": {       \"identifier\": \"my_pack:default_color_grading\"     },     \"color_grading\": {       \"midtones\": {         \"contrast\": [1.3, 1.3, 1.3],         \"gain\": [1.0, 1.0, 1.0],         \"gamma\": [2.2, 2.2, 2.2],         \"offset\": [0.0, 0.0, 0.0],         \"saturation\": [1.05, 1.05, 1.05]       },       \"temperature\": {         \"enabled\": true,         \"temperature\": 6500,         \"type\": \"color_temperature\"       }     },     \"tone_mapping\": {       \"operator\": \"generic\"     }   } }  References  Hable, John. 2010. Uncharted 2: HDR Lighting. GDC 2010. Naughty Dog. https://www.gdcvault.com/play/1012351/Uncharted-2-HDR  Hill, Stephen & Narkowicz, Krzysztof & MJP. https://github.com/ampas/aces-dev; https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/; https://github.com/TheRealMJP/BakingLab  Reinhard, Erik & Stark, Michael & Shirley, Peter & Ferwerda, James. 2002. Photographic Tone Reproduction for Digital Images. ACM Transactions on Graphics. Vol 21. https://www-old.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/colorgradingtonemappingcustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Color Grading and Tone Mapping 06/11/2025  Vibrant Visuals gives you new data-driven capabilities for color grading and tone mapping! With these tools, resource packs can convey unique moods and themes using industry-standard color correction controls.  Color grading  Minecraft's color grading system allows for many degrees of customization of the final image. You can control the saturation, contrast, gain, and offset of pixels per RGB channel. This can be done on a global scale regardless of pixel luminance, or it can be done on a more fine-grained scale with unique sets of parameters for shadows, midtones, and highlights. The highlight parameters are applied to the brightest pixels, the shadow parameters applied to the darkest pixels, and the midtone parameters applied to the pixels with luminance close to the average luminance of the scene.  In order to enable highlight and/or shadow grading, set the corresponding \"enabled\" parameter to true along with any actual grading parameters for that luminance range; simply specifying a Shadow Max or Highlight Min is not enough. The Minecraft Bedrock Editor is a great way to see the effects of these parameters in real-time.  Unless highlights or shadows are specified, midtones will be applied to all pixels. Think of midtones as global settings, and highlights and shadows as refining the bright or dark regions of the image.  Saturation: Determines the hue intensity of colors. A value of 1.0 results in no change in saturation to the original image. A value of 0.0 results in a grayscale image. Values > 1.0 will increase the intensity of colors.  Contrast: Describes the tonal range, the difference in luminance between the bright and dark pixels in an image. An image with high contrast will have pixels with a wide range of luminance values, whereas an image with low contrast will have pixels of a relatively small luminance range. A value of 1.0 results in no change in contrast to the original image. A value of 0.0 results in a completely washed-out, gray image. Values > 1.0 increase the brightness of highlights while darkening the shadows in the final image.  Gain: A multiplication factor applied to each color channel to adjust the overall luminance intensity of the image. A value of 1.0 results in no change to the original image. Values < 1.0 will darken the image while values > 1.0 will brighten it. A value of 0.0 cancels out that color channel completely. Gain is multiplicative and therefore has a stronger affect on brighter pixels than darker pixels.  Gamma: An exponential factor applied to the final color after both color grading and tone mapping to adjust the overall luminance intensity of the image. The standard value for gamma is 2.2. Lower values darken the final image, whereas higher values brighten it. Too high a gamma will cause the final image to appear washed-out.  Offset: An additive factor that is multiplied by the average luminance of the scene and then added to a given color channel to adjust the overall luminance intensity of the image. A value of 0.0 results in no change to the original image. Values > 0.0 will brighten the image, while values < 0.0 will darken it. Offset is additive and therefore has a stronger effect on darker pixels than brighter pixels.  Shadow Max: A factor multiplied by the average luminance of the scene to determine which pixels are considered shadows. Pixels with luminance less than ShadowMax * AverageLuminance will have the shadows set of color grading values applied. A value of 1.0 indicates shadows occupy the entire range of values including and up to the average luminance. Lower values will cause the maximum required luminance value for a pixel to be considered a shadow to drop. This value should not be equal to Highlight Min.  Highlight Min: A factor multiplied by the average luminance of the scene to determine which pixels are considered highlights. Pixels with luminance greater than HighlightMin * AverageLuminance will have the highlights set of color grading values applied. A value of 1.0 indicates highlights occupy the entire range of values including and above the average luminance. Higher values will cause the minimum required luminance value for a pixel to be considered a highlight to rise. This value should not be equal to Shadow Max.  Temperature grading  Temperature-based color grading, added in version 1.21.90, allows you to globally adjust how \"warm\" or \"cool\" the scene is. Warmer temperatures cause the scene to become more yellow/orange, while cooler temperatures make the scene more blue.  Temperature: The overall image temperature measured in Kelvin. The default value is 6500.0, the standard \"daylight\" illumination.  Type: For artistic preference, the temperature scale can be inverted using the type field. A value of \"color_temperature\" will cause higher temperature values to result in a warmer image, while lower temperature values will result in a cooler image. A value of \"white_balance\" will behave in the inverse, i.e., higher temperature values will correspond to a cooler image, while lower temperature values will result in a warmer image. The default, if not provided, is \"white_balance\".  Tone mapping  Tone mapping determines how a color is remapped from HDR-space to SDR-space for display on modern televisions and monitors. For tone mapping, you can choose from the following operators:  Expand table Tone Map\tDescription Reinhard\tA low-cost tone mapping operator [3, eq. 3] that remaps HDR color values in the range [0, ∞) to [0, 1). This operator looks especially good when applied to low-contrast scenes whose values are already within the range of [0, 1), but tends to mute higher luminance values. Reinhard Luma\tAn extended version of the Reinhard operator [3, eq. 4] that comes at a slightly higher cost, but it preserves details in low dynamic range regions of an image that would otherwise be lost by the standard Reinhard operator. Reinhard Luminance\tA version of the extended Reinhard operator [3, eq. 4] modified to adjust the luminance of the input colors. It comes at a slightly higher cost, but it preserves colors in high luminance regions of an image that would otherwise be washed out by the standard Reinhard operator. Hable\tA filmic tone mapping operator meant to emulate the behaviors of real-life film, developed and shared by John Hable at a GDC talk from 2010 titled \"Uncharted 2: HDR Lighting\". [1] Academy Color Encoding System (ACES)\tA filmic tone mapping operator meant to emulate the behaviors of real-life film, specifically following the ACES standard used in television and film. [2] Generic\tA generic tone mapping curve that has been hand-tuned by Mojang's artists. It is similar to the other filmic operators but preserves a bit more hue saturation at high luminance regions. Filmic tone mapping operators  Because filmic tone mapping operators are designed to emulate real-life film, they tend to look best when remapping HDR scene values that were produced from other real-life, physically accurate values, such as the intensity of the sun or the strength of Rayleigh scattering in the atmosphere.  For instance, the relative difference in luminous power between a torch and an Earth-based sun is orders of magnitudes different at noon. Filmic operators are designed to preserve subtle differences in extremely dark and extremely bright areas (like low luminance and high luminance) for this reason, but they come at a higher performance cost compared to the non-filmic variants. There is currently no way for creators to alter the properties of the filmic curves.  Schema  Color grading configurations are JSON files located in the color_grading directory in a resource pack. They follow this format:  JSON Copy {   string \"format_version\", // The 3-part schema version for parsing these color grading settings.   object \"minecraft:color_grading_settings\"   {     object \"description\"     {       string \"identifier\" // The identifier for these color grading settings. The identifier must include a namespace.     }     object \"color_grading\" : opt     {       object \"midtones\" // Color grading parameters for midtones, and for when highlights or shadows are not specified.       {         float[3] \"contrast\" <0.0-4.0> : opt         float[3] \"gain\" <0.0-10.0> : opt         float[3] \"gamma\" <0.0-4.0> : opt         float[3] \"offset\" <-1.0-1.0> : opt         float[3] \"saturation\" <0.0-10.0> : opt       },       object \"highlights\" : opt // Optional color grading parameters for highlights.       {         bool \"enabled\" <true | false>         float \"highlightsMin\" <1.0 - 4.0> : opt         float[3] \"contrast\" <0.0-4.0> : opt         float[3] \"gain\" <0.0-10.0> : opt         float[3] \"gamma\" <0.0-4.0> : opt         float[3] \"offset\" <-1.0-1.0> : opt         float[3] \"saturation\" <0.0-10.0> : opt       },       object \"shadows\" : opt // Optional color grading parameters for shadows.       {         bool \"enabled\" <true | false>         float \"shadowsMax\" <0.1 - 1.0> : opt         float[3] \"contrast\" <0.0-4.0> : opt         float[3] \"gain\" <0.0-10.0> : opt         float[3] \"gamma\" <0.0-4.0> : opt         float[3] \"offset\" <-1.0-1.0> : opt         float[3] \"saturation\" <0.0-10.0> : opt       },       object \"temperature\": opt // Optional parameters for temperature based color grading.       {         bool \"enabled\" <true | false>         float \"temperature\" <1000.0-15000.0> : opt         string \"type\" <\"white_balance\" | \"color_temperature\"> : opt       }     },     object \"tone_mapping\" : opt     {       string \"operator\" <\"reinhard\"|\"reinhard_luma\"|\"reinhard_luminance\"|\"hable\"|\"aces\"|\"generic\">     }   } }   This sample color_grading/color_grading.json file can be used as a starting point. You can also download a sample at https://github.com/microsoft/minecraft-samples/tree/main/deferred_lighting_starter.  JSON Copy {   \"format_version\": \"1.21.40\",   \"minecraft:color_grading_settings\": {     \"description\": {       \"identifier\": \"my_pack:default_color_grading\"     },     \"color_grading\": {       \"midtones\": {           \"contrast\": [1.3, 1.3, 1.3],           \"gain\": [1.0, 1.0, 1.0],           \"gamma\": [2.2, 2.2, 2.2],           \"offset\": [0.0, 0.0, 0.0],           \"saturation\": [1.05, 1.05, 1.05]         }     },     \"tone_mapping\": {       \"operator\": \"reinhard_luminance\"     }   } }  JSON Copy {   \"format_version\": \"1.21.90\",   \"minecraft:color_grading_settings\": {     \"description\": {       \"identifier\": \"my_pack:default_color_grading\"     },     \"color_grading\": {       \"midtones\": {         \"contrast\": [1.3, 1.3, 1.3],         \"gain\": [1.0, 1.0, 1.0],         \"gamma\": [2.2, 2.2, 2.2],         \"offset\": [0.0, 0.0, 0.0],         \"saturation\": [1.05, 1.05, 1.05]       },       \"temperature\": {         \"enabled\": true,         \"temperature\": 6500,         \"type\": \"color_temperature\"       }     },     \"tone_mapping\": {       \"operator\": \"generic\"     }   } }  References  Hable, John. 2010. Uncharted 2: HDR Lighting. GDC 2010. Naughty Dog. https://www.gdcvault.com/play/1012351/Uncharted-2-HDR  Hill, Stephen & Narkowicz, Krzysztof & MJP. https://github.com/ampas/aces-dev; https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/; https://github.com/TheRealMJP/BakingLab  Reinhard, Erik & Stark, Michael & Shirley, Peter & Ferwerda, James. 2002. Photographic Tone Reproduction for Digital Images. ACM Transactions on Graphics. Vol 21. https://www-old.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/subsurfacescatteringcustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Subsurface Scattering 06/11/2025  Vibrant Visuals adds a new capability to Texture Sets: subsurface scattering. This simulates the effect of light shining on translucent surfaces, like leaves, wax, and skin.  This is a comparison of a forest scene with no subsurface scattering vs full subsurface scattering applied to all leaves:  Subsurface Scattering OFF Subsurface Scattering ON  This effect can be controlled with Texture Sets, much like how metalness, emissive, and roughness are controlled. Note that metalness and subsurface cannot be used in conjunction with each other for the same pixel in a texture or uniform value. That is, only non-metals can exhibit subsurface scattering effects. If non-zero values are provided for both metalness and subsurface, then the larger value will win and the other will be ignored. In the event of a tie, subsurface will take precedence.  𝑚 𝑒 𝑡 𝑎 𝑙 𝑛 𝑒 𝑠 𝑠 ( 𝑚 , 𝑠 ) = { 0 : 𝑚 ⩽ 𝑠   𝑚 : 𝑚 > 𝑠 }  𝑠 𝑢 𝑏 𝑠 𝑢 𝑟 𝑓 𝑎 𝑐 𝑒 ( 𝑠 , 𝑚 ) = { 0 : 𝑠 < 𝑚   𝑠 : 𝑠 ⩾ 𝑚 }  (m = Metalness Texture Set; s = Subsurface Texture Set)  Higher subsurface values will increase the effect, allowing more light to penetrate the surface of a given object more and more, while a value of 0 will have no subsurface effect. The effect is calibrated to allow a maximum penetration depth of roughly 1 block.  To take advantage of subsurface scattering, your texture set must define a four-channel \"metalness_emissiveness_roughness_subsurface\" image rather than the typical three-channel MER image. For more details, read the Texture Sets documentation.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/subsurfacescatteringcustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Subsurface Scattering 06/11/2025  Vibrant Visuals adds a new capability to Texture Sets: subsurface scattering. This simulates the effect of light shining on translucent surfaces, like leaves, wax, and skin.  This is a comparison of a forest scene with no subsurface scattering vs full subsurface scattering applied to all leaves:  Subsurface Scattering OFF Subsurface Scattering ON  This effect can be controlled with Texture Sets, much like how metalness, emissive, and roughness are controlled. Note that metalness and subsurface cannot be used in conjunction with each other for the same pixel in a texture or uniform value. That is, only non-metals can exhibit subsurface scattering effects. If non-zero values are provided for both metalness and subsurface, then the larger value will win and the other will be ignored. In the event of a tie, subsurface will take precedence.  𝑚 𝑒 𝑡 𝑎 𝑙 𝑛 𝑒 𝑠 𝑠 ( 𝑚 , 𝑠 ) = { 0 : 𝑚 ⩽ 𝑠   𝑚 : 𝑚 > 𝑠 }  𝑠 𝑢 𝑏 𝑠 𝑢 𝑟 𝑓 𝑎 𝑐 𝑒 ( 𝑠 , 𝑚 ) = { 0 : 𝑠 < 𝑚   𝑠 : 𝑠 ⩾ 𝑚 }  (m = Metalness Texture Set; s = Subsurface Texture Set)  Higher subsurface values will increase the effect, allowing more light to penetrate the surface of a given object more and more, while a value of 0 will have no subsurface effect. The effect is calibrated to allow a maximum penetration depth of roughly 1 block.  To take advantage of subsurface scattering, your texture set must define a four-channel \"metalness_emissiveness_roughness_subsurface\" image rather than the typical three-channel MER image. For more details, read the Texture Sets documentation.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/shadowscustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Shadow Customization 06/11/2025  With Vibrant Visuals, Minecraft: Bedrock Edition gives you control over shadow styles in resource packs. You can choose between either blocky or soft shadows, depending on the artistic effect you want to create.  Styles  Shadows can be styled in one of two ways: blocky or soft. If a pack does not customize the shadow stylization, then soft shadows will be used by default. This stylization is controlled via the \"shadow_style\" field where valid options are \"blocky_shadows\" or \"soft_shadows\".  Shadow Stylization - Blocky Shadow Stylization - Soft  When you use blocky shadows, it's recommended you specify a \"texel_size\" value, which represents the resolution in texels (texture units) to which shadows will be quantized. For this effect to look consistent across all blocks in the world, creators should ensure that all of their block textures are the same resolution (i.e., 16x16px or 32x32px) and specify the shadow texel size to match the same pixel dimension (i.e., 16 or 32). If textures are composed of different resolutions, then shadows will not snap consistently. If not provided, this value will default to the resolution of Minecraft's core assets, which is 16.  Schema  Shadows are configured by the shadows/global.json file in a resource pack. They follow this format:  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these shadow settings.     object \"minecraft:shadow_settings\"     {         string \"shadow_style\", // The type of shadows to use, either \"blocky_shadows\" or \"soft_shadows\"         integer \"texel_size\" // The resolution to snap shadow texels to; recommended to use the same resolution as block texture assets in the accompanying pack     } }   For example, a pack wanting to make use of blocky shadows whose block texture assets have a common resolution of 16x16px would use the following JSON:  JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:shadow_settings\": {         \"shadow_style\": \"blocky_shadows\",         \"texel_size\": 16     } }  Feedback  Was this page helpful?  Yes No Additional resources  Training  Learning path  Minecraft block coding academy - Training  Explore how educators use Minecraft Education to teach programming skills and concepts to learners at lower elementary, upper elementary, and secondary levels."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/shadowscustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Shadow Customization 06/11/2025  With Vibrant Visuals, Minecraft: Bedrock Edition gives you control over shadow styles in resource packs. You can choose between either blocky or soft shadows, depending on the artistic effect you want to create.  Styles  Shadows can be styled in one of two ways: blocky or soft. If a pack does not customize the shadow stylization, then soft shadows will be used by default. This stylization is controlled via the \"shadow_style\" field where valid options are \"blocky_shadows\" or \"soft_shadows\".  Shadow Stylization - Blocky Shadow Stylization - Soft  When you use blocky shadows, it's recommended you specify a \"texel_size\" value, which represents the resolution in texels (texture units) to which shadows will be quantized. For this effect to look consistent across all blocks in the world, creators should ensure that all of their block textures are the same resolution (i.e., 16x16px or 32x32px) and specify the shadow texel size to match the same pixel dimension (i.e., 16 or 32). If textures are composed of different resolutions, then shadows will not snap consistently. If not provided, this value will default to the resolution of Minecraft's core assets, which is 16.  Schema  Shadows are configured by the shadows/global.json file in a resource pack. They follow this format:  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these shadow settings.     object \"minecraft:shadow_settings\"     {         string \"shadow_style\", // The type of shadows to use, either \"blocky_shadows\" or \"soft_shadows\"         integer \"texel_size\" // The resolution to snap shadow texels to; recommended to use the same resolution as block texture assets in the accompanying pack     } }   For example, a pack wanting to make use of blocky shadows whose block texture assets have a common resolution of 16x16px would use the following JSON:  JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:shadow_settings\": {         \"shadow_style\": \"blocky_shadows\",         \"texel_size\": 16     } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/watercustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Water Effects 06/11/2025  Vibrant Visuals dramatically enhances the look of water in Minecraft: Bedrock Edition. You get many of the new features simply by enabling Vibrant Visuals in Minecraft's settings, but you can customize the behavior of water blocks through resource packs. Use the Editor to experiment with different water characteristics and help build your JSON schemas.  Particle concentrations  The composition of particles in a body of water determines its color and how light behaves as it travels through the water. We've boiled them down to three concentrations in mg/L. Use these values to simulate crystal clear lakes, deep oceans, or muddy rivers:  CDOM (Chromophoric Dissolved Organic Matter): High concentrations produce yellow to yellow-brown colors, due to CDOM strongly absorbing blue wavelengths. Open oceans typically have little to no CDOM, and thus retain a blue appearance; fresh water sources, like rivers, tend to have higher concentrations.  Chlorophyll: High concentrations produce green colors, due to chlorophyll strongly absorbing blue and red wavelengths. Sources of chlorophyll, such as phytoplankton, exist in practically every type of body of water, though concentrations widely vary.  Suspended sediment: High concentrations produce red to red-brown colors, due to suspended sediment strongly absorbing blue and green wavelengths. Suspended sediment, like clay and silt, tend to be concentrated in rivers and can indicate recent floods or sources of pollution.  Waves  Waves are an optional effect that can be used to complement water surface animations to make your water appear more realistic. You can blend them with existing water texture animations, or replace them entirely. The waves in Vibrant Visuals are purely an image-based effect—waves don't actually move the vertices of the water surface, so the water surface geometry will remain unchanged.  There are a variety of ways to customize waves to convey different types of water:  Depth: Determines how much waves displace the water surface. Larger values will result in deeper waves, whereas smaller values will produce shallower waves.  Direction Increment: An angle, in degrees, that controls how much the heading changes between each octave.  Frequency: Determines how many waves there are per water block. Can also be thought of as the size of the waves. Larger values will create more tightly packed waves, whereas smaller values will spread waves out over a wider area.  Frequency Scaling: Specifies how much wave frequency changes between octaves. A value of 1 will result in no change between octaves. Values higher than 1 will cause frequencies to increase while values less than 1 will cause frequencies to decrease.  Mix: Controls how much each octave is blended into the neighboring octave.  Pull: Controls how much smaller waves are pulled into larger waves. A value of 0 results in no pull. Values larger than 0 will pull waves in a standard concave fashion, whereas values less than 0 will pull waves in a convex fashion, resulting in more pillowing waves as opposed to cresting waves.  Sample Width: Controls the overall resolution of the fractal effect. A value of 1 represents the lowest resolution, resulting in smoother waves, while values less than 1 produce more chaotic waves.  Shape: Adjusts the core shape of waves. A value of 1 results in a pure sine wave, whereas values larger than 1 will produce sharper waves.  Speed: Determines the movement speed of the first wave and the starting value of the Speed Scaling parameter.  Speed Scaling: Controls how much faster each subsequent octave moves. A value of 1 will result in no change between octaves. Values higher than 1 will cause speeds to increase while values less than 1 will cause speeds to decrease.  Caustics  Caustics make bodies of water more realistic by projecting light rays on underwater surfaces. These rays then scatter and dance as the surface of the water moves. This effect is enabled by default, but can be selectively disabled in given water configurations.  The following parameters can be used to control the appearance of caustics:  Enabled: Whether or not caustics is rendered. If false, all other parameters for caustics are ignored. By default, this value is true.  Frame Length: The number of seconds to spend on a single frame of animation in the caustics sprite sheet texture. A larger value will result in a slower animation, while smaller values will result in a faster animation. The number of frames is automatically determined by the game based on the width and height of the supplied caustics texture, where # of frames = height / width.  Power: Controls how bright the caustics effect appears. A larger value will increase the brightness/intensity.  Scale: Controls the size of the caustics texture when it is projected on the world. This value scales inversely in that, a larger value means that the texture will appear smaller, repeating/tiling more, whereas a smaller value will cause the texture to appear bigger, covering a larger area of the world.  Texture: Specifies a texture to use for the caustics animation. If this value is not supplied by a resource pack, then the game will automatically provide a built-in texture with 64 frames of animation. Any texture must adhere to the following rules:  All frames of animation must be contained in the single texture. Animation frames must be laid out vertically, not horizontally. Each individual frame of animation must have the same resolution as every other frame of animation in a given caustics texture. Each individual frame of animation must square in dimensions. The game will infer the number of frames in the animation based on the width and height of the overall texture, where # of frames = height / width. Like any other resource pack texture, the caustics texture should be located under the \"textures\" directory in the root of your pack, and must be declared in \"textures_list.json\". Schema  Water configurations are JSON files located in water/water.json in a resource pack. They follow this format:  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these water settings.     object \"minecraft:water_settings\"     {         object \"description\"         {             string \"identifier\" // The identifier for these water settings. The identifier must include a namespace.         },         object \"particle_concentrations\" : opt         {             float \"cdom\" <0.0 - 15.0> : opt, // Concentration of chromophoric dissolved organic matter in mg/L; higher concentrations produce more yellow/yellow-brown colors             float \"chlorophyll\" <0.0 - 10.0> : opt, // Concentration of chlorophyll in mg/L; higher concentrations produce more green colors             float \"suspended_sediment\" <0.0 - 300.0> : opt // Concentration of suspended sediment in mg/L; higher concentrations produce more red/red-brown colors         },         object \"waves\" : opt         {             bool \"enabled\" : opt, // Whether or not waves are on or off             float \"depth\" <0.0 - 3.0> : opt, // Controls the amount of wave displacement             float \"direction_increment\" <0.0 - 360.0> : opt, // Controls how much the heading changes between each octave             float \"frequency\" <0.01 - 3.0> : opt, // Controls the size of individual waves; higher values create more tightly packed waves             float \"frequency_scaling\" <0.0 - 2.0> : opt, // Controls how much frequencies change in subsequent octaves             float \"mix\" <0.0 - 1.0> : opt, // Controls how much each octave will blend into the neighboring octave             int \"octaves\" <1 - 30> : opt, // Determines how many layers of waves to simulate; high values result in more complex waves             float \"pull\" <-1.0 - 1.0> : opt, // Controls how much smaller waves are pulled into larger ones             float \"sampleWidth\" <0.01 - 1.0> : opt, // Controls the resolutions of the fractal effect; higher values result in smoother waves             float \"shape\" <1.0 - 10.0> : opt, // Adjusts the shape of the wave             float \"speed\" <0.01 - 10.0> : opt, // Controls the starting speed of the first waves             float \"speed_scaling\" <0.0 - 2.0> : opt // Controls how much faster/slower subsequent octaves move         },         object \"caustics\" : opt         {             bool \"enabled\" : opt, // Whether or not caustics are on or off             float \"frame_length\" <0.01 - 5.0> : opt, // How many seconds to spend on each frame of animation in the caustics texture             int \"power\" <1 - 6> : opt, // Controls how bright the caustics effect appears             float \"scale\" <0.1 - 5.0> : opt, // Controls how size of the repetition of the caustics texture             string \"texture\" : opt // Resource location to a texture for controlling the shape of the caustics; if not used, a built-in Minecraft texture will be supplied automatically         }     } }   The following example JSON can be used as a starting point for an ocean:  JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:water_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_water\"         },         \"particle_concentrations\": {             \"chlorophyll\": 0.5,             \"suspended_sediment\": 0.5,             \"cdom\": 1         },         \"waves\": {             \"enabled\": true,             \"depth\": 1,             \"direction_increment\": 80.0,             \"frequency\": 1,             \"frequency_scaling\": 1.2,             \"mix\": 0.2,             \"octaves\": 28,             \"pull\": 0.38,             \"sampleWidth\": 0.01,             \"shape\": 1.5,             \"speed\": 2,             \"speed_scaling\": 1.03         },         \"caustics\": {             \"enabled\": true,             \"frame_length\": 0.05,             \"power\": 2,             \"scale\": 0.5         }     } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/watercustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Water Effects 06/11/2025  Vibrant Visuals dramatically enhances the look of water in Minecraft: Bedrock Edition. You get many of the new features simply by enabling Vibrant Visuals in Minecraft's settings, but you can customize the behavior of water blocks through resource packs. Use the Editor to experiment with different water characteristics and help build your JSON schemas.  Particle concentrations  The composition of particles in a body of water determines its color and how light behaves as it travels through the water. We've boiled them down to three concentrations in mg/L. Use these values to simulate crystal clear lakes, deep oceans, or muddy rivers:  CDOM (Chromophoric Dissolved Organic Matter): High concentrations produce yellow to yellow-brown colors, due to CDOM strongly absorbing blue wavelengths. Open oceans typically have little to no CDOM, and thus retain a blue appearance; fresh water sources, like rivers, tend to have higher concentrations.  Chlorophyll: High concentrations produce green colors, due to chlorophyll strongly absorbing blue and red wavelengths. Sources of chlorophyll, such as phytoplankton, exist in practically every type of body of water, though concentrations widely vary.  Suspended sediment: High concentrations produce red to red-brown colors, due to suspended sediment strongly absorbing blue and green wavelengths. Suspended sediment, like clay and silt, tend to be concentrated in rivers and can indicate recent floods or sources of pollution.  Waves  Waves are an optional effect that can be used to complement water surface animations to make your water appear more realistic. You can blend them with existing water texture animations, or replace them entirely. The waves in Vibrant Visuals are purely an image-based effect—waves don't actually move the vertices of the water surface, so the water surface geometry will remain unchanged.  There are a variety of ways to customize waves to convey different types of water:  Depth: Determines how much waves displace the water surface. Larger values will result in deeper waves, whereas smaller values will produce shallower waves.  Direction Increment: An angle, in degrees, that controls how much the heading changes between each octave.  Frequency: Determines how many waves there are per water block. Can also be thought of as the size of the waves. Larger values will create more tightly packed waves, whereas smaller values will spread waves out over a wider area.  Frequency Scaling: Specifies how much wave frequency changes between octaves. A value of 1 will result in no change between octaves. Values higher than 1 will cause frequencies to increase while values less than 1 will cause frequencies to decrease.  Mix: Controls how much each octave is blended into the neighboring octave.  Pull: Controls how much smaller waves are pulled into larger waves. A value of 0 results in no pull. Values larger than 0 will pull waves in a standard concave fashion, whereas values less than 0 will pull waves in a convex fashion, resulting in more pillowing waves as opposed to cresting waves.  Sample Width: Controls the overall resolution of the fractal effect. A value of 1 represents the lowest resolution, resulting in smoother waves, while values less than 1 produce more chaotic waves.  Shape: Adjusts the core shape of waves. A value of 1 results in a pure sine wave, whereas values larger than 1 will produce sharper waves.  Speed: Determines the movement speed of the first wave and the starting value of the Speed Scaling parameter.  Speed Scaling: Controls how much faster each subsequent octave moves. A value of 1 will result in no change between octaves. Values higher than 1 will cause speeds to increase while values less than 1 will cause speeds to decrease.  Caustics  Caustics make bodies of water more realistic by projecting light rays on underwater surfaces. These rays then scatter and dance as the surface of the water moves. This effect is enabled by default, but can be selectively disabled in given water configurations.  The following parameters can be used to control the appearance of caustics:  Enabled: Whether or not caustics is rendered. If false, all other parameters for caustics are ignored. By default, this value is true.  Frame Length: The number of seconds to spend on a single frame of animation in the caustics sprite sheet texture. A larger value will result in a slower animation, while smaller values will result in a faster animation. The number of frames is automatically determined by the game based on the width and height of the supplied caustics texture, where # of frames = height / width.  Power: Controls how bright the caustics effect appears. A larger value will increase the brightness/intensity.  Scale: Controls the size of the caustics texture when it is projected on the world. This value scales inversely in that, a larger value means that the texture will appear smaller, repeating/tiling more, whereas a smaller value will cause the texture to appear bigger, covering a larger area of the world.  Texture: Specifies a texture to use for the caustics animation. If this value is not supplied by a resource pack, then the game will automatically provide a built-in texture with 64 frames of animation. Any texture must adhere to the following rules:  All frames of animation must be contained in the single texture. Animation frames must be laid out vertically, not horizontally. Each individual frame of animation must have the same resolution as every other frame of animation in a given caustics texture. Each individual frame of animation must square in dimensions. The game will infer the number of frames in the animation based on the width and height of the overall texture, where # of frames = height / width. Like any other resource pack texture, the caustics texture should be located under the \"textures\" directory in the root of your pack, and must be declared in \"textures_list.json\". Schema  Water configurations are JSON files located in water/water.json in a resource pack. They follow this format:  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these water settings.     object \"minecraft:water_settings\"     {         object \"description\"         {             string \"identifier\" // The identifier for these water settings. The identifier must include a namespace.         },         object \"particle_concentrations\" : opt         {             float \"cdom\" <0.0 - 15.0> : opt, // Concentration of chromophoric dissolved organic matter in mg/L; higher concentrations produce more yellow/yellow-brown colors             float \"chlorophyll\" <0.0 - 10.0> : opt, // Concentration of chlorophyll in mg/L; higher concentrations produce more green colors             float \"suspended_sediment\" <0.0 - 300.0> : opt // Concentration of suspended sediment in mg/L; higher concentrations produce more red/red-brown colors         },         object \"waves\" : opt         {             bool \"enabled\" : opt, // Whether or not waves are on or off             float \"depth\" <0.0 - 3.0> : opt, // Controls the amount of wave displacement             float \"direction_increment\" <0.0 - 360.0> : opt, // Controls how much the heading changes between each octave             float \"frequency\" <0.01 - 3.0> : opt, // Controls the size of individual waves; higher values create more tightly packed waves             float \"frequency_scaling\" <0.0 - 2.0> : opt, // Controls how much frequencies change in subsequent octaves             float \"mix\" <0.0 - 1.0> : opt, // Controls how much each octave will blend into the neighboring octave             int \"octaves\" <1 - 30> : opt, // Determines how many layers of waves to simulate; high values result in more complex waves             float \"pull\" <-1.0 - 1.0> : opt, // Controls how much smaller waves are pulled into larger ones             float \"sampleWidth\" <0.01 - 1.0> : opt, // Controls the resolutions of the fractal effect; higher values result in smoother waves             float \"shape\" <1.0 - 10.0> : opt, // Adjusts the shape of the wave             float \"speed\" <0.01 - 10.0> : opt, // Controls the starting speed of the first waves             float \"speed_scaling\" <0.0 - 2.0> : opt // Controls how much faster/slower subsequent octaves move         },         object \"caustics\" : opt         {             bool \"enabled\" : opt, // Whether or not caustics are on or off             float \"frame_length\" <0.01 - 5.0> : opt, // How many seconds to spend on each frame of animation in the caustics texture             int \"power\" <1 - 6> : opt, // Controls how bright the caustics effect appears             float \"scale\" <0.1 - 5.0> : opt, // Controls how size of the repetition of the caustics texture             string \"texture\" : opt // Resource location to a texture for controlling the shape of the caustics; if not used, a built-in Minecraft texture will be supplied automatically         }     } }   The following example JSON can be used as a starting point for an ocean:  JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:water_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_water\"         },         \"particle_concentrations\": {             \"chlorophyll\": 0.5,             \"suspended_sediment\": 0.5,             \"cdom\": 1         },         \"waves\": {             \"enabled\": true,             \"depth\": 1,             \"direction_increment\": 80.0,             \"frequency\": 1,             \"frequency_scaling\": 1.2,             \"mix\": 0.2,             \"octaves\": 28,             \"pull\": 0.38,             \"sampleWidth\": 0.01,             \"shape\": 1.5,             \"speed\": 2,             \"speed_scaling\": 1.03         },         \"caustics\": {             \"enabled\": true,             \"frame_length\": 0.05,             \"power\": 2,             \"scale\": 0.5         }     } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/biomecustomization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Biome Customization 06/11/2025  There are a lot of ways you can customize Vibrant Visuals effects for different biomes! This document goes over them, linking to more detailed documentation around the Minecraft Learning Portal.  Vibrant Visuals JSONs  Vibrant Visuals Resource packs support a variety of JSON files that allow Creators to customize things like the sun and moon color, the atmospheric properties of the sky, color grading, and more. Each grouping is documented on the following pages:  Atmospherics Color Grading Lighting Water  Packs can provide multiple instances for each type of JSON as long as they have unique filenames and unique identifier fields in their JSON schema. Those identifiers can then be specified in Client Biome JSONs to customize the look and feel of a given biome(s).  Transitions between biomes  In order to smoothly transition between different visual settings for different biomes, the game will automatically blend any customized settings in one of two ways:  Spatial blend based on viewer location  The following settings will smoothly transition as the player's camera moves through the world:  Atmospherics Color Grading Lighting  For instance, imagine a player is located in a Plains biome configured with a yellow sun and blue sky. Next to this biome is a Forest biome, which is configured with a less intense sun, a blue-gray sky and a bit more saturation. As the player approaches the Forest biome, their lighting, atmospherics and color grading settings will interpolate between the Plains biome settings and the forest biome settings. So the sun will become slightly more dim, the color of the sky will slowly adjust and the overall scene will gradually saturate. Once the player has fully transitioned past the biome boundary and into the Forest, then they will see only the Forest biome settings. If the player were to reverse course, the visuals would smoothly return to those of the Plains configuration. If the player were to stop midway between the two biomes, the visuals would hold at the halfway interpolated point for all settings in question.  Spatial blend based on geometry location  The following settings will be calculated on a per-geometry basis and its location in the world as opposed to where the player is located:  Water  This type of blending allows for differences in biomes to be observed from afar, without the need for the player to be located in the actual biome.  For example, imagine a player standing on a cliff in a Stony Shore biome looking out at an Ocean biome. The player pulls out their trusty spyglass where they can observe a Guardian swimming around in a Deep Ocean biome. Looking up and down the Stony Shore, the player sees the jagged rocks eventually turn into a tranquil Beach biome on both sides. The particular body of water in this example stretches across 4 biomes, possibly more. If a pack were to provide 4 different water configurations with slightly different properties and assign them to said biomes, then the player would be able to observe all 4 types of water from their vantage point on the cliff. As water blocks cross from one biome to another, their properties, and thus appearance, will smoothly interpolate from one style to another.  Limitations  There are some parameters that cannot be blended today:  Tone mapping operators cannot be blended. All color grading and tone mapping schemas in a given pack should use the same tone mapping operator. Orbital offset degrees cannot be blended. All lighting schemas in a given pack should use the same orbital offset degree value. Caustics cannot be blended. All water schemas in a given pack should use the same caustics parameters. Waves enabled/disabled cannot be blended. All water schemas in a given pack should use the same wave simulation boolean. Example  Assume a resource pack contains the following files that all contain valid schemas and unique identifiers:  Expand table File\tIdentifier atmospherics/atmospherics.json\tmy_pack:default_atmospherics atmospherics/end.json\tmy_pack:end_atmospherics atmospherics/nether.json\tmy_pack:nether_atmospherics color_grading/color_grading.json\tmy_pack:default_color_grading color_grading/end.json\tmy_pack:end_color_grading color_grading/nether.json\tmy_pack:nether_color_grading lighting/global.json\tmy_pack:default_lighting lighting/end.json\tmy_pack:end_lighting lighting/nether.json\tmy_pack:nether_lighting water/water.json\tmy_pack:default_water water/ocean.json\tmy_pack:ocean_water water/deep_ocean.json\tmy_pack:deep_ocean_water  Because the filenames are reserved to act as global/default values, the identifiers found in atmospherics/atmospherics.json, color_grading/color_grading.json, lighting/global.json and water/water.json will automatically be assigned to the minecraft:atmosphere_identifier, minecraft:color_grading_identifier, minecraft:lighting_identifier and minecraft:water_identifier biome components respectively unless a particular biome JSON specifies differently.  Let's customize the End and Nether biomes to use their own sets of visual parameters.  Filename: biomes/the_end.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"the_end\"     },     \"components\": {       ...,       \"minecraft:atmosphere_identifier\": {         \"atmosphere_identifier\": \"my_pack:end_atmospherics\"       },       \"minecraft:color_grading_identifier\": {         \"color_grading_identifier\": \"my_pack:end_color_grading\"       },       \"minecraft:lighting_identifier\": {         \"lighting_identifier\": \"my_pack:end_lighting\"       }     }   } }    Filename: biomes/hell.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"hell\"     },     \"components\": {       ...,       \"minecraft:atmosphere_identifier\": {         \"atmosphere_identifier\": \"my_pack:nether_atmospherics\"       },       \"minecraft:color_grading_identifier\": {         \"color_grading_identifier\": \"my_pack:nether_color_grading\"       },       \"minecraft:lighting_identifier\": {         \"lighting_identifier\": \"my_pack:nether_lighting\"       }     }   } }   To be complete, one would also want to specify the other biomes in the Nether, such as the Crimson Forest, the Nether Wastes, the Warped Forest, and so on, where you could further customize the look and feel to match the distinct mood of each biome. But we'll leave that as an exercise for the Creator.  Next, let's assign unique water configurations to the Ocean and Deep Ocean biomes.  Filename: biomes/ocean.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"ocean\"     },     \"components\": {       ...,       \"minecraft:water_identifier\": {         \"water_identifier\": \"my_pack:ocean_water\"       }     }   } }    Filename: biomes/deep_ocean.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"deep_ocean\"     },     \"components\": {       ...,       \"minecraft:water_identifier\": {         \"water_identifier\": \"my_pack:deep_ocean_water\"       }     }   } }   And that's all there is to it! Use these identifier components to customize all of your biomes in your Deferred enabled resource pack!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/biomecustomization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Biome Customization 06/11/2025  There are a lot of ways you can customize Vibrant Visuals effects for different biomes! This document goes over them, linking to more detailed documentation around the Minecraft Learning Portal.  Vibrant Visuals JSONs  Vibrant Visuals Resource packs support a variety of JSON files that allow Creators to customize things like the sun and moon color, the atmospheric properties of the sky, color grading, and more. Each grouping is documented on the following pages:  Atmospherics Color Grading Lighting Water  Packs can provide multiple instances for each type of JSON as long as they have unique filenames and unique identifier fields in their JSON schema. Those identifiers can then be specified in Client Biome JSONs to customize the look and feel of a given biome(s).  Transitions between biomes  In order to smoothly transition between different visual settings for different biomes, the game will automatically blend any customized settings in one of two ways:  Spatial blend based on viewer location  The following settings will smoothly transition as the player's camera moves through the world:  Atmospherics Color Grading Lighting  For instance, imagine a player is located in a Plains biome configured with a yellow sun and blue sky. Next to this biome is a Forest biome, which is configured with a less intense sun, a blue-gray sky and a bit more saturation. As the player approaches the Forest biome, their lighting, atmospherics and color grading settings will interpolate between the Plains biome settings and the forest biome settings. So the sun will become slightly more dim, the color of the sky will slowly adjust and the overall scene will gradually saturate. Once the player has fully transitioned past the biome boundary and into the Forest, then they will see only the Forest biome settings. If the player were to reverse course, the visuals would smoothly return to those of the Plains configuration. If the player were to stop midway between the two biomes, the visuals would hold at the halfway interpolated point for all settings in question.  Spatial blend based on geometry location  The following settings will be calculated on a per-geometry basis and its location in the world as opposed to where the player is located:  Water  This type of blending allows for differences in biomes to be observed from afar, without the need for the player to be located in the actual biome.  For example, imagine a player standing on a cliff in a Stony Shore biome looking out at an Ocean biome. The player pulls out their trusty spyglass where they can observe a Guardian swimming around in a Deep Ocean biome. Looking up and down the Stony Shore, the player sees the jagged rocks eventually turn into a tranquil Beach biome on both sides. The particular body of water in this example stretches across 4 biomes, possibly more. If a pack were to provide 4 different water configurations with slightly different properties and assign them to said biomes, then the player would be able to observe all 4 types of water from their vantage point on the cliff. As water blocks cross from one biome to another, their properties, and thus appearance, will smoothly interpolate from one style to another.  Limitations  There are some parameters that cannot be blended today:  Tone mapping operators cannot be blended. All color grading and tone mapping schemas in a given pack should use the same tone mapping operator. Orbital offset degrees cannot be blended. All lighting schemas in a given pack should use the same orbital offset degree value. Caustics cannot be blended. All water schemas in a given pack should use the same caustics parameters. Waves enabled/disabled cannot be blended. All water schemas in a given pack should use the same wave simulation boolean. Example  Assume a resource pack contains the following files that all contain valid schemas and unique identifiers:  Expand table File\tIdentifier atmospherics/atmospherics.json\tmy_pack:default_atmospherics atmospherics/end.json\tmy_pack:end_atmospherics atmospherics/nether.json\tmy_pack:nether_atmospherics color_grading/color_grading.json\tmy_pack:default_color_grading color_grading/end.json\tmy_pack:end_color_grading color_grading/nether.json\tmy_pack:nether_color_grading lighting/global.json\tmy_pack:default_lighting lighting/end.json\tmy_pack:end_lighting lighting/nether.json\tmy_pack:nether_lighting water/water.json\tmy_pack:default_water water/ocean.json\tmy_pack:ocean_water water/deep_ocean.json\tmy_pack:deep_ocean_water  Because the filenames are reserved to act as global/default values, the identifiers found in atmospherics/atmospherics.json, color_grading/color_grading.json, lighting/global.json and water/water.json will automatically be assigned to the minecraft:atmosphere_identifier, minecraft:color_grading_identifier, minecraft:lighting_identifier and minecraft:water_identifier biome components respectively unless a particular biome JSON specifies differently.  Let's customize the End and Nether biomes to use their own sets of visual parameters.  Filename: biomes/the_end.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"the_end\"     },     \"components\": {       ...,       \"minecraft:atmosphere_identifier\": {         \"atmosphere_identifier\": \"my_pack:end_atmospherics\"       },       \"minecraft:color_grading_identifier\": {         \"color_grading_identifier\": \"my_pack:end_color_grading\"       },       \"minecraft:lighting_identifier\": {         \"lighting_identifier\": \"my_pack:end_lighting\"       }     }   } }    Filename: biomes/hell.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"hell\"     },     \"components\": {       ...,       \"minecraft:atmosphere_identifier\": {         \"atmosphere_identifier\": \"my_pack:nether_atmospherics\"       },       \"minecraft:color_grading_identifier\": {         \"color_grading_identifier\": \"my_pack:nether_color_grading\"       },       \"minecraft:lighting_identifier\": {         \"lighting_identifier\": \"my_pack:nether_lighting\"       }     }   } }   To be complete, one would also want to specify the other biomes in the Nether, such as the Crimson Forest, the Nether Wastes, the Warped Forest, and so on, where you could further customize the look and feel to match the distinct mood of each biome. But we'll leave that as an exercise for the Creator.  Next, let's assign unique water configurations to the Ocean and Deep Ocean biomes.  Filename: biomes/ocean.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"ocean\"     },     \"components\": {       ...,       \"minecraft:water_identifier\": {         \"water_identifier\": \"my_pack:ocean_water\"       }     }   } }    Filename: biomes/deep_ocean.client_biome.json  JSON Copy {   \"format_version\": \"1.21.70\",   \"minecraft:client_biome\": {     \"description\": {       \"identifier\": \"deep_ocean\"     },     \"components\": {       ...,       \"minecraft:water_identifier\": {         \"water_identifier\": \"my_pack:deep_ocean_water\"       }     }   } }   And that's all there is to it! Use these identifier components to customize all of your biomes in your Deferred enabled resource pack!  Feedback  Was this page helpful?  Yes No Additional resources  Training  Learning path  Use advance techniques in canvas apps to perform custom updates and optimization - Training  Use advance techniques in canvas apps to perform custom updates and optimization"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/keyframejsonsyntax?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Key Frame JSON Syntax 06/11/2025  Sometimes, in order to make your world more dynamic, you will want to change a particular lighting parameter over time. To do this, you can take advantage of a new \"key frame\" syntax, which can be substituted for any value in the lighting JSON schemas annotated with optkeyframe.  Here's how it works:  Take this example of a lighting/global.json file:  JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:lighting_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_lighting\"         },         \"directional_lights\": {             \"sun\": {                 \"illuminance\": 100000,                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },             \"moon\": {                  \"illuminance\": 0.27,                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },              \"orbital_offset_degrees\": 0.0         },         \"emissive\": {             \"desaturation\": 0.1         },         \"ambient\": {             \"illuminance\": 0.02,             \"color\": \"#ffffffff\"         }     } }     While this illuminance parameter of 100,000 lux for our sun looks good at noon, it's far too bright during dawn and dusk. To address this, we can use key frames for the sun's illuminance parameter.  Key frames are simply a collection of pairs of numbers. These pairs are referred to as key-value pairs, where the key is a number from 0 (noon) to 1 (the next noon, 24 hours later) representing a particular time of day in game, and the value represents whatever parameter is being key-framed.  In our example using sun illuminance, the value would be of type float. When key frames are provided for a supported lighting parameter instead of a single value, the engine linearly interpolates between the values of the key frames according to the time of day in game.  With this in mind, we can adjust our lighting/global.json parameters to alter the sun's illuminance over time:  JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:lighting_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_lighting\"         },         \"directional_lights\": {             \"sun\": {                 \"illuminance\": {                   \"0.0\": 100000.0,  // Noon                   \"0.25\": 20000.0, // Sunset                   \"0.35\": 400.0,                   \"0.5\": 1.0,  // Midnight                   \"0.65\": 400.0,                   \"0.75\": 20000.0, // Sunrise                   \"1.0\": 100000.0   // Noon                 },                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },             \"moon\": {                  \"illuminance\": 0.27,                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },              \"orbital_offset_degrees\": 0.0         },         \"emissive\": {             \"desaturation\": 0.1         },         \"ambient\": {             \"illuminance\": 0.02,             \"color\": \"#ffffffff\"         }     } }   Similar things can be done with the sun's color or the moon's illuminance or any of the atmospherics parameters! Experiment to find the right thing for your world. Key frames currently support floats and colors (both RGB and hexadecimal) and the only supported method of interpolation is linear. There is virtually no limit to the granularity at which you can define key frames.  The following diagram can be used to reference key times of the day:  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/keyframejsonsyntax?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Key Frame JSON Syntax 06/11/2025  Sometimes, in order to make your world more dynamic, you will want to change a particular lighting parameter over time. To do this, you can take advantage of a new \"key frame\" syntax, which can be substituted for any value in the lighting JSON schemas annotated with optkeyframe.  Here's how it works:  Take this example of a lighting/global.json file:  JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:lighting_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_lighting\"         },         \"directional_lights\": {             \"sun\": {                 \"illuminance\": 100000,                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },             \"moon\": {                  \"illuminance\": 0.27,                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },              \"orbital_offset_degrees\": 0.0         },         \"emissive\": {             \"desaturation\": 0.1         },         \"ambient\": {             \"illuminance\": 0.02,             \"color\": \"#ffffffff\"         }     } }     While this illuminance parameter of 100,000 lux for our sun looks good at noon, it's far too bright during dawn and dusk. To address this, we can use key frames for the sun's illuminance parameter.  Key frames are simply a collection of pairs of numbers. These pairs are referred to as key-value pairs, where the key is a number from 0 (noon) to 1 (the next noon, 24 hours later) representing a particular time of day in game, and the value represents whatever parameter is being key-framed.  In our example using sun illuminance, the value would be of type float. When key frames are provided for a supported lighting parameter instead of a single value, the engine linearly interpolates between the values of the key frames according to the time of day in game.  With this in mind, we can adjust our lighting/global.json parameters to alter the sun's illuminance over time:  JSON Copy {     \"format_version\": \"1.21.40\",     \"minecraft:lighting_settings\": {         \"description\": {             \"identifier\": \"my_pack:default_lighting\"         },         \"directional_lights\": {             \"sun\": {                 \"illuminance\": {                   \"0.0\": 100000.0,  // Noon                   \"0.25\": 20000.0, // Sunset                   \"0.35\": 400.0,                   \"0.5\": 1.0,  // Midnight                   \"0.65\": 400.0,                   \"0.75\": 20000.0, // Sunrise                   \"1.0\": 100000.0   // Noon                 },                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },             \"moon\": {                  \"illuminance\": 0.27,                 \"color\": [ 255.0, 255.0, 255.0, 255.0 ]             },              \"orbital_offset_degrees\": 0.0         },         \"emissive\": {             \"desaturation\": 0.1         },         \"ambient\": {             \"illuminance\": 0.02,             \"color\": \"#ffffffff\"         }     } }   Similar things can be done with the sun's color or the moon's illuminance or any of the atmospherics parameters! Experiment to find the right thing for your world. Key frames currently support floats and colors (both RGB and hexadecimal) and the only supported method of interpolation is linear. There is virtually no limit to the granularity at which you can define key frames.  The following diagram can be used to reference key times of the day:  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/shadowscustomization?view=minecraft-bedrock-experimental&tabs=ShadowStylizationBlocky", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Shadow Customization 06/11/2025  With Vibrant Visuals, Minecraft: Bedrock Edition gives you control over shadow styles in resource packs. You can choose between either blocky or soft shadows, depending on the artistic effect you want to create.  Styles  Shadows can be styled in one of two ways: blocky or soft. If a pack does not customize the shadow stylization, then soft shadows will be used by default. This stylization is controlled via the \"shadow_style\" field where valid options are \"blocky_shadows\" or \"soft_shadows\".  Shadow Stylization - Blocky Shadow Stylization - Soft  When you use blocky shadows, it's recommended you specify a \"texel_size\" value, which represents the resolution in texels (texture units) to which shadows will be quantized. For this effect to look consistent across all blocks in the world, creators should ensure that all of their block textures are the same resolution (i.e., 16x16px or 32x32px) and specify the shadow texel size to match the same pixel dimension (i.e., 16 or 32). If textures are composed of different resolutions, then shadows will not snap consistently. If not provided, this value will default to the resolution of Minecraft's core assets, which is 16.  Schema  Shadows are configured by the shadows/global.json file in a resource pack. They follow this format:  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these shadow settings.     object \"minecraft:shadow_settings\"     {         string \"shadow_style\", // The type of shadows to use, either \"blocky_shadows\" or \"soft_shadows\"         integer \"texel_size\" // The resolution to snap shadow texels to; recommended to use the same resolution as block texture assets in the accompanying pack     } }   For example, a pack wanting to make use of blocky shadows whose block texture assets have a common resolution of 16x16px would use the following JSON:  JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:shadow_settings\": {         \"shadow_style\": \"blocky_shadows\",         \"texel_size\": 16     } }  Feedback  Was this page helpful?  Yes No Additional resources  Training  Learning path  Minecraft block coding academy - Training  Explore how educators use Minecraft Education to teach programming skills and concepts to learners at lower elementary, upper elementary, and secondary levels."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/shadowscustomization?view=minecraft-bedrock-stable&tabs=ShadowStylizationBlocky", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Shadow Customization 06/11/2025  With Vibrant Visuals, Minecraft: Bedrock Edition gives you control over shadow styles in resource packs. You can choose between either blocky or soft shadows, depending on the artistic effect you want to create.  Styles  Shadows can be styled in one of two ways: blocky or soft. If a pack does not customize the shadow stylization, then soft shadows will be used by default. This stylization is controlled via the \"shadow_style\" field where valid options are \"blocky_shadows\" or \"soft_shadows\".  Shadow Stylization - Blocky Shadow Stylization - Soft  When you use blocky shadows, it's recommended you specify a \"texel_size\" value, which represents the resolution in texels (texture units) to which shadows will be quantized. For this effect to look consistent across all blocks in the world, creators should ensure that all of their block textures are the same resolution (i.e., 16x16px or 32x32px) and specify the shadow texel size to match the same pixel dimension (i.e., 16 or 32). If textures are composed of different resolutions, then shadows will not snap consistently. If not provided, this value will default to the resolution of Minecraft's core assets, which is 16.  Schema  Shadows are configured by the shadows/global.json file in a resource pack. They follow this format:  JSON Copy {     string \"format_version\", // The 3-part schema version for parsing these shadow settings.     object \"minecraft:shadow_settings\"     {         string \"shadow_style\", // The type of shadows to use, either \"blocky_shadows\" or \"soft_shadows\"         integer \"texel_size\" // The resolution to snap shadow texels to; recommended to use the same resolution as block texture assets in the accompanying pack     } }   For example, a pack wanting to make use of blocky shadows whose block texture assets have a common resolution of 16x16px would use the following JSON:  JSON Copy {     \"format_version\": \"1.21.80\",     \"minecraft:shadow_settings\": {         \"shadow_style\": \"blocky_shadows\",         \"texel_size\": 16     } }  Feedback  Was this page helpful?  Yes No Additional resources  Training  Learning path  Minecraft block coding academy - Training  Explore how educators use Minecraft Education to teach programming skills and concepts to learners at lower elementary, upper elementary, and secondary levels."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/subsurfacescatteringcustomization?view=minecraft-bedrock-stable&tabs=SubSurfaceScatteringOFF", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Subsurface Scattering 06/11/2025  Vibrant Visuals adds a new capability to Texture Sets: subsurface scattering. This simulates the effect of light shining on translucent surfaces, like leaves, wax, and skin.  This is a comparison of a forest scene with no subsurface scattering vs full subsurface scattering applied to all leaves:  Subsurface Scattering OFF Subsurface Scattering ON  This effect can be controlled with Texture Sets, much like how metalness, emissive, and roughness are controlled. Note that metalness and subsurface cannot be used in conjunction with each other for the same pixel in a texture or uniform value. That is, only non-metals can exhibit subsurface scattering effects. If non-zero values are provided for both metalness and subsurface, then the larger value will win and the other will be ignored. In the event of a tie, subsurface will take precedence.  𝑚 𝑒 𝑡 𝑎 𝑙 𝑛 𝑒 𝑠 𝑠 ( 𝑚 , 𝑠 ) = { 0 : 𝑚 ⩽ 𝑠   𝑚 : 𝑚 > 𝑠 }  𝑠 𝑢 𝑏 𝑠 𝑢 𝑟 𝑓 𝑎 𝑐 𝑒 ( 𝑠 , 𝑚 ) = { 0 : 𝑠 < 𝑚   𝑠 : 𝑠 ⩾ 𝑚 }  (m = Metalness Texture Set; s = Subsurface Texture Set)  Higher subsurface values will increase the effect, allowing more light to penetrate the surface of a given object more and more, while a value of 0 will have no subsurface effect. The effect is calibrated to allow a maximum penetration depth of roughly 1 block.  To take advantage of subsurface scattering, your texture set must define a four-channel \"metalness_emissiveness_roughness_subsurface\" image rather than the typical three-channel MER image. For more details, read the Texture Sets documentation.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/vibrantvisuals/subsurfacescatteringcustomization?view=minecraft-bedrock-experimental&tabs=SubSurfaceScatteringOFF", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Subsurface Scattering 06/11/2025  Vibrant Visuals adds a new capability to Texture Sets: subsurface scattering. This simulates the effect of light shining on translucent surfaces, like leaves, wax, and skin.  This is a comparison of a forest scene with no subsurface scattering vs full subsurface scattering applied to all leaves:  Subsurface Scattering OFF Subsurface Scattering ON  This effect can be controlled with Texture Sets, much like how metalness, emissive, and roughness are controlled. Note that metalness and subsurface cannot be used in conjunction with each other for the same pixel in a texture or uniform value. That is, only non-metals can exhibit subsurface scattering effects. If non-zero values are provided for both metalness and subsurface, then the larger value will win and the other will be ignored. In the event of a tie, subsurface will take precedence.  𝑚 𝑒 𝑡 𝑎 𝑙 𝑛 𝑒 𝑠 𝑠 ( 𝑚 , 𝑠 ) = { 0 : 𝑚 ⩽ 𝑠   𝑚 : 𝑚 > 𝑠 }  𝑠 𝑢 𝑏 𝑠 𝑢 𝑟 𝑓 𝑎 𝑐 𝑒 ( 𝑠 , 𝑚 ) = { 0 : 𝑠 < 𝑚   𝑠 : 𝑠 ⩾ 𝑚 }  (m = Metalness Texture Set; s = Subsurface Texture Set)  Higher subsurface values will increase the effect, allowing more light to penetrate the surface of a given object more and more, while a value of 0 will have no subsurface effect. The effect is calibrated to allow a maximum penetration depth of roughly 1 block.  To take advantage of subsurface scattering, your texture set must define a four-channel \"metalness_emissiveness_roughness_subsurface\" image rather than the typical three-channel MER image. For more details, read the Texture Sets documentation.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxpbrtutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Physically Based Rendering Tutorial 06/11/2025   Important  This tutorial has been superseded by Use Blockbench to Create Vibrant Visual Models. Please follow that link to continue!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxpbrtutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Physically Based Rendering Tutorial 06/11/2025   Important  This tutorial has been superseded by Use Blockbench to Create Vibrant Visual Models. Please follow that link to continue!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/actorstorage?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Actor Storage in Minecraft: Bedrock Edition 09/08/2023  Minecraft has inspired many third parties to create useful world file viewing and editing tools that exist outside the client. Tools like the Universal Minecraft Editor and MCEdit are community favorites and are dependent upon knowing where to find each piece of the level's data on disk in the LevelDB files. With the upgrade from legacy actor storage to modern actor storage in 1.18.20, the locations in the LevelDB files which the data for actors (entities) is stored has changed and these third party developers need to be aware.  What did legacy actor data look like?  Before version 1.18.30, actor data was stored per chunk as a blob of all actors in that chunk. This meant that whenever a single actor changed, we would:  Collect the data from every individual actor in the chunk Append the data for each actor into a single buffer/blob Write that grouped data to the chunk Why are we moving actor data?  The legacy actor data storage format meant if one actor in a chunk is changed you have to save them all, even if only one actually changed. This resulted in a lot of unnecessary operations and made handling the transfer of entities between chunks an expensive and fragile system.  How is modern actor data stored on disk?  Modern actor storage moves to storing each Actor under a unique individual LevelDB key. This enables us to have save operations that act only in individual actors. This also means that there is no key-value pair for all actors in a chunk. In fact the individual actor keys are separated into their own key space from the rest of chunk data and chunks do not have data on disk directly referencing actors they contain.  Instead, we use data from the chunk to deterministically generate a key that is unique to the chunk in which we store a digest of the LevelDB keys for the Actors in the chunk. These digest entries are also separated from the non-actor chunk data and the actor key space.  Let's take a look at how this appears on disk:  Chunk Key Space  On the left of the diagram, we can see the chunk key space. These keys take the legacy chunk key form of <Chunk Position><DimensionID>. There is a very old legacy chunk format in which there is no dimension ID, so it is possible to load a really old world in which chunk keys do not have a dimension ID. They will be saved out under a new key with the dimension ID. This is old behavior that still exists.  These are the smallest keys used by pushing them together contiguously on disk. The chunk key is used as a prefix for keys which store all non-actor data from the chunk. Each type of data from the chunk has its own key ID that is appended to the chunk key prefix.  Non-Actor Data Chunk Key IDs C++ Copy enum class LevelChunkTag : char {   Data3D = 43,   Version, // This was moved to the front as needed for the extended heights feature. Old chunks will not have this data.   Data2D,   Data2DLegacy,   SubChunkPrefix,   LegacyTerrain,   BlockEntity,   Entity,   PendingTicks,   LegacyBlockExtraData,   BiomeState,   FinalizedState,   ConversionData, // data that the converter provides, that are used at runtime for things like blending   BorderBlocks,   HardcodedSpawners,   RandomTicks,   CheckSums,   GenerationSeed,   GeneratedPreCavesAndCliffsBlending = 61, // not used, DON'T REMOVE   BlendingBiomeHeight = 62, // not used, DON'T REMOVE   MetaDataHash,   BlendingData,   ActorDigestVersion,   LegacyVersion = 118, };    Actor Digest Key Space  In the middle, we have the digest key space. Each digest key takes the form digp<Chunk Key>.  digp is a hardcoded prefix for all digest keys. This forces all digests to be contiguous on disk and increases the size of all digest keys such that they are placed ahead of the non-actor chunk data in the LevelDB.  <Chunk Key> is the same key string used by the chunk the data is associated with.  Actor Key Space  On the right, we have the actor key space. Each actor key takes the form actorprefix<ActorUniqueID>.  actorprefix is a hardcoded prefix used for all actor keys. This forces all actor data to be contiguous on disk and increases the size of all actor keys such that they are placed ahead of the non-actor chunk data and all digests in the LevelDB.  <ActorUniqueID> is a unique ID that is generated for each actor when it is added to the level. This ID is consistent between play sessions and is only unique to this world. Other actors in other worlds may have the same ID, but no actor in the same world will have the same ID.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/actorstorage?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Actor Storage in Minecraft: Bedrock Edition 09/08/2023  Minecraft has inspired many third parties to create useful world file viewing and editing tools that exist outside the client. Tools like the Universal Minecraft Editor and MCEdit are community favorites and are dependent upon knowing where to find each piece of the level's data on disk in the LevelDB files. With the upgrade from legacy actor storage to modern actor storage in 1.18.20, the locations in the LevelDB files which the data for actors (entities) is stored has changed and these third party developers need to be aware.  What did legacy actor data look like?  Before version 1.18.30, actor data was stored per chunk as a blob of all actors in that chunk. This meant that whenever a single actor changed, we would:  Collect the data from every individual actor in the chunk Append the data for each actor into a single buffer/blob Write that grouped data to the chunk Why are we moving actor data?  The legacy actor data storage format meant if one actor in a chunk is changed you have to save them all, even if only one actually changed. This resulted in a lot of unnecessary operations and made handling the transfer of entities between chunks an expensive and fragile system.  How is modern actor data stored on disk?  Modern actor storage moves to storing each Actor under a unique individual LevelDB key. This enables us to have save operations that act only in individual actors. This also means that there is no key-value pair for all actors in a chunk. In fact the individual actor keys are separated into their own key space from the rest of chunk data and chunks do not have data on disk directly referencing actors they contain.  Instead, we use data from the chunk to deterministically generate a key that is unique to the chunk in which we store a digest of the LevelDB keys for the Actors in the chunk. These digest entries are also separated from the non-actor chunk data and the actor key space.  Let's take a look at how this appears on disk:  Chunk Key Space  On the left of the diagram, we can see the chunk key space. These keys take the legacy chunk key form of <Chunk Position><DimensionID>. There is a very old legacy chunk format in which there is no dimension ID, so it is possible to load a really old world in which chunk keys do not have a dimension ID. They will be saved out under a new key with the dimension ID. This is old behavior that still exists.  These are the smallest keys used by pushing them together contiguously on disk. The chunk key is used as a prefix for keys which store all non-actor data from the chunk. Each type of data from the chunk has its own key ID that is appended to the chunk key prefix.  Non-Actor Data Chunk Key IDs C++ Copy enum class LevelChunkTag : char {   Data3D = 43,   Version, // This was moved to the front as needed for the extended heights feature. Old chunks will not have this data.   Data2D,   Data2DLegacy,   SubChunkPrefix,   LegacyTerrain,   BlockEntity,   Entity,   PendingTicks,   LegacyBlockExtraData,   BiomeState,   FinalizedState,   ConversionData, // data that the converter provides, that are used at runtime for things like blending   BorderBlocks,   HardcodedSpawners,   RandomTicks,   CheckSums,   GenerationSeed,   GeneratedPreCavesAndCliffsBlending = 61, // not used, DON'T REMOVE   BlendingBiomeHeight = 62, // not used, DON'T REMOVE   MetaDataHash,   BlendingData,   ActorDigestVersion,   LegacyVersion = 118, };    Actor Digest Key Space  In the middle, we have the digest key space. Each digest key takes the form digp<Chunk Key>.  digp is a hardcoded prefix for all digest keys. This forces all digests to be contiguous on disk and increases the size of all digest keys such that they are placed ahead of the non-actor chunk data in the LevelDB.  <Chunk Key> is the same key string used by the chunk the data is associated with.  Actor Key Space  On the right, we have the actor key space. Each actor key takes the form actorprefix<ActorUniqueID>.  actorprefix is a hardcoded prefix used for all actor keys. This forces all actor data to be contiguous on disk and increases the size of all actor keys such that they are placed ahead of the non-actor chunk data and all digests in the LevelDB.  <ActorUniqueID> is a unique ID that is generated for each actor when it is added to the level. This ID is consistent between play sessions and is only unique to this world. Other actors in other worlds may have the same ID, but no actor in the same world will have the same ID.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxpbrtutorial?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Physically Based Rendering Tutorial 06/11/2025   Important  This tutorial has been superseded by Use Blockbench to Create Vibrant Visual Models. Please follow that link to continue!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/rtxpbrtutorial?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Physically Based Rendering Tutorial 06/11/2025   Important  This tutorial has been superseded by Use Blockbench to Create Vibrant Visual Models. Please follow that link to continue!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/foginresourcepacks?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fog in Resource Packs 05/19/2025  Fogs in Minecraft: Bedrock Edition use JSON files to determine their values. Creators can define their own sets of fog values in their resource packs. A new folder can be made at the root of a resource pack called fogs. Any JSON files within this folder will be registered as new fog definitions that can be used by the game.  In this tutorial you will learn the following:  What a fog file looks like and what options are available for customization. The order that fog is applied based on various features, including biome definitions and the /fog command. Requirements  It's recommended you complete Introduction to Resource Packs before beginning this tutorial.  JSON Example  The Vanilla Resource Pack template contains all of the fog files used in the game. These files can serve as examples for creating your own fog definitions. A completed fog file will look similar to the following:  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"minecraft:fog_default\"     },     \"distance\": {       \"air\": {         \"fog_start\": 0.92,         \"fog_end\": 1.0,         \"fog_color\": \"#ABD2FF\",         \"render_distance_type\": \"render\"       },       \"water\": {         \"fog_start\": 0,         \"fog_end\": 60.0,         \"fog_color\": \"#44AFF5\",         \"render_distance_type\": \"fixed\",         \"transition_fog\": {           \"init_fog\": {             \"fog_start\": 0.0,             \"fog_end\": 0.01,             \"fog_color\": \"#44AFF5\",             \"render_distance_type\": \"fixed\"           },           \"min_percent\": 0.25,           \"mid_seconds\": 5,           \"mid_percent\": 0.6,           \"max_seconds\": 30         }       },       \"weather\": {         \"fog_start\": 0.23,         \"fog_end\": 0.7,         \"fog_color\": \"#666666\",         \"render_distance_type\": \"render\"       },       \"lava\": {         \"fog_start\": 0.0,         \"fog_end\": 0.64,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       },       \"lava_resistance\": {         \"fog_start\": 2.0,         \"fog_end\": 4.0,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       }     }   } }  Variables format_version  The resource pack version that this fog setting was built for. This is used for determining upgrade paths and backwards compatibility in newer versions of the game. The minimum version is 1.16.100.  minecraft:fog_settings  Contains the definitions and options of the fog.  description  Holds the description for this fog setting, which primarily contains an identifier.  identifier  Held within the description object.  The unique name to refer to this fog setting. Each identifier requires a namespace. You also must have each identifier be unique or you will get an error. The minecraft namespace is allowed to be used only by the vanilla resource packs.  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"custom_pack:example\"     },     ...   } }  distance  This object contains the values for distance-based fog. This is the fog that limits the player from seeing anything beyond a specific distance from them. Each field within this object contains one type of distance value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and the Lava Resistance effect is active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"distance\": {       \"air\": {         ...       },       \"water\": {         ...       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each distance setting type, you can set the following variables:  fog_start: The distance where the fog will begin to appear. fog_end: The distance where the fog will become completely opaque. render_distance_type: Setting this will determine how the start and end values are used for calculating the fog distances. fixed: The distance is measured in the number of blocks away. render: The distance is multiplied against the current render distance. fog_color: The color that the fog will take on. transition_fog   Note  transition_fog works only for fog in a water setting.  With transition_fog specified, players will see a fog transition from init_fog setting to the water setting when they move into water. The speed of transition can be controlled by percent and second values.  In each transition_fog setting type, you can set the following variables:  init_fog: Initial fog that will slowly transition into water distance fog of the biome when player goes into water. min_percent: Minimum progress of fog transition. mid_seconds: The time takes to reach certain progress('mid_percent') of fog transition. mid_percent: The progress of fog transition after 'mid_seconds' seconds. max_seconds: Total amount of time it takes to complete the fog transition. volumetric  This object contains the values for volumetric fog. This fog will be displayed as a calculation from light passing through blocks. Currently this is only used for Ray Tracing.  density  Held within the volumetric object. Each field within it contains one type of density value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and they have the Lava Resistance effect active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"density\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each density setting type, you can set the following variables:  max_density: the multiplier on how much the fog disrupts the light. 0.0 will have no fog, and 1.0 will be near opaque. uniform: when set to true, the fog density will occur evenly across all heights. zero_density_height: the height in blocks that the fog will begin to appear. This can only be set if uniform is set to false. max_density_height: the height in blocks that the fog will become its max_density. This can be set only if uniform is set to false. media_coefficients  Held within the volumetric object.  Each field within this object defines one type of coefficient value. These are used to determine how the light is dispersed or refracted by the fog as rays travel through different mediums/blocks.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water. cloud: used when light is passing through clouds.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"media_coefficients\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each coefficient setting type, you can set the following variables:  scattering: how much of the RGB of the light the fog will spread. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. absorption: how much of the RGB of the light the fog will absorb. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. Henyey-Greenstein G  Available in format_version 1.21.90 and above, and only applicable in Vibrant Visuals resource packs.  Held within the volumetric object.  Each field within this object defines one type of g value. These are used to determine the distribution of scattered light in different mediums.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"henyey_greenstein_g\": {         \"air\": {           \"henyey_greenstein_g\": 0.75         },         \"water\": {           \"henyey_greenstein_g\": 0.6         }       }     }   In each medium setting type, you can set the following variable:  henyey_greenstein_g: Controls the distribution of scattered light. Values can range from [-1.0, 1.0]. Positive values will result in forward-scattering, while negative values will result in back-scattering. The default value for air is 0.75, while the default for water is 0.6. Active Fog Stack  The active fog stack is used to determine which fog setting to use at any given time in the game. Each player has a unique fog stack.  Whenever the game needs to determine the values for the fog, it will start at the top of the fog stack and check down it until it has found a value for the current setting type. If a fog setting on the stack does not have a setting, then the game will continue checking down the stack. If the game finds no such setting, it will instead use the defaults defined by the engine.  The fog stack is initially setup as follows, with the highest precedence starting at the top:  Command: the settings set on the player by server commands. Biomes: the settings defined to be on each biome. Data Default: the default data driven settings. Engine Default: hard code values. Command  At the top of the stack, the command layer has all the settings set by the /fog command and is evaluated as one stack from top to bottom. More details about the command's usage is found in the \"Fog Command\" section.  Biomes  The biome layer is an average of all the settings defined by the biomes around the player's position. Fog settings can be defined for each individual biome within the biomes_client.json file located at the root of a resource pack. In each biome entry, you can have a variable called fog_identifier and set a name that matches the fog setting you want to use with that biome.  JSON Copy {   \"biomes\": {     ...     \"ice_plains\": {       \"fog_identifier\": \"minecraft:fog_ice_plains\",       ...     },     ...     \"mesa_plateau\": {       \"fog_identifier\": \"minecraft:fog_mesa_plateau\",       ...     },     ...   } }   The default entry can also be set this way and will be used underneath the biome entries in the active fog stack. So, a biome's fog setting does not completely replace the default setting, but instead the biome is read on top of the default as described in the \"Data Default\" section.  Data Default  The data default layer is defined within the default object in the biomes_client.json file in the root of a resource pack, provided that it references a fog definition via the fog_identifier field.  JSON Copy {   \"biomes\": {     \"default\": {       \"fog_identifier\": \"minecraft:fog_default\",       ...     }   },   ... }  Engine Default  The bottom of the stack uses hard-coded values in case there are no data driven values. As such, these cannot be changed and there cannot be any layers beneath it.  Fog Command  The /fog command can be used to manage fog settings at the \"command\" layer of the active fog stack for each player.  Fog settings in this layer are ordered via the push, pop, and remove modes of the /fog command described below. Fog settings are evaluated top-to-bottom in the active fog stack which includes top-to-bottom in this layer first.  Fog settings in this layer are saved and then restored on world load per player. In this way, a fog setting that is pushed before a world save will still apply after a world load and can then be popped.  Push  Pushes a new fog setting to specified player(s), along with a user provided ID, onto the top of the Fog Command layers of the players' active fog stacks.  Pop  Removes the top-most fog setting from selected player(s) that matches the user provided ID, as provided previously via a /fog push command.  Remove  Removes all matching fog settings, from the selected player(s), that matches the user-provided ID, as as provided previously via one or more /fog push commands.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/foginresourcepacks?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fog in Resource Packs 05/19/2025  Fogs in Minecraft: Bedrock Edition use JSON files to determine their values. Creators can define their own sets of fog values in their resource packs. A new folder can be made at the root of a resource pack called fogs. Any JSON files within this folder will be registered as new fog definitions that can be used by the game.  In this tutorial you will learn the following:  What a fog file looks like and what options are available for customization. The order that fog is applied based on various features, including biome definitions and the /fog command. Requirements  It's recommended you complete Introduction to Resource Packs before beginning this tutorial.  JSON Example  The Vanilla Resource Pack template contains all of the fog files used in the game. These files can serve as examples for creating your own fog definitions. A completed fog file will look similar to the following:  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"minecraft:fog_default\"     },     \"distance\": {       \"air\": {         \"fog_start\": 0.92,         \"fog_end\": 1.0,         \"fog_color\": \"#ABD2FF\",         \"render_distance_type\": \"render\"       },       \"water\": {         \"fog_start\": 0,         \"fog_end\": 60.0,         \"fog_color\": \"#44AFF5\",         \"render_distance_type\": \"fixed\",         \"transition_fog\": {           \"init_fog\": {             \"fog_start\": 0.0,             \"fog_end\": 0.01,             \"fog_color\": \"#44AFF5\",             \"render_distance_type\": \"fixed\"           },           \"min_percent\": 0.25,           \"mid_seconds\": 5,           \"mid_percent\": 0.6,           \"max_seconds\": 30         }       },       \"weather\": {         \"fog_start\": 0.23,         \"fog_end\": 0.7,         \"fog_color\": \"#666666\",         \"render_distance_type\": \"render\"       },       \"lava\": {         \"fog_start\": 0.0,         \"fog_end\": 0.64,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       },       \"lava_resistance\": {         \"fog_start\": 2.0,         \"fog_end\": 4.0,         \"fog_color\": \"#991A00\",         \"render_distance_type\": \"fixed\"       }     }   } }  Variables format_version  The resource pack version that this fog setting was built for. This is used for determining upgrade paths and backwards compatibility in newer versions of the game. The minimum version is 1.16.100.  minecraft:fog_settings  Contains the definitions and options of the fog.  description  Holds the description for this fog setting, which primarily contains an identifier.  identifier  Held within the description object.  The unique name to refer to this fog setting. Each identifier requires a namespace. You also must have each identifier be unique or you will get an error. The minecraft namespace is allowed to be used only by the vanilla resource packs.  JSON Copy {   \"format_version\": \"1.16.100\",   \"minecraft:fog_settings\": {     \"description\": {       \"identifier\": \"custom_pack:example\"     },     ...   } }  distance  This object contains the values for distance-based fog. This is the fog that limits the player from seeing anything beyond a specific distance from them. Each field within this object contains one type of distance value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and the Lava Resistance effect is active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"distance\": {       \"air\": {         ...       },       \"water\": {         ...       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each distance setting type, you can set the following variables:  fog_start: The distance where the fog will begin to appear. fog_end: The distance where the fog will become completely opaque. render_distance_type: Setting this will determine how the start and end values are used for calculating the fog distances. fixed: The distance is measured in the number of blocks away. render: The distance is multiplied against the current render distance. fog_color: The color that the fog will take on. transition_fog   Note  transition_fog works only for fog in a water setting.  With transition_fog specified, players will see a fog transition from init_fog setting to the water setting when they move into water. The speed of transition can be controlled by percent and second values.  In each transition_fog setting type, you can set the following variables:  init_fog: Initial fog that will slowly transition into water distance fog of the biome when player goes into water. min_percent: Minimum progress of fog transition. mid_seconds: The time takes to reach certain progress('mid_percent') of fog transition. mid_percent: The progress of fog transition after 'mid_seconds' seconds. max_seconds: Total amount of time it takes to complete the fog transition. volumetric  This object contains the values for volumetric fog. This fog will be displayed as a calculation from light passing through blocks. Currently this is only used for Ray Tracing.  density  Held within the volumetric object. Each field within it contains one type of density value.  You can set the following types by name:  air: used when the player's camera is in the air. weather: used when the player's camera is in the air and weather is currently active. water: used when the player's camera is in water. lava: used when the player's camera is in lava. lava_resistance: used when the player's camera is in lava and they have the Lava Resistance effect active.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"density\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each density setting type, you can set the following variables:  max_density: the multiplier on how much the fog disrupts the light. 0.0 will have no fog, and 1.0 will be near opaque. uniform: when set to true, the fog density will occur evenly across all heights. zero_density_height: the height in blocks that the fog will begin to appear. This can only be set if uniform is set to false. max_density_height: the height in blocks that the fog will become its max_density. This can be set only if uniform is set to false. media_coefficients  Held within the volumetric object.  Each field within this object defines one type of coefficient value. These are used to determine how the light is dispersed or refracted by the fog as rays travel through different mediums/blocks.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water. cloud: used when light is passing through clouds.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"media_coefficients\": {         \"air\": {           ...         },         \"water\": {           ...         }       }     }   If you do not set a value here, the game will use the value set for the next-lowest priority fog setting. This is described in more detail later in the \"Active Fog Stack\" section.  In each coefficient setting type, you can set the following variables:  scattering: how much of the RGB of the light the fog will spread. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. absorption: how much of the RGB of the light the fog will absorb. Either can be set as an array of 3 multipliers from [0.0, 1.0] or as a Hex color value. Henyey-Greenstein G  Available in format_version 1.21.90 and above, and only applicable in Vibrant Visuals resource packs.  Held within the volumetric object.  Each field within this object defines one type of g value. These are used to determine the distribution of scattered light in different mediums.  You can set the following types by name:  air: used when light is passing through air. water: used when light is passing through water.  You can have one of each type as needed, though they are all optional.  JSON Copy     \"volumetric\": {       \"henyey_greenstein_g\": {         \"air\": {           \"henyey_greenstein_g\": 0.75         },         \"water\": {           \"henyey_greenstein_g\": 0.6         }       }     }   In each medium setting type, you can set the following variable:  henyey_greenstein_g: Controls the distribution of scattered light. Values can range from [-1.0, 1.0]. Positive values will result in forward-scattering, while negative values will result in back-scattering. The default value for air is 0.75, while the default for water is 0.6. Active Fog Stack  The active fog stack is used to determine which fog setting to use at any given time in the game. Each player has a unique fog stack.  Whenever the game needs to determine the values for the fog, it will start at the top of the fog stack and check down it until it has found a value for the current setting type. If a fog setting on the stack does not have a setting, then the game will continue checking down the stack. If the game finds no such setting, it will instead use the defaults defined by the engine.  The fog stack is initially setup as follows, with the highest precedence starting at the top:  Command: the settings set on the player by server commands. Biomes: the settings defined to be on each biome. Data Default: the default data driven settings. Engine Default: hard code values. Command  At the top of the stack, the command layer has all the settings set by the /fog command and is evaluated as one stack from top to bottom. More details about the command's usage is found in the \"Fog Command\" section.  Biomes  The biome layer is an average of all the settings defined by the biomes around the player's position. Fog settings can be defined for each individual biome within the biomes_client.json file located at the root of a resource pack. In each biome entry, you can have a variable called fog_identifier and set a name that matches the fog setting you want to use with that biome.  JSON Copy {   \"biomes\": {     ...     \"ice_plains\": {       \"fog_identifier\": \"minecraft:fog_ice_plains\",       ...     },     ...     \"mesa_plateau\": {       \"fog_identifier\": \"minecraft:fog_mesa_plateau\",       ...     },     ...   } }   The default entry can also be set this way and will be used underneath the biome entries in the active fog stack. So, a biome's fog setting does not completely replace the default setting, but instead the biome is read on top of the default as described in the \"Data Default\" section.  Data Default  The data default layer is defined within the default object in the biomes_client.json file in the root of a resource pack, provided that it references a fog definition via the fog_identifier field.  JSON Copy {   \"biomes\": {     \"default\": {       \"fog_identifier\": \"minecraft:fog_default\",       ...     }   },   ... }  Engine Default  The bottom of the stack uses hard-coded values in case there are no data driven values. As such, these cannot be changed and there cannot be any layers beneath it.  Fog Command  The /fog command can be used to manage fog settings at the \"command\" layer of the active fog stack for each player.  Fog settings in this layer are ordered via the push, pop, and remove modes of the /fog command described below. Fog settings are evaluated top-to-bottom in the active fog stack which includes top-to-bottom in this layer first.  Fog settings in this layer are saved and then restored on world load per player. In this way, a fog setting that is pushed before a world save will still apply after a world load and can then be popped.  Push  Pushes a new fog setting to specified player(s), along with a user provided ID, onto the top of the Fog Command layers of the players' active fog stacks.  Pop  Removes the top-most fog setting from selected player(s) that matches the user provided ID, as provided previously via a /fog push command.  Remove  Removes all matching fog settings, from the selected player(s), that matches the user-provided ID, as as provided previously via one or more /fog push commands.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/actorstorage?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Actor Storage in Minecraft: Bedrock Edition 09/08/2023  Minecraft has inspired many third parties to create useful world file viewing and editing tools that exist outside the client. Tools like the Universal Minecraft Editor and MCEdit are community favorites and are dependent upon knowing where to find each piece of the level's data on disk in the LevelDB files. With the upgrade from legacy actor storage to modern actor storage in 1.18.20, the locations in the LevelDB files which the data for actors (entities) is stored has changed and these third party developers need to be aware.  What did legacy actor data look like?  Before version 1.18.30, actor data was stored per chunk as a blob of all actors in that chunk. This meant that whenever a single actor changed, we would:  Collect the data from every individual actor in the chunk Append the data for each actor into a single buffer/blob Write that grouped data to the chunk Why are we moving actor data?  The legacy actor data storage format meant if one actor in a chunk is changed you have to save them all, even if only one actually changed. This resulted in a lot of unnecessary operations and made handling the transfer of entities between chunks an expensive and fragile system.  How is modern actor data stored on disk?  Modern actor storage moves to storing each Actor under a unique individual LevelDB key. This enables us to have save operations that act only in individual actors. This also means that there is no key-value pair for all actors in a chunk. In fact the individual actor keys are separated into their own key space from the rest of chunk data and chunks do not have data on disk directly referencing actors they contain.  Instead, we use data from the chunk to deterministically generate a key that is unique to the chunk in which we store a digest of the LevelDB keys for the Actors in the chunk. These digest entries are also separated from the non-actor chunk data and the actor key space.  Let's take a look at how this appears on disk:  Chunk Key Space  On the left of the diagram, we can see the chunk key space. These keys take the legacy chunk key form of <Chunk Position><DimensionID>. There is a very old legacy chunk format in which there is no dimension ID, so it is possible to load a really old world in which chunk keys do not have a dimension ID. They will be saved out under a new key with the dimension ID. This is old behavior that still exists.  These are the smallest keys used by pushing them together contiguously on disk. The chunk key is used as a prefix for keys which store all non-actor data from the chunk. Each type of data from the chunk has its own key ID that is appended to the chunk key prefix.  Non-Actor Data Chunk Key IDs C++ Copy enum class LevelChunkTag : char {   Data3D = 43,   Version, // This was moved to the front as needed for the extended heights feature. Old chunks will not have this data.   Data2D,   Data2DLegacy,   SubChunkPrefix,   LegacyTerrain,   BlockEntity,   Entity,   PendingTicks,   LegacyBlockExtraData,   BiomeState,   FinalizedState,   ConversionData, // data that the converter provides, that are used at runtime for things like blending   BorderBlocks,   HardcodedSpawners,   RandomTicks,   CheckSums,   GenerationSeed,   GeneratedPreCavesAndCliffsBlending = 61, // not used, DON'T REMOVE   BlendingBiomeHeight = 62, // not used, DON'T REMOVE   MetaDataHash,   BlendingData,   ActorDigestVersion,   LegacyVersion = 118, };    Actor Digest Key Space  In the middle, we have the digest key space. Each digest key takes the form digp<Chunk Key>.  digp is a hardcoded prefix for all digest keys. This forces all digests to be contiguous on disk and increases the size of all digest keys such that they are placed ahead of the non-actor chunk data in the LevelDB.  <Chunk Key> is the same key string used by the chunk the data is associated with.  Actor Key Space  On the right, we have the actor key space. Each actor key takes the form actorprefix<ActorUniqueID>.  actorprefix is a hardcoded prefix used for all actor keys. This forces all actor data to be contiguous on disk and increases the size of all actor keys such that they are placed ahead of the non-actor chunk data and all digests in the LevelDB.  <ActorUniqueID> is a unique ID that is generated for each actor when it is added to the level. This ID is consistent between play sessions and is only unique to this world. Other actors in other worlds may have the same ID, but no actor in the same world will have the same ID.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/actorstorage?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Actor Storage in Minecraft: Bedrock Edition 09/08/2023  Minecraft has inspired many third parties to create useful world file viewing and editing tools that exist outside the client. Tools like the Universal Minecraft Editor and MCEdit are community favorites and are dependent upon knowing where to find each piece of the level's data on disk in the LevelDB files. With the upgrade from legacy actor storage to modern actor storage in 1.18.20, the locations in the LevelDB files which the data for actors (entities) is stored has changed and these third party developers need to be aware.  What did legacy actor data look like?  Before version 1.18.30, actor data was stored per chunk as a blob of all actors in that chunk. This meant that whenever a single actor changed, we would:  Collect the data from every individual actor in the chunk Append the data for each actor into a single buffer/blob Write that grouped data to the chunk Why are we moving actor data?  The legacy actor data storage format meant if one actor in a chunk is changed you have to save them all, even if only one actually changed. This resulted in a lot of unnecessary operations and made handling the transfer of entities between chunks an expensive and fragile system.  How is modern actor data stored on disk?  Modern actor storage moves to storing each Actor under a unique individual LevelDB key. This enables us to have save operations that act only in individual actors. This also means that there is no key-value pair for all actors in a chunk. In fact the individual actor keys are separated into their own key space from the rest of chunk data and chunks do not have data on disk directly referencing actors they contain.  Instead, we use data from the chunk to deterministically generate a key that is unique to the chunk in which we store a digest of the LevelDB keys for the Actors in the chunk. These digest entries are also separated from the non-actor chunk data and the actor key space.  Let's take a look at how this appears on disk:  Chunk Key Space  On the left of the diagram, we can see the chunk key space. These keys take the legacy chunk key form of <Chunk Position><DimensionID>. There is a very old legacy chunk format in which there is no dimension ID, so it is possible to load a really old world in which chunk keys do not have a dimension ID. They will be saved out under a new key with the dimension ID. This is old behavior that still exists.  These are the smallest keys used by pushing them together contiguously on disk. The chunk key is used as a prefix for keys which store all non-actor data from the chunk. Each type of data from the chunk has its own key ID that is appended to the chunk key prefix.  Non-Actor Data Chunk Key IDs C++ Copy enum class LevelChunkTag : char {   Data3D = 43,   Version, // This was moved to the front as needed for the extended heights feature. Old chunks will not have this data.   Data2D,   Data2DLegacy,   SubChunkPrefix,   LegacyTerrain,   BlockEntity,   Entity,   PendingTicks,   LegacyBlockExtraData,   BiomeState,   FinalizedState,   ConversionData, // data that the converter provides, that are used at runtime for things like blending   BorderBlocks,   HardcodedSpawners,   RandomTicks,   CheckSums,   GenerationSeed,   GeneratedPreCavesAndCliffsBlending = 61, // not used, DON'T REMOVE   BlendingBiomeHeight = 62, // not used, DON'T REMOVE   MetaDataHash,   BlendingData,   ActorDigestVersion,   LegacyVersion = 118, };    Actor Digest Key Space  In the middle, we have the digest key space. Each digest key takes the form digp<Chunk Key>.  digp is a hardcoded prefix for all digest keys. This forces all digests to be contiguous on disk and increases the size of all digest keys such that they are placed ahead of the non-actor chunk data in the LevelDB.  <Chunk Key> is the same key string used by the chunk the data is associated with.  Actor Key Space  On the right, we have the actor key space. Each actor key takes the form actorprefix<ActorUniqueID>.  actorprefix is a hardcoded prefix used for all actor keys. This forces all actor data to be contiguous on disk and increases the size of all actor keys such that they are placed ahead of the non-actor chunk data and all digests in the LevelDB.  <ActorUniqueID> is a unique ID that is generated for each actor when it is added to the level. This ID is consistent between play sessions and is only unique to this world. Other actors in other worlds may have the same ID, but no actor in the same world will have the same ID.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/experimentalfeaturestoggle?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Experimental Features in Minecraft: Bedrock Edition 05/21/2025   Note  To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs version on the sidebar, or switch using this link.  With each retail version of Minecraft: Bedrock Edition, there are a few features that are currently in an experimental state. Experimental Features can be toggled on for creators who are interested in testing the latest features offered in the preview, and retail versions of Minecraft.   Note  The Experiments toggle list is subject to frequent changes and could have entirely different options from the ones in your own version of Minecraft. Also, the screen shots shown here might look different.  Available experimental features  There are two sets of experimental features available, depending on whether you are using a retail version of Minecraft or the latest version of Minecraft Preview.  Retail  These are the currently available Experimental toggles in the 1.21.80 retail build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing Drop 2 2025\tExperience flying with the Happy Ghast, coming in the second game drop of 2025 Locator Bar\tShow the direction of other players in multiplayer  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Custom Components V2\tEnables custom components V2 for scripting (V2.0.0-beta and higher) and JSON (V1.21.80 and higher) APIs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder Preview  These are the currently available Experimental toggles in the 1.21.90.23 preview build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes actor properties and adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Render Dragon Features for Creators\tEnable the deferred rendering pipeline. Requires a PBR-enables resource pack and compatible hardware. Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder How do I activate an experimental features toggle for my world?  You can activate an experimental toggle for any of your new or existing worlds.   Warning  Activating experimental features that are still under development means that your world might crash, break, or not work with future updates.  If you're planning to build content that you want to share with the community, it would be best to do it in a non-experimental world.  Toggle experimental features in a new world  If you are building a new world from scratch to test experimental features, you can toggle which features you want enabled in the Game Settings.  Under Game settings, navigate down to Experiments and select a toggle to enable the feature.  When you get the popup asking if you're sure, select Turn on Experiments anyway.  Toggle experimental features in an existing world  If you want to add experimental features to an existing world, open that world's game settings and activate the toggles just like you would for a new world.   Note  A copy of your world will be generated automatically after you activate an experimental feature toggle. You can also manually create copies of your world as an extra precaution, in case something goes wrong.  After you select Activate Experiments, a copy of your existing world will be created. The copy will have the same name as the original world with \"Copy of...\" added in front of it.  Verify the world has experimental features enabled  After you've created a world that has an experimental feature toggle enabled, your world will get a tag next to the game mode in your Worlds list that says Experimental.  Another way to identify if your world is using experimental toggles is to visit the settings for your world. In the Game world settings, scroll down to the Experiments section to see which experiments are enabled.   Important  Worlds that use experimental features cannot be restored to a non-experimental state.  What's next?  If you like experimenting and testing things in Minecraft, you could learn more about the GameTest Framework.  Introduction to the GameTest Framework  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/experimentalfeaturestoggle?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Experimental Features in Minecraft: Bedrock Edition 05/21/2025   Note  To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs version on the sidebar, or switch using this link.  With each retail version of Minecraft: Bedrock Edition, there are a few features that are currently in an experimental state. Experimental Features can be toggled on for creators who are interested in testing the latest features offered in the preview, and retail versions of Minecraft.   Note  The Experiments toggle list is subject to frequent changes and could have entirely different options from the ones in your own version of Minecraft. Also, the screen shots shown here might look different.  Available experimental features  There are two sets of experimental features available, depending on whether you are using a retail version of Minecraft or the latest version of Minecraft Preview.  Retail  These are the currently available Experimental toggles in the 1.21.80 retail build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing Drop 2 2025\tExperience flying with the Happy Ghast, coming in the second game drop of 2025 Locator Bar\tShow the direction of other players in multiplayer  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Custom Components V2\tEnables custom components V2 for scripting (V2.0.0-beta and higher) and JSON (V1.21.80 and higher) APIs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder Preview  These are the currently available Experimental toggles in the 1.21.90.23 preview build at the time of this writing.  GAMEPLAY - Change the way your world works  Expand table Experimental Toggle\tDescription Villager Trade Rebalancing\tContains updated trades for villages for the purpose of rebalancing  ADD-ON CREATORS - For creators of game packs and other add-ons  Expand table Experimental Toggle\tDescription Custom Biomes\tCreate custom biomes and change world generation Upcoming Creator Features\tIncludes actor properties and adjustable fog parameters Beta APIs\tUse \"-beta\" versions of API modules in add-on packs Experimental Creator Camera Features\tEnables the use of the latest custom camera features Render Dragon Features for Creators\tEnable the deferred rendering pipeline. Requires a PBR-enables resource pack and compatible hardware. Data-Driven Jigsaw Structures\tLoads Jigsaw Structures from the behavior pack worldgen folder How do I activate an experimental features toggle for my world?  You can activate an experimental toggle for any of your new or existing worlds.   Warning  Activating experimental features that are still under development means that your world might crash, break, or not work with future updates.  If you're planning to build content that you want to share with the community, it would be best to do it in a non-experimental world.  Toggle experimental features in a new world  If you are building a new world from scratch to test experimental features, you can toggle which features you want enabled in the Game Settings.  Under Game settings, navigate down to Experiments and select a toggle to enable the feature.  When you get the popup asking if you're sure, select Turn on Experiments anyway.  Toggle experimental features in an existing world  If you want to add experimental features to an existing world, open that world's game settings and activate the toggles just like you would for a new world.   Note  A copy of your world will be generated automatically after you activate an experimental feature toggle. You can also manually create copies of your world as an extra precaution, in case something goes wrong.  After you select Activate Experiments, a copy of your existing world will be created. The copy will have the same name as the original world with \"Copy of...\" added in front of it.  Verify the world has experimental features enabled  After you've created a world that has an experimental feature toggle enabled, your world will get a tag next to the game mode in your Worlds list that says Experimental.  Another way to identify if your world is using experimental toggles is to visit the settings for your world. In the Game world settings, scroll down to the Experiments section to see which experiments are enabled.   Important  Worlds that use experimental features cannot be restored to a non-experimental state.  What's next?  If you like experimenting and testing things in Minecraft, you could learn more about the GameTest Framework.  Introduction to the GameTest Framework  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/designinggameplayforvariousdevices?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Designing Gameplay for Various Devices 01/19/2024  When creating content, it's important to consider that it will be played on many different devices varying wildly in control scheme, screen size, and processing power. Only a small percentage of Bedrock Edition users play on a PC, while the rest use the variety of cell phones and consoles that the engine supports. This means that, although content development likely takes place almost entirely on a PC, keyboard-and-mouse users are statistically the last group you should be designing around.  This article outlines some common problems creators may run into in the multi-platform ecosystem, but is by no means an exhaustive list. Ultimately, your biggest takeaway should be that you are developing content for an ever-expanding platform which will be interacted with in a multitude of ways. Integrate the design concepts of playability and flexibility into the core of your development process.  Performance  Bedrock Edition is available on most cell phones, and obviously these devices have a harder time running more intensive content, such as mini games with multiple commands or adventure maps with custom models. One important skill as a creator is balancing the complexity and quality of the content required to meet your vision while keeping in mind that as content becomes more complex, it becomes less playable for certain audiences.  Render Distance  Users on low-performance devices may be restricted to a shorter maximum render distance than what you develop with. For example, low-end devices may only be able to render a six or eight-chunk radius. Keep in mind when you're designing and building worlds that players may have limited vision. Whenever possible, design vital information to be visible from the shortest possible render distance. Rather than telling your players to walk towards a beacon in the far distance, give them \"breadcrumbs\" to follow, such as a pathway or a series of beacons so the path can be followed from short render distances. This extends to building style as well. Consider how your map looks to players on short render distances.  Sound  People use their cell phones almost everywhere, and it's common when playing a mobile game to mute your phone; keep this in mind when designing sounds.  In general, players should never be stuck because they couldn't or didn't hear something. In most cases, such as voice acting or important sound effects, you can simply mirror what's heard with a chat message. This is a basic concept in good, inclusive game design. If a player forgets what an NPC said, they should be able to check the chat or open a quest book to double-check. Captioning your audio not only helps users who choose to mute their game, it ensures your content is accessible to players with hearing loss or disabilities which should always be a consideration.  Interactions and Controls  A big difference in the way different control schemes interact with the world is how users interact with entities. On touchscreen devices interactions like breeding, feeding, and trading use a secondary button that appears on the screen when the player looks at the entity. This raises a few special considerations for creators.  First, be sure to should use the interact_text or equivalent parameter on any interaction components in custom entity behaviors to set the text that appears on the interaction button when touchscreen players look at the entity. This is vital for letting players know that an entity can be interacted with, and allows you to clearly communicate what happens when they do interact with it.  Second, consider building your custom entities with touch-friendly behaviors in mind. For example, if a mob can be interacted with using a certain item, consider giving the mob a high-priority goal to move towards players when they are holding that item type. This keeps the entity from unexpectedly walking away while the player is reaching for the interact button and accidentally punching the entity.  Touchscreen devices present another unique situation to creators as they have fewer buttons than other devices. For example, players using a keyboard press Q (by default) to drop a held item on the ground, while players on touchscreens must press and hold on the item in their hotbar for over two seconds to drop an item. Players on touchscreen devices also have no pick block button like console or mouse-and-keyboard players.  Fine Motor Controls  Map elements that require exact timing, such as difficult parkour courses, can be more challenging than expected when played on a touch screen or console. As a general rule, if something is \"difficult\" with a mouse and keyboard, it's nearly impossible for users on a touchscreen.  This is obviously a generalization, and many touchscreen or console users are incredible with their respective devices. A touchscreen isn't an inherently worse device, just one with a potentially steeper learning curve to reach the level of accuracy a PC player might take for granted. This is where testing on multiple devices is critical. Most creators will be surprised what you take for granted when you experience the game in a different way than usual.  Consider the difficulty some players may have with jumps that require pixel-perfect timing, turning corners mid-air, or other difficult maneuvers. Complex combat situations, like a player fighting a large number of enemies at once, may also prove difficult depending on control scheme.  In the end, of course, the content you design is completely up to you. No one's going to stop you from making \"Max-Distance Parkour on Glass Panes Over the Void: The Map,\" but we want to make sure you're cautious about decisions that may alienate portions of your player base.  What's Next?  These are a small sampling of the considerations to keep in mind when designing content for Bedrock Edition. Incorporating cross-platform design decisions is a key skill to developing content that's fun and engaging for all players. Pick up some devices to test on and get to work!  There are many next steps towards making content, from using command blocks for increased interaction with the game world to controlling a variety of entity actions with behavior packs. There are also plenty of tools to help you create your content. Coincidentally, here are some links to articles detailing all of those ideas!  Introduction to Command Blocks  Introduction to Resource Packs  Introduction to Behavior Packs  Commonly Used Tools  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/designinggameplayforvariousdevices?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Designing Gameplay for Various Devices 01/19/2024  When creating content, it's important to consider that it will be played on many different devices varying wildly in control scheme, screen size, and processing power. Only a small percentage of Bedrock Edition users play on a PC, while the rest use the variety of cell phones and consoles that the engine supports. This means that, although content development likely takes place almost entirely on a PC, keyboard-and-mouse users are statistically the last group you should be designing around.  This article outlines some common problems creators may run into in the multi-platform ecosystem, but is by no means an exhaustive list. Ultimately, your biggest takeaway should be that you are developing content for an ever-expanding platform which will be interacted with in a multitude of ways. Integrate the design concepts of playability and flexibility into the core of your development process.  Performance  Bedrock Edition is available on most cell phones, and obviously these devices have a harder time running more intensive content, such as mini games with multiple commands or adventure maps with custom models. One important skill as a creator is balancing the complexity and quality of the content required to meet your vision while keeping in mind that as content becomes more complex, it becomes less playable for certain audiences.  Render Distance  Users on low-performance devices may be restricted to a shorter maximum render distance than what you develop with. For example, low-end devices may only be able to render a six or eight-chunk radius. Keep in mind when you're designing and building worlds that players may have limited vision. Whenever possible, design vital information to be visible from the shortest possible render distance. Rather than telling your players to walk towards a beacon in the far distance, give them \"breadcrumbs\" to follow, such as a pathway or a series of beacons so the path can be followed from short render distances. This extends to building style as well. Consider how your map looks to players on short render distances.  Sound  People use their cell phones almost everywhere, and it's common when playing a mobile game to mute your phone; keep this in mind when designing sounds.  In general, players should never be stuck because they couldn't or didn't hear something. In most cases, such as voice acting or important sound effects, you can simply mirror what's heard with a chat message. This is a basic concept in good, inclusive game design. If a player forgets what an NPC said, they should be able to check the chat or open a quest book to double-check. Captioning your audio not only helps users who choose to mute their game, it ensures your content is accessible to players with hearing loss or disabilities which should always be a consideration.  Interactions and Controls  A big difference in the way different control schemes interact with the world is how users interact with entities. On touchscreen devices interactions like breeding, feeding, and trading use a secondary button that appears on the screen when the player looks at the entity. This raises a few special considerations for creators.  First, be sure to should use the interact_text or equivalent parameter on any interaction components in custom entity behaviors to set the text that appears on the interaction button when touchscreen players look at the entity. This is vital for letting players know that an entity can be interacted with, and allows you to clearly communicate what happens when they do interact with it.  Second, consider building your custom entities with touch-friendly behaviors in mind. For example, if a mob can be interacted with using a certain item, consider giving the mob a high-priority goal to move towards players when they are holding that item type. This keeps the entity from unexpectedly walking away while the player is reaching for the interact button and accidentally punching the entity.  Touchscreen devices present another unique situation to creators as they have fewer buttons than other devices. For example, players using a keyboard press Q (by default) to drop a held item on the ground, while players on touchscreens must press and hold on the item in their hotbar for over two seconds to drop an item. Players on touchscreen devices also have no pick block button like console or mouse-and-keyboard players.  Fine Motor Controls  Map elements that require exact timing, such as difficult parkour courses, can be more challenging than expected when played on a touch screen or console. As a general rule, if something is \"difficult\" with a mouse and keyboard, it's nearly impossible for users on a touchscreen.  This is obviously a generalization, and many touchscreen or console users are incredible with their respective devices. A touchscreen isn't an inherently worse device, just one with a potentially steeper learning curve to reach the level of accuracy a PC player might take for granted. This is where testing on multiple devices is critical. Most creators will be surprised what you take for granted when you experience the game in a different way than usual.  Consider the difficulty some players may have with jumps that require pixel-perfect timing, turning corners mid-air, or other difficult maneuvers. Complex combat situations, like a player fighting a large number of enemies at once, may also prove difficult depending on control scheme.  In the end, of course, the content you design is completely up to you. No one's going to stop you from making \"Max-Distance Parkour on Glass Panes Over the Void: The Map,\" but we want to make sure you're cautious about decisions that may alienate portions of your player base.  What's Next?  These are a small sampling of the considerations to keep in mind when designing content for Bedrock Edition. Incorporating cross-platform design decisions is a key skill to developing content that's fun and engaging for all players. Pick up some devices to test on and get to work!  There are many next steps towards making content, from using command blocks for increased interaction with the game world to controlling a variety of entity actions with behavior packs. There are also plenty of tools to help you create your content. Coincidentally, here are some links to articles detailing all of those ideas!  Introduction to Command Blocks  Introduction to Resource Packs  Introduction to Behavior Packs  Commonly Used Tools  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createaworldtemplate?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create a World Template from an Exported World 12/06/2023  If you created a really neat Minecraft world and you wanted to share that world with other players, you have some options.  You could export the world and send out copies of it, or you could create a template of the world.  Worlds in the Minecraft Marketplace, like survival spawns, are typically world templates. When a player creates a world from the template, they get their own fresh copy of the world.  So where do world templates come from? Well, they are made from a zipped Minecraft world has been given the file extension .mctemplate and has the proper manifest.json file and a texts folder with some files inside it.  If your exported world has custom stuff added to it, like add-on packs, those get included, too.  When you import a world file (.mcworld), it gets added to your list of worlds where you can open it and start mining and crafting.  When you import a world template (.mctemplate), it goes into the list of world templates where you can select it and Minecraft will use it to create a world that will then be added to your list of worlds.  Let's start with the simplest possible Minecraft world and learn some cool renaming tricks.  Unpacking, Examining, and Re-Packing a Minecraft World File  In this first part, we are going to create a world, export it, change the file extension on the name, unzip it, look at the contents, zip the contents back up, and open it again in Minecraft.  This is just to get you used to tinkering around in Minecraft files so things make more sense when you start making changes.  Ready? Here we go!  Launch Minecraft, create a world, give it a memorable name like New_World, and play in it to test it out. (I love it when instructions tell me to play Minecraft!)  Save and quit the world to go back to the Minecraft Play screen that shows all of your worlds.  Click the Edit button for that world to go to the Edit World screen.  On the General tab, in the File Management section, find the Export World button and click it. The Save As window will be displayed.  Choose a location that is easy for you to find, like in a folder on your computer's Desktop, and click the Export button.  Minimize Minecraft and go find the exported world file. It will have a Minecraft icon and the .mcworld file extension.  Change the file extension from .mcworld to .zip.  Your computer will warn you that the file might become unusable and ask \"Are you sure you want to change it?\" We're sure. Click Yes. The file's icon will look different.  Double-click the .zip file to open it and choose Extract All. The structure should look something like this:  Open the files and check them out in Visual Studio Code, but don't move them or change the names of anything. Structure of a Minecraft World package (without add-on packs)  This is the baseline for our project.  db folder that contains files similar to this: 000005.ldb - Microsoft Access Record-Locking Information 000006.log - Text Document 000005.ldb - Binary file, not editable 000006.log - Binary file, not editable CURRENT - File that says something like \"MANIFEST-000004\" MANIFEST-000004 - Binary file that cannot be opened level.dat - DAT file that contains important data about your Minecraft world level.dat_old - DAT_OLD File that can be used as a backup for the other DAT file levelname.txt - Text document that holds the name of the world: \"New_World\" world_icon.jpeg - JPEG File that contains the first image Minecraft displays for the world  .ldb and .log files are part of the database implementation for how your map is stored. They are binary and not friendly for editing by hand, so don't touch these!  Edit the world_icon.jpeg file in an app like Paint.  Don't get too attached to your edited world icon, though. Whenever you play the world and then save and exit, Minecraft makes a new icon to replace it to reflect your gameplay. We want to make changes to this first one to distinguish it from the original world.  Re-Packaging a Minecraft World  Now, we're going to zip everything back up, rename the .zip extension to .mcworld, and open it again in Minecraft.  Inside the world folder, select all of the individual files.  With all of the files selected, right-click any one of the selected files and choose Compress to ZIP file.  The zip file will be created among the other files and the computer will automatically give it the same name as the file you right-clicked. That's okay. You can rename the zip file to something distinctive like New_World_EDITED.zip.  After the zip file is created, use the rename option to change the .zip extension to .mcworld.   Note  You can give the new zip file the name New_World.mcworld as it's being created, but we want to show you that the final .mcworld file is simply a renamed .zip file.   Important  Do not try to zip the whole folder and rename it from .zip to .mcworld. When the computer zips a file, it creates a folder for the things you want zipped, so the world folder goes inside another folder and Minecraft will not be able to import the world.  After you change the file extension to .mcworld, the file will have the Minecraft logo on it.  Double-click the New_World.mcworld to launch Minecraft and import the world. You should see messages that confirm the world has started and finished being imported successfully.  Click Play to go to the Play screen, where the world will be displayed along with any others.  When you go into the edited world, it will look just like the original one.  Okay. Now that we know what a world file has in it, and how to zip and rename the contents, let's learn about the structure of a world template.  Creating a World Template  All you need to do to turn a Minecraft world into a world template is:  Create a working exported world with any configurations and add-on packs activated.  Add the proper manifest.json file.  Optional: Create a folder named texts with 2 text files inside: en_US.lang and languages.json.  After you zip everything up, rename the file to have a .mctemplate extension.  That's it!  manifest.json  The manifest.json for a world template should have these contents:  name: This field is always pack.name. This is the name that will be in the imported template file in the world_templates folder. description: This field is always pack.description version: This tells the game what version of the pack this is. Always create new content with [1, 0 ,0]. uuid: Generate two different UUIDs from this site: https://www.uuidgenerator.net/version4. type: This tells the game to treat this pack as a world template  Template world template manifest.json:  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"world_template\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 2 }  Texts folder  The texts folder is where the name and description of your world is defined in the en_US.lang file.  If you do not have this folder and its contents, then the name of your world template will be \"pack.name\" as specified in the manifest.  en_US.lang  This is where the name and description of your world are defined. You are required to have these two lines in your .lang file:  Pack name: pack.name=[name of pack] Pack description: pack.description=[description of pack]  Template en_US.lang:  The names after the = are what will show up in the UI of the game.  JSON Copy pack.name=Western World pack.description=Howdy partner  languages.json (optional)  This file tells the game what languages your skin pack supports. The only language currently required is English. If you would like to support other languages, you can create additional xx_YY.lang files and edit them to tell the game to support those languages.  Template languages.json:  JSON Copy [     \"en_US\" ]  world_icon.jpeg  This is the image that shows up when your world is created from the template. Non-marketplace templates do not need a world icon, but if a template is made from an existing world, the world icon will already be available to use.  Dimensions: 800x450px File format: JPEG Using a World Template  The easiest way to import a world template into Minecraft is to double-click it and let Minecraft do the rest.  You should see Import started... and Successfully imported ... messages.  After Minecraft launches, click Play.  Because we are working with a template instead of a world, it will not be shown in your list of worlds. Instead, click Create New.  On the Create... page, scroll down to the Imported Templates collection. Your template should be listed there. Click it to create a world from the template.  Troubleshooting  While you learn how to create and modify worlds and templates, you are probably going to import and re-import your files. You will get \"Failed to import\" errors if you already have content with the same UUIDs loaded into your com.mojang folder.  Instead of creating new UUIDs for each manifest.json file, you can clean out the contents of the MinecraftWorlds and Minecraft Templates folders in your com.mojang folder.  You might not want to throw anything away until you're sure you don't need it, so rather than deleting the contents of these folders, we suggest dragging the contents to a backup folder.  If you accidentally drag the entire folder out of your com.mojang folder, it should be okay. Minecraft will just make a new one.  Go to your com.mojang folder, as explained in the Getting Started tutorial.  All of your existing worlds are in the MinecraftWorlds folder. You can remove the ones you don't need. Names of worlds are not terribly descriptive (like \"XqZXZZQdBQQ\"), so if you're not sure which world you're about to pull out of the folder, take a look inside the texts folder. The .lang file (like en_US.lang) will have the name of the world in the pack.name= line.  All of your imported templates are in the world_templates folder. Minecraft puts them in there during the import process.  Variation: Add-on Packs  If you activate add-on packs in a world and then export that world, Minecraft creates a few more folders and files to handle it all:  behavior_packs All the behavior packs you activated in the world will be copied into here db resource_packs 0.All the resource packs you activated in the world will be copied into here level.dat level.dat_old levelname.txt world_behavior_pack_history.json - Contains information about the behavior packs, such as UUIDs world_behavior_packs.json - Contains behavior pack ID and version world_icon.jpeg world_resource_pack_history.json - Contains information about the resource packs, such as UUIDs world_resource_packs.json - Contains resource pack ID and version   Important  Resource pack and behavior pack folder names in world templates must be 10 characters or shorter. This is due to an issue on Xbox where long paths may cause resource or behavior packs to not load properly. We suggest using an acronym of the contents title for folder names.  Variation: Random Seed  Your template does not have to be used on only one world. You can enable random seed generation and have your changes applied to any random world.  Starting with any unzipped, exported world, delete the db folder.  Add \"allow_random_seed\" : true to the manifest.json.  Sample random seed world template manifest.json file  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\",     \"allow_random_seed\" : true    },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"world_template\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 2 }   After the world is created, the world seed is locked and no longer editable.  What's Next?  Now that you know more about world templates, you can learn even more interesting things you can do with them.  Base Game Versioning  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/createaworldtemplate?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Create a World Template from an Exported World 12/06/2023  If you created a really neat Minecraft world and you wanted to share that world with other players, you have some options.  You could export the world and send out copies of it, or you could create a template of the world.  Worlds in the Minecraft Marketplace, like survival spawns, are typically world templates. When a player creates a world from the template, they get their own fresh copy of the world.  So where do world templates come from? Well, they are made from a zipped Minecraft world has been given the file extension .mctemplate and has the proper manifest.json file and a texts folder with some files inside it.  If your exported world has custom stuff added to it, like add-on packs, those get included, too.  When you import a world file (.mcworld), it gets added to your list of worlds where you can open it and start mining and crafting.  When you import a world template (.mctemplate), it goes into the list of world templates where you can select it and Minecraft will use it to create a world that will then be added to your list of worlds.  Let's start with the simplest possible Minecraft world and learn some cool renaming tricks.  Unpacking, Examining, and Re-Packing a Minecraft World File  In this first part, we are going to create a world, export it, change the file extension on the name, unzip it, look at the contents, zip the contents back up, and open it again in Minecraft.  This is just to get you used to tinkering around in Minecraft files so things make more sense when you start making changes.  Ready? Here we go!  Launch Minecraft, create a world, give it a memorable name like New_World, and play in it to test it out. (I love it when instructions tell me to play Minecraft!)  Save and quit the world to go back to the Minecraft Play screen that shows all of your worlds.  Click the Edit button for that world to go to the Edit World screen.  On the General tab, in the File Management section, find the Export World button and click it. The Save As window will be displayed.  Choose a location that is easy for you to find, like in a folder on your computer's Desktop, and click the Export button.  Minimize Minecraft and go find the exported world file. It will have a Minecraft icon and the .mcworld file extension.  Change the file extension from .mcworld to .zip.  Your computer will warn you that the file might become unusable and ask \"Are you sure you want to change it?\" We're sure. Click Yes. The file's icon will look different.  Double-click the .zip file to open it and choose Extract All. The structure should look something like this:  Open the files and check them out in Visual Studio Code, but don't move them or change the names of anything. Structure of a Minecraft World package (without add-on packs)  This is the baseline for our project.  db folder that contains files similar to this: 000005.ldb - Microsoft Access Record-Locking Information 000006.log - Text Document 000005.ldb - Binary file, not editable 000006.log - Binary file, not editable CURRENT - File that says something like \"MANIFEST-000004\" MANIFEST-000004 - Binary file that cannot be opened level.dat - DAT file that contains important data about your Minecraft world level.dat_old - DAT_OLD File that can be used as a backup for the other DAT file levelname.txt - Text document that holds the name of the world: \"New_World\" world_icon.jpeg - JPEG File that contains the first image Minecraft displays for the world  .ldb and .log files are part of the database implementation for how your map is stored. They are binary and not friendly for editing by hand, so don't touch these!  Edit the world_icon.jpeg file in an app like Paint.  Don't get too attached to your edited world icon, though. Whenever you play the world and then save and exit, Minecraft makes a new icon to replace it to reflect your gameplay. We want to make changes to this first one to distinguish it from the original world.  Re-Packaging a Minecraft World  Now, we're going to zip everything back up, rename the .zip extension to .mcworld, and open it again in Minecraft.  Inside the world folder, select all of the individual files.  With all of the files selected, right-click any one of the selected files and choose Compress to ZIP file.  The zip file will be created among the other files and the computer will automatically give it the same name as the file you right-clicked. That's okay. You can rename the zip file to something distinctive like New_World_EDITED.zip.  After the zip file is created, use the rename option to change the .zip extension to .mcworld.   Note  You can give the new zip file the name New_World.mcworld as it's being created, but we want to show you that the final .mcworld file is simply a renamed .zip file.   Important  Do not try to zip the whole folder and rename it from .zip to .mcworld. When the computer zips a file, it creates a folder for the things you want zipped, so the world folder goes inside another folder and Minecraft will not be able to import the world.  After you change the file extension to .mcworld, the file will have the Minecraft logo on it.  Double-click the New_World.mcworld to launch Minecraft and import the world. You should see messages that confirm the world has started and finished being imported successfully.  Click Play to go to the Play screen, where the world will be displayed along with any others.  When you go into the edited world, it will look just like the original one.  Okay. Now that we know what a world file has in it, and how to zip and rename the contents, let's learn about the structure of a world template.  Creating a World Template  All you need to do to turn a Minecraft world into a world template is:  Create a working exported world with any configurations and add-on packs activated.  Add the proper manifest.json file.  Optional: Create a folder named texts with 2 text files inside: en_US.lang and languages.json.  After you zip everything up, rename the file to have a .mctemplate extension.  That's it!  manifest.json  The manifest.json for a world template should have these contents:  name: This field is always pack.name. This is the name that will be in the imported template file in the world_templates folder. description: This field is always pack.description version: This tells the game what version of the pack this is. Always create new content with [1, 0 ,0]. uuid: Generate two different UUIDs from this site: https://www.uuidgenerator.net/version4. type: This tells the game to treat this pack as a world template  Template world template manifest.json:  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"world_template\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 2 }  Texts folder  The texts folder is where the name and description of your world is defined in the en_US.lang file.  If you do not have this folder and its contents, then the name of your world template will be \"pack.name\" as specified in the manifest.  en_US.lang  This is where the name and description of your world are defined. You are required to have these two lines in your .lang file:  Pack name: pack.name=[name of pack] Pack description: pack.description=[description of pack]  Template en_US.lang:  The names after the = are what will show up in the UI of the game.  JSON Copy pack.name=Western World pack.description=Howdy partner  languages.json (optional)  This file tells the game what languages your skin pack supports. The only language currently required is English. If you would like to support other languages, you can create additional xx_YY.lang files and edit them to tell the game to support those languages.  Template languages.json:  JSON Copy [     \"en_US\" ]  world_icon.jpeg  This is the image that shows up when your world is created from the template. Non-marketplace templates do not need a world icon, but if a template is made from an existing world, the world icon will already be available to use.  Dimensions: 800x450px File format: JPEG Using a World Template  The easiest way to import a world template into Minecraft is to double-click it and let Minecraft do the rest.  You should see Import started... and Successfully imported ... messages.  After Minecraft launches, click Play.  Because we are working with a template instead of a world, it will not be shown in your list of worlds. Instead, click Create New.  On the Create... page, scroll down to the Imported Templates collection. Your template should be listed there. Click it to create a world from the template.  Troubleshooting  While you learn how to create and modify worlds and templates, you are probably going to import and re-import your files. You will get \"Failed to import\" errors if you already have content with the same UUIDs loaded into your com.mojang folder.  Instead of creating new UUIDs for each manifest.json file, you can clean out the contents of the MinecraftWorlds and Minecraft Templates folders in your com.mojang folder.  You might not want to throw anything away until you're sure you don't need it, so rather than deleting the contents of these folders, we suggest dragging the contents to a backup folder.  If you accidentally drag the entire folder out of your com.mojang folder, it should be okay. Minecraft will just make a new one.  Go to your com.mojang folder, as explained in the Getting Started tutorial.  All of your existing worlds are in the MinecraftWorlds folder. You can remove the ones you don't need. Names of worlds are not terribly descriptive (like \"XqZXZZQdBQQ\"), so if you're not sure which world you're about to pull out of the folder, take a look inside the texts folder. The .lang file (like en_US.lang) will have the name of the world in the pack.name= line.  All of your imported templates are in the world_templates folder. Minecraft puts them in there during the import process.  Variation: Add-on Packs  If you activate add-on packs in a world and then export that world, Minecraft creates a few more folders and files to handle it all:  behavior_packs All the behavior packs you activated in the world will be copied into here db resource_packs 0.All the resource packs you activated in the world will be copied into here level.dat level.dat_old levelname.txt world_behavior_pack_history.json - Contains information about the behavior packs, such as UUIDs world_behavior_packs.json - Contains behavior pack ID and version world_icon.jpeg world_resource_pack_history.json - Contains information about the resource packs, such as UUIDs world_resource_packs.json - Contains resource pack ID and version   Important  Resource pack and behavior pack folder names in world templates must be 10 characters or shorter. This is due to an issue on Xbox where long paths may cause resource or behavior packs to not load properly. We suggest using an acronym of the contents title for folder names.  Variation: Random Seed  Your template does not have to be used on only one world. You can enable random seed generation and have your changes applied to any random world.  Starting with any unzipped, exported world, delete the db folder.  Add \"allow_random_seed\" : true to the manifest.json.  Sample random seed world template manifest.json file  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\",     \"allow_random_seed\" : true    },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"world_template\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 2 }   After the world is created, the world seed is locked and no longer editable.  What's Next?  Now that you know more about world templates, you can learn even more interesting things you can do with them.  Base Game Versioning  To see examples of unchanged resource and behavior files, check out the Minecraft Vanilla resource pack and Vanilla behavior Pack.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/packagingaskinpack?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Packaging a Skin Pack 12/15/2023  Skin packs are some of the most popular content available, offering players multiple looks for their avatars and fundamentally changing the feel of their gameplay experience. Creating a skin pack is not only a great way to offer something new to players, it's also a lot of fun both technically and artistically!  In this guide you will learn:  The folder and file structure for skin packs in Minecraft: Bedrock Edition. How to construct the necessary metadata files for a skin pack and how to define skins using them. Skin Pack Folder Structure  manifest.json  A manifest tells Minecraft general information about your skin pack. Create a JSON file named manifest.json at the root of the skin pack. Within it contains the following:  name: the name of the pack, which is always pack.name. version: the version of the pack. For example, [1, 0 ,0] would indicate version 1.0.0. uuid: a unique identifier to prevent package conflicts, which can be generated from this site: https://www.uuidgenerator.net/version4 (two different UUIDs need to be generated). type: set to skin_pack to tell the game to treat this pack as a skin pack. Template manifest.json JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 1 }  skins.json  A skins.json file will define the skins that come with your skin pack. Create a JSON file named skins.json at the root of the skin pack. Within it contains the following:  localization_name and serialize_name: these will be the same and are the localization keys whose value will be defined later in en_US.lang with the full key being skinpack.<localization_name>. That value will be the title of the pack. The key will also always be prepended to each individual skin's localization key. skins: a collection of definitions, each defining a single skin.  Each individual skin definition will then contain the following:  localization_name: the localization key whose value is defined later in en_US.lang. The value will be the name of the individual skin. geometry: the base model this skin is for. geometry.humanoid.customSlim is the Alex model and geometry.humanoid.custom is the Steve model. texture: the file name for each of the skin textures as they appear in the root of the skin pack. type: either free or paid. Template skins.json   Note  Unfortunately, it's not possible to add custom models to skin packs at this time using the skin pack JSON capability.  JSON Copy {   \"serialize_name\": \"TemplateSkinPack\",   \"localization_name\": \"TemplateSkinPack\",   \"skins\": [     {       \"localization_name\": \"TemplateSkin1\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name1.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin2\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name2.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin3\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name3.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin4\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name4.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin5\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name5.png\",       \"type\": \"paid\"     }   ] }  Skin Textures  The actual skin textures are PNGs. The file names are referred to in the skins.json metadata file. They can be used only at the root of the skin pack. You can use Blockbench to create a usable skin PNG for your skin pack.  Texts Folder  Inside this folder are the en_US.lang and languages.json files, which define the actual names of your pack and skins and the supported languages of your pack. The names after the = are what show up in-game, such as in the skin picker.  en_US.lang  This is the file where you name your pack and the skins.  Pack name: skinpack.[skins.json localization_name]=[name of pack] Skin names: skin.[skins.json localization_name].[skins.json single skin localization_name]=[name of skin]  The below template uses the \"localization keys\" from the template skin.json to name the pack \"Your Skin Pack Name Here\" and to name the individual skins \"Skin Name 1-5\".  Template en_US.lang JSON Copy skinpack.TemplateSkinPack=Your Skin Pack Name Here skin.TemplateSkinPack.TemplateSkin1=Skin Name 1 skin.TemplateSkinPack.TemplateSkin2=Skin Name 2 skin.TemplateSkinPack.TemplateSkin3=Skin Name 3 skin.TemplateSkinPack.TemplateSkin4=Skin Name 4 skin.TemplateSkinPack.TemplateSkin5=Skin Name 5  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/packagingaskinpack?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Packaging a Skin Pack 12/15/2023  Skin packs are some of the most popular content available, offering players multiple looks for their avatars and fundamentally changing the feel of their gameplay experience. Creating a skin pack is not only a great way to offer something new to players, it's also a lot of fun both technically and artistically!  In this guide you will learn:  The folder and file structure for skin packs in Minecraft: Bedrock Edition. How to construct the necessary metadata files for a skin pack and how to define skins using them. Skin Pack Folder Structure  manifest.json  A manifest tells Minecraft general information about your skin pack. Create a JSON file named manifest.json at the root of the skin pack. Within it contains the following:  name: the name of the pack, which is always pack.name. version: the version of the pack. For example, [1, 0 ,0] would indicate version 1.0.0. uuid: a unique identifier to prevent package conflicts, which can be generated from this site: https://www.uuidgenerator.net/version4 (two different UUIDs need to be generated). type: set to skin_pack to tell the game to treat this pack as a skin pack. Template manifest.json JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"version\": [1, 0, 0],     \"uuid\": \"<FIRST GENERATED UUID>\"   },   \"modules\": [     {       \"version\": [1, 0, 0],       \"type\": \"skin_pack\",       \"uuid\": \"<SECOND GENERATED UUID>\"     }   ],   \"format_version\": 1 }  skins.json  A skins.json file will define the skins that come with your skin pack. Create a JSON file named skins.json at the root of the skin pack. Within it contains the following:  localization_name and serialize_name: these will be the same and are the localization keys whose value will be defined later in en_US.lang with the full key being skinpack.<localization_name>. That value will be the title of the pack. The key will also always be prepended to each individual skin's localization key. skins: a collection of definitions, each defining a single skin.  Each individual skin definition will then contain the following:  localization_name: the localization key whose value is defined later in en_US.lang. The value will be the name of the individual skin. geometry: the base model this skin is for. geometry.humanoid.customSlim is the Alex model and geometry.humanoid.custom is the Steve model. texture: the file name for each of the skin textures as they appear in the root of the skin pack. type: either free or paid. Template skins.json   Note  Unfortunately, it's not possible to add custom models to skin packs at this time using the skin pack JSON capability.  JSON Copy {   \"serialize_name\": \"TemplateSkinPack\",   \"localization_name\": \"TemplateSkinPack\",   \"skins\": [     {       \"localization_name\": \"TemplateSkin1\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name1.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin2\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name2.png\",       \"type\": \"free\"     },     {       \"localization_name\": \"TemplateSkin3\",       \"geometry\": \"geometry.humanoid.customSlim\",       \"texture\": \"skin_file_name3.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin4\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name4.png\",       \"type\": \"paid\"     },     {       \"localization_name\": \"TemplateSkin5\",       \"geometry\": \"geometry.humanoid.custom\",       \"texture\": \"skin_file_name5.png\",       \"type\": \"paid\"     }   ] }  Skin Textures  The actual skin textures are PNGs. The file names are referred to in the skins.json metadata file. They can be used only at the root of the skin pack. You can use Blockbench to create a usable skin PNG for your skin pack.  Texts Folder  Inside this folder are the en_US.lang and languages.json files, which define the actual names of your pack and skins and the supported languages of your pack. The names after the = are what show up in-game, such as in the skin picker.  en_US.lang  This is the file where you name your pack and the skins.  Pack name: skinpack.[skins.json localization_name]=[name of pack] Skin names: skin.[skins.json localization_name].[skins.json single skin localization_name]=[name of skin]  The below template uses the \"localization keys\" from the template skin.json to name the pack \"Your Skin Pack Name Here\" and to name the individual skins \"Skin Name 1-5\".  Template en_US.lang JSON Copy skinpack.TemplateSkinPack=Your Skin Pack Name Here skin.TemplateSkinPack.TemplateSkin1=Skin Name 1 skin.TemplateSkinPack.TemplateSkin2=Skin Name 2 skin.TemplateSkinPack.TemplateSkin3=Skin Name 3 skin.TemplateSkinPack.TemplateSkin4=Skin Name 4 skin.TemplateSkinPack.TemplateSkin5=Skin Name 5  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/utilizingsubpacks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Utilizing Sub-Packs 11/08/2023  One of the most wonderful aspects of being a Minecraft creator (and also, one of the most frustrating) is that no two players are the same: some are younger, some are older; some are on top-of-the-line gaming PCs, some are on muted mobile devices; the list goes on. With such a vast range of factors to account for, how do you ensure that all of your players are having an amazing experience? This is where sub-packs come in!  Sub-packs allow players to choose between different options or variations of a resource pack and to switch said variation at any time, without the need to create separate packs. Creators can use sub-packs to offer multiple levels of fidelity, different content for different user types, and more. As with most features in Minecraft, the only limitation is what you can imagine.  Creating a Sub-Pack  To create a sub-pack, open the resource pack for your world and create a new folder named subpacks. Next, open the subpacks folder and create a new folder for each sub-pack you would like to create. We are using the names \"SP1,\" \"SP2,\" and \"SP3\" for this example, but feel free to use whatever names work for your project.  Now that your folders have been created, you can add the content for each into its' respective folder. Any files that normally go into your resource pack can be added into your sub-pack 'SP' folders.   Note  Files added to sub-packs will override the files in the main resource pack.  Adding Sub-Packs to the Manifest  Once you have created your sub-packs, it's time to add them to the manifest.json file. This way, the game knows that the files exist and pulls them into the game.  \"folder_name\": This is the name for the folder where the sub-pack lives. \"name\": This is the name that players will see when choosing the sub-pack. \"memory_tier\": This allows you to set a designated amount of RAM that a device must have to run a sub-pack; each tier represents .25 GB. As such, memory_tier 4 = 1 GB RAM, memory_tier 32 = 8 GB RAM, etc. \"type\": For our purposes, the type will always be 'label'. This will allow you to enter a description of your pack and sub-packs. \"text\": This is the description players will see for your sub-packs. Additional type/text combinations must be used for additional paragraphs.  Note that the 'name' and 'text' fields can not be translated.  Example Sub-pack Manifest JSON Copy {     \"format_version\": \"1.20.30\",     \"header\": {         \"name\": \"Name of your resource pack\",         \"description\": \"A brief summary of your pack\",         \"version\": [1, 0, 0],         \"base_game_version\": [1, 18, 0],         \"uuid\": \"b955dcc1-911e-4d2c-9674-59cb1b760284\"     },     \"modules\": [         {             \"type\": \"resources\",             \"version\": [1, 0, 0],             \"uuid\": \"84d63d51-cd77-4bad-b51c-aac62d9cf773\"         }     ],     \"subpacks\": [         {             \"folder_name\": \"SP1\",             \"name\": \"Low-fi Assets\",             \"memory_tier\": 0         },         {             \"folder_name\": \"SP2\",             \"name\": \"Standard Assets\",             \"memory_tier\": 16         },         {             \"folder_name\": \"SP3\",             \"name\": \"Hi-fi Assets\",             \"memory_tier\": 64         }     ],     \"settings\": [         {             \"type\": \"label\",             \"text\": \"A description of what the pack and sub-packs include. Multiple paragraphs require multiple type/text pairs.\"         },         {             \"type\": \"label\",             \"text\": \"This would be the second paragraph that the player reads when looking at the description of the pack and sub-packs.\"         }       ]     }   Now that our manifest is complete, here is our example sub-pack in action!  What's Next?  Now that you know how sub-packs work, experiment with using them in different ways! Remove spiders from a spooky pack to help players with arachnophobia, let players choose the music they want to hear while they play your pack, or which biome they start in... Whatever you choose to create, sub-packs are a great tool for making sure you deliver an enjoyable experience for all users.  Feedback  Was this page helpful?  Yes No Additional resources  Documentation  Preparing Raw Text for Localization  A set of guidelines to use when preparing raw text files for localization  Minecraft File Extensions  An overview of different file extensions and what they do  Addons Documentation - manifest.json  A reference document detailing the basic information about manifest.json files  Show 4 more  Training  Module  Grow your Minecraft esports program - Training  Grow your Minecraft Education esports program by setting expectations and creating competitive tournaments."}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/utilizingsubpacks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Utilizing Sub-Packs 11/08/2023  One of the most wonderful aspects of being a Minecraft creator (and also, one of the most frustrating) is that no two players are the same: some are younger, some are older; some are on top-of-the-line gaming PCs, some are on muted mobile devices; the list goes on. With such a vast range of factors to account for, how do you ensure that all of your players are having an amazing experience? This is where sub-packs come in!  Sub-packs allow players to choose between different options or variations of a resource pack and to switch said variation at any time, without the need to create separate packs. Creators can use sub-packs to offer multiple levels of fidelity, different content for different user types, and more. As with most features in Minecraft, the only limitation is what you can imagine.  Creating a Sub-Pack  To create a sub-pack, open the resource pack for your world and create a new folder named subpacks. Next, open the subpacks folder and create a new folder for each sub-pack you would like to create. We are using the names \"SP1,\" \"SP2,\" and \"SP3\" for this example, but feel free to use whatever names work for your project.  Now that your folders have been created, you can add the content for each into its' respective folder. Any files that normally go into your resource pack can be added into your sub-pack 'SP' folders.   Note  Files added to sub-packs will override the files in the main resource pack.  Adding Sub-Packs to the Manifest  Once you have created your sub-packs, it's time to add them to the manifest.json file. This way, the game knows that the files exist and pulls them into the game.  \"folder_name\": This is the name for the folder where the sub-pack lives. \"name\": This is the name that players will see when choosing the sub-pack. \"memory_tier\": This allows you to set a designated amount of RAM that a device must have to run a sub-pack; each tier represents .25 GB. As such, memory_tier 4 = 1 GB RAM, memory_tier 32 = 8 GB RAM, etc. \"type\": For our purposes, the type will always be 'label'. This will allow you to enter a description of your pack and sub-packs. \"text\": This is the description players will see for your sub-packs. Additional type/text combinations must be used for additional paragraphs.  Note that the 'name' and 'text' fields can not be translated.  Example Sub-pack Manifest JSON Copy {     \"format_version\": \"1.20.30\",     \"header\": {         \"name\": \"Name of your resource pack\",         \"description\": \"A brief summary of your pack\",         \"version\": [1, 0, 0],         \"base_game_version\": [1, 18, 0],         \"uuid\": \"b955dcc1-911e-4d2c-9674-59cb1b760284\"     },     \"modules\": [         {             \"type\": \"resources\",             \"version\": [1, 0, 0],             \"uuid\": \"84d63d51-cd77-4bad-b51c-aac62d9cf773\"         }     ],     \"subpacks\": [         {             \"folder_name\": \"SP1\",             \"name\": \"Low-fi Assets\",             \"memory_tier\": 0         },         {             \"folder_name\": \"SP2\",             \"name\": \"Standard Assets\",             \"memory_tier\": 16         },         {             \"folder_name\": \"SP3\",             \"name\": \"Hi-fi Assets\",             \"memory_tier\": 64         }     ],     \"settings\": [         {             \"type\": \"label\",             \"text\": \"A description of what the pack and sub-packs include. Multiple paragraphs require multiple type/text pairs.\"         },         {             \"type\": \"label\",             \"text\": \"This would be the second paragraph that the player reads when looking at the description of the pack and sub-packs.\"         }       ]     }   Now that our manifest is complete, here is our example sub-pack in action!  What's Next?  Now that you know how sub-packs work, experiment with using them in different ways! Remove spiders from a spooky pack to help players with arachnophobia, let players choose the music they want to hear while they play your pack, or which biome they start in... Whatever you choose to create, sub-packs are a great tool for making sure you deliver an enjoyable experience for all users.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/convertingtexturepacks?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Converting Texture Packs from Minecraft: Java Edition to Minecraft: Bedrock Edition 09/20/2023  This article discusses the general tasks required to manually convert a resource pack made for Java Edition to a texture pack for Bedrock Edition. The actual creation of custom textures and features for a custom texture pack is not within the scope of this article. It's assumed that the creator has sufficient knowledge and experience with a raster graphics editor, such as Adobe Photoshop, to create and edit the texture files as necessary. Note that not all tools may support the required file formats or alpha channels.  In this tutorial you will learn the following:  Differences in texture packs between Bedrock Edition and Java Edition. The changes necessary to convert a pack from Java Edition to Bedrock Edition. Requirements  It is recommended that the following be completed before beginning this tutorial.  Differences Between Minecraft: Bedrock Edition and Minecraft: Java Edition Texture Pack Differences Between Java and Bedrock Editions  In general, the differences between texture packs for Java Edition and Bedrock Edition are as follows:  The directory structure The naming conventions (filenames) The file formats (.png vs .tga) The file types (single face vs. UV) The method of defining some features such as animated textures The metadata files (.json). Expand table Content\tBedrock Edition\tNotes Animation\tBlock animations controlled by flipbook_textures.json, can be customized\t Spawn Egg\tIndividual spawn egg textures\t Potion bottle\tIndividual potion bottles\t Color maps\t.json file\t Transparency or emissive\t.tga file with alpha channel .png for items\tSome textures with transparent or emissive pixels need to be saved in Targa (.tga) file format with an alpha channel for the mask Particles\tCompletely data driven\t Geometry\tCustom mob geometry, UVs\tGeometry can be updated with programs such as Blockbench or Blender Best Practices  Start with a copy of a valid custom Java Edition texture pack and a copy of the vanilla Bedrock Edition texture pack. The conversion process will replace the vanilla Bedrock Edition texture files with custom texture files from the Java Edition pack. There are some required Bedrock Edition texture files that have different file formats and file types, and some that don't exist in the Java Edition pack will need to be created. Advanced customizations in the Java Edition pack may or may not be possible to duplicate in the Bedrock Edition pack and aren't within the scope of this article.  Obtain the most current version of the vanilla Bedrock Edition texture pack for reference. Download for the most recent Bedrock Edition resource pack, which contains textures. Setup File Explorer windows side by side -- one with your Java Edition texture pack, and one with the vanilla Bedrock Edition texture pack. This vanilla Bedrock Edition pack will become your custom Bedrock Edition texture pack at the end of this process, as the vanilla texture files are replaced with your custom ones. Obtain and install the latest version of the Minecraft Bedrock Edition game app. In general, copy over your Java Edition texture files to the copy of the vanilla Bedrock Edition texture pack. Make sure that every Java Edition file copied over is replacing an existing Bedrock Edition file. If there is no corresponding Bedrock Edition file, it's not needed and shouldn't be present in the Bedrock Edition pack.  Nonexistent: Don't copy over any Java Edition files that don't exist in the Bedrock Edition vanilla texture pack. This includes .mcmeta files.  Do Not Replace: Do not copy over any non-texture Java Edition files including data files.  No Changes: Many textures require no changes whatsoever and can be dropped into the Bedrock Edition pack straight away. Begin replacing textures in the vanilla Bedrock Edition texture pack with your Java Edition texture files where the filenames are exactly the same. Test the modified pack and verify the replaced files are seen in-game. Repeat with all the textures with no filename change required until completed.  Name Change Only: Many textures require only a filename change for Bedrock Edition. Change your Java Edition texture filenames to their corresponding Bedrock Edition filenames and replace the ones in the vanilla Bedrock Edition texture pack. Test the pack in-game to verify that these textures are working.  Format Change Required: Unlike Java Edition textures, Bedrock Edition uses alpha channels for transparency. Some textures with transparency may need to be saved in TGA format for Bedrock Edition. If your texture is not rendering correctly in PNG, convert to TGA and indicate transparent pixels in the alpha channel with a mask (white is solid and black is transparent). Note that while PNG may work, TGA is the preferred format.  For blocks that support emissive, emissive pixels are indicated as an alpha channel mask. Note that transparency and emissive are mutually exclusive. (Examples: phantom eyes, spider eyes, Endermen eyes, etc.) For blocks and items and entities that support dye colors, areas that are to be colored by dyes are defined in an alpha channel mask with grey pixels (not black or white). (Examples: leather armor, fireworks charge.)  New Texture Files Required: Some textures in Bedrock Edition require additional textures to be created. Examples include potions and spawn eggs. In Java Edition, a base texture is recolored automatically by the game, but in Bedrock Edition, each color texture must be explicitly defined. For example, each mob spawn egg must have its own texture file.  File Type Change Required: For some blocks and entities, Bedrock Edition requires UV maps instead of individual files for each face. The individual Java Edition textures will need to be combined into one UV map, with alpha channels if needed. For example, the pig_saddle.png contains the full pig texture instead of just the saddle texture.  Flipbook animation: Where in Java Edition packs texture animation frames are defined in individual .mcmeta text files, Bedrock Edition combines all the texture animation definitions into a single flipbook_textures.json file. In general, you can edit the corresponding animation definitions in flipbook_textures.json to reflect the customizations in the .mcmeta files.  Packaging Changes Expand table Java Edition textures folder subdirectories\tBedrock Edition textures folder subdirectories block\tblocks colormap\tcolormap effect\t:--- entity\tentity environment\tenvironment font\t:--- gui\tgui item\titems map\tmap misc\tmisc models\tmodels painting\tpainting particle\tparticle :---\tpersona_thumbnails Expand table Sample Java Edition texture filenames\tSample Bedrock Edition texture filenames beehive_end.png\tbeehive_top.png honeycomb_block.png\thoneycomb.png honey_block_bottom.png\thoney_bottom.png honey_block_side.png\thoney_side.png honey_block_top.png\thoney_top.png wither_rose.png\tflower_wither_rose.png block_iron.png\tiron_block.png Advanced Options  The following advanced techniques and options are beyond the scope of this article, including:  HD textures and related issues Customizing animation_controllers.json Custom UI Custom model geometry Customizing animated textures Custom sounds Customizing behavior packs What's Next?  If you want to learn more about resource packs, which makes use of textures, see the resource pack tutorial.  Introduction to Resource Packs  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/convertingtexturepacks?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Converting Texture Packs from Minecraft: Java Edition to Minecraft: Bedrock Edition 09/20/2023  This article discusses the general tasks required to manually convert a resource pack made for Java Edition to a texture pack for Bedrock Edition. The actual creation of custom textures and features for a custom texture pack is not within the scope of this article. It's assumed that the creator has sufficient knowledge and experience with a raster graphics editor, such as Adobe Photoshop, to create and edit the texture files as necessary. Note that not all tools may support the required file formats or alpha channels.  In this tutorial you will learn the following:  Differences in texture packs between Bedrock Edition and Java Edition. The changes necessary to convert a pack from Java Edition to Bedrock Edition. Requirements  It is recommended that the following be completed before beginning this tutorial.  Differences Between Minecraft: Bedrock Edition and Minecraft: Java Edition Texture Pack Differences Between Java and Bedrock Editions  In general, the differences between texture packs for Java Edition and Bedrock Edition are as follows:  The directory structure The naming conventions (filenames) The file formats (.png vs .tga) The file types (single face vs. UV) The method of defining some features such as animated textures The metadata files (.json). Expand table Content\tBedrock Edition\tNotes Animation\tBlock animations controlled by flipbook_textures.json, can be customized\t Spawn Egg\tIndividual spawn egg textures\t Potion bottle\tIndividual potion bottles\t Color maps\t.json file\t Transparency or emissive\t.tga file with alpha channel .png for items\tSome textures with transparent or emissive pixels need to be saved in Targa (.tga) file format with an alpha channel for the mask Particles\tCompletely data driven\t Geometry\tCustom mob geometry, UVs\tGeometry can be updated with programs such as Blockbench or Blender Best Practices  Start with a copy of a valid custom Java Edition texture pack and a copy of the vanilla Bedrock Edition texture pack. The conversion process will replace the vanilla Bedrock Edition texture files with custom texture files from the Java Edition pack. There are some required Bedrock Edition texture files that have different file formats and file types, and some that don't exist in the Java Edition pack will need to be created. Advanced customizations in the Java Edition pack may or may not be possible to duplicate in the Bedrock Edition pack and aren't within the scope of this article.  Obtain the most current version of the vanilla Bedrock Edition texture pack for reference. Download for the most recent Bedrock Edition resource pack, which contains textures. Setup File Explorer windows side by side -- one with your Java Edition texture pack, and one with the vanilla Bedrock Edition texture pack. This vanilla Bedrock Edition pack will become your custom Bedrock Edition texture pack at the end of this process, as the vanilla texture files are replaced with your custom ones. Obtain and install the latest version of the Minecraft Bedrock Edition game app. In general, copy over your Java Edition texture files to the copy of the vanilla Bedrock Edition texture pack. Make sure that every Java Edition file copied over is replacing an existing Bedrock Edition file. If there is no corresponding Bedrock Edition file, it's not needed and shouldn't be present in the Bedrock Edition pack.  Nonexistent: Don't copy over any Java Edition files that don't exist in the Bedrock Edition vanilla texture pack. This includes .mcmeta files.  Do Not Replace: Do not copy over any non-texture Java Edition files including data files.  No Changes: Many textures require no changes whatsoever and can be dropped into the Bedrock Edition pack straight away. Begin replacing textures in the vanilla Bedrock Edition texture pack with your Java Edition texture files where the filenames are exactly the same. Test the modified pack and verify the replaced files are seen in-game. Repeat with all the textures with no filename change required until completed.  Name Change Only: Many textures require only a filename change for Bedrock Edition. Change your Java Edition texture filenames to their corresponding Bedrock Edition filenames and replace the ones in the vanilla Bedrock Edition texture pack. Test the pack in-game to verify that these textures are working.  Format Change Required: Unlike Java Edition textures, Bedrock Edition uses alpha channels for transparency. Some textures with transparency may need to be saved in TGA format for Bedrock Edition. If your texture is not rendering correctly in PNG, convert to TGA and indicate transparent pixels in the alpha channel with a mask (white is solid and black is transparent). Note that while PNG may work, TGA is the preferred format.  For blocks that support emissive, emissive pixels are indicated as an alpha channel mask. Note that transparency and emissive are mutually exclusive. (Examples: phantom eyes, spider eyes, Endermen eyes, etc.) For blocks and items and entities that support dye colors, areas that are to be colored by dyes are defined in an alpha channel mask with grey pixels (not black or white). (Examples: leather armor, fireworks charge.)  New Texture Files Required: Some textures in Bedrock Edition require additional textures to be created. Examples include potions and spawn eggs. In Java Edition, a base texture is recolored automatically by the game, but in Bedrock Edition, each color texture must be explicitly defined. For example, each mob spawn egg must have its own texture file.  File Type Change Required: For some blocks and entities, Bedrock Edition requires UV maps instead of individual files for each face. The individual Java Edition textures will need to be combined into one UV map, with alpha channels if needed. For example, the pig_saddle.png contains the full pig texture instead of just the saddle texture.  Flipbook animation: Where in Java Edition packs texture animation frames are defined in individual .mcmeta text files, Bedrock Edition combines all the texture animation definitions into a single flipbook_textures.json file. In general, you can edit the corresponding animation definitions in flipbook_textures.json to reflect the customizations in the .mcmeta files.  Packaging Changes Expand table Java Edition textures folder subdirectories\tBedrock Edition textures folder subdirectories block\tblocks colormap\tcolormap effect\t:--- entity\tentity environment\tenvironment font\t:--- gui\tgui item\titems map\tmap misc\tmisc models\tmodels painting\tpainting particle\tparticle :---\tpersona_thumbnails Expand table Sample Java Edition texture filenames\tSample Bedrock Edition texture filenames beehive_end.png\tbeehive_top.png honeycomb_block.png\thoneycomb.png honey_block_bottom.png\thoney_bottom.png honey_block_side.png\thoney_side.png honey_block_top.png\thoney_top.png wither_rose.png\tflower_wither_rose.png block_iron.png\tiron_block.png Advanced Options  The following advanced techniques and options are beyond the scope of this article, including:  HD textures and related issues Customizing animation_controllers.json Custom UI Custom model geometry Customizing animated textures Custom sounds Customizing behavior packs What's Next?  If you want to learn more about resource packs, which makes use of textures, see the resource pack tutorial.  Introduction to Resource Packs  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/preparingrawtextforlocalization?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Preparing Raw Text for Localization 09/21/2023  Please adhere to these guidelines when preparing raw text files for localization. These guidelines are critical for both the technical aspect of localization - parsing and distributing content within the localization system - and for ensuring the best possible translations through comprehensive and descriptive commenting.  In this tutorial you will learn the following:  How to create a properly formatted language file Best practices for supplying context to each translation Requirements  It's recommended that at least one of the following be completed before beginning this tutorial, as they make use of translations and can serve as examples for this tutorial.  Packaging a Skin Pack Creating a World Template Text Strings  Text that you create to appear in the game is found in the en_US.lang file. Each text string should be on a single line and have special formatting to include certain data:  String Name (required) String Value (required) String Comment (highly recommended)  In general, it looks like this:  JSON Copy StringName=StringValue ###StringComment  String Names  Each text string must have a string name (or ID, or key). This name is used to identify the text string within our translation system.  The string name (key/ID) starts at the beginning of a line and end with an equals = sign. It must be unique when compared with all other names within the file.  String Names Example JSON Copy Welcome.Message.1=   Be sure to create a descriptive string name. A good string name gives clues to the translator about how and where the text is used in the game.  String Values  Each text string must have a string value. This value is the text that appears in the game to the player. Each value starts at the first equals = sign on the line and ends with a tab character followed by a hashtag character.  String Values Example JSON Copy Welcome.Message.1=Welcome to our world! #   Here, the string name is Welcome.Message.1, and the string value is Welcome to our world!.   Note  <tab># is the required terminator for our parser to recognize the string. There's no harm in adding extra hashtags because that is the start of a comment (see below). Watch out for programs and/or processing that convert tabs to spaces because that won't work. The tab must be character code U+0009. Do not use leading or trailing spaces around the equals = sign.  Comments  Comments provide key contextual information about a text string for translators. They are often critical for quality translations, so are highly recommended.  Associate a comment with a text string by adding two more hashtag characters at the end of the line, and then the comment. The comment is allowed to have a space after the last hashtag character.  JSON Copy Author.Name.2=Created by <name> ###<name> is the proper name of the map creator, and he is a male person.   The comment, <name> is the proper name of the map creator, and he is a male person, is shown to the translator while they are translating the text, Created by <name>. Notice how the comment specifies that the person's name is a singular male proper name. This is a good practice, because translations in some languages are different depending on whether the context is a singular person (including their gender), a group of people, or a company name.  We highly recommended commenting every string to help the translators do the best possible work. Make sure to detail anything that will be helpful for translators, including:  Context and parts-of-speech Proper names (with descriptions) Subject/object gender, number, and whether it's a place/location Meanings of characters and items The intent of color codes Any parts that should not be translated The full text of any split or concatenated lines (see below)   Important  Comments are per string. If you want a comment to apply to multiple strings, copy and paste it for each line. Translators only see comments that are associated with strings. They do not get the entire en_US.lang file. Due to this, best practice would be to try not to split lines or conversations across multiple text strings. If you must, please enter the full text of the sentence or conversation into a comment on each string to help translators. Remember that translators will see each of these lines separately, and not necessarily in order.  Comments Example  Here we include the full text of the sign in each line's comment. This makes it much easier for the translator to correctly translate.  JSON Copy Welcome.Sign.1=Welcome to ### Welcome to our world! We hope you have fun! Welcome.Sign.2=our world! ### Welcome to our world! We hope you have fun! Welcome.Sign.3=We hope you ### Welcome to our world! We hope you have fun! Welcome.Sign.4=have fun! ### Welcome to our world! We hope you have fun!  Files  The en_US.lang file must be saved in UTF-8 encoding. Processing will fail if the file is encoded in ANSI, UTF-8 BOM, UCS-2, or any other encoding.  For example, if you are using Windows 10's Notepad, when saving a file, make sure the \"encoding\" drop-down menu has UTF-8 selected. You should also set the \"Save as type\" to \"All files\" to avoid accidentally creating a .txt file.  It is possible to send separate documents (like PNG images or PDF documents) that show context for translation, but this is a manual process outside of the regular translation pipeline, and is not a replacement for well-authored comments and string names.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/preparingrawtextforlocalization?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Preparing Raw Text for Localization 09/21/2023  Please adhere to these guidelines when preparing raw text files for localization. These guidelines are critical for both the technical aspect of localization - parsing and distributing content within the localization system - and for ensuring the best possible translations through comprehensive and descriptive commenting.  In this tutorial you will learn the following:  How to create a properly formatted language file Best practices for supplying context to each translation Requirements  It's recommended that at least one of the following be completed before beginning this tutorial, as they make use of translations and can serve as examples for this tutorial.  Packaging a Skin Pack Creating a World Template Text Strings  Text that you create to appear in the game is found in the en_US.lang file. Each text string should be on a single line and have special formatting to include certain data:  String Name (required) String Value (required) String Comment (highly recommended)  In general, it looks like this:  JSON Copy StringName=StringValue ###StringComment  String Names  Each text string must have a string name (or ID, or key). This name is used to identify the text string within our translation system.  The string name (key/ID) starts at the beginning of a line and end with an equals = sign. It must be unique when compared with all other names within the file.  String Names Example JSON Copy Welcome.Message.1=   Be sure to create a descriptive string name. A good string name gives clues to the translator about how and where the text is used in the game.  String Values  Each text string must have a string value. This value is the text that appears in the game to the player. Each value starts at the first equals = sign on the line and ends with a tab character followed by a hashtag character.  String Values Example JSON Copy Welcome.Message.1=Welcome to our world! #   Here, the string name is Welcome.Message.1, and the string value is Welcome to our world!.   Note  <tab># is the required terminator for our parser to recognize the string. There's no harm in adding extra hashtags because that is the start of a comment (see below). Watch out for programs and/or processing that convert tabs to spaces because that won't work. The tab must be character code U+0009. Do not use leading or trailing spaces around the equals = sign.  Comments  Comments provide key contextual information about a text string for translators. They are often critical for quality translations, so are highly recommended.  Associate a comment with a text string by adding two more hashtag characters at the end of the line, and then the comment. The comment is allowed to have a space after the last hashtag character.  JSON Copy Author.Name.2=Created by <name> ###<name> is the proper name of the map creator, and he is a male person.   The comment, <name> is the proper name of the map creator, and he is a male person, is shown to the translator while they are translating the text, Created by <name>. Notice how the comment specifies that the person's name is a singular male proper name. This is a good practice, because translations in some languages are different depending on whether the context is a singular person (including their gender), a group of people, or a company name.  We highly recommended commenting every string to help the translators do the best possible work. Make sure to detail anything that will be helpful for translators, including:  Context and parts-of-speech Proper names (with descriptions) Subject/object gender, number, and whether it's a place/location Meanings of characters and items The intent of color codes Any parts that should not be translated The full text of any split or concatenated lines (see below)   Important  Comments are per string. If you want a comment to apply to multiple strings, copy and paste it for each line. Translators only see comments that are associated with strings. They do not get the entire en_US.lang file. Due to this, best practice would be to try not to split lines or conversations across multiple text strings. If you must, please enter the full text of the sentence or conversation into a comment on each string to help translators. Remember that translators will see each of these lines separately, and not necessarily in order.  Comments Example  Here we include the full text of the sign in each line's comment. This makes it much easier for the translator to correctly translate.  JSON Copy Welcome.Sign.1=Welcome to ### Welcome to our world! We hope you have fun! Welcome.Sign.2=our world! ### Welcome to our world! We hope you have fun! Welcome.Sign.3=We hope you ### Welcome to our world! We hope you have fun! Welcome.Sign.4=have fun! ### Welcome to our world! We hope you have fun!  Files  The en_US.lang file must be saved in UTF-8 encoding. Processing will fail if the file is encoded in ANSI, UTF-8 BOM, UCS-2, or any other encoding.  For example, if you are using Windows 10's Notepad, when saving a file, make sure the \"encoding\" drop-down menu has UTF-8 selected. You should also set the \"Save as type\" to \"All files\" to avoid accidentally creating a .txt file.  It is possible to send separate documents (like PNG images or PDF documents) that show context for translation, but this is a manual process outside of the regular translation pipeline, and is not a replacement for well-authored comments and string names.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/preparingrawtextforlocalization?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Preparing Raw Text for Localization 09/21/2023  Please adhere to these guidelines when preparing raw text files for localization. These guidelines are critical for both the technical aspect of localization - parsing and distributing content within the localization system - and for ensuring the best possible translations through comprehensive and descriptive commenting.  In this tutorial you will learn the following:  How to create a properly formatted language file Best practices for supplying context to each translation Requirements  It's recommended that at least one of the following be completed before beginning this tutorial, as they make use of translations and can serve as examples for this tutorial.  Packaging a Skin Pack Creating a World Template Text Strings  Text that you create to appear in the game is found in the en_US.lang file. Each text string should be on a single line and have special formatting to include certain data:  String Name (required) String Value (required) String Comment (highly recommended)  In general, it looks like this:  JSON Copy StringName=StringValue ###StringComment  String Names  Each text string must have a string name (or ID, or key). This name is used to identify the text string within our translation system.  The string name (key/ID) starts at the beginning of a line and end with an equals = sign. It must be unique when compared with all other names within the file.  String Names Example JSON Copy Welcome.Message.1=   Be sure to create a descriptive string name. A good string name gives clues to the translator about how and where the text is used in the game.  String Values  Each text string must have a string value. This value is the text that appears in the game to the player. Each value starts at the first equals = sign on the line and ends with a tab character followed by a hashtag character.  String Values Example JSON Copy Welcome.Message.1=Welcome to our world! #   Here, the string name is Welcome.Message.1, and the string value is Welcome to our world!.   Note  <tab># is the required terminator for our parser to recognize the string. There's no harm in adding extra hashtags because that is the start of a comment (see below). Watch out for programs and/or processing that convert tabs to spaces because that won't work. The tab must be character code U+0009. Do not use leading or trailing spaces around the equals = sign.  Comments  Comments provide key contextual information about a text string for translators. They are often critical for quality translations, so are highly recommended.  Associate a comment with a text string by adding two more hashtag characters at the end of the line, and then the comment. The comment is allowed to have a space after the last hashtag character.  JSON Copy Author.Name.2=Created by <name> ###<name> is the proper name of the map creator, and he is a male person.   The comment, <name> is the proper name of the map creator, and he is a male person, is shown to the translator while they are translating the text, Created by <name>. Notice how the comment specifies that the person's name is a singular male proper name. This is a good practice, because translations in some languages are different depending on whether the context is a singular person (including their gender), a group of people, or a company name.  We highly recommended commenting every string to help the translators do the best possible work. Make sure to detail anything that will be helpful for translators, including:  Context and parts-of-speech Proper names (with descriptions) Subject/object gender, number, and whether it's a place/location Meanings of characters and items The intent of color codes Any parts that should not be translated The full text of any split or concatenated lines (see below)   Important  Comments are per string. If you want a comment to apply to multiple strings, copy and paste it for each line. Translators only see comments that are associated with strings. They do not get the entire en_US.lang file. Due to this, best practice would be to try not to split lines or conversations across multiple text strings. If you must, please enter the full text of the sentence or conversation into a comment on each string to help translators. Remember that translators will see each of these lines separately, and not necessarily in order.  Comments Example  Here we include the full text of the sign in each line's comment. This makes it much easier for the translator to correctly translate.  JSON Copy Welcome.Sign.1=Welcome to ### Welcome to our world! We hope you have fun! Welcome.Sign.2=our world! ### Welcome to our world! We hope you have fun! Welcome.Sign.3=We hope you ### Welcome to our world! We hope you have fun! Welcome.Sign.4=have fun! ### Welcome to our world! We hope you have fun!  Files  The en_US.lang file must be saved in UTF-8 encoding. Processing will fail if the file is encoded in ANSI, UTF-8 BOM, UCS-2, or any other encoding.  For example, if you are using Windows 10's Notepad, when saving a file, make sure the \"encoding\" drop-down menu has UTF-8 selected. You should also set the \"Save as type\" to \"All files\" to avoid accidentally creating a .txt file.  It is possible to send separate documents (like PNG images or PDF documents) that show context for translation, but this is a manual process outside of the regular translation pipeline, and is not a replacement for well-authored comments and string names.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/preparingrawtextforlocalization?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Preparing Raw Text for Localization 09/21/2023  Please adhere to these guidelines when preparing raw text files for localization. These guidelines are critical for both the technical aspect of localization - parsing and distributing content within the localization system - and for ensuring the best possible translations through comprehensive and descriptive commenting.  In this tutorial you will learn the following:  How to create a properly formatted language file Best practices for supplying context to each translation Requirements  It's recommended that at least one of the following be completed before beginning this tutorial, as they make use of translations and can serve as examples for this tutorial.  Packaging a Skin Pack Creating a World Template Text Strings  Text that you create to appear in the game is found in the en_US.lang file. Each text string should be on a single line and have special formatting to include certain data:  String Name (required) String Value (required) String Comment (highly recommended)  In general, it looks like this:  JSON Copy StringName=StringValue ###StringComment  String Names  Each text string must have a string name (or ID, or key). This name is used to identify the text string within our translation system.  The string name (key/ID) starts at the beginning of a line and end with an equals = sign. It must be unique when compared with all other names within the file.  String Names Example JSON Copy Welcome.Message.1=   Be sure to create a descriptive string name. A good string name gives clues to the translator about how and where the text is used in the game.  String Values  Each text string must have a string value. This value is the text that appears in the game to the player. Each value starts at the first equals = sign on the line and ends with a tab character followed by a hashtag character.  String Values Example JSON Copy Welcome.Message.1=Welcome to our world! #   Here, the string name is Welcome.Message.1, and the string value is Welcome to our world!.   Note  <tab># is the required terminator for our parser to recognize the string. There's no harm in adding extra hashtags because that is the start of a comment (see below). Watch out for programs and/or processing that convert tabs to spaces because that won't work. The tab must be character code U+0009. Do not use leading or trailing spaces around the equals = sign.  Comments  Comments provide key contextual information about a text string for translators. They are often critical for quality translations, so are highly recommended.  Associate a comment with a text string by adding two more hashtag characters at the end of the line, and then the comment. The comment is allowed to have a space after the last hashtag character.  JSON Copy Author.Name.2=Created by <name> ###<name> is the proper name of the map creator, and he is a male person.   The comment, <name> is the proper name of the map creator, and he is a male person, is shown to the translator while they are translating the text, Created by <name>. Notice how the comment specifies that the person's name is a singular male proper name. This is a good practice, because translations in some languages are different depending on whether the context is a singular person (including their gender), a group of people, or a company name.  We highly recommended commenting every string to help the translators do the best possible work. Make sure to detail anything that will be helpful for translators, including:  Context and parts-of-speech Proper names (with descriptions) Subject/object gender, number, and whether it's a place/location Meanings of characters and items The intent of color codes Any parts that should not be translated The full text of any split or concatenated lines (see below)   Important  Comments are per string. If you want a comment to apply to multiple strings, copy and paste it for each line. Translators only see comments that are associated with strings. They do not get the entire en_US.lang file. Due to this, best practice would be to try not to split lines or conversations across multiple text strings. If you must, please enter the full text of the sentence or conversation into a comment on each string to help translators. Remember that translators will see each of these lines separately, and not necessarily in order.  Comments Example  Here we include the full text of the sign in each line's comment. This makes it much easier for the translator to correctly translate.  JSON Copy Welcome.Sign.1=Welcome to ### Welcome to our world! We hope you have fun! Welcome.Sign.2=our world! ### Welcome to our world! We hope you have fun! Welcome.Sign.3=We hope you ### Welcome to our world! We hope you have fun! Welcome.Sign.4=have fun! ### Welcome to our world! We hope you have fun!  Files  The en_US.lang file must be saved in UTF-8 encoding. Processing will fail if the file is encoded in ANSI, UTF-8 BOM, UCS-2, or any other encoding.  For example, if you are using Windows 10's Notepad, when saving a file, make sure the \"encoding\" drop-down menu has UTF-8 selected. You should also set the \"Save as type\" to \"All files\" to avoid accidentally creating a .txt file.  It is possible to send separate documents (like PNG images or PDF documents) that show context for translation, but this is a manual process outside of the regular translation pipeline, and is not a replacement for well-authored comments and string names.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftfileextensions?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Minecraft File Extensions 11/15/2023  A file extension is the series of letters after the period in a name of a computer file. File extensions specify the program or programs the file is associated with. In Minecraft: Bedrock Edition, many extensions begin with '.mc,' as detailed below.  .mcaddon  A zip file that contains .mcpack or .mcworld files to modify Minecraft (Bedrock Edition); generally used to distribute add-ons to other users.  .mcmeta  A custom resource pack configuration file.  .mcpack  A zipped resource or behavior pack that modifies Minecraft: Bedrock Edition, typically used to transfer resources between users.  .mcproject  Minecraft Bedrock Editor's filetype. Files of this type only open in Editor and are capable of containing Editor extensions.  .mcworld files can be imported into Editor, at which point they are converted to an .mcproject. When an .mcproject is exported as an .mcworld, Editor extensions are removed. .mcstructure  Contains a Minecraft structure such as a building or natural feature, saved using the Structure Block tool; can be shared between players, allowing the sharing of each other's structures.  .mctemplate  A zip archive containing the template of a world used in Minecraft.  .mcworld  A zip archive that contains all the files needed to load a Minecraft: Bedrock Edition or Minecraft Education world, for example .dat and .txt files.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/minecraftfileextensions?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Minecraft File Extensions 11/15/2023  A file extension is the series of letters after the period in a name of a computer file. File extensions specify the program or programs the file is associated with. In Minecraft: Bedrock Edition, many extensions begin with '.mc,' as detailed below.  .mcaddon  A zip file that contains .mcpack or .mcworld files to modify Minecraft (Bedrock Edition); generally used to distribute add-ons to other users.  .mcmeta  A custom resource pack configuration file.  .mcpack  A zipped resource or behavior pack that modifies Minecraft: Bedrock Edition, typically used to transfer resources between users.  .mcproject  Minecraft Bedrock Editor's filetype. Files of this type only open in Editor and are capable of containing Editor extensions.  .mcworld files can be imported into Editor, at which point they are converted to an .mcproject. When an .mcproject is exported as an .mcworld, Editor extensions are removed. .mcstructure  Contains a Minecraft structure such as a building or natural feature, saved using the Structure Block tool; can be shared between players, allowing the sharing of each other's structures.  .mctemplate  A zip archive containing the template of a world used in Minecraft.  .mcworld  A zip archive that contains all the files needed to load a Minecraft: Bedrock Edition or Minecraft Education world, for example .dat and .txt files.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/guidelinesforbuildingcooperativeaddons?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Guidelines for Building Cooperative Add-Ons 12/13/2024  Across the Minecraft platform, there is so much potential to customize how the game looks and acts. You can build your own mobs or override \"vanilla mobs\". Build your own blocks that fit into Minecraft, or change the default textures to something completely different. If you want fewer skeletons spawning in, you can override the skeleton or change its spawn rules. Where possible, we aim for as much customizability as possible!  But if you want to support an environment where players can play Minecraft survival or creative experiences -- and add maybe a dozen different additional enhancements they love -- you're going to want your add-on to be \"cooperative\". A cooperative add-on is designed to play nicely: it doesn't fundamentally change how Minecraft plays, avoids interrupting other Minecraft add-ons or experiences, and doesn't consume so many resources that it doesn't leave anything left for other add-ons to use (considering the wide array of devices Minecraft runs on). A cooperative add-on is also designed to use features and capabilities that will better stand the test of time, version over version.  It turns out there are also a lot of hidden things that could potentially cause \"conflicts\" across add-ons. For example, if two add-ons ship an entity called \"common:boss\", then based on per-world pack stack order, one of them will \"win\" and the other won't be available. Even if one creator ships two separate add-ons with the same mob in it with the same namespace, it can cause versioning issues if the implementation of that entity evolves over time across packs or version and the \"old version\" unexpectedly loads in a new version of a world.  Based on this, we introduce the concept of a \"Cooperative\" Add-On. A Cooperative Add-On is \"just\" a behavior pack+resource pack combo, but its behavior is generally additive and does not fundamentally change the gameplay of other experiences, such as the vanilla gameplay experiences or inadvertently conflict with other add-ons. It also takes precautions to avoid accidental conflicts, and to be more robust over the course of versions.  What follows is a set of guidelines for building these cooperative, additive-only add-ons. In many places, and out of a sense of precaution, you'll want to go to longer lengths to avoid add-ons that have any potential to conflict with other add-ons. Keep in mind that some of these rules are relatively strict; if you're creating an add-on for sharing with your friends, you may not need to adhere to all of these guidelines because the risk of \"add-on conflicts\" is probably much less.  Also, we have a web and command-line based tool available via Minecraft Creator Tools. It has a validation suite called \"Add-On Best Practices\" in the Inspector that looks at your add-on and suggests fixes you can make that will make your add-on more compatible with cooperative guidelines.  As time goes on, this section will evolve to capture more use cases that will change the complexity of add-ons.  Cooperativity  Fundamentally, Cooperative Add-Ons need to be designed to have \"additive\" functionality, rather than functionality that modifies or removes other functionality. For example, functionality that changes how creepers work might not be bad in and of itself, but if two completely separate add-ons are added by a player that happen to change how the creeper works, one will \"win\" (based on pack stack order, which for most players is not set in any particular intentful order). The add-on that \"loses\" (doesn't have its creeper customizations apply) might no longer work completely. We do not want to rely on players configuring their pack stack order precisely in order to have great experiences, so we want to avoid conflicts that come down to pack stack ordering.  Cooperative add-ons need to work with other add-ons. Your cooperative add-ons should work (stacked) with at least one other cooperative add-on, and you should test your add-ons around that. Add-Ons should not disable or remove fundamental vanilla gameplay. It must sit on top of vanilla and should be able to be removed without affecting the gameplay of vanilla and/or any add-on. \"Affecting the gameplay of vanilla\" is a wide and grey area - even introducing a new hostile mob can make achieving the goals of vanilla Minecraft more difficult - but what we mean is that no one add-on should prevent fundamental gameplay styles of Minecraft or make the game substantially harder or easier. You should not be making any changes to any vanilla files to accommodate your add-ons. That includes overriding or removing things that can be embedded in the world, like block types, item types, entity types, etc. For all identifiers across types (such as custom item types or custom block types), you should not use minecraft: as a name and ensure that the namespace is unique to the add-on. \"Overriding\" built-in mobs by including a type that starts with minecraft: to change how they work is not generally stable across versions. Based on this, you should also NOT override minecraft:player. You should only add new elements to the game; these changes should not change vanilla behaviors and/or vanilla item types. Because there can only be one item that can be created per recipe \"shape\" - when creating recipes for the crafting table, furnace, or brewing stand, try to use custom items whenever possible so that the \"recipe input\" is unique and diverse. Add-Ons should not override a player's skin or Character Creator. Versioning  One of the most fundamental requirements for add-ons is that they work across Minecraft versions and into the future as Minecraft evolves.  This is unlike when you create a custom world or world template; with worlds, you can use the base_game_version attribute to lock your world to a particular version of Minecraft, and where possible, that world will be frozen at that version (for example, worlds with a base game version less than 1.18.0 should not have a Pale Garden biome in them). It is important to realize that cooperative add-ons don't have a concept of version locking; they need to keep working even as version numbers advance into the future. And even if you apply these best practices listed below for cross-version compatibility, and while we do try to avoid gratuitous breaking changes in how the Minecraft Bedrock Platform works, in some cases you may need to update your add-ons over time to account for changes in how Minecraft works. Don't build in hard (or soft) dependencies that a particular mob will spawn in a particular quantity at a particular place in the Minecraft world, for example. Be resilient if new mobs are introduced that your add-on doesn't \"understand\" (because they were added in a release in the future and are now working in the world your current-day add-on is working within.)  Cooperative Add-Ons need to work release over release without the need for you to make updates. Worlds with Cooperative Add-Ons need to upgrade the same way as vanilla worlds do (without add-ons applied): ideally, seamlessly and automatically and without any data loss. Keep in mind your add-on needs to keep working in a world that is played over the span of years. Any bug fixes that you make to an add-on should not break existing worlds or remove content from within the packs. Bug fixes should not cause data loss. For example, removing a custom entity type has the impact of removing/hiding all instances of that entity in the world - essentially making them disappear, which is not preferable. Instead, if you wish to upgrade an entity type, continue to support the old entity type for backwards compatibility reasons. You should not use \"runtime_identifier\": when creating new entities because as versions change, a mob's behavior can change significantly, potentially leading to frequent breaks. min_engine_version must be set on both packs of the cooperative add-on. Add-Ons should not use or rely on Experimental features. When making updates, don't change namespaces, as that will cause version-related breaks in the add-on for players. Cooperative Add-On Technical Structure  Cooperative Add-Ons use existing tech and are added to the world by the player from either the Resource Pack or Behavior Pack tabs of the Create New World or Edit World screens. The requirement for each pack having a dependency on the other ensures that players won't get into a state where they have one pack applied to the world without the other.  Cooperative Add-Ons should consist of only one Behavior Pack and one Resource Pack. Both the Behavior Pack and Resource Pack need to contain dependencies on each other so one should not be applied without the other. Cooperative Add-Ons should not have a dependency on packs outside of their own packs.  These restrictions keep the process of adding add-on packs as simple as possible for players.  Manifest Updates  There is an additional field that needs to be added to the manifest of the Resource Pack of your add-on. To ensure that your resource pack can't be applied as a Global Resource Pack, you will need to add \"pack_scope\": \"world\", just after the \"uuid:\".  Here is an example of where that field goes in the resource pack manifest file:  JSON Copy {   \"format_version\": 2,    \"header\": {      \"name\": \"pack.name\",      \"description\": \"pack.description\",      \"uuid\": \"aa943e69-b6b8-955b-d405-29d77cc87283\",      \"pack_scope\": \"world\",      \"version\": [1, 0, 0],      \"min_engine_version\": [1, 21, 50],    },    \"modules\": [      {        \"version\": [1, 0, 0],        \"uuid\": \"bb461250-6de3-49f0-4a94-62c1deeb9b71\",        \"type\": \"data\"      }    ],    \"dependencies\": [      {        \"uuid\": \"aabcb1dc-29ca-4fc4-fa8c-ea1ea2d6788d\",        \"version\": [1, 0, 0]      }    ]  }   Limits for Performance  Many players will add 10+ add-on packs to their worlds, which can cause problems on a variety of devices. For example, some devices cannot scale to having 10 add-ons, each with 4,000 pieces of furniture and their attendant textures. On the other hand, 10 add-ons that each add 5-10 mobs is a bit more scalable. Based on this, we have some (admittedly coarse) guidelines on overall size of your add-ons.  Try not to exceed 25MB uncompressed, or a maximum of 3,500 files. because you need many files to implement basic concepts like a new block type, a 3,500 file limit equates to a rough maximum limit of 1,000 elements in your add-on, whether those elements are blocks, items, entities, or some combination thereof Block permutations should not exceed 10,000 blocks to ensure minimal performance impact across all platforms. Conserve overall texture size. When creating items like books, continue to use lower-resolution textures (<500 x <500). Aim for below 256x256 for blocks and items. Aim for below 2048x2048 for everything else. Prioritize efficient use of space over power-of-2 (e.g., 512x512, 1024x1024) sizing. See Improving Performance and Resource Usage for more tips. Use techniques like Molang and materials to produce color variants of textures, rather than creating, say, 8 color-tinted texture variants of the same texture. Types of Customizations to Avoid You should not add a dimension file to your add-on. Do not override UI files (resource packs/ui) Do not use custom client biome override files (resource) Via .lang files, do not override the words used for vanilla strings Do not override vanilla sounds and music with your own custom sounds and music. Do not use setLore APIs on minecraft:written_book. Ticking Areas  Because the number of available ticking areas are limited, avoid using ticking areas in your design plans when making your add-on.  Also, players or the base world can define their own ticking areas - even in the case that you are the only add-on applied to a world, it still may not be enough available ticking areas on that world.  Namespacing and Identifiers  There are several items in your add-on that need to have names that are unique. Because it is conceivable that you could accidentally conflict with other add-ons, you would need to prevent conflicts with other add-ons (including other those from yourself as a creator – past, present or future.) Below is a detailed recommendation on creating names for these items.  The following items need to have a unique name that no other add-on can ever have. It is recommended that you use a combination of creator name + pack abbreviations to create a unique namespace that you don't use in any other packs.  Namespace  Every item in the add-on needs to have a namespace and that namespace can't be minecraft:.  The namespace needs to be the same for every item in the add-on, including particles.  Every add-on you make needs to have a different namespace from any other namespace used in previous packs. This will ensure that your pack won't have a conflict with add-ons from others creations, as well as any add-on that you may have released.  We recommend that you use your creator name (or abbreviated creator name) followed by an underscore and an abbreviated pack name. For example, for the add-on called Your Creator Name's Super Awesome Add-On Pack, you could use the namespace ycn_saaop:.   Important  Having a conflict in the namespace is the only thing that can't easily be updated post-release, so you really want to get this right! If you have a conflict with another add-on you created, it is likely that you can't update the namespaces as that will cause data loss for all the items that you update to that namespace.  Texture Name  Texture names need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. Texture names can be anything and it is likely that there will be conflicts with other creators because texture names tend to be descriptive -- you could imagine multiple furniture add-ons naming a texture \"table\", and that would conflict based on pack stack order. For most players, pack stack order is not intentfully set so which texture \"wins\" would be random.  All textures should be placed at least 2 folders deep (although additional folders can be used if you want for additional organization.) The first folder should be your creator name and the second folder should be the pack name. The folder structure will look like this.  PowerShell Copy &lt;resource pack name&gt; -> textures -> &lt;creator name&gt; -> &lt;pack name&gt; -> mycustomtexture.png  Texture Reference  Like texture names, texture references need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. When creating texture references, use the pack's \"namespace:\" before the name. This will prevent any conflicts.  Localization (Lang Files)  If you localize your packs via .lang resource files, ensure that you use namespaced names for your .lang string replacement tokens.  Geometry Identifiers  Geometry identifiers also need to be unique to prevent items from using the wrong geo file when multiple add-ons are applied. Geometry identifiers need to start with \"geometry.\". Because of that, we recommend that add \".namespace\" immediately after \"geometry.\". Your geometry identifiers will look like this: geometry.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Tags and Scoreboard Objective names  When using tags or scoreboard objectives within commands, you need to ensure that they are unique so that they don't conflict with other add-ons. When creating tags and Scoreboard objective names, use a namespace before the tag and scoreboard names.  Loot Tables  Loot table names need to be unique, or they can conflict with other loot tables in other add-ons. To prevent this, we suggest that every creator nests their loot tables in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> loot_tables -> &lt;creator name&gt; -> &lt;pack name&gt; -> <loot table name>  Animations  Animation names need to be unique. These are the names that are provided inside the animation file. Animation names need to start with \"animation.\". To prevent creators from using the same animation names, we recommend you add \".namespace\" immediately after \"animation.\" and will look like this animation.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Animation Controllers  Animation controller names need to be unique. These are the names that are provided inside the animation controller file. Animation controller names need to start with \"controller.animation.\". To prevent creators from using the same animation controller names, we recommend you add \".namespace\" immediately after \"controller.animation.\". It will look like this: controller.animation.creatorname_gamename.whatever.else.  Render Controllers  Render controller names need to be unique to prevent the wrong render controller files from being used. Render controller names need to start with \"controller.render.<render_controller_name>\". We recommend you add \".namespace\" immediately after \"controller.render.\". It will look like this: controller.render.creatorname_gamename.whatever.else. Please note this is the name contained within the file.  Structures  Structures for add-ons can be used with the structure command and/or features and feature rules.  When naming your structure, you need to place them in a folder that has the same name as the namespace used for the pack. When loading a structure file, the namespace used in this case is the folder name the structure appears.  Here is an example below:  PowerShell Copy <behavior pack name> -> structures -> <namespace> -> <structure file name>  Feature and Feature Rules  Feature and feature rules file names need to be unique, or they can conflict with other feature and feature rules files in other add-ons. Use the namespace identifier conventions that you use in other files. Be advised that, unfortunately, feature files cannot be located in subfolders without changing how their namespace identifier works in unpredictable ways.  Functions  Function file names need to be unique, or they can conflict with other functions in other add-ons.  To prevent this, we suggest that every creator nests their functions in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> functions -> &lt;creator name&gt; -> &lt;pack name&gt; -> <function file name>.   Using this naming convention also allows creators to use tick.json in their packs without conflicting with other creators.  Sounds  Sounds are located within the Resource pack, and can override other sounds based on their file path and name. To prevent unwanted overrides, we suggest placing your sound files at least 2 folders deep in the sounds folder (although more can be used if desired).  The first folder is your creator name, and the second folder is the pack name. This will cause your folder structure to look like this:  PowerShell Copy &lt;resource pack name&gt; -> sounds -> &lt;creator name&gt; -> &lt;pack name&gt;  Sound Reference  Sound References need to be unique. Sound references are assigned in the sound definition file. All sound references need to start with \"namespace:\" to prevent files from conflicting with each other.  NPC Scenes  NPC scenes need to have unique names to prevent any conflicts with other add-ons. Use the same namespace format that you use throughout the add-on to name the NPC scenes.  Trade Tables  Trade table names need to be unique, or they can conflict with other trade tables in other add-ons. Creators should place their trade tables in a folder named \"trading\". Inside the trading folder we suggest that every creator nests their trade table files two additional folders deep to prevent conflict with other creators' add-ons.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> trading -> &lt;creator name&gt; -> &lt;pack name&gt; -> <trade table file name>.  JSON UI and Custom Fonts overrides are disalllowed  Because JSON UI (i.e., files in <resource pack name>/ui) and fonts (i.e., files in <resource pack name>/font) are not overridable in a cooperative manner - such that multiple add-ons can customize the same asset - cooperative add-ons should not override any JSON UI or font glyph files.  Folder Structures  For folders like textures, functions, loot tables, sounds, and trading we recommend that your folder structure appear like this, textures-> <creator_name> -> <pack_name>.  Where possible, always ensure your textures, functions, loot tables, sounds, and trading folder have a subfolder that is your <creator_name> and only that folder. You should not have \"loose\" files in the <creator_name> folder.  Inside the <creator_name> folder, we recommend that you don't add more than two folders. The first is the recommended <pack_name> folder. The only other folder that should appear in here is one called \"common\". You can use this to help speed up development by placing assets in there that you use commonly across packs.   Note  Use of a common folder inside of <pack_name> folder is a little risky. If you change the asset in any way, you need to update it in every pack that contains it to prevent one of your packs conflicting with another pack.  You should come up with a unique namespace for each pack, and that name should consist of your creator name appended to the pack name and separated by an underscore. Doing this will ensure that your packs will work with all add-ons created and future proof against any add-ons created in the future. This will help prevent a potential negative experience for players.  Using that namespace as suffix to texture names, texture references, geo identifiers, tags and scoreboard objective names also ensures that what you create in your add-on will always appear the way that you intend them to look.  Using Block Placing Methods like Structures, Setblock, Fill, and Clone  Suppose you want to add something to an existing 5 year old world. Your add-on should not arbitrarily destroy (or replace blocks in) areas of the world, especially without explicit user consent - because you could be destroying someone's cherished 5 year old creations!  While placing structures have more of a chance of altering or destroying something that the player cares about, it can still occur when replacing a single block. If that happens, there is no way for the player to recover from this (unless they backed up the world before loading).  If your concept requires a starting area structure, or for large structures to spawn in or be created without player interaction, or without the player knowing what is going to happen, please consider using these ideas in an entire world instead of as a Cooperative Add-On.  Here are some recommendations for using these features:  In existing saved chunks  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  Check to make sure that these blocks are only placed in areas that are empty - meaning the blocks they are replacing are only air.  In unmodified chunks  If these come in without player interaction check to make sure that these blocks are only placed in areas that are fully air.  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  If you are going to replace blocks, try to ensure that blocks that are valuable to players aren't replaced (like ores, archeology blocks, etc.)  Teaching players how to use your Add-On  Teaching players how to use your add-on is vitally important for a great player experience and there should be a single, non-destructive way to do this. This way the players will have the same expectations no matter which add-on they add to the world.  We recommend that all creators spawn a book at the feet of the player on first load that teaches the player how to use the add-on. This needs to be done in a non-destructive way.  There are a few techniques for adding an instructional book:  Adding a book  It's a little clunky, but one way to safely add a book to a players' inventory is to make the book spawn at the player's location.  The mechanism behind this is to create a small (1 block) structure at the player's position that contains only the book and a structure void. Make the structure spawn only once.  Doing this will allow players with a space in their inventory to automatically pick up the book. For those with a full inventory, they would need to choose something to drop to pick it up. Because this is generally the way that all cooperative add-ons work, there will be a player expectation to look for this book. You can also send the player an onscreen message that informs them about the book (so players with a full inventory will look for it), but this isn't required.  If you want to be super-nice, you could provide an empty chest so players can off-load items so they can pick up the book.  Messages in chat  If you choose to have a chat message, please ensure that it is 28 characters or less so that it fits on one line. Stacking multiple add-ons will make it difficult for players to read all the messages. You should also make sure that it only sends the message the first time the player joins the world. Try to avoid excessive messages being broadcast to players.  Custom item that acts like a book  Another alternative is to create a custom item and entity that looks and acts like a book when opened. Please note that if you go this route that the text might not be localize-able since it is part of the textures.  You will also need to handle the opening, closing, and reacquiring of the book yourself and need to do this in a way that won't interfere with other entity books in multiplayer. It will be much easier for players to lose books when using this method. We recommend creating a way to craft your entity books so players can easily craft a replacement if needed. Please keep these things in mind when deciding to use this method.  It is recommended that you make the max item stack size for these types of books 64. This will allow players to place them in bundles. The bundle uses max stack size and a max stack size of 1 will fill the entire bundle with that one item. Nothing extra needs to be done if you are using the structure that spawns a book approach.  Regardless of whether you choose to spawn the guidebook as an entity or a structure containing a signed book, spawning it at the player's location can only happen once per player. Do not spawn a book every time a player joins the world or after the player dies.  Lastly, do not use setLore APIs on your books, as it will be added to all the guidebooks the player has. (it will overwrite the books of other creators that may be stacked in the world as well!)  Summary of Cooperative Add-On Creator Guidelines  Use namespaces and custom folder names to ensure that the identifiers used across your add-on are unique, and cannot accidentally collide with other add-ons.  Do not use certain features, like custom dimension sizes or UI JSON overrides, that don't scale to being cooperatively overridden.  Do not change or remove vanilla behavior; only add new things to the game. Vanilla gameplay changes over time and new gameplay updates rely on existing vanilla blocks, items, mobs, and mechanics, so changing these can affect gameplay. To prevent vanilla gameplay from breaking, you should not change any of the vanilla gameplay files or use scripting to disable vanilla gameplay elements.  In addition to vanilla gameplay, you should not change or update vanilla elements, because we need to ensure that multiple add-ons work together. If we allow you to change a vanilla element, it could interfere with another add-on that relies on the same element. To prevent add-ons from unintentionally disabling another add-on, we only allow new things to be created.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/guidelinesforbuildingcooperativeaddons?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Guidelines for Building Cooperative Add-Ons 12/13/2024  Across the Minecraft platform, there is so much potential to customize how the game looks and acts. You can build your own mobs or override \"vanilla mobs\". Build your own blocks that fit into Minecraft, or change the default textures to something completely different. If you want fewer skeletons spawning in, you can override the skeleton or change its spawn rules. Where possible, we aim for as much customizability as possible!  But if you want to support an environment where players can play Minecraft survival or creative experiences -- and add maybe a dozen different additional enhancements they love -- you're going to want your add-on to be \"cooperative\". A cooperative add-on is designed to play nicely: it doesn't fundamentally change how Minecraft plays, avoids interrupting other Minecraft add-ons or experiences, and doesn't consume so many resources that it doesn't leave anything left for other add-ons to use (considering the wide array of devices Minecraft runs on). A cooperative add-on is also designed to use features and capabilities that will better stand the test of time, version over version.  It turns out there are also a lot of hidden things that could potentially cause \"conflicts\" across add-ons. For example, if two add-ons ship an entity called \"common:boss\", then based on per-world pack stack order, one of them will \"win\" and the other won't be available. Even if one creator ships two separate add-ons with the same mob in it with the same namespace, it can cause versioning issues if the implementation of that entity evolves over time across packs or version and the \"old version\" unexpectedly loads in a new version of a world.  Based on this, we introduce the concept of a \"Cooperative\" Add-On. A Cooperative Add-On is \"just\" a behavior pack+resource pack combo, but its behavior is generally additive and does not fundamentally change the gameplay of other experiences, such as the vanilla gameplay experiences or inadvertently conflict with other add-ons. It also takes precautions to avoid accidental conflicts, and to be more robust over the course of versions.  What follows is a set of guidelines for building these cooperative, additive-only add-ons. In many places, and out of a sense of precaution, you'll want to go to longer lengths to avoid add-ons that have any potential to conflict with other add-ons. Keep in mind that some of these rules are relatively strict; if you're creating an add-on for sharing with your friends, you may not need to adhere to all of these guidelines because the risk of \"add-on conflicts\" is probably much less.  Also, we have a web and command-line based tool available via Minecraft Creator Tools. It has a validation suite called \"Add-On Best Practices\" in the Inspector that looks at your add-on and suggests fixes you can make that will make your add-on more compatible with cooperative guidelines.  As time goes on, this section will evolve to capture more use cases that will change the complexity of add-ons.  Cooperativity  Fundamentally, Cooperative Add-Ons need to be designed to have \"additive\" functionality, rather than functionality that modifies or removes other functionality. For example, functionality that changes how creepers work might not be bad in and of itself, but if two completely separate add-ons are added by a player that happen to change how the creeper works, one will \"win\" (based on pack stack order, which for most players is not set in any particular intentful order). The add-on that \"loses\" (doesn't have its creeper customizations apply) might no longer work completely. We do not want to rely on players configuring their pack stack order precisely in order to have great experiences, so we want to avoid conflicts that come down to pack stack ordering.  Cooperative add-ons need to work with other add-ons. Your cooperative add-ons should work (stacked) with at least one other cooperative add-on, and you should test your add-ons around that. Add-Ons should not disable or remove fundamental vanilla gameplay. It must sit on top of vanilla and should be able to be removed without affecting the gameplay of vanilla and/or any add-on. \"Affecting the gameplay of vanilla\" is a wide and grey area - even introducing a new hostile mob can make achieving the goals of vanilla Minecraft more difficult - but what we mean is that no one add-on should prevent fundamental gameplay styles of Minecraft or make the game substantially harder or easier. You should not be making any changes to any vanilla files to accommodate your add-ons. That includes overriding or removing things that can be embedded in the world, like block types, item types, entity types, etc. For all identifiers across types (such as custom item types or custom block types), you should not use minecraft: as a name and ensure that the namespace is unique to the add-on. \"Overriding\" built-in mobs by including a type that starts with minecraft: to change how they work is not generally stable across versions. Based on this, you should also NOT override minecraft:player. You should only add new elements to the game; these changes should not change vanilla behaviors and/or vanilla item types. Because there can only be one item that can be created per recipe \"shape\" - when creating recipes for the crafting table, furnace, or brewing stand, try to use custom items whenever possible so that the \"recipe input\" is unique and diverse. Add-Ons should not override a player's skin or Character Creator. Versioning  One of the most fundamental requirements for add-ons is that they work across Minecraft versions and into the future as Minecraft evolves.  This is unlike when you create a custom world or world template; with worlds, you can use the base_game_version attribute to lock your world to a particular version of Minecraft, and where possible, that world will be frozen at that version (for example, worlds with a base game version less than 1.18.0 should not have a Pale Garden biome in them). It is important to realize that cooperative add-ons don't have a concept of version locking; they need to keep working even as version numbers advance into the future. And even if you apply these best practices listed below for cross-version compatibility, and while we do try to avoid gratuitous breaking changes in how the Minecraft Bedrock Platform works, in some cases you may need to update your add-ons over time to account for changes in how Minecraft works. Don't build in hard (or soft) dependencies that a particular mob will spawn in a particular quantity at a particular place in the Minecraft world, for example. Be resilient if new mobs are introduced that your add-on doesn't \"understand\" (because they were added in a release in the future and are now working in the world your current-day add-on is working within.)  Cooperative Add-Ons need to work release over release without the need for you to make updates. Worlds with Cooperative Add-Ons need to upgrade the same way as vanilla worlds do (without add-ons applied): ideally, seamlessly and automatically and without any data loss. Keep in mind your add-on needs to keep working in a world that is played over the span of years. Any bug fixes that you make to an add-on should not break existing worlds or remove content from within the packs. Bug fixes should not cause data loss. For example, removing a custom entity type has the impact of removing/hiding all instances of that entity in the world - essentially making them disappear, which is not preferable. Instead, if you wish to upgrade an entity type, continue to support the old entity type for backwards compatibility reasons. You should not use \"runtime_identifier\": when creating new entities because as versions change, a mob's behavior can change significantly, potentially leading to frequent breaks. min_engine_version must be set on both packs of the cooperative add-on. Add-Ons should not use or rely on Experimental features. When making updates, don't change namespaces, as that will cause version-related breaks in the add-on for players. Cooperative Add-On Technical Structure  Cooperative Add-Ons use existing tech and are added to the world by the player from either the Resource Pack or Behavior Pack tabs of the Create New World or Edit World screens. The requirement for each pack having a dependency on the other ensures that players won't get into a state where they have one pack applied to the world without the other.  Cooperative Add-Ons should consist of only one Behavior Pack and one Resource Pack. Both the Behavior Pack and Resource Pack need to contain dependencies on each other so one should not be applied without the other. Cooperative Add-Ons should not have a dependency on packs outside of their own packs.  These restrictions keep the process of adding add-on packs as simple as possible for players.  Manifest Updates  There is an additional field that needs to be added to the manifest of the Resource Pack of your add-on. To ensure that your resource pack can't be applied as a Global Resource Pack, you will need to add \"pack_scope\": \"world\", just after the \"uuid:\".  Here is an example of where that field goes in the resource pack manifest file:  JSON Copy {   \"format_version\": 2,    \"header\": {      \"name\": \"pack.name\",      \"description\": \"pack.description\",      \"uuid\": \"aa943e69-b6b8-955b-d405-29d77cc87283\",      \"pack_scope\": \"world\",      \"version\": [1, 0, 0],      \"min_engine_version\": [1, 21, 50],    },    \"modules\": [      {        \"version\": [1, 0, 0],        \"uuid\": \"bb461250-6de3-49f0-4a94-62c1deeb9b71\",        \"type\": \"data\"      }    ],    \"dependencies\": [      {        \"uuid\": \"aabcb1dc-29ca-4fc4-fa8c-ea1ea2d6788d\",        \"version\": [1, 0, 0]      }    ]  }   Limits for Performance  Many players will add 10+ add-on packs to their worlds, which can cause problems on a variety of devices. For example, some devices cannot scale to having 10 add-ons, each with 4,000 pieces of furniture and their attendant textures. On the other hand, 10 add-ons that each add 5-10 mobs is a bit more scalable. Based on this, we have some (admittedly coarse) guidelines on overall size of your add-ons.  Try not to exceed 25MB uncompressed, or a maximum of 3,500 files. because you need many files to implement basic concepts like a new block type, a 3,500 file limit equates to a rough maximum limit of 1,000 elements in your add-on, whether those elements are blocks, items, entities, or some combination thereof Block permutations should not exceed 10,000 blocks to ensure minimal performance impact across all platforms. Conserve overall texture size. When creating items like books, continue to use lower-resolution textures (<500 x <500). Aim for below 256x256 for blocks and items. Aim for below 2048x2048 for everything else. Prioritize efficient use of space over power-of-2 (e.g., 512x512, 1024x1024) sizing. See Improving Performance and Resource Usage for more tips. Use techniques like Molang and materials to produce color variants of textures, rather than creating, say, 8 color-tinted texture variants of the same texture. Types of Customizations to Avoid You should not add a dimension file to your add-on. Do not override UI files (resource packs/ui) Do not use custom client biome override files (resource) Via .lang files, do not override the words used for vanilla strings Do not override vanilla sounds and music with your own custom sounds and music. Do not use setLore APIs on minecraft:written_book. Ticking Areas  Because the number of available ticking areas are limited, avoid using ticking areas in your design plans when making your add-on.  Also, players or the base world can define their own ticking areas - even in the case that you are the only add-on applied to a world, it still may not be enough available ticking areas on that world.  Namespacing and Identifiers  There are several items in your add-on that need to have names that are unique. Because it is conceivable that you could accidentally conflict with other add-ons, you would need to prevent conflicts with other add-ons (including other those from yourself as a creator – past, present or future.) Below is a detailed recommendation on creating names for these items.  The following items need to have a unique name that no other add-on can ever have. It is recommended that you use a combination of creator name + pack abbreviations to create a unique namespace that you don't use in any other packs.  Namespace  Every item in the add-on needs to have a namespace and that namespace can't be minecraft:.  The namespace needs to be the same for every item in the add-on, including particles.  Every add-on you make needs to have a different namespace from any other namespace used in previous packs. This will ensure that your pack won't have a conflict with add-ons from others creations, as well as any add-on that you may have released.  We recommend that you use your creator name (or abbreviated creator name) followed by an underscore and an abbreviated pack name. For example, for the add-on called Your Creator Name's Super Awesome Add-On Pack, you could use the namespace ycn_saaop:.   Important  Having a conflict in the namespace is the only thing that can't easily be updated post-release, so you really want to get this right! If you have a conflict with another add-on you created, it is likely that you can't update the namespaces as that will cause data loss for all the items that you update to that namespace.  Texture Name  Texture names need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. Texture names can be anything and it is likely that there will be conflicts with other creators because texture names tend to be descriptive -- you could imagine multiple furniture add-ons naming a texture \"table\", and that would conflict based on pack stack order. For most players, pack stack order is not intentfully set so which texture \"wins\" would be random.  All textures should be placed at least 2 folders deep (although additional folders can be used if you want for additional organization.) The first folder should be your creator name and the second folder should be the pack name. The folder structure will look like this.  PowerShell Copy &lt;resource pack name&gt; -> textures -> &lt;creator name&gt; -> &lt;pack name&gt; -> mycustomtexture.png  Texture Reference  Like texture names, texture references need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. When creating texture references, use the pack's \"namespace:\" before the name. This will prevent any conflicts.  Localization (Lang Files)  If you localize your packs via .lang resource files, ensure that you use namespaced names for your .lang string replacement tokens.  Geometry Identifiers  Geometry identifiers also need to be unique to prevent items from using the wrong geo file when multiple add-ons are applied. Geometry identifiers need to start with \"geometry.\". Because of that, we recommend that add \".namespace\" immediately after \"geometry.\". Your geometry identifiers will look like this: geometry.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Tags and Scoreboard Objective names  When using tags or scoreboard objectives within commands, you need to ensure that they are unique so that they don't conflict with other add-ons. When creating tags and Scoreboard objective names, use a namespace before the tag and scoreboard names.  Loot Tables  Loot table names need to be unique, or they can conflict with other loot tables in other add-ons. To prevent this, we suggest that every creator nests their loot tables in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> loot_tables -> &lt;creator name&gt; -> &lt;pack name&gt; -> <loot table name>  Animations  Animation names need to be unique. These are the names that are provided inside the animation file. Animation names need to start with \"animation.\". To prevent creators from using the same animation names, we recommend you add \".namespace\" immediately after \"animation.\" and will look like this animation.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Animation Controllers  Animation controller names need to be unique. These are the names that are provided inside the animation controller file. Animation controller names need to start with \"controller.animation.\". To prevent creators from using the same animation controller names, we recommend you add \".namespace\" immediately after \"controller.animation.\". It will look like this: controller.animation.creatorname_gamename.whatever.else.  Render Controllers  Render controller names need to be unique to prevent the wrong render controller files from being used. Render controller names need to start with \"controller.render.<render_controller_name>\". We recommend you add \".namespace\" immediately after \"controller.render.\". It will look like this: controller.render.creatorname_gamename.whatever.else. Please note this is the name contained within the file.  Structures  Structures for add-ons can be used with the structure command and/or features and feature rules.  When naming your structure, you need to place them in a folder that has the same name as the namespace used for the pack. When loading a structure file, the namespace used in this case is the folder name the structure appears.  Here is an example below:  PowerShell Copy <behavior pack name> -> structures -> <namespace> -> <structure file name>  Feature and Feature Rules  Feature and feature rules file names need to be unique, or they can conflict with other feature and feature rules files in other add-ons. Use the namespace identifier conventions that you use in other files. Be advised that, unfortunately, feature files cannot be located in subfolders without changing how their namespace identifier works in unpredictable ways.  Functions  Function file names need to be unique, or they can conflict with other functions in other add-ons.  To prevent this, we suggest that every creator nests their functions in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> functions -> &lt;creator name&gt; -> &lt;pack name&gt; -> <function file name>.   Using this naming convention also allows creators to use tick.json in their packs without conflicting with other creators.  Sounds  Sounds are located within the Resource pack, and can override other sounds based on their file path and name. To prevent unwanted overrides, we suggest placing your sound files at least 2 folders deep in the sounds folder (although more can be used if desired).  The first folder is your creator name, and the second folder is the pack name. This will cause your folder structure to look like this:  PowerShell Copy &lt;resource pack name&gt; -> sounds -> &lt;creator name&gt; -> &lt;pack name&gt;  Sound Reference  Sound References need to be unique. Sound references are assigned in the sound definition file. All sound references need to start with \"namespace:\" to prevent files from conflicting with each other.  NPC Scenes  NPC scenes need to have unique names to prevent any conflicts with other add-ons. Use the same namespace format that you use throughout the add-on to name the NPC scenes.  Trade Tables  Trade table names need to be unique, or they can conflict with other trade tables in other add-ons. Creators should place their trade tables in a folder named \"trading\". Inside the trading folder we suggest that every creator nests their trade table files two additional folders deep to prevent conflict with other creators' add-ons.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> trading -> &lt;creator name&gt; -> &lt;pack name&gt; -> <trade table file name>.  JSON UI and Custom Fonts overrides are disalllowed  Because JSON UI (i.e., files in <resource pack name>/ui) and fonts (i.e., files in <resource pack name>/font) are not overridable in a cooperative manner - such that multiple add-ons can customize the same asset - cooperative add-ons should not override any JSON UI or font glyph files.  Folder Structures  For folders like textures, functions, loot tables, sounds, and trading we recommend that your folder structure appear like this, textures-> <creator_name> -> <pack_name>.  Where possible, always ensure your textures, functions, loot tables, sounds, and trading folder have a subfolder that is your <creator_name> and only that folder. You should not have \"loose\" files in the <creator_name> folder.  Inside the <creator_name> folder, we recommend that you don't add more than two folders. The first is the recommended <pack_name> folder. The only other folder that should appear in here is one called \"common\". You can use this to help speed up development by placing assets in there that you use commonly across packs.   Note  Use of a common folder inside of <pack_name> folder is a little risky. If you change the asset in any way, you need to update it in every pack that contains it to prevent one of your packs conflicting with another pack.  You should come up with a unique namespace for each pack, and that name should consist of your creator name appended to the pack name and separated by an underscore. Doing this will ensure that your packs will work with all add-ons created and future proof against any add-ons created in the future. This will help prevent a potential negative experience for players.  Using that namespace as suffix to texture names, texture references, geo identifiers, tags and scoreboard objective names also ensures that what you create in your add-on will always appear the way that you intend them to look.  Using Block Placing Methods like Structures, Setblock, Fill, and Clone  Suppose you want to add something to an existing 5 year old world. Your add-on should not arbitrarily destroy (or replace blocks in) areas of the world, especially without explicit user consent - because you could be destroying someone's cherished 5 year old creations!  While placing structures have more of a chance of altering or destroying something that the player cares about, it can still occur when replacing a single block. If that happens, there is no way for the player to recover from this (unless they backed up the world before loading).  If your concept requires a starting area structure, or for large structures to spawn in or be created without player interaction, or without the player knowing what is going to happen, please consider using these ideas in an entire world instead of as a Cooperative Add-On.  Here are some recommendations for using these features:  In existing saved chunks  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  Check to make sure that these blocks are only placed in areas that are empty - meaning the blocks they are replacing are only air.  In unmodified chunks  If these come in without player interaction check to make sure that these blocks are only placed in areas that are fully air.  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  If you are going to replace blocks, try to ensure that blocks that are valuable to players aren't replaced (like ores, archeology blocks, etc.)  Teaching players how to use your Add-On  Teaching players how to use your add-on is vitally important for a great player experience and there should be a single, non-destructive way to do this. This way the players will have the same expectations no matter which add-on they add to the world.  We recommend that all creators spawn a book at the feet of the player on first load that teaches the player how to use the add-on. This needs to be done in a non-destructive way.  There are a few techniques for adding an instructional book:  Adding a book  It's a little clunky, but one way to safely add a book to a players' inventory is to make the book spawn at the player's location.  The mechanism behind this is to create a small (1 block) structure at the player's position that contains only the book and a structure void. Make the structure spawn only once.  Doing this will allow players with a space in their inventory to automatically pick up the book. For those with a full inventory, they would need to choose something to drop to pick it up. Because this is generally the way that all cooperative add-ons work, there will be a player expectation to look for this book. You can also send the player an onscreen message that informs them about the book (so players with a full inventory will look for it), but this isn't required.  If you want to be super-nice, you could provide an empty chest so players can off-load items so they can pick up the book.  Messages in chat  If you choose to have a chat message, please ensure that it is 28 characters or less so that it fits on one line. Stacking multiple add-ons will make it difficult for players to read all the messages. You should also make sure that it only sends the message the first time the player joins the world. Try to avoid excessive messages being broadcast to players.  Custom item that acts like a book  Another alternative is to create a custom item and entity that looks and acts like a book when opened. Please note that if you go this route that the text might not be localize-able since it is part of the textures.  You will also need to handle the opening, closing, and reacquiring of the book yourself and need to do this in a way that won't interfere with other entity books in multiplayer. It will be much easier for players to lose books when using this method. We recommend creating a way to craft your entity books so players can easily craft a replacement if needed. Please keep these things in mind when deciding to use this method.  It is recommended that you make the max item stack size for these types of books 64. This will allow players to place them in bundles. The bundle uses max stack size and a max stack size of 1 will fill the entire bundle with that one item. Nothing extra needs to be done if you are using the structure that spawns a book approach.  Regardless of whether you choose to spawn the guidebook as an entity or a structure containing a signed book, spawning it at the player's location can only happen once per player. Do not spawn a book every time a player joins the world or after the player dies.  Lastly, do not use setLore APIs on your books, as it will be added to all the guidebooks the player has. (it will overwrite the books of other creators that may be stacked in the world as well!)  Summary of Cooperative Add-On Creator Guidelines  Use namespaces and custom folder names to ensure that the identifiers used across your add-on are unique, and cannot accidentally collide with other add-ons.  Do not use certain features, like custom dimension sizes or UI JSON overrides, that don't scale to being cooperatively overridden.  Do not change or remove vanilla behavior; only add new things to the game. Vanilla gameplay changes over time and new gameplay updates rely on existing vanilla blocks, items, mobs, and mechanics, so changing these can affect gameplay. To prevent vanilla gameplay from breaking, you should not change any of the vanilla gameplay files or use scripting to disable vanilla gameplay elements.  In addition to vanilla gameplay, you should not change or update vanilla elements, because we need to ensure that multiple add-ons work together. If we allow you to change a vanilla element, it could interfere with another add-on that relies on the same element. To prevent add-ons from unintentionally disabling another add-on, we only allow new things to be created.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/guidelinesforbuildingcooperativeaddons?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Guidelines for Building Cooperative Add-Ons 12/13/2024  Across the Minecraft platform, there is so much potential to customize how the game looks and acts. You can build your own mobs or override \"vanilla mobs\". Build your own blocks that fit into Minecraft, or change the default textures to something completely different. If you want fewer skeletons spawning in, you can override the skeleton or change its spawn rules. Where possible, we aim for as much customizability as possible!  But if you want to support an environment where players can play Minecraft survival or creative experiences -- and add maybe a dozen different additional enhancements they love -- you're going to want your add-on to be \"cooperative\". A cooperative add-on is designed to play nicely: it doesn't fundamentally change how Minecraft plays, avoids interrupting other Minecraft add-ons or experiences, and doesn't consume so many resources that it doesn't leave anything left for other add-ons to use (considering the wide array of devices Minecraft runs on). A cooperative add-on is also designed to use features and capabilities that will better stand the test of time, version over version.  It turns out there are also a lot of hidden things that could potentially cause \"conflicts\" across add-ons. For example, if two add-ons ship an entity called \"common:boss\", then based on per-world pack stack order, one of them will \"win\" and the other won't be available. Even if one creator ships two separate add-ons with the same mob in it with the same namespace, it can cause versioning issues if the implementation of that entity evolves over time across packs or version and the \"old version\" unexpectedly loads in a new version of a world.  Based on this, we introduce the concept of a \"Cooperative\" Add-On. A Cooperative Add-On is \"just\" a behavior pack+resource pack combo, but its behavior is generally additive and does not fundamentally change the gameplay of other experiences, such as the vanilla gameplay experiences or inadvertently conflict with other add-ons. It also takes precautions to avoid accidental conflicts, and to be more robust over the course of versions.  What follows is a set of guidelines for building these cooperative, additive-only add-ons. In many places, and out of a sense of precaution, you'll want to go to longer lengths to avoid add-ons that have any potential to conflict with other add-ons. Keep in mind that some of these rules are relatively strict; if you're creating an add-on for sharing with your friends, you may not need to adhere to all of these guidelines because the risk of \"add-on conflicts\" is probably much less.  Also, we have a web and command-line based tool available via Minecraft Creator Tools. It has a validation suite called \"Add-On Best Practices\" in the Inspector that looks at your add-on and suggests fixes you can make that will make your add-on more compatible with cooperative guidelines.  As time goes on, this section will evolve to capture more use cases that will change the complexity of add-ons.  Cooperativity  Fundamentally, Cooperative Add-Ons need to be designed to have \"additive\" functionality, rather than functionality that modifies or removes other functionality. For example, functionality that changes how creepers work might not be bad in and of itself, but if two completely separate add-ons are added by a player that happen to change how the creeper works, one will \"win\" (based on pack stack order, which for most players is not set in any particular intentful order). The add-on that \"loses\" (doesn't have its creeper customizations apply) might no longer work completely. We do not want to rely on players configuring their pack stack order precisely in order to have great experiences, so we want to avoid conflicts that come down to pack stack ordering.  Cooperative add-ons need to work with other add-ons. Your cooperative add-ons should work (stacked) with at least one other cooperative add-on, and you should test your add-ons around that. Add-Ons should not disable or remove fundamental vanilla gameplay. It must sit on top of vanilla and should be able to be removed without affecting the gameplay of vanilla and/or any add-on. \"Affecting the gameplay of vanilla\" is a wide and grey area - even introducing a new hostile mob can make achieving the goals of vanilla Minecraft more difficult - but what we mean is that no one add-on should prevent fundamental gameplay styles of Minecraft or make the game substantially harder or easier. You should not be making any changes to any vanilla files to accommodate your add-ons. That includes overriding or removing things that can be embedded in the world, like block types, item types, entity types, etc. For all identifiers across types (such as custom item types or custom block types), you should not use minecraft: as a name and ensure that the namespace is unique to the add-on. \"Overriding\" built-in mobs by including a type that starts with minecraft: to change how they work is not generally stable across versions. Based on this, you should also NOT override minecraft:player. You should only add new elements to the game; these changes should not change vanilla behaviors and/or vanilla item types. Because there can only be one item that can be created per recipe \"shape\" - when creating recipes for the crafting table, furnace, or brewing stand, try to use custom items whenever possible so that the \"recipe input\" is unique and diverse. Add-Ons should not override a player's skin or Character Creator. Versioning  One of the most fundamental requirements for add-ons is that they work across Minecraft versions and into the future as Minecraft evolves.  This is unlike when you create a custom world or world template; with worlds, you can use the base_game_version attribute to lock your world to a particular version of Minecraft, and where possible, that world will be frozen at that version (for example, worlds with a base game version less than 1.18.0 should not have a Pale Garden biome in them). It is important to realize that cooperative add-ons don't have a concept of version locking; they need to keep working even as version numbers advance into the future. And even if you apply these best practices listed below for cross-version compatibility, and while we do try to avoid gratuitous breaking changes in how the Minecraft Bedrock Platform works, in some cases you may need to update your add-ons over time to account for changes in how Minecraft works. Don't build in hard (or soft) dependencies that a particular mob will spawn in a particular quantity at a particular place in the Minecraft world, for example. Be resilient if new mobs are introduced that your add-on doesn't \"understand\" (because they were added in a release in the future and are now working in the world your current-day add-on is working within.)  Cooperative Add-Ons need to work release over release without the need for you to make updates. Worlds with Cooperative Add-Ons need to upgrade the same way as vanilla worlds do (without add-ons applied): ideally, seamlessly and automatically and without any data loss. Keep in mind your add-on needs to keep working in a world that is played over the span of years. Any bug fixes that you make to an add-on should not break existing worlds or remove content from within the packs. Bug fixes should not cause data loss. For example, removing a custom entity type has the impact of removing/hiding all instances of that entity in the world - essentially making them disappear, which is not preferable. Instead, if you wish to upgrade an entity type, continue to support the old entity type for backwards compatibility reasons. You should not use \"runtime_identifier\": when creating new entities because as versions change, a mob's behavior can change significantly, potentially leading to frequent breaks. min_engine_version must be set on both packs of the cooperative add-on. Add-Ons should not use or rely on Experimental features. When making updates, don't change namespaces, as that will cause version-related breaks in the add-on for players. Cooperative Add-On Technical Structure  Cooperative Add-Ons use existing tech and are added to the world by the player from either the Resource Pack or Behavior Pack tabs of the Create New World or Edit World screens. The requirement for each pack having a dependency on the other ensures that players won't get into a state where they have one pack applied to the world without the other.  Cooperative Add-Ons should consist of only one Behavior Pack and one Resource Pack. Both the Behavior Pack and Resource Pack need to contain dependencies on each other so one should not be applied without the other. Cooperative Add-Ons should not have a dependency on packs outside of their own packs.  These restrictions keep the process of adding add-on packs as simple as possible for players.  Manifest Updates  There is an additional field that needs to be added to the manifest of the Resource Pack of your add-on. To ensure that your resource pack can't be applied as a Global Resource Pack, you will need to add \"pack_scope\": \"world\", just after the \"uuid:\".  Here is an example of where that field goes in the resource pack manifest file:  JSON Copy {   \"format_version\": 2,    \"header\": {      \"name\": \"pack.name\",      \"description\": \"pack.description\",      \"uuid\": \"aa943e69-b6b8-955b-d405-29d77cc87283\",      \"pack_scope\": \"world\",      \"version\": [1, 0, 0],      \"min_engine_version\": [1, 21, 50],    },    \"modules\": [      {        \"version\": [1, 0, 0],        \"uuid\": \"bb461250-6de3-49f0-4a94-62c1deeb9b71\",        \"type\": \"data\"      }    ],    \"dependencies\": [      {        \"uuid\": \"aabcb1dc-29ca-4fc4-fa8c-ea1ea2d6788d\",        \"version\": [1, 0, 0]      }    ]  }   Limits for Performance  Many players will add 10+ add-on packs to their worlds, which can cause problems on a variety of devices. For example, some devices cannot scale to having 10 add-ons, each with 4,000 pieces of furniture and their attendant textures. On the other hand, 10 add-ons that each add 5-10 mobs is a bit more scalable. Based on this, we have some (admittedly coarse) guidelines on overall size of your add-ons.  Try not to exceed 25MB uncompressed, or a maximum of 3,500 files. because you need many files to implement basic concepts like a new block type, a 3,500 file limit equates to a rough maximum limit of 1,000 elements in your add-on, whether those elements are blocks, items, entities, or some combination thereof Block permutations should not exceed 10,000 blocks to ensure minimal performance impact across all platforms. Conserve overall texture size. When creating items like books, continue to use lower-resolution textures (<500 x <500). Aim for below 256x256 for blocks and items. Aim for below 2048x2048 for everything else. Prioritize efficient use of space over power-of-2 (e.g., 512x512, 1024x1024) sizing. See Improving Performance and Resource Usage for more tips. Use techniques like Molang and materials to produce color variants of textures, rather than creating, say, 8 color-tinted texture variants of the same texture. Types of Customizations to Avoid You should not add a dimension file to your add-on. Do not override UI files (resource packs/ui) Do not use custom client biome override files (resource) Via .lang files, do not override the words used for vanilla strings Do not override vanilla sounds and music with your own custom sounds and music. Do not use setLore APIs on minecraft:written_book. Ticking Areas  Because the number of available ticking areas are limited, avoid using ticking areas in your design plans when making your add-on.  Also, players or the base world can define their own ticking areas - even in the case that you are the only add-on applied to a world, it still may not be enough available ticking areas on that world.  Namespacing and Identifiers  There are several items in your add-on that need to have names that are unique. Because it is conceivable that you could accidentally conflict with other add-ons, you would need to prevent conflicts with other add-ons (including other those from yourself as a creator – past, present or future.) Below is a detailed recommendation on creating names for these items.  The following items need to have a unique name that no other add-on can ever have. It is recommended that you use a combination of creator name + pack abbreviations to create a unique namespace that you don't use in any other packs.  Namespace  Every item in the add-on needs to have a namespace and that namespace can't be minecraft:.  The namespace needs to be the same for every item in the add-on, including particles.  Every add-on you make needs to have a different namespace from any other namespace used in previous packs. This will ensure that your pack won't have a conflict with add-ons from others creations, as well as any add-on that you may have released.  We recommend that you use your creator name (or abbreviated creator name) followed by an underscore and an abbreviated pack name. For example, for the add-on called Your Creator Name's Super Awesome Add-On Pack, you could use the namespace ycn_saaop:.   Important  Having a conflict in the namespace is the only thing that can't easily be updated post-release, so you really want to get this right! If you have a conflict with another add-on you created, it is likely that you can't update the namespaces as that will cause data loss for all the items that you update to that namespace.  Texture Name  Texture names need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. Texture names can be anything and it is likely that there will be conflicts with other creators because texture names tend to be descriptive -- you could imagine multiple furniture add-ons naming a texture \"table\", and that would conflict based on pack stack order. For most players, pack stack order is not intentfully set so which texture \"wins\" would be random.  All textures should be placed at least 2 folders deep (although additional folders can be used if you want for additional organization.) The first folder should be your creator name and the second folder should be the pack name. The folder structure will look like this.  PowerShell Copy &lt;resource pack name&gt; -> textures -> &lt;creator name&gt; -> &lt;pack name&gt; -> mycustomtexture.png  Texture Reference  Like texture names, texture references need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. When creating texture references, use the pack's \"namespace:\" before the name. This will prevent any conflicts.  Localization (Lang Files)  If you localize your packs via .lang resource files, ensure that you use namespaced names for your .lang string replacement tokens.  Geometry Identifiers  Geometry identifiers also need to be unique to prevent items from using the wrong geo file when multiple add-ons are applied. Geometry identifiers need to start with \"geometry.\". Because of that, we recommend that add \".namespace\" immediately after \"geometry.\". Your geometry identifiers will look like this: geometry.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Tags and Scoreboard Objective names  When using tags or scoreboard objectives within commands, you need to ensure that they are unique so that they don't conflict with other add-ons. When creating tags and Scoreboard objective names, use a namespace before the tag and scoreboard names.  Loot Tables  Loot table names need to be unique, or they can conflict with other loot tables in other add-ons. To prevent this, we suggest that every creator nests their loot tables in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> loot_tables -> &lt;creator name&gt; -> &lt;pack name&gt; -> <loot table name>  Animations  Animation names need to be unique. These are the names that are provided inside the animation file. Animation names need to start with \"animation.\". To prevent creators from using the same animation names, we recommend you add \".namespace\" immediately after \"animation.\" and will look like this animation.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Animation Controllers  Animation controller names need to be unique. These are the names that are provided inside the animation controller file. Animation controller names need to start with \"controller.animation.\". To prevent creators from using the same animation controller names, we recommend you add \".namespace\" immediately after \"controller.animation.\". It will look like this: controller.animation.creatorname_gamename.whatever.else.  Render Controllers  Render controller names need to be unique to prevent the wrong render controller files from being used. Render controller names need to start with \"controller.render.<render_controller_name>\". We recommend you add \".namespace\" immediately after \"controller.render.\". It will look like this: controller.render.creatorname_gamename.whatever.else. Please note this is the name contained within the file.  Structures  Structures for add-ons can be used with the structure command and/or features and feature rules.  When naming your structure, you need to place them in a folder that has the same name as the namespace used for the pack. When loading a structure file, the namespace used in this case is the folder name the structure appears.  Here is an example below:  PowerShell Copy <behavior pack name> -> structures -> <namespace> -> <structure file name>  Feature and Feature Rules  Feature and feature rules file names need to be unique, or they can conflict with other feature and feature rules files in other add-ons. Use the namespace identifier conventions that you use in other files. Be advised that, unfortunately, feature files cannot be located in subfolders without changing how their namespace identifier works in unpredictable ways.  Functions  Function file names need to be unique, or they can conflict with other functions in other add-ons.  To prevent this, we suggest that every creator nests their functions in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> functions -> &lt;creator name&gt; -> &lt;pack name&gt; -> <function file name>.   Using this naming convention also allows creators to use tick.json in their packs without conflicting with other creators.  Sounds  Sounds are located within the Resource pack, and can override other sounds based on their file path and name. To prevent unwanted overrides, we suggest placing your sound files at least 2 folders deep in the sounds folder (although more can be used if desired).  The first folder is your creator name, and the second folder is the pack name. This will cause your folder structure to look like this:  PowerShell Copy &lt;resource pack name&gt; -> sounds -> &lt;creator name&gt; -> &lt;pack name&gt;  Sound Reference  Sound References need to be unique. Sound references are assigned in the sound definition file. All sound references need to start with \"namespace:\" to prevent files from conflicting with each other.  NPC Scenes  NPC scenes need to have unique names to prevent any conflicts with other add-ons. Use the same namespace format that you use throughout the add-on to name the NPC scenes.  Trade Tables  Trade table names need to be unique, or they can conflict with other trade tables in other add-ons. Creators should place their trade tables in a folder named \"trading\". Inside the trading folder we suggest that every creator nests their trade table files two additional folders deep to prevent conflict with other creators' add-ons.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> trading -> &lt;creator name&gt; -> &lt;pack name&gt; -> <trade table file name>.  JSON UI and Custom Fonts overrides are disalllowed  Because JSON UI (i.e., files in <resource pack name>/ui) and fonts (i.e., files in <resource pack name>/font) are not overridable in a cooperative manner - such that multiple add-ons can customize the same asset - cooperative add-ons should not override any JSON UI or font glyph files.  Folder Structures  For folders like textures, functions, loot tables, sounds, and trading we recommend that your folder structure appear like this, textures-> <creator_name> -> <pack_name>.  Where possible, always ensure your textures, functions, loot tables, sounds, and trading folder have a subfolder that is your <creator_name> and only that folder. You should not have \"loose\" files in the <creator_name> folder.  Inside the <creator_name> folder, we recommend that you don't add more than two folders. The first is the recommended <pack_name> folder. The only other folder that should appear in here is one called \"common\". You can use this to help speed up development by placing assets in there that you use commonly across packs.   Note  Use of a common folder inside of <pack_name> folder is a little risky. If you change the asset in any way, you need to update it in every pack that contains it to prevent one of your packs conflicting with another pack.  You should come up with a unique namespace for each pack, and that name should consist of your creator name appended to the pack name and separated by an underscore. Doing this will ensure that your packs will work with all add-ons created and future proof against any add-ons created in the future. This will help prevent a potential negative experience for players.  Using that namespace as suffix to texture names, texture references, geo identifiers, tags and scoreboard objective names also ensures that what you create in your add-on will always appear the way that you intend them to look.  Using Block Placing Methods like Structures, Setblock, Fill, and Clone  Suppose you want to add something to an existing 5 year old world. Your add-on should not arbitrarily destroy (or replace blocks in) areas of the world, especially without explicit user consent - because you could be destroying someone's cherished 5 year old creations!  While placing structures have more of a chance of altering or destroying something that the player cares about, it can still occur when replacing a single block. If that happens, there is no way for the player to recover from this (unless they backed up the world before loading).  If your concept requires a starting area structure, or for large structures to spawn in or be created without player interaction, or without the player knowing what is going to happen, please consider using these ideas in an entire world instead of as a Cooperative Add-On.  Here are some recommendations for using these features:  In existing saved chunks  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  Check to make sure that these blocks are only placed in areas that are empty - meaning the blocks they are replacing are only air.  In unmodified chunks  If these come in without player interaction check to make sure that these blocks are only placed in areas that are fully air.  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  If you are going to replace blocks, try to ensure that blocks that are valuable to players aren't replaced (like ores, archeology blocks, etc.)  Teaching players how to use your Add-On  Teaching players how to use your add-on is vitally important for a great player experience and there should be a single, non-destructive way to do this. This way the players will have the same expectations no matter which add-on they add to the world.  We recommend that all creators spawn a book at the feet of the player on first load that teaches the player how to use the add-on. This needs to be done in a non-destructive way.  There are a few techniques for adding an instructional book:  Adding a book  It's a little clunky, but one way to safely add a book to a players' inventory is to make the book spawn at the player's location.  The mechanism behind this is to create a small (1 block) structure at the player's position that contains only the book and a structure void. Make the structure spawn only once.  Doing this will allow players with a space in their inventory to automatically pick up the book. For those with a full inventory, they would need to choose something to drop to pick it up. Because this is generally the way that all cooperative add-ons work, there will be a player expectation to look for this book. You can also send the player an onscreen message that informs them about the book (so players with a full inventory will look for it), but this isn't required.  If you want to be super-nice, you could provide an empty chest so players can off-load items so they can pick up the book.  Messages in chat  If you choose to have a chat message, please ensure that it is 28 characters or less so that it fits on one line. Stacking multiple add-ons will make it difficult for players to read all the messages. You should also make sure that it only sends the message the first time the player joins the world. Try to avoid excessive messages being broadcast to players.  Custom item that acts like a book  Another alternative is to create a custom item and entity that looks and acts like a book when opened. Please note that if you go this route that the text might not be localize-able since it is part of the textures.  You will also need to handle the opening, closing, and reacquiring of the book yourself and need to do this in a way that won't interfere with other entity books in multiplayer. It will be much easier for players to lose books when using this method. We recommend creating a way to craft your entity books so players can easily craft a replacement if needed. Please keep these things in mind when deciding to use this method.  It is recommended that you make the max item stack size for these types of books 64. This will allow players to place them in bundles. The bundle uses max stack size and a max stack size of 1 will fill the entire bundle with that one item. Nothing extra needs to be done if you are using the structure that spawns a book approach.  Regardless of whether you choose to spawn the guidebook as an entity or a structure containing a signed book, spawning it at the player's location can only happen once per player. Do not spawn a book every time a player joins the world or after the player dies.  Lastly, do not use setLore APIs on your books, as it will be added to all the guidebooks the player has. (it will overwrite the books of other creators that may be stacked in the world as well!)  Summary of Cooperative Add-On Creator Guidelines  Use namespaces and custom folder names to ensure that the identifiers used across your add-on are unique, and cannot accidentally collide with other add-ons.  Do not use certain features, like custom dimension sizes or UI JSON overrides, that don't scale to being cooperatively overridden.  Do not change or remove vanilla behavior; only add new things to the game. Vanilla gameplay changes over time and new gameplay updates rely on existing vanilla blocks, items, mobs, and mechanics, so changing these can affect gameplay. To prevent vanilla gameplay from breaking, you should not change any of the vanilla gameplay files or use scripting to disable vanilla gameplay elements.  In addition to vanilla gameplay, you should not change or update vanilla elements, because we need to ensure that multiple add-ons work together. If we allow you to change a vanilla element, it could interfere with another add-on that relies on the same element. To prevent add-ons from unintentionally disabling another add-on, we only allow new things to be created.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/latestplatformversion?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Latest Platform Version Guidance 09/05/2024  When delivering your add-ons and worlds to players, you'll want to ensure that it is built on \"up to date\" versions of the Minecraft Bedrock platform. What do we mean by up to date? Unfortunately, versions are a little complicated in Minecraft; this article attempts to document the latest versions of content across sources.  In addition, we also have (preview) tooling available at https://mctools.dev that can scan your content and tell you if it is conformant to \"up to date version\". When you open a zip or MCAddon of your content, under the Inspector option, select the \"Current Platform Versions\" suite, and it should show relevant versions and if any files are considered \"out of date\".  Content should be within N or N-1 of the latest Minecraft version  Brand-new content should be built built on platform elements related to the last current released retail version, and the major released version before that. To define this in more concrete terms, we will consider N and N-1 \"minor\" versions of Minecraft as \"up to date\". For example, at the time of this writing, 1.21.20 is the major retail version in players' hands; so therefore, 1.21.* and 1.20.* would be considered up to date versions of content. Of course, as a creator you should generally try to target the latest major.minor.patch release (e.g., 1.21.20) where you can help it.  Versions across Minecraft  Minecraft Bedrock Edition uses several different \"versioning\" systems and histories in different places within the platform. In many cases – say, block type definitions – the latest format version of the file matches the version of the product (at the time of this writing, that is 1.21.20). In other places, the de-facto \"most modern version\" comes from a previous version of the game (e.g., animations should be at version 1.10.0). Still in other places – e.g., scripting -- the versioning scheme differs altogether. For these reasons, in places the \"N-1\" rule may not literally mean the version has to match the game version. In this rest of this article, we will list the exceptions and nuances of versioning in major portions of the platform.  The major versions to consider include:  Base game version Min engine version Command version Per-file-type format versions Script module version Base Game Version  Base game version is a world template-only concept and located in manifest.json of a world template file. base_game_version is compliant with the N-1 minor version idea.  Example non-conformant content:  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 7],     \"lock_template_options\": true,     \"base_game_version\": [1, 16, 0],     \"uuid\": \"cb599a1d-0fc2-4263-a06d-3e294fd5ffc4\"   },   \"modules\": [{     \"version\": [1, 0, 7],     \"type\": \"world_template\",     \"uuid\": \"6eb7c7a6-7db3-496d-8155-edd8a5003116\"   }],   \"format_version\": 2 }   As you upgrade content to newer base game versions, you will need to validate your world works as expected – for example, that the introduction of 1.19 or 1.20-era mobs doesn't suddenly cause game play bugs in various forms (e.g., a glow squid suddenly inside of your dungeon pond).  Manifest File Format Version  Within manifest.json files, manifest.json in behavior packs/resource packs should have a format version of \"2\".  Behavior Pack/Resource Pack Manifest File min_engine_version  Behavior pack/resource pack files have min_engine_version that is within the the N-1 rule. min_engine_version influences a wide array of things, including the version of commands as run within MCFunctions, tick.json, and behavior animations/behavior animation controllers.  Command versions in Level DB and in structures  As part of using command blocks, an inherent command version gets associated with that command block. Commands as used inside of command blocks should be upgraded to a command version consistent with the N-1 rule. For version 1.21.0, this is command version 33.  Format_version  Format version is declared in many major JSON files in Minecraft packs. Depending on the type of file, we will validate version is at least the minimum version specified. If the value is \"N-1\", we will validate against versions based on the \"N-1\" rule logic above.  It is expected that this table will update over time, so stay tuned.  Behavior Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Block Types\tblocks folder\tN-1 Entity Types\tentities folder\t(exempt - entity type versioning is highly variable) Item Types\titems folder\tN-1 Loot Tables\tloot_tables folder\t(no versioning concept) Recipes\trecipes folder\tN-1 Spawn Rules\tspawn_rules folder\tN-1 Trading Tables\tTrading folder\t(no versioning concept) Resource Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Attachables (Item type rendering descriptions)\tattachables folder\t1.10.0 Client Biome definitions\tbiomes_client.json\t(no versioning concept) Block rendering definitions\tblocks.json\t(no versioning concept) Entity type render descriptions\tentity folder\tN-1 Fogs\tfogs folder\tN-1 Models\tmodels folder\t1.12.0 Render Controllers\trender_controllers folder\t1.10.0 Sound/Music definitions\tsounds folder\tN-1 Texture definitions\ttextures/*_texture.json\t(no versioning concept) JSON UI\tui folder\t(no versioning concept) Script Module Versions  Every script module has its minor version incremented if new capabilities are introduced, version over version. Its major version (e.g., going from 1.x to 2.y) is incremented if there are known backwards compatibility impacting bugs that are fixed or changed.  Most Minecraft content that uses scripting uses the @minecraft/server module. Its \"script module version\" to \"major version\" mapping is described in the Script Versioning article. To adhere to the \"N-1 rule\", and assuming the current major version is 1.21.20, we would ensure that Minecraft content in a behavior pack expresses a dependency on at least \"1.2.0\" of @minecraft/server (the version of the @minecraft/script contemporary of 1.20.0), if it uses scripting.  Upgrading a dependency within a scripting minor version should generally be safe. Because the difference between version 1.2.0 and, say, 1.9.0, should only be additive and not-backwards-compatible impacting, updating script module version dependencies with minor versions should not impact how that code works.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/latestplatformversion?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Latest Platform Version Guidance 09/05/2024  When delivering your add-ons and worlds to players, you'll want to ensure that it is built on \"up to date\" versions of the Minecraft Bedrock platform. What do we mean by up to date? Unfortunately, versions are a little complicated in Minecraft; this article attempts to document the latest versions of content across sources.  In addition, we also have (preview) tooling available at https://mctools.dev that can scan your content and tell you if it is conformant to \"up to date version\". When you open a zip or MCAddon of your content, under the Inspector option, select the \"Current Platform Versions\" suite, and it should show relevant versions and if any files are considered \"out of date\".  Content should be within N or N-1 of the latest Minecraft version  Brand-new content should be built built on platform elements related to the last current released retail version, and the major released version before that. To define this in more concrete terms, we will consider N and N-1 \"minor\" versions of Minecraft as \"up to date\". For example, at the time of this writing, 1.21.20 is the major retail version in players' hands; so therefore, 1.21.* and 1.20.* would be considered up to date versions of content. Of course, as a creator you should generally try to target the latest major.minor.patch release (e.g., 1.21.20) where you can help it.  Versions across Minecraft  Minecraft Bedrock Edition uses several different \"versioning\" systems and histories in different places within the platform. In many cases – say, block type definitions – the latest format version of the file matches the version of the product (at the time of this writing, that is 1.21.20). In other places, the de-facto \"most modern version\" comes from a previous version of the game (e.g., animations should be at version 1.10.0). Still in other places – e.g., scripting -- the versioning scheme differs altogether. For these reasons, in places the \"N-1\" rule may not literally mean the version has to match the game version. In this rest of this article, we will list the exceptions and nuances of versioning in major portions of the platform.  The major versions to consider include:  Base game version Min engine version Command version Per-file-type format versions Script module version Base Game Version  Base game version is a world template-only concept and located in manifest.json of a world template file. base_game_version is compliant with the N-1 minor version idea.  Example non-conformant content:  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 7],     \"lock_template_options\": true,     \"base_game_version\": [1, 16, 0],     \"uuid\": \"cb599a1d-0fc2-4263-a06d-3e294fd5ffc4\"   },   \"modules\": [{     \"version\": [1, 0, 7],     \"type\": \"world_template\",     \"uuid\": \"6eb7c7a6-7db3-496d-8155-edd8a5003116\"   }],   \"format_version\": 2 }   As you upgrade content to newer base game versions, you will need to validate your world works as expected – for example, that the introduction of 1.19 or 1.20-era mobs doesn't suddenly cause game play bugs in various forms (e.g., a glow squid suddenly inside of your dungeon pond).  Manifest File Format Version  Within manifest.json files, manifest.json in behavior packs/resource packs should have a format version of \"2\".  Behavior Pack/Resource Pack Manifest File min_engine_version  Behavior pack/resource pack files have min_engine_version that is within the the N-1 rule. min_engine_version influences a wide array of things, including the version of commands as run within MCFunctions, tick.json, and behavior animations/behavior animation controllers.  Command versions in Level DB and in structures  As part of using command blocks, an inherent command version gets associated with that command block. Commands as used inside of command blocks should be upgraded to a command version consistent with the N-1 rule. For version 1.21.0, this is command version 33.  Format_version  Format version is declared in many major JSON files in Minecraft packs. Depending on the type of file, we will validate version is at least the minimum version specified. If the value is \"N-1\", we will validate against versions based on the \"N-1\" rule logic above.  It is expected that this table will update over time, so stay tuned.  Behavior Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Block Types\tblocks folder\tN-1 Entity Types\tentities folder\t(exempt - entity type versioning is highly variable) Item Types\titems folder\tN-1 Loot Tables\tloot_tables folder\t(no versioning concept) Recipes\trecipes folder\tN-1 Spawn Rules\tspawn_rules folder\tN-1 Trading Tables\tTrading folder\t(no versioning concept) Resource Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Attachables (Item type rendering descriptions)\tattachables folder\t1.10.0 Client Biome definitions\tbiomes_client.json\t(no versioning concept) Block rendering definitions\tblocks.json\t(no versioning concept) Entity type render descriptions\tentity folder\tN-1 Fogs\tfogs folder\tN-1 Models\tmodels folder\t1.12.0 Render Controllers\trender_controllers folder\t1.10.0 Sound/Music definitions\tsounds folder\tN-1 Texture definitions\ttextures/*_texture.json\t(no versioning concept) JSON UI\tui folder\t(no versioning concept) Script Module Versions  Every script module has its minor version incremented if new capabilities are introduced, version over version. Its major version (e.g., going from 1.x to 2.y) is incremented if there are known backwards compatibility impacting bugs that are fixed or changed.  Most Minecraft content that uses scripting uses the @minecraft/server module. Its \"script module version\" to \"major version\" mapping is described in the Script Versioning article. To adhere to the \"N-1 rule\", and assuming the current major version is 1.21.20, we would ensure that Minecraft content in a behavior pack expresses a dependency on at least \"1.2.0\" of @minecraft/server (the version of the @minecraft/script contemporary of 1.20.0), if it uses scripting.  Upgrading a dependency within a scripting minor version should generally be safe. Because the difference between version 1.2.0 and, say, 1.9.0, should only be additive and not-backwards-compatible impacting, updating script module version dependencies with minor versions should not impact how that code works.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/improvingperformanceandresourceusage?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Improving performance and resource usage 01/31/2025  Add-Ons that can extend your vanilla playing experience have always been a popular part of the Minecraft experience - and if anything, they're growing even more in popularity! It's increasingly common for someone to have a Minecraft world with a furniture add-on, a few different add-ons with new families of mobs, some custom pets, and maybe a custom gameplay extension or two. And then you add some additional utilities, like a custom back pack or a piece of equipment. And of course, every Minecraft experience loads every vanilla texture, and there is a lot of those too. Its not uncommon for players to maybe add 8 or more add-ons to their world. And they do this across a range of devices; from the latest consoles to high spec workstations, to their older phones from 5 years ago or a very basic integrated PC.  But as players add more add-ons additively to their world, there may come a point where their device runs out of resources, and bad behaviors could result (textures may grow fuzzy or fail to load; performance may slow down; there may even be crashes if you add enough add-ons). The best solution for this is for individual add-ons to attempt to be a thrifty in their resource usage and performance. But even if it's most important for add-ons to be thrifty, these techniques also apply to any custom world experiences or texture packs you may be building - better performance is almost always noticeable and appreciated by players.  Model Complexity Custom Block Geometry  Be mindful of how blocks with complex geometry are used within your pack. Blocks that appear repeatedly throughout your world, or are expected to be placed repeatedly by players, can quickly consume large amounts of memory. We recommend targeting no more than 50 cubes per block model, but depending on the usage this may need to be even lower. Use your best judgment in determining how a given block will be utilized within your pack.  Texture size  Typically, we see overall texture size as one of the first things that can fail on devices. Generally, all textures - including for the user interface of Minecraft, are loaded when a world is first loaded. Everything you see in the game has a texture applied to it. And textures, being two-dimensional and all, can occupy a lot of memory quickly if the collective texture dimensions grow in size; the difference between a 256 x 256 texture (65536 bytes) and a 1024 x 1024 texture (1,048,576 bytes) is a factor of 16x (983,040 additional bytes), and when multiplied by 100 different entities or skin variants, can add up to some serious memory usages.  Avoid wasted space  A key issue is that textures are loaded uncompressed into memory. Even if you have a largely-empty 1024 x 1024 texture that compresses to something small as a PNG file on your disk -- at least as far as Minecraft loads it, it occupies the same texture size in memory as any other 1024 x 1024 texture - that is, 1,048,576 bytes of memory. This brings us to our first recommendation: as you build textures, try to avoid wasted space and texture \"real-estate\". Previously, we recommended that textures have a sizing that is square and a power of 2 (e.g., 256x256, 512x512, 1024x1024), but we no longer recommend that if your texture is not close to a power of 2 dimension. For example, if you can cleave off empty space and go with a 1024 x 512 image (or even 632 x 486, to mention a random size) - then we would recommend that.  Consider texture atlasing  For content that has many small, frequently used textures, it is often more efficient to store the textures in a single, larger texture (often referred to as Atlasing). In addition to making better use of space (less empty space) - this also can improve the disk input/output speed as the world is loading.  Minecraft will automatically assemble non-entity textures into an atlas. But for entity textures, you can create your own texture atlas.  Step 1. Create the combined texture atlas  Here is an example of the initial 2 textures:  Initial mob texture:  Second mob texture:  We then combined them into a single \"atlas texture\" taking note of the coordinates where the initial texture ends up.  Step 2. Create a custom material  In order for the texture to be appropriately indexed during rendering USE_UV_ANIM within a .material file will need to be enabled.  This is done by deriving from the desired material and enabling the define:  JSON Copy \"my_uv_offset:entity_alphatest\": {     \"+defines\": [\"USE_UV_ANIM\"] }  Step 3. Render Controller  To make use of the new material, it requires the render controller to have the uv_anim field to be set. These need to be the correct offset and scale the original texture relative to the final atlas texture.  To avoid defining many render controllers we are using a client entity variable:  JSON Copy \"controller.render.uv_offset\": {     \"geometry\": \"Geometry.default\",     \"materials\": [{ \"*\": \"Material.default\" }],     \"textures\": [\"Texture.default\"],     \"uv_anim\" : {         \"offset\" : [\"variable.offset_x\", \"variable.offset_y\"],         \"scale\" : [\"variable.scale_x\", \"variable.scale_y\"]     } }  Step 4. Update the client entity to set the offset and scale coordinates  The client entity will need to reference the new atlas texture, the new material, and finally define the Molang variables in the client entity will allow the render controller to use the appropriate values.  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"design:sample_addon_atlas_1\",             \"materials\": { \"default\": \"uv_offset\" }, // UV material             \"textures\": {                 \"default\": \"textures/entity/sample_addon_atlas\" // new atlas texture             },             \"scripts\": {                 \"pre_animation\": [                     \"variable.offset_x = 0.0 / 1.0;\", // (horizonal index) / (num textures horizontal)                     \"variable.offset_y = 0.0 / 2.0;\", // (vertical index) / (num textures vertical)                     \"variable.scale_x = 1.0 / 1.0;\", // 1.0 / (num textures horizontal)                     \"variable.scale_y = 1.0 / 2.0;\" // 1.0 / (num textures vertical)                 ],             },             \"render_controllers\": [\"controller.render.uv_offset\"],             \"geometry\": {                 \"default\": \"geometry.sample_addon\"             },             \"spawn_egg\": {                 \"base_color\": \"#CC55FF\",                 \"overlay_color\": \"#2926FF\"             }         }     } }         This simple example above assumes all textures are the same size. This doesn't have to be the case; however, it does make the calculation for the offset + scale more complicated.  Size recommendations  The maximum size of these non-entity auto-generated atlases is based on platform requirements and may be scaled down to ensure consistent player experience. For best results across all platforms, we recommend a maximum size of 256x256 for non-entity textures (e.g., a block texture) and 2048x2048 for flipbook textures.  In this case, Minecraft may scale the entire atlas to ensure a consistent player experience. For best results across all platforms, we recommend manually created atlases do not exceed 2048x2048.  Consider subpacks  Minecraft texture loading also has a feature where you can use subpacks and sub-textures to load differently-sized textures depending on the performance characteristics of the device they are loaded on. For example, you can utilize good-looking medium-resolution textures on a low-end mobile device, but \"HD\" textures on a higher-end gaming PC. See the article on Utilizing Subpacks for more information on how to get started.  Special note: Books  Many add-ons and worlds frequently include basic elements of user interface or instructional content - for example, a visual book that you can hold in your hand, complete with animated pages that can flip. When a user looks at the book, it's essentially an entity that looks like a book, complete with individual pages that are the \"body\" of the entity.  From a texture perspective, every page then frequently becomes its own texture, and there is a desire to perhaps increase the size of pages to ensure text readability. However, this can be problematic if each page is its own 1024x1024 or greater texture. We've found that individual pages with a texture size of 350x250 pixels work just great to create readable pages in an entity-based help book.  Or, just try not to go wild with variants  A very common visual flourish can be to have texture variants for different states of a mob - for example, the cat has a wholly separate texture \"just\" to implement a collar for cats when they are tamed. This essentially occupies twice the amount of space in memory from a texture size perspective. While of course no one would deny the importance of collars for tamed cats 😺, do try to conserve the number of variants like this that you consider for your mobs.  Texture Handles  In addition to overall texture size, you should consider the number of textures that are also loaded into Minecraft. Texture handles correspond to the number of unique texture files that Minecraft has loaded into GPU memory - but there are exceptions for some textures like block textures that get compiled into a broader atlas'ed texture. Each texture handle has memory overhead, and Minecraft has a limit of 4,000 texture handles. Exceeding this limit can result in \"pink textures\" and instability.  You can use tools like Minecraft Creator Tools and its Inspector view to get an approximation of the number of texture handles your pack uses.  For World Templates, we recommend staying under 2,000 texture handles. For Add-ons, we recommend staying under 800 texture handles. Pack Size & File Counts  We've seen packs larger than 200MB (uncompressed) running low on memory on some devices. Staying under 200MB is recommended but less than 100MB (uncompressed) is safest.  Every file has overhead, so having too many files can also impact performance. We've seen packs with thousands of mcfunction files have difficulty on some platforms. We've seen packs with over 10,000 files running out of memory of some devices.  It's highly recommended to stay under 10,000 files, but a top-end range of 5,000-7,000 is safer. File counts also have an impact on loading times.  Pack size and file count impact can vary significantly so the above are just guidelines.  For Add-Ons, we recommend a max pack size of 25MB (uncompressed) and a maximum of 2,500 files.  Entities  Keep an eye on entity count, complexity and density.  When you have a lot of entities in one place, the slowdown on the server side is going to be due to path finding logic (or AI in general). On the client it is rendering.  Limit the number of entities in loaded chunks, especially those that cannot be seen. This includes the entire vertical space of the chunk.  Level designs with many entities arrayed in a small vertical space can lead to executing entity behaviors throughout that space, even when entities are too far away to be seen, or hidden behind blocks.  Limit the number of entities that need to do path-finding within close range of each other.  Limit the length of time entity scripts run for. Long scripts or large numbers of entities in a chunk will degrade FPS.  Avoid using entities to implement complex block behaviors. Use custom blocks instead.  Sound  Consider limiting the length, size and number of sounds playing at once -- especially things that can be triggered in quick succession by minimal player input (for example, playing voice dialogues).  Limit sound file counts and sizes. Compressing the files does not help; the cost is the total in-memory size.  Many entities can emit sounds - playing sounds for many entities can get very costly.  Sounds get cached in memory, and cache management involves some locks. Playing many sounds can cause lock contention problems that show up as freezes or drops in FPS on some platforms.  Sound files also have a memory/lookup cost. The number of sound files increases lookup cost finding the sound to play. The size of sound files increases memory pressure and can result in thrashing/disk reads if the files don't all fit in the cache at once.  Particles  Make sure there aren't too many particles simulating at once and that their complexity isn't too large.  Commands & Scripts  Try to avoid running commands and script functionality on every tick. It is especially important to not run dozens of commands or lots of script on every tick.  If you need to run commands often, consider putting them on an interval, so they run every 5 or 20 or 100 ticks instead. Also, if you are running commands and script on these intervals, offset the intervals so your commands or script run on different ticks.  Try not to use long running commands or script operations often (e.g. a big block /fill or /clone). If possible, split this into more than one command that runs at different ticks.  More General Suggestions  Consider creating your own in-game performance toggles with varying levels of fidelity and features.  With newer script APIs for getting at the rough outlines of a player's client system e.g., player.clientSystemInfo, you can key time-intensive behaviors (e.g., spawning particles) based on the rough outlines of performance (e.g., the more render distance a player has, assumedly the more performant their device is.) You will want to carefully ensure that the fundamental gameplay experience doesn't change depending on the performance profile of the player's device, however - for example, you don't want that fewer monsters spawn in a given area if the client device information is on the lower end.  Prepare for low end devices by testing on these devices as early as possible in your development process. You don't know how it's going to perform until you test.  Summary  In sum, the foremost consumer of resources in a particular world or add-on is usually these set of textures that are included inside of its resource packs. Through the minimization of the number or dimensions of the size of textures, you can help to conserve previous space on a player's device, allowing them to load more diverse add-ons and experiences into their worlds. Across entities, script, and commands, there are also a number of ways to improve overall performance by more tightly managing when expensive operations occur. Thanks for helping to conserve texture memory and build performant experiences for Minecraft!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/improvingperformanceandresourceusage?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Improving performance and resource usage 01/31/2025  Add-Ons that can extend your vanilla playing experience have always been a popular part of the Minecraft experience - and if anything, they're growing even more in popularity! It's increasingly common for someone to have a Minecraft world with a furniture add-on, a few different add-ons with new families of mobs, some custom pets, and maybe a custom gameplay extension or two. And then you add some additional utilities, like a custom back pack or a piece of equipment. And of course, every Minecraft experience loads every vanilla texture, and there is a lot of those too. Its not uncommon for players to maybe add 8 or more add-ons to their world. And they do this across a range of devices; from the latest consoles to high spec workstations, to their older phones from 5 years ago or a very basic integrated PC.  But as players add more add-ons additively to their world, there may come a point where their device runs out of resources, and bad behaviors could result (textures may grow fuzzy or fail to load; performance may slow down; there may even be crashes if you add enough add-ons). The best solution for this is for individual add-ons to attempt to be a thrifty in their resource usage and performance. But even if it's most important for add-ons to be thrifty, these techniques also apply to any custom world experiences or texture packs you may be building - better performance is almost always noticeable and appreciated by players.  Model Complexity Custom Block Geometry  Be mindful of how blocks with complex geometry are used within your pack. Blocks that appear repeatedly throughout your world, or are expected to be placed repeatedly by players, can quickly consume large amounts of memory. We recommend targeting no more than 50 cubes per block model, but depending on the usage this may need to be even lower. Use your best judgment in determining how a given block will be utilized within your pack.  Texture size  Typically, we see overall texture size as one of the first things that can fail on devices. Generally, all textures - including for the user interface of Minecraft, are loaded when a world is first loaded. Everything you see in the game has a texture applied to it. And textures, being two-dimensional and all, can occupy a lot of memory quickly if the collective texture dimensions grow in size; the difference between a 256 x 256 texture (65536 bytes) and a 1024 x 1024 texture (1,048,576 bytes) is a factor of 16x (983,040 additional bytes), and when multiplied by 100 different entities or skin variants, can add up to some serious memory usages.  Avoid wasted space  A key issue is that textures are loaded uncompressed into memory. Even if you have a largely-empty 1024 x 1024 texture that compresses to something small as a PNG file on your disk -- at least as far as Minecraft loads it, it occupies the same texture size in memory as any other 1024 x 1024 texture - that is, 1,048,576 bytes of memory. This brings us to our first recommendation: as you build textures, try to avoid wasted space and texture \"real-estate\". Previously, we recommended that textures have a sizing that is square and a power of 2 (e.g., 256x256, 512x512, 1024x1024), but we no longer recommend that if your texture is not close to a power of 2 dimension. For example, if you can cleave off empty space and go with a 1024 x 512 image (or even 632 x 486, to mention a random size) - then we would recommend that.  Consider texture atlasing  For content that has many small, frequently used textures, it is often more efficient to store the textures in a single, larger texture (often referred to as Atlasing). In addition to making better use of space (less empty space) - this also can improve the disk input/output speed as the world is loading.  Minecraft will automatically assemble non-entity textures into an atlas. But for entity textures, you can create your own texture atlas.  Step 1. Create the combined texture atlas  Here is an example of the initial 2 textures:  Initial mob texture:  Second mob texture:  We then combined them into a single \"atlas texture\" taking note of the coordinates where the initial texture ends up.  Step 2. Create a custom material  In order for the texture to be appropriately indexed during rendering USE_UV_ANIM within a .material file will need to be enabled.  This is done by deriving from the desired material and enabling the define:  JSON Copy \"my_uv_offset:entity_alphatest\": {     \"+defines\": [\"USE_UV_ANIM\"] }  Step 3. Render Controller  To make use of the new material, it requires the render controller to have the uv_anim field to be set. These need to be the correct offset and scale the original texture relative to the final atlas texture.  To avoid defining many render controllers we are using a client entity variable:  JSON Copy \"controller.render.uv_offset\": {     \"geometry\": \"Geometry.default\",     \"materials\": [{ \"*\": \"Material.default\" }],     \"textures\": [\"Texture.default\"],     \"uv_anim\" : {         \"offset\" : [\"variable.offset_x\", \"variable.offset_y\"],         \"scale\" : [\"variable.scale_x\", \"variable.scale_y\"]     } }  Step 4. Update the client entity to set the offset and scale coordinates  The client entity will need to reference the new atlas texture, the new material, and finally define the Molang variables in the client entity will allow the render controller to use the appropriate values.  JSON Copy {     \"format_version\": \"1.10.0\",     \"minecraft:client_entity\": {         \"description\": {             \"identifier\": \"design:sample_addon_atlas_1\",             \"materials\": { \"default\": \"uv_offset\" }, // UV material             \"textures\": {                 \"default\": \"textures/entity/sample_addon_atlas\" // new atlas texture             },             \"scripts\": {                 \"pre_animation\": [                     \"variable.offset_x = 0.0 / 1.0;\", // (horizonal index) / (num textures horizontal)                     \"variable.offset_y = 0.0 / 2.0;\", // (vertical index) / (num textures vertical)                     \"variable.scale_x = 1.0 / 1.0;\", // 1.0 / (num textures horizontal)                     \"variable.scale_y = 1.0 / 2.0;\" // 1.0 / (num textures vertical)                 ],             },             \"render_controllers\": [\"controller.render.uv_offset\"],             \"geometry\": {                 \"default\": \"geometry.sample_addon\"             },             \"spawn_egg\": {                 \"base_color\": \"#CC55FF\",                 \"overlay_color\": \"#2926FF\"             }         }     } }         This simple example above assumes all textures are the same size. This doesn't have to be the case; however, it does make the calculation for the offset + scale more complicated.  Size recommendations  The maximum size of these non-entity auto-generated atlases is based on platform requirements and may be scaled down to ensure consistent player experience. For best results across all platforms, we recommend a maximum size of 256x256 for non-entity textures (e.g., a block texture) and 2048x2048 for flipbook textures.  In this case, Minecraft may scale the entire atlas to ensure a consistent player experience. For best results across all platforms, we recommend manually created atlases do not exceed 2048x2048.  Consider subpacks  Minecraft texture loading also has a feature where you can use subpacks and sub-textures to load differently-sized textures depending on the performance characteristics of the device they are loaded on. For example, you can utilize good-looking medium-resolution textures on a low-end mobile device, but \"HD\" textures on a higher-end gaming PC. See the article on Utilizing Subpacks for more information on how to get started.  Special note: Books  Many add-ons and worlds frequently include basic elements of user interface or instructional content - for example, a visual book that you can hold in your hand, complete with animated pages that can flip. When a user looks at the book, it's essentially an entity that looks like a book, complete with individual pages that are the \"body\" of the entity.  From a texture perspective, every page then frequently becomes its own texture, and there is a desire to perhaps increase the size of pages to ensure text readability. However, this can be problematic if each page is its own 1024x1024 or greater texture. We've found that individual pages with a texture size of 350x250 pixels work just great to create readable pages in an entity-based help book.  Or, just try not to go wild with variants  A very common visual flourish can be to have texture variants for different states of a mob - for example, the cat has a wholly separate texture \"just\" to implement a collar for cats when they are tamed. This essentially occupies twice the amount of space in memory from a texture size perspective. While of course no one would deny the importance of collars for tamed cats 😺, do try to conserve the number of variants like this that you consider for your mobs.  Texture Handles  In addition to overall texture size, you should consider the number of textures that are also loaded into Minecraft. Texture handles correspond to the number of unique texture files that Minecraft has loaded into GPU memory - but there are exceptions for some textures like block textures that get compiled into a broader atlas'ed texture. Each texture handle has memory overhead, and Minecraft has a limit of 4,000 texture handles. Exceeding this limit can result in \"pink textures\" and instability.  You can use tools like Minecraft Creator Tools and its Inspector view to get an approximation of the number of texture handles your pack uses.  For World Templates, we recommend staying under 2,000 texture handles. For Add-ons, we recommend staying under 800 texture handles. Pack Size & File Counts  We've seen packs larger than 200MB (uncompressed) running low on memory on some devices. Staying under 200MB is recommended but less than 100MB (uncompressed) is safest.  Every file has overhead, so having too many files can also impact performance. We've seen packs with thousands of mcfunction files have difficulty on some platforms. We've seen packs with over 10,000 files running out of memory of some devices.  It's highly recommended to stay under 10,000 files, but a top-end range of 5,000-7,000 is safer. File counts also have an impact on loading times.  Pack size and file count impact can vary significantly so the above are just guidelines.  For Add-Ons, we recommend a max pack size of 25MB (uncompressed) and a maximum of 2,500 files.  Entities  Keep an eye on entity count, complexity and density.  When you have a lot of entities in one place, the slowdown on the server side is going to be due to path finding logic (or AI in general). On the client it is rendering.  Limit the number of entities in loaded chunks, especially those that cannot be seen. This includes the entire vertical space of the chunk.  Level designs with many entities arrayed in a small vertical space can lead to executing entity behaviors throughout that space, even when entities are too far away to be seen, or hidden behind blocks.  Limit the number of entities that need to do path-finding within close range of each other.  Limit the length of time entity scripts run for. Long scripts or large numbers of entities in a chunk will degrade FPS.  Avoid using entities to implement complex block behaviors. Use custom blocks instead.  Sound  Consider limiting the length, size and number of sounds playing at once -- especially things that can be triggered in quick succession by minimal player input (for example, playing voice dialogues).  Limit sound file counts and sizes. Compressing the files does not help; the cost is the total in-memory size.  Many entities can emit sounds - playing sounds for many entities can get very costly.  Sounds get cached in memory, and cache management involves some locks. Playing many sounds can cause lock contention problems that show up as freezes or drops in FPS on some platforms.  Sound files also have a memory/lookup cost. The number of sound files increases lookup cost finding the sound to play. The size of sound files increases memory pressure and can result in thrashing/disk reads if the files don't all fit in the cache at once.  Particles  Make sure there aren't too many particles simulating at once and that their complexity isn't too large.  Commands & Scripts  Try to avoid running commands and script functionality on every tick. It is especially important to not run dozens of commands or lots of script on every tick.  If you need to run commands often, consider putting them on an interval, so they run every 5 or 20 or 100 ticks instead. Also, if you are running commands and script on these intervals, offset the intervals so your commands or script run on different ticks.  Try not to use long running commands or script operations often (e.g. a big block /fill or /clone). If possible, split this into more than one command that runs at different ticks.  More General Suggestions  Consider creating your own in-game performance toggles with varying levels of fidelity and features.  With newer script APIs for getting at the rough outlines of a player's client system e.g., player.clientSystemInfo, you can key time-intensive behaviors (e.g., spawning particles) based on the rough outlines of performance (e.g., the more render distance a player has, assumedly the more performant their device is.) You will want to carefully ensure that the fundamental gameplay experience doesn't change depending on the performance profile of the player's device, however - for example, you don't want that fewer monsters spawn in a given area if the client device information is on the lower end.  Prepare for low end devices by testing on these devices as early as possible in your development process. You don't know how it's going to perform until you test.  Summary  In sum, the foremost consumer of resources in a particular world or add-on is usually these set of textures that are included inside of its resource packs. Through the minimization of the number or dimensions of the size of textures, you can help to conserve previous space on a player's device, allowing them to load more diverse add-ons and experiences into their worlds. Across entities, script, and commands, there are also a number of ways to improve overall performance by more tightly managing when expensive operations occur. Thanks for helping to conserve texture memory and build performant experiences for Minecraft!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tipsforusingthissite?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Tips For Using This Site 07/11/2024  Here are some very common links and tips for using the content available here.  Search  You may have noticed that the Search bar, at the top of the page, searches across all Microsoft Learn content, which may not be your intention.  If you want to search only within Minecraft content, use (and potentially bookmark!) https://learn.microsoft.com/search/?scope=Minecraft, which is a more narrowly scoped version of search focused solely on learn.microsoft.com Minecraft content.  Experimental vs. Stable documentation  This documentation set is divided into \"Stable\" and \"Experimental\" views via the \"Minecraft Bedrock Stable APIs\"/\"Minecraft Bedrock Experimental APIs\" picker you can see on this page. The \"Experimental\" view contains more reference documentation about experimental capabilities, particularly in the area of script APIs. To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs option.  More Sources of Information  Don't see what you're looking for here? Check the list of broader information sources amongst sample repositories and community information services.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tipsforusingthissite?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Tips For Using This Site 07/11/2024  Here are some very common links and tips for using the content available here.  Search  You may have noticed that the Search bar, at the top of the page, searches across all Microsoft Learn content, which may not be your intention.  If you want to search only within Minecraft content, use (and potentially bookmark!) https://learn.microsoft.com/search/?scope=Minecraft, which is a more narrowly scoped version of search focused solely on learn.microsoft.com Minecraft content.  Experimental vs. Stable documentation  This documentation set is divided into \"Stable\" and \"Experimental\" views via the \"Minecraft Bedrock Stable APIs\"/\"Minecraft Bedrock Experimental APIs\" picker you can see on this page. The \"Experimental\" view contains more reference documentation about experimental capabilities, particularly in the area of script APIs. To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs option.  More Sources of Information  Don't see what you're looking for here? Check the list of broader information sources amongst sample repositories and community information services.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/guidelinesforbuildingcooperativeaddons?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Guidelines for Building Cooperative Add-Ons 12/13/2024  Across the Minecraft platform, there is so much potential to customize how the game looks and acts. You can build your own mobs or override \"vanilla mobs\". Build your own blocks that fit into Minecraft, or change the default textures to something completely different. If you want fewer skeletons spawning in, you can override the skeleton or change its spawn rules. Where possible, we aim for as much customizability as possible!  But if you want to support an environment where players can play Minecraft survival or creative experiences -- and add maybe a dozen different additional enhancements they love -- you're going to want your add-on to be \"cooperative\". A cooperative add-on is designed to play nicely: it doesn't fundamentally change how Minecraft plays, avoids interrupting other Minecraft add-ons or experiences, and doesn't consume so many resources that it doesn't leave anything left for other add-ons to use (considering the wide array of devices Minecraft runs on). A cooperative add-on is also designed to use features and capabilities that will better stand the test of time, version over version.  It turns out there are also a lot of hidden things that could potentially cause \"conflicts\" across add-ons. For example, if two add-ons ship an entity called \"common:boss\", then based on per-world pack stack order, one of them will \"win\" and the other won't be available. Even if one creator ships two separate add-ons with the same mob in it with the same namespace, it can cause versioning issues if the implementation of that entity evolves over time across packs or version and the \"old version\" unexpectedly loads in a new version of a world.  Based on this, we introduce the concept of a \"Cooperative\" Add-On. A Cooperative Add-On is \"just\" a behavior pack+resource pack combo, but its behavior is generally additive and does not fundamentally change the gameplay of other experiences, such as the vanilla gameplay experiences or inadvertently conflict with other add-ons. It also takes precautions to avoid accidental conflicts, and to be more robust over the course of versions.  What follows is a set of guidelines for building these cooperative, additive-only add-ons. In many places, and out of a sense of precaution, you'll want to go to longer lengths to avoid add-ons that have any potential to conflict with other add-ons. Keep in mind that some of these rules are relatively strict; if you're creating an add-on for sharing with your friends, you may not need to adhere to all of these guidelines because the risk of \"add-on conflicts\" is probably much less.  Also, we have a web and command-line based tool available via Minecraft Creator Tools. It has a validation suite called \"Add-On Best Practices\" in the Inspector that looks at your add-on and suggests fixes you can make that will make your add-on more compatible with cooperative guidelines.  As time goes on, this section will evolve to capture more use cases that will change the complexity of add-ons.  Cooperativity  Fundamentally, Cooperative Add-Ons need to be designed to have \"additive\" functionality, rather than functionality that modifies or removes other functionality. For example, functionality that changes how creepers work might not be bad in and of itself, but if two completely separate add-ons are added by a player that happen to change how the creeper works, one will \"win\" (based on pack stack order, which for most players is not set in any particular intentful order). The add-on that \"loses\" (doesn't have its creeper customizations apply) might no longer work completely. We do not want to rely on players configuring their pack stack order precisely in order to have great experiences, so we want to avoid conflicts that come down to pack stack ordering.  Cooperative add-ons need to work with other add-ons. Your cooperative add-ons should work (stacked) with at least one other cooperative add-on, and you should test your add-ons around that. Add-Ons should not disable or remove fundamental vanilla gameplay. It must sit on top of vanilla and should be able to be removed without affecting the gameplay of vanilla and/or any add-on. \"Affecting the gameplay of vanilla\" is a wide and grey area - even introducing a new hostile mob can make achieving the goals of vanilla Minecraft more difficult - but what we mean is that no one add-on should prevent fundamental gameplay styles of Minecraft or make the game substantially harder or easier. You should not be making any changes to any vanilla files to accommodate your add-ons. That includes overriding or removing things that can be embedded in the world, like block types, item types, entity types, etc. For all identifiers across types (such as custom item types or custom block types), you should not use minecraft: as a name and ensure that the namespace is unique to the add-on. \"Overriding\" built-in mobs by including a type that starts with minecraft: to change how they work is not generally stable across versions. Based on this, you should also NOT override minecraft:player. You should only add new elements to the game; these changes should not change vanilla behaviors and/or vanilla item types. Because there can only be one item that can be created per recipe \"shape\" - when creating recipes for the crafting table, furnace, or brewing stand, try to use custom items whenever possible so that the \"recipe input\" is unique and diverse. Add-Ons should not override a player's skin or Character Creator. Versioning  One of the most fundamental requirements for add-ons is that they work across Minecraft versions and into the future as Minecraft evolves.  This is unlike when you create a custom world or world template; with worlds, you can use the base_game_version attribute to lock your world to a particular version of Minecraft, and where possible, that world will be frozen at that version (for example, worlds with a base game version less than 1.18.0 should not have a Pale Garden biome in them). It is important to realize that cooperative add-ons don't have a concept of version locking; they need to keep working even as version numbers advance into the future. And even if you apply these best practices listed below for cross-version compatibility, and while we do try to avoid gratuitous breaking changes in how the Minecraft Bedrock Platform works, in some cases you may need to update your add-ons over time to account for changes in how Minecraft works. Don't build in hard (or soft) dependencies that a particular mob will spawn in a particular quantity at a particular place in the Minecraft world, for example. Be resilient if new mobs are introduced that your add-on doesn't \"understand\" (because they were added in a release in the future and are now working in the world your current-day add-on is working within.)  Cooperative Add-Ons need to work release over release without the need for you to make updates. Worlds with Cooperative Add-Ons need to upgrade the same way as vanilla worlds do (without add-ons applied): ideally, seamlessly and automatically and without any data loss. Keep in mind your add-on needs to keep working in a world that is played over the span of years. Any bug fixes that you make to an add-on should not break existing worlds or remove content from within the packs. Bug fixes should not cause data loss. For example, removing a custom entity type has the impact of removing/hiding all instances of that entity in the world - essentially making them disappear, which is not preferable. Instead, if you wish to upgrade an entity type, continue to support the old entity type for backwards compatibility reasons. You should not use \"runtime_identifier\": when creating new entities because as versions change, a mob's behavior can change significantly, potentially leading to frequent breaks. min_engine_version must be set on both packs of the cooperative add-on. Add-Ons should not use or rely on Experimental features. When making updates, don't change namespaces, as that will cause version-related breaks in the add-on for players. Cooperative Add-On Technical Structure  Cooperative Add-Ons use existing tech and are added to the world by the player from either the Resource Pack or Behavior Pack tabs of the Create New World or Edit World screens. The requirement for each pack having a dependency on the other ensures that players won't get into a state where they have one pack applied to the world without the other.  Cooperative Add-Ons should consist of only one Behavior Pack and one Resource Pack. Both the Behavior Pack and Resource Pack need to contain dependencies on each other so one should not be applied without the other. Cooperative Add-Ons should not have a dependency on packs outside of their own packs.  These restrictions keep the process of adding add-on packs as simple as possible for players.  Manifest Updates  There is an additional field that needs to be added to the manifest of the Resource Pack of your add-on. To ensure that your resource pack can't be applied as a Global Resource Pack, you will need to add \"pack_scope\": \"world\", just after the \"uuid:\".  Here is an example of where that field goes in the resource pack manifest file:  JSON Copy {   \"format_version\": 2,    \"header\": {      \"name\": \"pack.name\",      \"description\": \"pack.description\",      \"uuid\": \"aa943e69-b6b8-955b-d405-29d77cc87283\",      \"pack_scope\": \"world\",      \"version\": [1, 0, 0],      \"min_engine_version\": [1, 21, 50],    },    \"modules\": [      {        \"version\": [1, 0, 0],        \"uuid\": \"bb461250-6de3-49f0-4a94-62c1deeb9b71\",        \"type\": \"data\"      }    ],    \"dependencies\": [      {        \"uuid\": \"aabcb1dc-29ca-4fc4-fa8c-ea1ea2d6788d\",        \"version\": [1, 0, 0]      }    ]  }   Limits for Performance  Many players will add 10+ add-on packs to their worlds, which can cause problems on a variety of devices. For example, some devices cannot scale to having 10 add-ons, each with 4,000 pieces of furniture and their attendant textures. On the other hand, 10 add-ons that each add 5-10 mobs is a bit more scalable. Based on this, we have some (admittedly coarse) guidelines on overall size of your add-ons.  Try not to exceed 25MB uncompressed, or a maximum of 3,500 files. because you need many files to implement basic concepts like a new block type, a 3,500 file limit equates to a rough maximum limit of 1,000 elements in your add-on, whether those elements are blocks, items, entities, or some combination thereof Block permutations should not exceed 10,000 blocks to ensure minimal performance impact across all platforms. Conserve overall texture size. When creating items like books, continue to use lower-resolution textures (<500 x <500). Aim for below 256x256 for blocks and items. Aim for below 2048x2048 for everything else. Prioritize efficient use of space over power-of-2 (e.g., 512x512, 1024x1024) sizing. See Improving Performance and Resource Usage for more tips. Use techniques like Molang and materials to produce color variants of textures, rather than creating, say, 8 color-tinted texture variants of the same texture. Types of Customizations to Avoid You should not add a dimension file to your add-on. Do not override UI files (resource packs/ui) Do not use custom client biome override files (resource) Via .lang files, do not override the words used for vanilla strings Do not override vanilla sounds and music with your own custom sounds and music. Do not use setLore APIs on minecraft:written_book. Ticking Areas  Because the number of available ticking areas are limited, avoid using ticking areas in your design plans when making your add-on.  Also, players or the base world can define their own ticking areas - even in the case that you are the only add-on applied to a world, it still may not be enough available ticking areas on that world.  Namespacing and Identifiers  There are several items in your add-on that need to have names that are unique. Because it is conceivable that you could accidentally conflict with other add-ons, you would need to prevent conflicts with other add-ons (including other those from yourself as a creator – past, present or future.) Below is a detailed recommendation on creating names for these items.  The following items need to have a unique name that no other add-on can ever have. It is recommended that you use a combination of creator name + pack abbreviations to create a unique namespace that you don't use in any other packs.  Namespace  Every item in the add-on needs to have a namespace and that namespace can't be minecraft:.  The namespace needs to be the same for every item in the add-on, including particles.  Every add-on you make needs to have a different namespace from any other namespace used in previous packs. This will ensure that your pack won't have a conflict with add-ons from others creations, as well as any add-on that you may have released.  We recommend that you use your creator name (or abbreviated creator name) followed by an underscore and an abbreviated pack name. For example, for the add-on called Your Creator Name's Super Awesome Add-On Pack, you could use the namespace ycn_saaop:.   Important  Having a conflict in the namespace is the only thing that can't easily be updated post-release, so you really want to get this right! If you have a conflict with another add-on you created, it is likely that you can't update the namespaces as that will cause data loss for all the items that you update to that namespace.  Texture Name  Texture names need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. Texture names can be anything and it is likely that there will be conflicts with other creators because texture names tend to be descriptive -- you could imagine multiple furniture add-ons naming a texture \"table\", and that would conflict based on pack stack order. For most players, pack stack order is not intentfully set so which texture \"wins\" would be random.  All textures should be placed at least 2 folders deep (although additional folders can be used if you want for additional organization.) The first folder should be your creator name and the second folder should be the pack name. The folder structure will look like this.  PowerShell Copy &lt;resource pack name&gt; -> textures -> &lt;creator name&gt; -> &lt;pack name&gt; -> mycustomtexture.png  Texture Reference  Like texture names, texture references need to be unique to prevent items from using the wrong texture when multiple add-ons are applied. When creating texture references, use the pack's \"namespace:\" before the name. This will prevent any conflicts.  Localization (Lang Files)  If you localize your packs via .lang resource files, ensure that you use namespaced names for your .lang string replacement tokens.  Geometry Identifiers  Geometry identifiers also need to be unique to prevent items from using the wrong geo file when multiple add-ons are applied. Geometry identifiers need to start with \"geometry.\". Because of that, we recommend that add \".namespace\" immediately after \"geometry.\". Your geometry identifiers will look like this: geometry.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Tags and Scoreboard Objective names  When using tags or scoreboard objectives within commands, you need to ensure that they are unique so that they don't conflict with other add-ons. When creating tags and Scoreboard objective names, use a namespace before the tag and scoreboard names.  Loot Tables  Loot table names need to be unique, or they can conflict with other loot tables in other add-ons. To prevent this, we suggest that every creator nests their loot tables in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> loot_tables -> &lt;creator name&gt; -> &lt;pack name&gt; -> <loot table name>  Animations  Animation names need to be unique. These are the names that are provided inside the animation file. Animation names need to start with \"animation.\". To prevent creators from using the same animation names, we recommend you add \".namespace\" immediately after \"animation.\" and will look like this animation.creatorname_gamename.whatever.else. Doing this will prevent conflicts with other geometry files in add-ons.  Animation Controllers  Animation controller names need to be unique. These are the names that are provided inside the animation controller file. Animation controller names need to start with \"controller.animation.\". To prevent creators from using the same animation controller names, we recommend you add \".namespace\" immediately after \"controller.animation.\". It will look like this: controller.animation.creatorname_gamename.whatever.else.  Render Controllers  Render controller names need to be unique to prevent the wrong render controller files from being used. Render controller names need to start with \"controller.render.<render_controller_name>\". We recommend you add \".namespace\" immediately after \"controller.render.\". It will look like this: controller.render.creatorname_gamename.whatever.else. Please note this is the name contained within the file.  Structures  Structures for add-ons can be used with the structure command and/or features and feature rules.  When naming your structure, you need to place them in a folder that has the same name as the namespace used for the pack. When loading a structure file, the namespace used in this case is the folder name the structure appears.  Here is an example below:  PowerShell Copy <behavior pack name> -> structures -> <namespace> -> <structure file name>  Feature and Feature Rules  Feature and feature rules file names need to be unique, or they can conflict with other feature and feature rules files in other add-ons. Use the namespace identifier conventions that you use in other files. Be advised that, unfortunately, feature files cannot be located in subfolders without changing how their namespace identifier works in unpredictable ways.  Functions  Function file names need to be unique, or they can conflict with other functions in other add-ons.  To prevent this, we suggest that every creator nests their functions in 2 folders.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> functions -> &lt;creator name&gt; -> &lt;pack name&gt; -> <function file name>.   Using this naming convention also allows creators to use tick.json in their packs without conflicting with other creators.  Sounds  Sounds are located within the Resource pack, and can override other sounds based on their file path and name. To prevent unwanted overrides, we suggest placing your sound files at least 2 folders deep in the sounds folder (although more can be used if desired).  The first folder is your creator name, and the second folder is the pack name. This will cause your folder structure to look like this:  PowerShell Copy &lt;resource pack name&gt; -> sounds -> &lt;creator name&gt; -> &lt;pack name&gt;  Sound Reference  Sound References need to be unique. Sound references are assigned in the sound definition file. All sound references need to start with \"namespace:\" to prevent files from conflicting with each other.  NPC Scenes  NPC scenes need to have unique names to prevent any conflicts with other add-ons. Use the same namespace format that you use throughout the add-on to name the NPC scenes.  Trade Tables  Trade table names need to be unique, or they can conflict with other trade tables in other add-ons. Creators should place their trade tables in a folder named \"trading\". Inside the trading folder we suggest that every creator nests their trade table files two additional folders deep to prevent conflict with other creators' add-ons.  The first folder is your creator name, and the second is the name of the add-on pack name. Here is an example below:  PowerShell Copy <behavior pack name> -> trading -> &lt;creator name&gt; -> &lt;pack name&gt; -> <trade table file name>.  JSON UI and Custom Fonts overrides are disalllowed  Because JSON UI (i.e., files in <resource pack name>/ui) and fonts (i.e., files in <resource pack name>/font) are not overridable in a cooperative manner - such that multiple add-ons can customize the same asset - cooperative add-ons should not override any JSON UI or font glyph files.  Folder Structures  For folders like textures, functions, loot tables, sounds, and trading we recommend that your folder structure appear like this, textures-> <creator_name> -> <pack_name>.  Where possible, always ensure your textures, functions, loot tables, sounds, and trading folder have a subfolder that is your <creator_name> and only that folder. You should not have \"loose\" files in the <creator_name> folder.  Inside the <creator_name> folder, we recommend that you don't add more than two folders. The first is the recommended <pack_name> folder. The only other folder that should appear in here is one called \"common\". You can use this to help speed up development by placing assets in there that you use commonly across packs.   Note  Use of a common folder inside of <pack_name> folder is a little risky. If you change the asset in any way, you need to update it in every pack that contains it to prevent one of your packs conflicting with another pack.  You should come up with a unique namespace for each pack, and that name should consist of your creator name appended to the pack name and separated by an underscore. Doing this will ensure that your packs will work with all add-ons created and future proof against any add-ons created in the future. This will help prevent a potential negative experience for players.  Using that namespace as suffix to texture names, texture references, geo identifiers, tags and scoreboard objective names also ensures that what you create in your add-on will always appear the way that you intend them to look.  Using Block Placing Methods like Structures, Setblock, Fill, and Clone  Suppose you want to add something to an existing 5 year old world. Your add-on should not arbitrarily destroy (or replace blocks in) areas of the world, especially without explicit user consent - because you could be destroying someone's cherished 5 year old creations!  While placing structures have more of a chance of altering or destroying something that the player cares about, it can still occur when replacing a single block. If that happens, there is no way for the player to recover from this (unless they backed up the world before loading).  If your concept requires a starting area structure, or for large structures to spawn in or be created without player interaction, or without the player knowing what is going to happen, please consider using these ideas in an entire world instead of as a Cooperative Add-On.  Here are some recommendations for using these features:  In existing saved chunks  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  Check to make sure that these blocks are only placed in areas that are empty - meaning the blocks they are replacing are only air.  In unmodified chunks  If these come in without player interaction check to make sure that these blocks are only placed in areas that are fully air.  Ensure that these are brought in during player interaction, explain what is going to happen, and allow the player a way to undo.  If you are going to replace blocks, try to ensure that blocks that are valuable to players aren't replaced (like ores, archeology blocks, etc.)  Teaching players how to use your Add-On  Teaching players how to use your add-on is vitally important for a great player experience and there should be a single, non-destructive way to do this. This way the players will have the same expectations no matter which add-on they add to the world.  We recommend that all creators spawn a book at the feet of the player on first load that teaches the player how to use the add-on. This needs to be done in a non-destructive way.  There are a few techniques for adding an instructional book:  Adding a book  It's a little clunky, but one way to safely add a book to a players' inventory is to make the book spawn at the player's location.  The mechanism behind this is to create a small (1 block) structure at the player's position that contains only the book and a structure void. Make the structure spawn only once.  Doing this will allow players with a space in their inventory to automatically pick up the book. For those with a full inventory, they would need to choose something to drop to pick it up. Because this is generally the way that all cooperative add-ons work, there will be a player expectation to look for this book. You can also send the player an onscreen message that informs them about the book (so players with a full inventory will look for it), but this isn't required.  If you want to be super-nice, you could provide an empty chest so players can off-load items so they can pick up the book.  Messages in chat  If you choose to have a chat message, please ensure that it is 28 characters or less so that it fits on one line. Stacking multiple add-ons will make it difficult for players to read all the messages. You should also make sure that it only sends the message the first time the player joins the world. Try to avoid excessive messages being broadcast to players.  Custom item that acts like a book  Another alternative is to create a custom item and entity that looks and acts like a book when opened. Please note that if you go this route that the text might not be localize-able since it is part of the textures.  You will also need to handle the opening, closing, and reacquiring of the book yourself and need to do this in a way that won't interfere with other entity books in multiplayer. It will be much easier for players to lose books when using this method. We recommend creating a way to craft your entity books so players can easily craft a replacement if needed. Please keep these things in mind when deciding to use this method.  It is recommended that you make the max item stack size for these types of books 64. This will allow players to place them in bundles. The bundle uses max stack size and a max stack size of 1 will fill the entire bundle with that one item. Nothing extra needs to be done if you are using the structure that spawns a book approach.  Regardless of whether you choose to spawn the guidebook as an entity or a structure containing a signed book, spawning it at the player's location can only happen once per player. Do not spawn a book every time a player joins the world or after the player dies.  Lastly, do not use setLore APIs on your books, as it will be added to all the guidebooks the player has. (it will overwrite the books of other creators that may be stacked in the world as well!)  Summary of Cooperative Add-On Creator Guidelines  Use namespaces and custom folder names to ensure that the identifiers used across your add-on are unique, and cannot accidentally collide with other add-ons.  Do not use certain features, like custom dimension sizes or UI JSON overrides, that don't scale to being cooperatively overridden.  Do not change or remove vanilla behavior; only add new things to the game. Vanilla gameplay changes over time and new gameplay updates rely on existing vanilla blocks, items, mobs, and mechanics, so changing these can affect gameplay. To prevent vanilla gameplay from breaking, you should not change any of the vanilla gameplay files or use scripting to disable vanilla gameplay elements.  In addition to vanilla gameplay, you should not change or update vanilla elements, because we need to ensure that multiple add-ons work together. If we allow you to change a vanilla element, it could interfere with another add-on that relies on the same element. To prevent add-ons from unintentionally disabling another add-on, we only allow new things to be created.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tipsforusingthissite?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Tips For Using This Site 07/11/2024  Here are some very common links and tips for using the content available here.  Search  You may have noticed that the Search bar, at the top of the page, searches across all Microsoft Learn content, which may not be your intention.  If you want to search only within Minecraft content, use (and potentially bookmark!) https://learn.microsoft.com/search/?scope=Minecraft, which is a more narrowly scoped version of search focused solely on learn.microsoft.com Minecraft content.  Experimental vs. Stable documentation  This documentation set is divided into \"Stable\" and \"Experimental\" views via the \"Minecraft Bedrock Stable APIs\"/\"Minecraft Bedrock Experimental APIs\" picker you can see on this page. The \"Experimental\" view contains more reference documentation about experimental capabilities, particularly in the area of script APIs. To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs option.  More Sources of Information  Don't see what you're looking for here? Check the list of broader information sources amongst sample repositories and community information services.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/tipsforusingthissite?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Tips For Using This Site 07/11/2024  Here are some very common links and tips for using the content available here.  Search  You may have noticed that the Search bar, at the top of the page, searches across all Microsoft Learn content, which may not be your intention.  If you want to search only within Minecraft content, use (and potentially bookmark!) https://learn.microsoft.com/search/?scope=Minecraft, which is a more narrowly scoped version of search focused solely on learn.microsoft.com Minecraft content.  Experimental vs. Stable documentation  This documentation set is divided into \"Stable\" and \"Experimental\" views via the \"Minecraft Bedrock Stable APIs\"/\"Minecraft Bedrock Experimental APIs\" picker you can see on this page. The \"Experimental\" view contains more reference documentation about experimental capabilities, particularly in the area of script APIs. To see full documentation about experimental features and APIs, select the Minecraft Bedrock Experimental APIs option.  More Sources of Information  Don't see what you're looking for here? Check the list of broader information sources amongst sample repositories and community information services.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/latestplatformversion?source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Latest Platform Version Guidance 09/05/2024  When delivering your add-ons and worlds to players, you'll want to ensure that it is built on \"up to date\" versions of the Minecraft Bedrock platform. What do we mean by up to date? Unfortunately, versions are a little complicated in Minecraft; this article attempts to document the latest versions of content across sources.  In addition, we also have (preview) tooling available at https://mctools.dev that can scan your content and tell you if it is conformant to \"up to date version\". When you open a zip or MCAddon of your content, under the Inspector option, select the \"Current Platform Versions\" suite, and it should show relevant versions and if any files are considered \"out of date\".  Content should be within N or N-1 of the latest Minecraft version  Brand-new content should be built built on platform elements related to the last current released retail version, and the major released version before that. To define this in more concrete terms, we will consider N and N-1 \"minor\" versions of Minecraft as \"up to date\". For example, at the time of this writing, 1.21.20 is the major retail version in players' hands; so therefore, 1.21.* and 1.20.* would be considered up to date versions of content. Of course, as a creator you should generally try to target the latest major.minor.patch release (e.g., 1.21.20) where you can help it.  Versions across Minecraft  Minecraft Bedrock Edition uses several different \"versioning\" systems and histories in different places within the platform. In many cases – say, block type definitions – the latest format version of the file matches the version of the product (at the time of this writing, that is 1.21.20). In other places, the de-facto \"most modern version\" comes from a previous version of the game (e.g., animations should be at version 1.10.0). Still in other places – e.g., scripting -- the versioning scheme differs altogether. For these reasons, in places the \"N-1\" rule may not literally mean the version has to match the game version. In this rest of this article, we will list the exceptions and nuances of versioning in major portions of the platform.  The major versions to consider include:  Base game version Min engine version Command version Per-file-type format versions Script module version Base Game Version  Base game version is a world template-only concept and located in manifest.json of a world template file. base_game_version is compliant with the N-1 minor version idea.  Example non-conformant content:  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 7],     \"lock_template_options\": true,     \"base_game_version\": [1, 16, 0],     \"uuid\": \"cb599a1d-0fc2-4263-a06d-3e294fd5ffc4\"   },   \"modules\": [{     \"version\": [1, 0, 7],     \"type\": \"world_template\",     \"uuid\": \"6eb7c7a6-7db3-496d-8155-edd8a5003116\"   }],   \"format_version\": 2 }   As you upgrade content to newer base game versions, you will need to validate your world works as expected – for example, that the introduction of 1.19 or 1.20-era mobs doesn't suddenly cause game play bugs in various forms (e.g., a glow squid suddenly inside of your dungeon pond).  Manifest File Format Version  Within manifest.json files, manifest.json in behavior packs/resource packs should have a format version of \"2\".  Behavior Pack/Resource Pack Manifest File min_engine_version  Behavior pack/resource pack files have min_engine_version that is within the the N-1 rule. min_engine_version influences a wide array of things, including the version of commands as run within MCFunctions, tick.json, and behavior animations/behavior animation controllers.  Command versions in Level DB and in structures  As part of using command blocks, an inherent command version gets associated with that command block. Commands as used inside of command blocks should be upgraded to a command version consistent with the N-1 rule. For version 1.21.0, this is command version 33.  Format_version  Format version is declared in many major JSON files in Minecraft packs. Depending on the type of file, we will validate version is at least the minimum version specified. If the value is \"N-1\", we will validate against versions based on the \"N-1\" rule logic above.  It is expected that this table will update over time, so stay tuned.  Behavior Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Block Types\tblocks folder\tN-1 Entity Types\tentities folder\t(exempt - entity type versioning is highly variable) Item Types\titems folder\tN-1 Loot Tables\tloot_tables folder\t(no versioning concept) Recipes\trecipes folder\tN-1 Spawn Rules\tspawn_rules folder\tN-1 Trading Tables\tTrading folder\t(no versioning concept) Resource Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Attachables (Item type rendering descriptions)\tattachables folder\t1.10.0 Client Biome definitions\tbiomes_client.json\t(no versioning concept) Block rendering definitions\tblocks.json\t(no versioning concept) Entity type render descriptions\tentity folder\tN-1 Fogs\tfogs folder\tN-1 Models\tmodels folder\t1.12.0 Render Controllers\trender_controllers folder\t1.10.0 Sound/Music definitions\tsounds folder\tN-1 Texture definitions\ttextures/*_texture.json\t(no versioning concept) JSON UI\tui folder\t(no versioning concept) Script Module Versions  Every script module has its minor version incremented if new capabilities are introduced, version over version. Its major version (e.g., going from 1.x to 2.y) is incremented if there are known backwards compatibility impacting bugs that are fixed or changed.  Most Minecraft content that uses scripting uses the @minecraft/server module. Its \"script module version\" to \"major version\" mapping is described in the Script Versioning article. To adhere to the \"N-1 rule\", and assuming the current major version is 1.21.20, we would ensure that Minecraft content in a behavior pack expresses a dependency on at least \"1.2.0\" of @minecraft/server (the version of the @minecraft/script contemporary of 1.20.0), if it uses scripting.  Upgrading a dependency within a scripting minor version should generally be safe. Because the difference between version 1.2.0 and, say, 1.9.0, should only be additive and not-backwards-compatible impacting, updating script module version dependencies with minor versions should not impact how that code works.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/practices/latestplatformversion?view=minecraft-bedrock-stable&source=recommendations", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Latest Platform Version Guidance 09/05/2024  When delivering your add-ons and worlds to players, you'll want to ensure that it is built on \"up to date\" versions of the Minecraft Bedrock platform. What do we mean by up to date? Unfortunately, versions are a little complicated in Minecraft; this article attempts to document the latest versions of content across sources.  In addition, we also have (preview) tooling available at https://mctools.dev that can scan your content and tell you if it is conformant to \"up to date version\". When you open a zip or MCAddon of your content, under the Inspector option, select the \"Current Platform Versions\" suite, and it should show relevant versions and if any files are considered \"out of date\".  Content should be within N or N-1 of the latest Minecraft version  Brand-new content should be built built on platform elements related to the last current released retail version, and the major released version before that. To define this in more concrete terms, we will consider N and N-1 \"minor\" versions of Minecraft as \"up to date\". For example, at the time of this writing, 1.21.20 is the major retail version in players' hands; so therefore, 1.21.* and 1.20.* would be considered up to date versions of content. Of course, as a creator you should generally try to target the latest major.minor.patch release (e.g., 1.21.20) where you can help it.  Versions across Minecraft  Minecraft Bedrock Edition uses several different \"versioning\" systems and histories in different places within the platform. In many cases – say, block type definitions – the latest format version of the file matches the version of the product (at the time of this writing, that is 1.21.20). In other places, the de-facto \"most modern version\" comes from a previous version of the game (e.g., animations should be at version 1.10.0). Still in other places – e.g., scripting -- the versioning scheme differs altogether. For these reasons, in places the \"N-1\" rule may not literally mean the version has to match the game version. In this rest of this article, we will list the exceptions and nuances of versioning in major portions of the platform.  The major versions to consider include:  Base game version Min engine version Command version Per-file-type format versions Script module version Base Game Version  Base game version is a world template-only concept and located in manifest.json of a world template file. base_game_version is compliant with the N-1 minor version idea.  Example non-conformant content:  JSON Copy {   \"header\": {     \"name\": \"pack.name\",     \"description\": \"pack.description\",     \"version\": [1, 0, 7],     \"lock_template_options\": true,     \"base_game_version\": [1, 16, 0],     \"uuid\": \"cb599a1d-0fc2-4263-a06d-3e294fd5ffc4\"   },   \"modules\": [{     \"version\": [1, 0, 7],     \"type\": \"world_template\",     \"uuid\": \"6eb7c7a6-7db3-496d-8155-edd8a5003116\"   }],   \"format_version\": 2 }   As you upgrade content to newer base game versions, you will need to validate your world works as expected – for example, that the introduction of 1.19 or 1.20-era mobs doesn't suddenly cause game play bugs in various forms (e.g., a glow squid suddenly inside of your dungeon pond).  Manifest File Format Version  Within manifest.json files, manifest.json in behavior packs/resource packs should have a format version of \"2\".  Behavior Pack/Resource Pack Manifest File min_engine_version  Behavior pack/resource pack files have min_engine_version that is within the the N-1 rule. min_engine_version influences a wide array of things, including the version of commands as run within MCFunctions, tick.json, and behavior animations/behavior animation controllers.  Command versions in Level DB and in structures  As part of using command blocks, an inherent command version gets associated with that command block. Commands as used inside of command blocks should be upgraded to a command version consistent with the N-1 rule. For version 1.21.0, this is command version 33.  Format_version  Format version is declared in many major JSON files in Minecraft packs. Depending on the type of file, we will validate version is at least the minimum version specified. If the value is \"N-1\", we will validate against versions based on the \"N-1\" rule logic above.  It is expected that this table will update over time, so stay tuned.  Behavior Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Block Types\tblocks folder\tN-1 Entity Types\tentities folder\t(exempt - entity type versioning is highly variable) Item Types\titems folder\tN-1 Loot Tables\tloot_tables folder\t(no versioning concept) Recipes\trecipes folder\tN-1 Spawn Rules\tspawn_rules folder\tN-1 Trading Tables\tTrading folder\t(no versioning concept) Resource Packs Expand table Type of File\tWhat JSON files?\tMinimum version Animation Controllers\tanimation_controllers folder\t1.10.0 Animations\tanimations folder\t1.10.0 Attachables (Item type rendering descriptions)\tattachables folder\t1.10.0 Client Biome definitions\tbiomes_client.json\t(no versioning concept) Block rendering definitions\tblocks.json\t(no versioning concept) Entity type render descriptions\tentity folder\tN-1 Fogs\tfogs folder\tN-1 Models\tmodels folder\t1.12.0 Render Controllers\trender_controllers folder\t1.10.0 Sound/Music definitions\tsounds folder\tN-1 Texture definitions\ttextures/*_texture.json\t(no versioning concept) JSON UI\tui folder\t(no versioning concept) Script Module Versions  Every script module has its minor version incremented if new capabilities are introduced, version over version. Its major version (e.g., going from 1.x to 2.y) is incremented if there are known backwards compatibility impacting bugs that are fixed or changed.  Most Minecraft content that uses scripting uses the @minecraft/server module. Its \"script module version\" to \"major version\" mapping is described in the Script Versioning article. To adhere to the \"N-1 rule\", and assuming the current major version is 1.21.20, we would ensure that Minecraft content in a behavior pack expresses a dependency on at least \"1.2.0\" of @minecraft/server (the version of the @minecraft/script contemporary of 1.20.0), if it uses scripting.  Upgrading a dependency within a scripting minor version should generally be safe. Because the difference between version 1.2.0 and, say, 1.9.0, should only be additive and not-backwards-compatible impacting, updating script module version dependencies with minor versions should not impact how that code works.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/copycoordinates?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Copying and Pasting Coordinates 09/20/2023  Minecraft players and creators frequently share and use coordinates through various areas of gameplay. The ability to capture and paste the players' relative coordinates on any platform allows for faster content creation, command execution, and communication.  The copy coordinates function focuses on commonly visited screens which often require coordinate information. The chat screen contains the majority of the changes; adding a field, dropdown selector, and copy and paste button for viewing and retrieving relative coordinates. The command block screen has a paste button that allows easy data transfer when creating control scenarios.  How to enable the copy coordinates functionality How to use the functionality with keyboard shortcuts (and controller actions?) How to target the block where the player is located or the block that the player is focused on Requirements Introduction to Commands A Minecraft world Enabling the Copy Coordinates Feature Launch Minecraft and go into Settings. On the Creator tab, make sure the toggle for Enable Copy Coordinate UI is on.  How to Copy Coordinates Local copies the player's location - Where are my feet? Cursor copies the location of the block selected by the cursor - What am I looking at? Copying with a keyboard  To copy the local coordinates, press CTRL + ALT + C. A dialog will be displayed that reads \"Copied current position to clipboard\" along with the coordinates. To copy the cursor coordinates, press CTRL + ALT + X. A dialog will be displayed that reads \"Copied facing position to clipboard.\" If you want to use different keys than C or X, you can change the keybindings on the Keyboard & Mouse tab in the Settings.  Copying with a controller or touchpad Open the chat menu. The Copy Coordinates feature is at the top of the window. Choose Local or Cursor from the drop-down menu.  Press the copy button. A pop-up dialog confirms that the coordinates were indeed copied.  Pasting Coordinates  To paste the coordinates, navigate to the area where you want to put the coordinates, such as a command in the chat window or in a command block. Then, you can either select the paste button or press the 'Y' button on a controller.  The coordinates will be pasted in without commas. On a PC, you can use the usual keyboard shortcut CTRL+ V to paste the coordinates into a text document outside of Minecraft.  What's Next?  Now that you know how to copy coordinates, here are some commands that use them (along with some that don't).  Popular Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/copycoordinates?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Copying and Pasting Coordinates 09/20/2023  Minecraft players and creators frequently share and use coordinates through various areas of gameplay. The ability to capture and paste the players' relative coordinates on any platform allows for faster content creation, command execution, and communication.  The copy coordinates function focuses on commonly visited screens which often require coordinate information. The chat screen contains the majority of the changes; adding a field, dropdown selector, and copy and paste button for viewing and retrieving relative coordinates. The command block screen has a paste button that allows easy data transfer when creating control scenarios.  How to enable the copy coordinates functionality How to use the functionality with keyboard shortcuts (and controller actions?) How to target the block where the player is located or the block that the player is focused on Requirements Introduction to Commands A Minecraft world Enabling the Copy Coordinates Feature Launch Minecraft and go into Settings. On the Creator tab, make sure the toggle for Enable Copy Coordinate UI is on.  How to Copy Coordinates Local copies the player's location - Where are my feet? Cursor copies the location of the block selected by the cursor - What am I looking at? Copying with a keyboard  To copy the local coordinates, press CTRL + ALT + C. A dialog will be displayed that reads \"Copied current position to clipboard\" along with the coordinates. To copy the cursor coordinates, press CTRL + ALT + X. A dialog will be displayed that reads \"Copied facing position to clipboard.\" If you want to use different keys than C or X, you can change the keybindings on the Keyboard & Mouse tab in the Settings.  Copying with a controller or touchpad Open the chat menu. The Copy Coordinates feature is at the top of the window. Choose Local or Cursor from the drop-down menu.  Press the copy button. A pop-up dialog confirms that the coordinates were indeed copied.  Pasting Coordinates  To paste the coordinates, navigate to the area where you want to put the coordinates, such as a command in the chat window or in a command block. Then, you can either select the paste button or press the 'Y' button on a controller.  The coordinates will be pasted in without commas. On a PC, you can use the usual keyboard shortcut CTRL+ V to paste the coordinates into a text document outside of Minecraft.  What's Next?  Now that you know how to copy coordinates, here are some commands that use them (along with some that don't).  Popular Commands  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/contenterrorlog?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Content Error Log 04/16/2025  While playing Minecraft: Bedrock Edition, the game is constantly processing content to produce the game experience we all know and love. This content can be anything from textures for character skins, configuration files describing how a torch's fire looks, or a behavior for a mob. While this is going on, Minecraft logs information related to this in a separate content specific log. Some of these messages are just noting normal game operations, but some of the messages denote problems detected in content that can either lead to instability or unpredictable behavior.  The messages in this log are broken into two larger categories outlined below.  Errors and Warnings Show up in both the GUI dialog, content log history screen, and the content log file Occur when problematic or concerning content is processed  While loading and processing content generated by our creators, mistakes and unexpected results are bound to happen. These sorts of problems can present themselves in any number of ways, some of which the game can determine as problematic on its own. These can be things like putting a word in a configuration file that was expecting a number or having a reference to a texture file that wasn't included in the content pack. When Minecraft detects this sort of problem, it will output a message outlining the problem as well as some advice on how to correct it.  Info and Verbose Only show up in the log file Occur to show a record of steps taken during the course processing content  These classes of messages are used mostly as a record of what happened. These mostly serve to provide some context around other errors while content is being processed. It can be useful to know what happened right before or right after an error/warning occurs in the log. These messages are not a sign that something is wrong and are safe to ignore.  How to use the Content Log  In the settings you can enable/disable both the file and GUI reporting from the content log. Turning either on or off will enable/disable the functionality of either reporting methodology. Turning off all the content log reporting methods effectively disables the content log. These options currently live in the \"Creator\" menu.  What the Content Log GUI looks like  Looking at previous Content Log messages  There are two ways to get to the content log history. The first is by clicking the Content Log History button in the profile screen:  By pressing this button, you will end up at this screen:  Here you can also copy all messages to the clipboard to save for later.  An alternative to get to this screen is to press Control + H, and this will only work if the Enable Content Log GUI option is enabled.  Location of the Content Log file  The content log file is stored in the logging folder. You can find the exact location of this log file by looking at the profile screen where the path to the current content log is stored.  Example Paths  Windows UWP  %LocalAppData%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe  Android (varies whether the app is installed on the phone or SD card)  *root storage location*/games/com.mojang/logs  iOS (varies based on where the external storage is located for the app)  *root storage location*/Minecraft/game/com.mojang/logs  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/contenterrorlog?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Content Error Log 04/16/2025  While playing Minecraft: Bedrock Edition, the game is constantly processing content to produce the game experience we all know and love. This content can be anything from textures for character skins, configuration files describing how a torch's fire looks, or a behavior for a mob. While this is going on, Minecraft logs information related to this in a separate content specific log. Some of these messages are just noting normal game operations, but some of the messages denote problems detected in content that can either lead to instability or unpredictable behavior.  The messages in this log are broken into two larger categories outlined below.  Errors and Warnings Show up in both the GUI dialog, content log history screen, and the content log file Occur when problematic or concerning content is processed  While loading and processing content generated by our creators, mistakes and unexpected results are bound to happen. These sorts of problems can present themselves in any number of ways, some of which the game can determine as problematic on its own. These can be things like putting a word in a configuration file that was expecting a number or having a reference to a texture file that wasn't included in the content pack. When Minecraft detects this sort of problem, it will output a message outlining the problem as well as some advice on how to correct it.  Info and Verbose Only show up in the log file Occur to show a record of steps taken during the course processing content  These classes of messages are used mostly as a record of what happened. These mostly serve to provide some context around other errors while content is being processed. It can be useful to know what happened right before or right after an error/warning occurs in the log. These messages are not a sign that something is wrong and are safe to ignore.  How to use the Content Log  In the settings you can enable/disable both the file and GUI reporting from the content log. Turning either on or off will enable/disable the functionality of either reporting methodology. Turning off all the content log reporting methods effectively disables the content log. These options currently live in the \"Creator\" menu.  What the Content Log GUI looks like  Looking at previous Content Log messages  There are two ways to get to the content log history. The first is by clicking the Content Log History button in the profile screen:  By pressing this button, you will end up at this screen:  Here you can also copy all messages to the clipboard to save for later.  An alternative to get to this screen is to press Control + H, and this will only work if the Enable Content Log GUI option is enabled.  Location of the Content Log file  The content log file is stored in the logging folder. You can find the exact location of this log file by looking at the profile screen where the path to the current content log is stored.  Example Paths  Windows UWP  %LocalAppData%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe  Android (varies whether the app is installed on the phone or SD card)  *root storage location*/games/com.mojang/logs  iOS (varies based on where the external storage is located for the app)  *root storage location*/Minecraft/game/com.mojang/logs  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gametestbuildyourfirstgametest?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Building your first GameTest 06/20/2024 What's in a GameTest?  A GameTest is a miniature environment along with a set of starting conditions, such as a set of mobs or items. After that environment plays out in the Minecraft world for a little while, you can run conditional code to evaluate that your expectations were met.  Building sets of GameTests requires building out your GameTests via a behavior Pack, and writing some simple JavaScript code.   Important  GameTest Framework is still experimental. As with all experiments, you may see additions, removals, and changes in functionality in Minecraft versions without significant advanced warning. Check the Minecraft Changelog for details on any changes to Beta APIs or GameTest Framework.  To learn more about Experimental Features, please visit Experimental Features in Minecraft: Bedrock Edition.   Caution  Because GameTest Framework is adding and updating functionality frequently, we recommend using the latest Beta versions of Minecraft. See Minecraft Betas for more information. The syntax of this sample is intended to be compatible with the latest beta versions.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Behavior Packs GameTest Elements  Within a behavior pack, every GameTest consists of a few elements:  A structure which defines the physical environment for the test as well as any starting entities. Within Minecraft, you can create new structures by designing them out (typically in Creative Mode) and then placing a structure block nearby. You can then use the structure block to save out the results to disk. This creates a .mcstructure file which you can add to your test.  When GameTests are run in Minecraft, your structure will be loaded and expanded into Minecraft. You should note that this structure will be created and run in a generally flat, broader world, so you'll want to ensure that any mobs are penned into the structures you create.  GameTests then use JavaScript code to define the test, including:  Test registration: a small amount of code to establish a test in the environment.  Test setup: additional code that sets up conditions within the Structure environment that has been created. Typically, this will be the creation of additional mobs.  Test validation: additional code snippets written in JavaScript that evaluates whether a test has completed successfully or has failed.  With this simple foundation, GameTests can be created with a few lines of JavaScript code plus a Minecraft structure.  Start building your own tests   Note  A completed version of this tutorial is available on GitHub, at https://github.com/microsoft/minecraft-gametests. You can use this sample to compare against your sample, or if you just want to see what this looks like when completed.  Within the startertests folder, you'll also want to include two subfolders:  structures for holding MCStructure files scripts for holding JavaScript files Update your manifest  You can start a behavior pack manifest with a manifest.json file within your startertests folder, as follows:  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Introductory tests for Minecraft GameTest Framework.\",     \"name\": \"Starter Hello World Tests\",     \"uuid\": \"afeeb2ab-0404-4518-822f-9837117e78e1\",     \"version\": [       1,       0,       0     ],     \"min_engine_version\": [       1,       21,       0     ]   } }   A behavior pack manifest needs to have additional elements to support GameTests. The modules section needs one module, added beneath the header section, that registers your JavaScript code entry point, as follows:  JSON Copy   \"modules\": [     {       \"description\": \"Script that implements basic starter tests.\",       \"type\": \"script\",       \"language\": \"javascript\",       \"uuid\": \"ead57a90-41fc-4f3b-8e1a-ccc64c99da0c\",       \"version\": [         1,         0,         0       ],       \"entry\": \"scripts/StarterTests.js\"     }   ]   Note several facets of this module:  This module is of type script. The uuid needs to be unique and generated for your project. See the Introduction To Behavior Packs topic for tools for generating new UUIDs. The entry attribute points to a JavaScript file that contains your GameTest code.  In addition, you will need to establish dependencies on Minecraft APIs and GameTest Framework. You can do this with additional dependencies added beneath the modules section below:  JSON Copy   \"dependencies\": [     {       \"module_name\": \"@minecraft/server\",       \"version\": \"1.13.0-beta\"     },     {       \"module_name\": \"@minecraft/server-gametest\",       \"version\": \"1.0.0-beta\"     }   ]    Important  As you can see, GameTest Framework tests dependent on versions \"1.13.0-beta\" of Minecraft APIs and GameTest Framework. Beta versions indicate that these features are still experimental. As with all experiments, we are improving their capabilities over time, and API signatures may change build over build without advanced notice. Check the Minecraft Changelog for more changes over time.  A full manifest file for a Behavior Pack with a GameTest looks like:  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Introductory tests for Minecraft GameTest Framework.\",     \"name\": \"Starter Hello World Tests\",     \"uuid\": \"afeeb2ab-0404-4518-822f-9837117e78e1\",     \"version\": [       1,       0,       0     ],     \"min_engine_version\": [       1,       21,       0     ]   },   \"modules\": [     {       \"description\": \"Script that implements basic starter tests.\",       \"type\": \"script\",       \"language\": \"javascript\",       \"uuid\": \"ead57a90-41fc-4f3b-8e1a-ccc64c99da0c\",       \"version\": [         1,         0,         0       ],       \"entry\": \"scripts/StarterTests.js\"     }   ],   \"dependencies\": [     {       \"module_name\": \"@minecraft/server\",       \"version\": \"1.13.0-beta\"     },     {       \"module_name\": \"@minecraft/server-gametest\",       \"version\": \"1.0.0-beta\"     }   ] }  GameTest Registration  Every GameTest needs a script file. As you saw in the previous section, we added a module with an entry attribute that points at a JavaScript file:  JSON Copy         \"entry\": \"scripts/StarterTests.js\"   When a GameTest Framework-enabled world opens with this file registered, your GameTest JavaScript file will load and execute. Here, the main role for your code is to register downstream GameTests.  Note that as you make changes to your scripts or structures, you will need to exit out of your world and reload it. If there are any script errors, you will see them displayed as the world is loaded.  To register your GameTest scripts, you'll want to use the RegistrationBuilder class. You can see more information on the Registration Builder class at Registration Builder.  An example line of JavaScript that uses RegistrationBuilder looks like:  JavaScript Copy GameTest.register(\"StarterTests\", \"simpleMobTest\", simpleMobTest)         .maxTicks(410)         .structureName(\"startertests:mediumglass\"); /* use the mediumglass.mcstructure file */   This line of code establishes a new test called simpleMobTest within the StarterTests test group. It adds an additional parameter (maxTicks) that expresses this test may take 410 ticks (20.5 seconds) to run. Finally, the GameTest specifies a MCStructure (startertests:mediumglass). By convention, this causes Minecraft to use an MCStructure file at /structures/startertests/mediumglass.mcstructure within your behavior pack folder.  The rest of the JavaScript uses the GameTest Helper class to actually express the test within a simpleMobTest function.  Test Functions  Test functions are where the actual execution of a test happens. The test function both sets up initial conditions for a test to run, and returns an additional test function where criteria is evaluated.  Sample Test:  JavaScript Copy import * as GameTest from \"@minecraft/server-gametest\";  function simpleMobTest(test) {   const foxId = \"fox\";   const chickenId = \"chicken\";      test.spawn(foxId, { x: 5, y: 2, z: 5 });   test.spawn(chickenId, { x: 2, y: 2, z: 2 });      test.assertEntityPresentInArea(chickenId, true);      test.succeedWhen(() => {     test.assertEntityPresentInArea(chickenId, false);   }); }   Some things to observe in this test function:  You can use the spawn method to create new mobs in your test. Coordinates used in APIs like spawn are relative to the structure block of your .MCStructure. assert functions cause code execution to stop if the conditions described in the method are not true. Here, this code asserts that a chicken entity is no longer in the structure (the false in the method assertEntityPresentInArea tells the function to assert that the entity is no longer there). If one is found within any of the blocks in the structure, the assert code will throw an error. However, if no chicken is found, we make our way to the test.succeed line of code, and the test passes.  The full JavaScript StarterTests.js file looks like:  JavaScript Copy import * as GameTest from \"@minecraft/server-gametest\";  function simpleMobTest(test) {   const foxId = \"fox\";   const chickenId = \"chicken\";      test.spawn(foxId, { x: 5, y: 2, z: 5 });   test.spawn(chickenId, { x: 2, y: 2, z: 2 });      test.assertEntityPresentInArea(chickenId, true);      test.succeedWhen(() => {     test.assertEntityPresentInArea(chickenId, false);   }); }  GameTest.register(\"StarterTests\", \"simpleMobTest\", simpleMobTest)   .maxTicks(410)   .structureName(\"startertests:mediumglass\"); /* use the mediumglass.mcstructure file */   To finish the sample, you will want to use a structure block to define the test.  To do this, open up Minecraft and start a new world in Creative mode to build your environment. This is a simple glass pen that was built for our GameTest, made from glass blocks:  Next, you will want to export this as a structure. Run the following command in Minecraft:  /give @s structure_block  This will give you a structure block to work with. Place a structure block next to your creation, and use the Structure Block popup to frame your creation. Export this as mediumglass.mcstructure.  In your behavior pack, go to your structures folder and create a subfolder called startertests.  Place this mediumglass.mcstructure file within a subfolder called startertests. Make sure that you match the casing you specified in your JavaScript code, so make it all lower-case. Copy the mediumglass.mcstructure file to that folder. Your folder should look like this:  Running your tests within the game  Once you have completed your GameTest behavior pack, you'll want to try it out within Minecraft. To do this, create a new Minecraft world. For this new world, you'll want to start in Creative mode and turn the Beta APIs experiment on. You'll want to add the GameTest Behavior Packs in your world. If everything is correct, you should see the Start Hello World GameTest behavior pack when you create your world:  Click on the Starter Hello World behavior packs tile to activate it.   Important  You'll also likely want to specify some additional changes in your environment:  Selecting a Flat world Retain Normal difficulty (mobs work differently in completely Peaceful worlds)  Once the world is loaded, use the /gametest command to run tests.  To run a specific test, use /gametest run <classname>:<testName>, like:  /gametest run startertests:simpleMobTest  What's Next  You've created your first GameTest Framework test. GameTests allow you, as a creator, to stretch your content, exercise your entities, and validate your gameplay mechanics. You can view the GameTest API below to learn more about what is included in the GameTest Framework.  GameTest API  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gametestbuildyourfirstgametest?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Building your first GameTest 06/20/2024 What's in a GameTest?  A GameTest is a miniature environment along with a set of starting conditions, such as a set of mobs or items. After that environment plays out in the Minecraft world for a little while, you can run conditional code to evaluate that your expectations were met.  Building sets of GameTests requires building out your GameTests via a behavior Pack, and writing some simple JavaScript code.   Important  GameTest Framework is still experimental. As with all experiments, you may see additions, removals, and changes in functionality in Minecraft versions without significant advanced warning. Check the Minecraft Changelog for details on any changes to Beta APIs or GameTest Framework.  To learn more about Experimental Features, please visit Experimental Features in Minecraft: Bedrock Edition.   Caution  Because GameTest Framework is adding and updating functionality frequently, we recommend using the latest Beta versions of Minecraft. See Minecraft Betas for more information. The syntax of this sample is intended to be compatible with the latest beta versions.  Requirements  It's recommended that the following be completed before beginning this tutorial.  Introduction to Behavior Packs GameTest Elements  Within a behavior pack, every GameTest consists of a few elements:  A structure which defines the physical environment for the test as well as any starting entities. Within Minecraft, you can create new structures by designing them out (typically in Creative Mode) and then placing a structure block nearby. You can then use the structure block to save out the results to disk. This creates a .mcstructure file which you can add to your test.  When GameTests are run in Minecraft, your structure will be loaded and expanded into Minecraft. You should note that this structure will be created and run in a generally flat, broader world, so you'll want to ensure that any mobs are penned into the structures you create.  GameTests then use JavaScript code to define the test, including:  Test registration: a small amount of code to establish a test in the environment.  Test setup: additional code that sets up conditions within the Structure environment that has been created. Typically, this will be the creation of additional mobs.  Test validation: additional code snippets written in JavaScript that evaluates whether a test has completed successfully or has failed.  With this simple foundation, GameTests can be created with a few lines of JavaScript code plus a Minecraft structure.  Start building your own tests   Note  A completed version of this tutorial is available on GitHub, at https://github.com/microsoft/minecraft-gametests. You can use this sample to compare against your sample, or if you just want to see what this looks like when completed.  Within the startertests folder, you'll also want to include two subfolders:  structures for holding MCStructure files scripts for holding JavaScript files Update your manifest  You can start a behavior pack manifest with a manifest.json file within your startertests folder, as follows:  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Introductory tests for Minecraft GameTest Framework.\",     \"name\": \"Starter Hello World Tests\",     \"uuid\": \"afeeb2ab-0404-4518-822f-9837117e78e1\",     \"version\": [       1,       0,       0     ],     \"min_engine_version\": [       1,       21,       0     ]   } }   A behavior pack manifest needs to have additional elements to support GameTests. The modules section needs one module, added beneath the header section, that registers your JavaScript code entry point, as follows:  JSON Copy   \"modules\": [     {       \"description\": \"Script that implements basic starter tests.\",       \"type\": \"script\",       \"language\": \"javascript\",       \"uuid\": \"ead57a90-41fc-4f3b-8e1a-ccc64c99da0c\",       \"version\": [         1,         0,         0       ],       \"entry\": \"scripts/StarterTests.js\"     }   ]   Note several facets of this module:  This module is of type script. The uuid needs to be unique and generated for your project. See the Introduction To Behavior Packs topic for tools for generating new UUIDs. The entry attribute points to a JavaScript file that contains your GameTest code.  In addition, you will need to establish dependencies on Minecraft APIs and GameTest Framework. You can do this with additional dependencies added beneath the modules section below:  JSON Copy   \"dependencies\": [     {       \"module_name\": \"@minecraft/server\",       \"version\": \"1.13.0-beta\"     },     {       \"module_name\": \"@minecraft/server-gametest\",       \"version\": \"1.0.0-beta\"     }   ]    Important  As you can see, GameTest Framework tests dependent on versions \"1.13.0-beta\" of Minecraft APIs and GameTest Framework. Beta versions indicate that these features are still experimental. As with all experiments, we are improving their capabilities over time, and API signatures may change build over build without advanced notice. Check the Minecraft Changelog for more changes over time.  A full manifest file for a Behavior Pack with a GameTest looks like:  JSON Copy {   \"format_version\": 2,   \"header\": {     \"description\": \"Introductory tests for Minecraft GameTest Framework.\",     \"name\": \"Starter Hello World Tests\",     \"uuid\": \"afeeb2ab-0404-4518-822f-9837117e78e1\",     \"version\": [       1,       0,       0     ],     \"min_engine_version\": [       1,       21,       0     ]   },   \"modules\": [     {       \"description\": \"Script that implements basic starter tests.\",       \"type\": \"script\",       \"language\": \"javascript\",       \"uuid\": \"ead57a90-41fc-4f3b-8e1a-ccc64c99da0c\",       \"version\": [         1,         0,         0       ],       \"entry\": \"scripts/StarterTests.js\"     }   ],   \"dependencies\": [     {       \"module_name\": \"@minecraft/server\",       \"version\": \"1.13.0-beta\"     },     {       \"module_name\": \"@minecraft/server-gametest\",       \"version\": \"1.0.0-beta\"     }   ] }  GameTest Registration  Every GameTest needs a script file. As you saw in the previous section, we added a module with an entry attribute that points at a JavaScript file:  JSON Copy         \"entry\": \"scripts/StarterTests.js\"   When a GameTest Framework-enabled world opens with this file registered, your GameTest JavaScript file will load and execute. Here, the main role for your code is to register downstream GameTests.  Note that as you make changes to your scripts or structures, you will need to exit out of your world and reload it. If there are any script errors, you will see them displayed as the world is loaded.  To register your GameTest scripts, you'll want to use the RegistrationBuilder class. You can see more information on the Registration Builder class at Registration Builder.  An example line of JavaScript that uses RegistrationBuilder looks like:  JavaScript Copy GameTest.register(\"StarterTests\", \"simpleMobTest\", simpleMobTest)         .maxTicks(410)         .structureName(\"startertests:mediumglass\"); /* use the mediumglass.mcstructure file */   This line of code establishes a new test called simpleMobTest within the StarterTests test group. It adds an additional parameter (maxTicks) that expresses this test may take 410 ticks (20.5 seconds) to run. Finally, the GameTest specifies a MCStructure (startertests:mediumglass). By convention, this causes Minecraft to use an MCStructure file at /structures/startertests/mediumglass.mcstructure within your behavior pack folder.  The rest of the JavaScript uses the GameTest Helper class to actually express the test within a simpleMobTest function.  Test Functions  Test functions are where the actual execution of a test happens. The test function both sets up initial conditions for a test to run, and returns an additional test function where criteria is evaluated.  Sample Test:  JavaScript Copy import * as GameTest from \"@minecraft/server-gametest\";  function simpleMobTest(test) {   const foxId = \"fox\";   const chickenId = \"chicken\";      test.spawn(foxId, { x: 5, y: 2, z: 5 });   test.spawn(chickenId, { x: 2, y: 2, z: 2 });      test.assertEntityPresentInArea(chickenId, true);      test.succeedWhen(() => {     test.assertEntityPresentInArea(chickenId, false);   }); }   Some things to observe in this test function:  You can use the spawn method to create new mobs in your test. Coordinates used in APIs like spawn are relative to the structure block of your .MCStructure. assert functions cause code execution to stop if the conditions described in the method are not true. Here, this code asserts that a chicken entity is no longer in the structure (the false in the method assertEntityPresentInArea tells the function to assert that the entity is no longer there). If one is found within any of the blocks in the structure, the assert code will throw an error. However, if no chicken is found, we make our way to the test.succeed line of code, and the test passes.  The full JavaScript StarterTests.js file looks like:  JavaScript Copy import * as GameTest from \"@minecraft/server-gametest\";  function simpleMobTest(test) {   const foxId = \"fox\";   const chickenId = \"chicken\";      test.spawn(foxId, { x: 5, y: 2, z: 5 });   test.spawn(chickenId, { x: 2, y: 2, z: 2 });      test.assertEntityPresentInArea(chickenId, true);      test.succeedWhen(() => {     test.assertEntityPresentInArea(chickenId, false);   }); }  GameTest.register(\"StarterTests\", \"simpleMobTest\", simpleMobTest)   .maxTicks(410)   .structureName(\"startertests:mediumglass\"); /* use the mediumglass.mcstructure file */   To finish the sample, you will want to use a structure block to define the test.  To do this, open up Minecraft and start a new world in Creative mode to build your environment. This is a simple glass pen that was built for our GameTest, made from glass blocks:  Next, you will want to export this as a structure. Run the following command in Minecraft:  /give @s structure_block  This will give you a structure block to work with. Place a structure block next to your creation, and use the Structure Block popup to frame your creation. Export this as mediumglass.mcstructure.  In your behavior pack, go to your structures folder and create a subfolder called startertests.  Place this mediumglass.mcstructure file within a subfolder called startertests. Make sure that you match the casing you specified in your JavaScript code, so make it all lower-case. Copy the mediumglass.mcstructure file to that folder. Your folder should look like this:  Running your tests within the game  Once you have completed your GameTest behavior pack, you'll want to try it out within Minecraft. To do this, create a new Minecraft world. For this new world, you'll want to start in Creative mode and turn the Beta APIs experiment on. You'll want to add the GameTest Behavior Packs in your world. If everything is correct, you should see the Start Hello World GameTest behavior pack when you create your world:  Click on the Starter Hello World behavior packs tile to activate it.   Important  You'll also likely want to specify some additional changes in your environment:  Selecting a Flat world Retain Normal difficulty (mobs work differently in completely Peaceful worlds)  Once the world is loaded, use the /gametest command to run tests.  To run a specific test, use /gametest run <classname>:<testName>, like:  /gametest run startertests:simpleMobTest  What's Next  You've created your first GameTest Framework test. GameTests allow you, as a creator, to stretch your content, exercise your entities, and validate your gameplay mechanics. You can view the GameTest API below to learn more about what is included in the GameTest Framework.  GameTest API  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/editoroverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Overview 12/04/2024  This overview is intended to introduce you to the parts of the Editor interface and the tools. The keyboard shortcuts, also known as keybindings, have been provided with each tool and in the table at the end of this document.  For a more in-depth experience using the tools to accomplish basic tasks, take a look at the Editor Tutorial.  There's more information about Editor on the Minecraft: Bedrock Editor GitHub site!   Important  The Editor is in beta and we're working to add more capabilities. It will continue to change as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  In this manual, you will learn the following:  What the difference is between a project and a world How to create a project How to customize the user interface and project world settings What all the parts of the UI are and where to find them How to save a project How to open an existing project How to export a project as a world How to open a world created from a project Where Editor stores exported and saved files Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  It's recommended that the following be completed before beginning this tutorial.  How to get Minecraft Bedrock Editor Creating an Editor Project  After you launch Editor, you get a screen that says \"Create New Project.\"  While you're creating a project, you can configure the name, export settings, and the usual settings for a Minecraft world.  Export settings will apply when you export as a playable world from the Editor (.mcworld).  New projects load with a Welcome/Quick Start screen. If you close it and you want it open again, go to the Help menu and select Quick Start.  First Things First: UI Settings  Editor looks like your usual Minecraft game with a user interface (UI) on top of it. Before we get started, let's make sure that UI looks okay for your monitor resolution and preferences.  Go to the File menu and select UI Settings.  UI Scale - Makes the menu bar and windows larger or smaller in relation to the project world. Font - Changes the size of the text in the windows. Theme - Changes the colors used in the UI.  After you make a selection from the UI Settings menu, your changes are reflected immediately.  Hint: If you accidentally adjust things to where you can't read the settings to fix it, press the Alt F4 keys on your keyboard to close Editor. Then, launch Editor again and create a new project. (This is part of why we're doing this first.)  Editor works with Minecraft Accessibility features.  When you're happy with the UI Settings, you can click the X to close the UI Settings window.  Editor UI Windows: Move, Minimize, Close  You can move Editor windows by clicking and dragging them by the title bar.  Click the double \"up arrows\" in the corner to collapse the windows upwards so you can tuck them out of the way if you don't want to close them.  If you do want to close the window, click the X in the corner. Some windows can be re-opened with a keyboard shortcut.  Welcome/Quick Start  Expand table Tab\tContent Introduction\tWelcome to the Minecraft Editor Beta, a tool designed to help you create stunning worlds in Bedrock with ease.  You may find these links helpful on your journey:   Documentation Report problems and give feedback Editor Community  To reopen Quick Start, you can find it under the 'Help' menu. Movement\tTo navigate in the Editor, you'll need a keyboard and mouse. Trackpads or controllers aren't recommended.  To move around in Editor:   Hold down the right mouse button to look around. While holding the right mouse button, move horizontally with WASD and vertically with SHIFT and SPACE.  Tools\tYou can find tools on the left rail. Each tool allows you to edit your world in different ways.  Click on the Information button (\"i\") at the top right corner of each tool to learn more about how it works. Actions\tActions are shortcuts that live at the top of your screen. Hit the “+” button in the Action Bar to customize which are displayed.  At the top center of your screen is the Block Hotbar. Click once to change the active block, click twice to open the Block Picker to customize the Hotbar.  You can create a new Hotbar by clicking the Hotbar Menu button to the right. \t Movement  Before we dive into the Tool Mode UI, you might want to take a moment to familiarize yourself with how to look around and move around in the different modes.  Unlock the camera: In Tool mode, hold down the right mouse button to look around. In Crosshair Mode, you do not need to hold down the right mouse button.  Moving around: In Tool Mode, hold the right mouse button down while you press W, A, S, D, Space, and Shift keys. You do not need to hold down the right mouse button to use the same keys to move around in Crosshair Mode.  Fly Speed: In Tool Mode, click the View menu and select View Settings to open the View Settings panel. From here, you can set your fly speed from 1 to 10 so that you can navigate your project faster.  Look-to-teleport: In Tool Mode, point your cursor at a block in the distance, and hit G on your keyboard. You will be \"Grapple teleported\" there. This function does not work in Crosshair Mode.  Directional Compass: In the upper-right corner of the editor window, the directional compass will show you which cardinal direction you are facing. You can even click a direction to snap your view to face it.  Editor and Bedrock Dedicated Server  Editor is only enabled in the preview version of Win32 Bedrock Dedicated Server (BDS). There are two ways to launch it:  Launch the .exe with the command line, like this:  bedrock_server.exe Editor=true  This will only work if you're launching BDS from scratch with no existing world.  You should see the output say:  Copy ##################################################### #                                                   # #              CREATING EDITOR PROJECT              # #                                                   # #####################################################  Create an Editor project from Minecraft Launch Editor from the usual desktop shortcut. Create a new Editor Project. Locate the Editor Project in the com.mojang/minecraftWorlds folder and copy it into the BDS worlds folder Ensure that server.properties has the correct world name. Execute bedrock_server.exe.  If correctly set up, you should see the output say  [2023-10-24 07:21:43:977 INFO] Enabling Editor Services  Editor Mode is controlled by a flag in the level data (not by the command line), so you need to launch the server either by having the server create a new Editor project, or by launching the server using an existing Editor project.  When the server is up and running, any client connections from Minecraft Bedrock Edition will connect as editor sessions and present the editor interface. If using a Preview version, connections from Non-Preview editions of Minecraft will be refused.  What's Next?  Now that you know more about the parts of Editor, let's use the tools to do some editing!  Editor Tutorial  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/editoroverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Overview 12/04/2024  This overview is intended to introduce you to the parts of the Editor interface and the tools. The keyboard shortcuts, also known as keybindings, have been provided with each tool and in the table at the end of this document.  For a more in-depth experience using the tools to accomplish basic tasks, take a look at the Editor Tutorial.  There's more information about Editor on the Minecraft: Bedrock Editor GitHub site!   Important  The Editor is in beta and we're working to add more capabilities. It will continue to change as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  In this manual, you will learn the following:  What the difference is between a project and a world How to create a project How to customize the user interface and project world settings What all the parts of the UI are and where to find them How to save a project How to open an existing project How to export a project as a world How to open a world created from a project Where Editor stores exported and saved files Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  It's recommended that the following be completed before beginning this tutorial.  How to get Minecraft Bedrock Editor Creating an Editor Project  After you launch Editor, you get a screen that says \"Create New Project.\"  While you're creating a project, you can configure the name, export settings, and the usual settings for a Minecraft world.  Export settings will apply when you export as a playable world from the Editor (.mcworld).  New projects load with a Welcome/Quick Start screen. If you close it and you want it open again, go to the Help menu and select Quick Start.  First Things First: UI Settings  Editor looks like your usual Minecraft game with a user interface (UI) on top of it. Before we get started, let's make sure that UI looks okay for your monitor resolution and preferences.  Go to the File menu and select UI Settings.  UI Scale - Makes the menu bar and windows larger or smaller in relation to the project world. Font - Changes the size of the text in the windows. Theme - Changes the colors used in the UI.  After you make a selection from the UI Settings menu, your changes are reflected immediately.  Hint: If you accidentally adjust things to where you can't read the settings to fix it, press the Alt F4 keys on your keyboard to close Editor. Then, launch Editor again and create a new project. (This is part of why we're doing this first.)  Editor works with Minecraft Accessibility features.  When you're happy with the UI Settings, you can click the X to close the UI Settings window.  Editor UI Windows: Move, Minimize, Close  You can move Editor windows by clicking and dragging them by the title bar.  Click the double \"up arrows\" in the corner to collapse the windows upwards so you can tuck them out of the way if you don't want to close them.  If you do want to close the window, click the X in the corner. Some windows can be re-opened with a keyboard shortcut.  Welcome/Quick Start  Expand table Tab\tContent Introduction\tWelcome to the Minecraft Editor Beta, a tool designed to help you create stunning worlds in Bedrock with ease.  You may find these links helpful on your journey:   Documentation Report problems and give feedback Editor Community  To reopen Quick Start, you can find it under the 'Help' menu. Movement\tTo navigate in the Editor, you'll need a keyboard and mouse. Trackpads or controllers aren't recommended.  To move around in Editor:   Hold down the right mouse button to look around. While holding the right mouse button, move horizontally with WASD and vertically with SHIFT and SPACE.  Tools\tYou can find tools on the left rail. Each tool allows you to edit your world in different ways.  Click on the Information button (\"i\") at the top right corner of each tool to learn more about how it works. Actions\tActions are shortcuts that live at the top of your screen. Hit the “+” button in the Action Bar to customize which are displayed.  At the top center of your screen is the Block Hotbar. Click once to change the active block, click twice to open the Block Picker to customize the Hotbar.  You can create a new Hotbar by clicking the Hotbar Menu button to the right. \t Movement  Before we dive into the Tool Mode UI, you might want to take a moment to familiarize yourself with how to look around and move around in the different modes.  Unlock the camera: In Tool mode, hold down the right mouse button to look around. In Crosshair Mode, you do not need to hold down the right mouse button.  Moving around: In Tool Mode, hold the right mouse button down while you press W, A, S, D, Space, and Shift keys. You do not need to hold down the right mouse button to use the same keys to move around in Crosshair Mode.  Fly Speed: In Tool Mode, click the View menu and select View Settings to open the View Settings panel. From here, you can set your fly speed from 1 to 10 so that you can navigate your project faster.  Look-to-teleport: In Tool Mode, point your cursor at a block in the distance, and hit G on your keyboard. You will be \"Grapple teleported\" there. This function does not work in Crosshair Mode.  Directional Compass: In the upper-right corner of the editor window, the directional compass will show you which cardinal direction you are facing. You can even click a direction to snap your view to face it.  Editor and Bedrock Dedicated Server  Editor is only enabled in the preview version of Win32 Bedrock Dedicated Server (BDS). There are two ways to launch it:  Launch the .exe with the command line, like this:  bedrock_server.exe Editor=true  This will only work if you're launching BDS from scratch with no existing world.  You should see the output say:  Copy ##################################################### #                                                   # #              CREATING EDITOR PROJECT              # #                                                   # #####################################################  Create an Editor project from Minecraft Launch Editor from the usual desktop shortcut. Create a new Editor Project. Locate the Editor Project in the com.mojang/minecraftWorlds folder and copy it into the BDS worlds folder Ensure that server.properties has the correct world name. Execute bedrock_server.exe.  If correctly set up, you should see the output say  [2023-10-24 07:21:43:977 INFO] Enabling Editor Services  Editor Mode is controlled by a flag in the level data (not by the command line), so you need to launch the server either by having the server create a new Editor project, or by launching the server using an existing Editor project.  When the server is up and running, any client connections from Minecraft Bedrock Edition will connect as editor sessions and present the editor interface. If using a Preview version, connections from Non-Preview editions of Minecraft will be refused.  What's Next?  Now that you know more about the parts of Editor, let's use the tools to do some editing!  Editor Tutorial  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Bedrock Editor  Content related to Bedrock Editor.  Learn about Bedrock Editor OVERVIEW Editor Overview Tool Mode World Options Action Bar Action Bar Settings Paste Preview Tools REFERENCE Selection Tool Brush Tool Extrude Tool Farm Tool Fill Tool Flatten Tool Repeater Tool Terrain Tool Summon Tool Inspectors and Panels REFERENCE Block Inspector Entity Inspector Structures Workbench Working with Bedrock Editor GET STARTED Installation Keyboard Inputs and Input Mapping Tutorial Editor Create, Import, Export a World Editor Extensions Introduction"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Bedrock Editor  Content related to Bedrock Editor.  Learn about Bedrock Editor OVERVIEW Editor Overview Tool Mode World Options Action Bar Action Bar Settings Paste Preview Tools REFERENCE Selection Tool Brush Tool Extrude Tool Farm Tool Fill Tool Flatten Tool Repeater Tool Terrain Tool Summon Tool Inspectors and Panels REFERENCE Block Inspector Entity Inspector Structures Workbench Working with Bedrock Editor GET STARTED Installation Keyboard Inputs and Input Mapping Tutorial Editor Create, Import, Export a World Editor Extensions Introduction"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editoroverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Overview 12/04/2024  This overview is intended to introduce you to the parts of the Editor interface and the tools. The keyboard shortcuts, also known as keybindings, have been provided with each tool and in the table at the end of this document.  For a more in-depth experience using the tools to accomplish basic tasks, take a look at the Editor Tutorial.  There's more information about Editor on the Minecraft: Bedrock Editor GitHub site!   Important  The Editor is in beta and we're working to add more capabilities. It will continue to change as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  In this manual, you will learn the following:  What the difference is between a project and a world How to create a project How to customize the user interface and project world settings What all the parts of the UI are and where to find them How to save a project How to open an existing project How to export a project as a world How to open a world created from a project Where Editor stores exported and saved files Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  It's recommended that the following be completed before beginning this tutorial.  How to get Minecraft Bedrock Editor Creating an Editor Project  After you launch Editor, you get a screen that says \"Create New Project.\"  While you're creating a project, you can configure the name, export settings, and the usual settings for a Minecraft world.  Export settings will apply when you export as a playable world from the Editor (.mcworld).  New projects load with a Welcome/Quick Start screen. If you close it and you want it open again, go to the Help menu and select Quick Start.  First Things First: UI Settings  Editor looks like your usual Minecraft game with a user interface (UI) on top of it. Before we get started, let's make sure that UI looks okay for your monitor resolution and preferences.  Go to the File menu and select UI Settings.  UI Scale - Makes the menu bar and windows larger or smaller in relation to the project world. Font - Changes the size of the text in the windows. Theme - Changes the colors used in the UI.  After you make a selection from the UI Settings menu, your changes are reflected immediately.  Hint: If you accidentally adjust things to where you can't read the settings to fix it, press the Alt F4 keys on your keyboard to close Editor. Then, launch Editor again and create a new project. (This is part of why we're doing this first.)  Editor works with Minecraft Accessibility features.  When you're happy with the UI Settings, you can click the X to close the UI Settings window.  Editor UI Windows: Move, Minimize, Close  You can move Editor windows by clicking and dragging them by the title bar.  Click the double \"up arrows\" in the corner to collapse the windows upwards so you can tuck them out of the way if you don't want to close them.  If you do want to close the window, click the X in the corner. Some windows can be re-opened with a keyboard shortcut.  Welcome/Quick Start  Expand table Tab\tContent Introduction\tWelcome to the Minecraft Editor Beta, a tool designed to help you create stunning worlds in Bedrock with ease.  You may find these links helpful on your journey:   Documentation Report problems and give feedback Editor Community  To reopen Quick Start, you can find it under the 'Help' menu. Movement\tTo navigate in the Editor, you'll need a keyboard and mouse. Trackpads or controllers aren't recommended.  To move around in Editor:   Hold down the right mouse button to look around. While holding the right mouse button, move horizontally with WASD and vertically with SHIFT and SPACE.  Tools\tYou can find tools on the left rail. Each tool allows you to edit your world in different ways.  Click on the Information button (\"i\") at the top right corner of each tool to learn more about how it works. Actions\tActions are shortcuts that live at the top of your screen. Hit the “+” button in the Action Bar to customize which are displayed.  At the top center of your screen is the Block Hotbar. Click once to change the active block, click twice to open the Block Picker to customize the Hotbar.  You can create a new Hotbar by clicking the Hotbar Menu button to the right. \t Movement  Before we dive into the Tool Mode UI, you might want to take a moment to familiarize yourself with how to look around and move around in the different modes.  Unlock the camera: In Tool mode, hold down the right mouse button to look around. In Crosshair Mode, you do not need to hold down the right mouse button.  Moving around: In Tool Mode, hold the right mouse button down while you press W, A, S, D, Space, and Shift keys. You do not need to hold down the right mouse button to use the same keys to move around in Crosshair Mode.  Fly Speed: In Tool Mode, click the View menu and select View Settings to open the View Settings panel. From here, you can set your fly speed from 1 to 10 so that you can navigate your project faster.  Look-to-teleport: In Tool Mode, point your cursor at a block in the distance, and hit G on your keyboard. You will be \"Grapple teleported\" there. This function does not work in Crosshair Mode.  Directional Compass: In the upper-right corner of the editor window, the directional compass will show you which cardinal direction you are facing. You can even click a direction to snap your view to face it.  Editor and Bedrock Dedicated Server  Editor is only enabled in the preview version of Win32 Bedrock Dedicated Server (BDS). There are two ways to launch it:  Launch the .exe with the command line, like this:  bedrock_server.exe Editor=true  This will only work if you're launching BDS from scratch with no existing world.  You should see the output say:  Copy ##################################################### #                                                   # #              CREATING EDITOR PROJECT              # #                                                   # #####################################################  Create an Editor project from Minecraft Launch Editor from the usual desktop shortcut. Create a new Editor Project. Locate the Editor Project in the com.mojang/minecraftWorlds folder and copy it into the BDS worlds folder Ensure that server.properties has the correct world name. Execute bedrock_server.exe.  If correctly set up, you should see the output say  [2023-10-24 07:21:43:977 INFO] Enabling Editor Services  Editor Mode is controlled by a flag in the level data (not by the command line), so you need to launch the server either by having the server create a new Editor project, or by launching the server using an existing Editor project.  When the server is up and running, any client connections from Minecraft Bedrock Edition will connect as editor sessions and present the editor interface. If using a Preview version, connections from Non-Preview editions of Minecraft will be refused.  What's Next?  Now that you know more about the parts of Editor, let's use the tools to do some editing!  Editor Tutorial  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editoroverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Overview 12/04/2024  This overview is intended to introduce you to the parts of the Editor interface and the tools. The keyboard shortcuts, also known as keybindings, have been provided with each tool and in the table at the end of this document.  For a more in-depth experience using the tools to accomplish basic tasks, take a look at the Editor Tutorial.  There's more information about Editor on the Minecraft: Bedrock Editor GitHub site!   Important  The Editor is in beta and we're working to add more capabilities. It will continue to change as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  In this manual, you will learn the following:  What the difference is between a project and a world How to create a project How to customize the user interface and project world settings What all the parts of the UI are and where to find them How to save a project How to open an existing project How to export a project as a world How to open a world created from a project Where Editor stores exported and saved files Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  It's recommended that the following be completed before beginning this tutorial.  How to get Minecraft Bedrock Editor Creating an Editor Project  After you launch Editor, you get a screen that says \"Create New Project.\"  While you're creating a project, you can configure the name, export settings, and the usual settings for a Minecraft world.  Export settings will apply when you export as a playable world from the Editor (.mcworld).  New projects load with a Welcome/Quick Start screen. If you close it and you want it open again, go to the Help menu and select Quick Start.  First Things First: UI Settings  Editor looks like your usual Minecraft game with a user interface (UI) on top of it. Before we get started, let's make sure that UI looks okay for your monitor resolution and preferences.  Go to the File menu and select UI Settings.  UI Scale - Makes the menu bar and windows larger or smaller in relation to the project world. Font - Changes the size of the text in the windows. Theme - Changes the colors used in the UI.  After you make a selection from the UI Settings menu, your changes are reflected immediately.  Hint: If you accidentally adjust things to where you can't read the settings to fix it, press the Alt F4 keys on your keyboard to close Editor. Then, launch Editor again and create a new project. (This is part of why we're doing this first.)  Editor works with Minecraft Accessibility features.  When you're happy with the UI Settings, you can click the X to close the UI Settings window.  Editor UI Windows: Move, Minimize, Close  You can move Editor windows by clicking and dragging them by the title bar.  Click the double \"up arrows\" in the corner to collapse the windows upwards so you can tuck them out of the way if you don't want to close them.  If you do want to close the window, click the X in the corner. Some windows can be re-opened with a keyboard shortcut.  Welcome/Quick Start  Expand table Tab\tContent Introduction\tWelcome to the Minecraft Editor Beta, a tool designed to help you create stunning worlds in Bedrock with ease.  You may find these links helpful on your journey:   Documentation Report problems and give feedback Editor Community  To reopen Quick Start, you can find it under the 'Help' menu. Movement\tTo navigate in the Editor, you'll need a keyboard and mouse. Trackpads or controllers aren't recommended.  To move around in Editor:   Hold down the right mouse button to look around. While holding the right mouse button, move horizontally with WASD and vertically with SHIFT and SPACE.  Tools\tYou can find tools on the left rail. Each tool allows you to edit your world in different ways.  Click on the Information button (\"i\") at the top right corner of each tool to learn more about how it works. Actions\tActions are shortcuts that live at the top of your screen. Hit the “+” button in the Action Bar to customize which are displayed.  At the top center of your screen is the Block Hotbar. Click once to change the active block, click twice to open the Block Picker to customize the Hotbar.  You can create a new Hotbar by clicking the Hotbar Menu button to the right. \t Movement  Before we dive into the Tool Mode UI, you might want to take a moment to familiarize yourself with how to look around and move around in the different modes.  Unlock the camera: In Tool mode, hold down the right mouse button to look around. In Crosshair Mode, you do not need to hold down the right mouse button.  Moving around: In Tool Mode, hold the right mouse button down while you press W, A, S, D, Space, and Shift keys. You do not need to hold down the right mouse button to use the same keys to move around in Crosshair Mode.  Fly Speed: In Tool Mode, click the View menu and select View Settings to open the View Settings panel. From here, you can set your fly speed from 1 to 10 so that you can navigate your project faster.  Look-to-teleport: In Tool Mode, point your cursor at a block in the distance, and hit G on your keyboard. You will be \"Grapple teleported\" there. This function does not work in Crosshair Mode.  Directional Compass: In the upper-right corner of the editor window, the directional compass will show you which cardinal direction you are facing. You can even click a direction to snap your view to face it.  Editor and Bedrock Dedicated Server  Editor is only enabled in the preview version of Win32 Bedrock Dedicated Server (BDS). There are two ways to launch it:  Launch the .exe with the command line, like this:  bedrock_server.exe Editor=true  This will only work if you're launching BDS from scratch with no existing world.  You should see the output say:  Copy ##################################################### #                                                   # #              CREATING EDITOR PROJECT              # #                                                   # #####################################################  Create an Editor project from Minecraft Launch Editor from the usual desktop shortcut. Create a new Editor Project. Locate the Editor Project in the com.mojang/minecraftWorlds folder and copy it into the BDS worlds folder Ensure that server.properties has the correct world name. Execute bedrock_server.exe.  If correctly set up, you should see the output say  [2023-10-24 07:21:43:977 INFO] Enabling Editor Services  Editor Mode is controlled by a flag in the level data (not by the command line), so you need to launch the server either by having the server create a new Editor project, or by launching the server using an existing Editor project.  When the server is up and running, any client connections from Minecraft Bedrock Edition will connect as editor sessions and present the editor interface. If using a Preview version, connections from Non-Preview editions of Minecraft will be refused.  What's Next?  Now that you know more about the parts of Editor, let's use the tools to do some editing!  Editor Tutorial  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorinstallation?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn How to get Minecraft Editor 12/06/2024  Minecraft's Bedrock Editor is a multiblock editing experience that helps you easily craft high-quality worlds in Minecraft Bedrock. The Editor is available in Retail and Preview editions of Minecraft Bedrock. You can access the Editor either through the Minecraft Launcher or a shortcut you create on your computer desktop.   Important  The Editor is in Beta and we're working to add more capabilities. It will change significantly as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  First, we are going to install Minecraft Bedrock. Then, we will create the shortcut that launches Editor. After that, we will open Editor and make sure it works.  In this tutorial, you will learn the following:  How to install Minecraft. How to create the shortcut that launches Editor. How to tell if everything is working correctly. Requirements  To get started, you need the following:  A Windows 10 (or higher) computer Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  Install Bedrock  The Bedrock Editor is a seperate mode of Bedrock. So if you already have Bedrock, you already have the Editor. If you do not, you will need the latest installation of Bedrock Retail and/or Preview. To learn more about what Preview is and where to get it, here is an article about Preview on Minecraft.net.  The easiest way to install either of these versions is from the Minecraft Launcher. You can get Minecraft Launcher from the Microsoft Store.  Once you have the Minecraft Launcher installed, navigate to the \"Creator Tools\" tab. From here you can install Retail and Preview versions of Bedrock.  To switch what version you are targeting, select the version from the drop down.  After you install Bedrock, the Launcher will update with a \"Create\" button under the \"Creator Tools\" tab.  To Launch Editor simply click the \"Create\" button and the Launcher will open Bedrock in Editor mode.  Make a Shortcut  Alternatively, if you already have Bedrock installed and want to create a shortcut to make accessing Editor easier in the future, follow these steps.  Right-click on your desktop, select New from the dropdown, and choose to create a new Shortcut.  For the location of the item, enter the following:  minecraft:?Editor=true  or  minecraft-preview:?Editor=true  This is case-sensitive and needs to match exactly.  Click Next and give your shortcut a name like Minecraft Editor.  Click Finish. Your Editor shortcut has been created!  You should see the shortcut created on your desktop and it should automatically have the Minecraft icon if you set it up correctly. If the icon does not populate, don't worry.  Double-click the shortcut to launch the Editor.  You should see Editor launch and display the \"Create New Project\" screen.  Great job! You're ready to create a project!   Note  If you uninstall Bedrock, but you plan on installing a newer version later, you can leave the Editor shortcut on your desktop and it should work with the new version.  Troubleshooting I can't get into the Editor when I open Minecraft  You can only access the Editor through the desktop shortcut and only if you have Bedrock. If you are attempting to access the Editor through Bedrock directly (not using the shortcut), it will not work.  I added the desktop shortcut, but it won't open the Editor. What's going on?  Three things to check:  Is the desktop shortcut set up correctly? Remember it is case-sensitive and needs to match exactly. Ensure it says the following: minecraft:?Editor=true.  Did you install Bedrock? If not, you need to do that.  Do you have both Bedrock Preview and Bedrock (Retail) installed? You may have selected a checkbox that says \"Always open\" for Bedrock (Retail) even if you are trying to open a Preview version. To fix this, perform the following steps:  Press Windows + I to open the Settings app.  Select Apps and click Default apps.  Scroll down to Minecraft and select it.  Scroll down and find the MINECRAFT entry (it should also say Minecraft | URL:minecraft) and click it.  In the pop-up, select Minecraft and click OK.  If you would like to open Editor a different way, you can open a file explorer window and enter minecraft:?Editor=true into the path:  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorinstallation?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn How to get Minecraft Editor 12/06/2024  Minecraft's Bedrock Editor is a multiblock editing experience that helps you easily craft high-quality worlds in Minecraft Bedrock. The Editor is available in Retail and Preview editions of Minecraft Bedrock. You can access the Editor either through the Minecraft Launcher or a shortcut you create on your computer desktop.   Important  The Editor is in Beta and we're working to add more capabilities. It will change significantly as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  First, we are going to install Minecraft Bedrock. Then, we will create the shortcut that launches Editor. After that, we will open Editor and make sure it works.  In this tutorial, you will learn the following:  How to install Minecraft. How to create the shortcut that launches Editor. How to tell if everything is working correctly. Requirements  To get started, you need the following:  A Windows 10 (or higher) computer Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  Install Bedrock  The Bedrock Editor is a seperate mode of Bedrock. So if you already have Bedrock, you already have the Editor. If you do not, you will need the latest installation of Bedrock Retail and/or Preview. To learn more about what Preview is and where to get it, here is an article about Preview on Minecraft.net.  The easiest way to install either of these versions is from the Minecraft Launcher. You can get Minecraft Launcher from the Microsoft Store.  Once you have the Minecraft Launcher installed, navigate to the \"Creator Tools\" tab. From here you can install Retail and Preview versions of Bedrock.  To switch what version you are targeting, select the version from the drop down.  After you install Bedrock, the Launcher will update with a \"Create\" button under the \"Creator Tools\" tab.  To Launch Editor simply click the \"Create\" button and the Launcher will open Bedrock in Editor mode.  Make a Shortcut  Alternatively, if you already have Bedrock installed and want to create a shortcut to make accessing Editor easier in the future, follow these steps.  Right-click on your desktop, select New from the dropdown, and choose to create a new Shortcut.  For the location of the item, enter the following:  minecraft:?Editor=true  or  minecraft-preview:?Editor=true  This is case-sensitive and needs to match exactly.  Click Next and give your shortcut a name like Minecraft Editor.  Click Finish. Your Editor shortcut has been created!  You should see the shortcut created on your desktop and it should automatically have the Minecraft icon if you set it up correctly. If the icon does not populate, don't worry.  Double-click the shortcut to launch the Editor.  You should see Editor launch and display the \"Create New Project\" screen.  Great job! You're ready to create a project!   Note  If you uninstall Bedrock, but you plan on installing a newer version later, you can leave the Editor shortcut on your desktop and it should work with the new version.  Troubleshooting I can't get into the Editor when I open Minecraft  You can only access the Editor through the desktop shortcut and only if you have Bedrock. If you are attempting to access the Editor through Bedrock directly (not using the shortcut), it will not work.  I added the desktop shortcut, but it won't open the Editor. What's going on?  Three things to check:  Is the desktop shortcut set up correctly? Remember it is case-sensitive and needs to match exactly. Ensure it says the following: minecraft:?Editor=true.  Did you install Bedrock? If not, you need to do that.  Do you have both Bedrock Preview and Bedrock (Retail) installed? You may have selected a checkbox that says \"Always open\" for Bedrock (Retail) even if you are trying to open a Preview version. To fix this, perform the following steps:  Press Windows + I to open the Settings app.  Select Apps and click Default apps.  Scroll down to Minecraft and select it.  Scroll down and find the MINECRAFT entry (it should also say Minecraft | URL:minecraft) and click it.  In the pop-up, select Minecraft and click OK.  If you would like to open Editor a different way, you can open a file explorer window and enter minecraft:?Editor=true into the path:  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editortutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Tutorial 05/07/2025  This tutorial is intended to guide you through using Minecraft Bedrock Editor to accomplish a variety of tasks. Before you begin, you should know how to launch Editor, create a project, move around, and switch between the two modes.   Important  The Editor is in preview and we're working to add more capabilities. It will change significantly as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is not available on mobile.  It's recommended that the following be completed before beginning this tutorial.  How to Get Minecraft Bedrock Editor  Bedrock Editor Overview  In this tutorial, you're going to learn how to build the Arc de Triomphe and instantly duplicate the structure to edit a world at massive scale. You'll only need two types of quartz block and a block of your choice to use as a visual guide.  Make the monument  Launch Minecraft Editor and find a relatively flat spot in the world.  Use the Selection tool to delete a large rectangle of terrain where you want to put the Arc de Triomphe. Make sure you delete an area of at least 99 x 99 to provide enough space for the final structure you'll build.   Use the Selection tool to create a 23 x 30 x 23 rectangular prism.   Double-click a block on the block picker and choose a quartz block, then press CTRL+F to fill the selection.  Change your target to Adjacent if it's not already, then select the top of one of the corner blocks of the monolith.   CTRL + click the corner block diagonal from the one you selected in the last step, then expand the selection one block along the X and Z axes on both corners. Fill the selection.   Select the top of the monument's corner block and use the Repeater to create a grid that repeats 12 times along the X and Z axes only.   Change the X and Z axis spacing to 2, then place the selection.  Use the Selection tool to delete all but the outermost repeated blocks, creating a border around the top of the monument.   (Optional) Select a line of 12 blocks from the bottom corner towards the center with a different block type of your choosing. Repeat the process vertically from the horizontal center point of the monument to mark the center block.   (Optional) Select and copy the blocks that make up the guides and use Paste Preview to rotate and copy the selection on all four faces of the monument.  Use the Block Picker to choose quartz stairs.  Use the Selection tool and change your target to Adjacent to select the corner block beneath the overhang at the top of the monument.  Double-click the selected block and drag the blue slider horizontally to the opposite corner, then press CTRL+F to fill the selection.   Use the Workbench to hover over the stairs and SHIFT+CTRL+CLICK to properly orient them.  Copy the stairs and use Paste Preview to place a row of stairs at the bottom and near the center of the monument face.  Use the Workbench to hover over the bottom row of stairs and SHIFT+CTRL+CLICK to properly orient them.  Use the Selection tool and change your target to Block to select and copy the three rows of stairs you just placed.  Use Paste Preview to copy the selection to the opposite face, then rotate the selection 90 degrees to repeat the process on the remaining two faces.  Carve the arc  Choose the Brush and select a uniform cylinder brush with a height of 12.   Use the Extrude tool to select Decrease Extrusion, then CTRL+ CLICK a monument face. Align the top of the preview with where you want the arc's apex to be.   Use the Selection tool to make a rectangle that extends to the bottom of the monument, then drag the slider through the monument to the opposite face.  Press DELETE to clear the rest of the blocks and complete the arc.   Repeat steps 2-4 on the other faces. You'll need to change the axis of extrusion.  Add some detail  Use the Block Picker to select quartz blocks, then use the Selection tool with your target set to Adjacent and place a rectangle that fills the space above the arc.  Switch your target to Block, then select and delete the interior quartz blocks of your new rectangle to create a border.   Set your target back to Adjacent, then place a border in one of the spaces on either side of the arc.   Copy the smaller border and use Paste Preview to paste it on the other side of the monument.  Set your target to block and select all three borders, then use Paste Preview to place the selection on the remaining three faces.   Use the Brush to select Single Block and set your target to Adjacent, then add details inside the borders of your Arc De Triomphe.   What's Next?  Select the entire structure, then use the Repeater to build at a massive scale!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editortutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Tutorial 05/07/2025  This tutorial is intended to guide you through using Minecraft Bedrock Editor to accomplish a variety of tasks. Before you begin, you should know how to launch Editor, create a project, move around, and switch between the two modes.   Important  The Editor is in preview and we're working to add more capabilities. It will change significantly as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is not available on mobile.  It's recommended that the following be completed before beginning this tutorial.  How to Get Minecraft Bedrock Editor  Bedrock Editor Overview  In this tutorial, you're going to learn how to build the Arc de Triomphe and instantly duplicate the structure to edit a world at massive scale. You'll only need two types of quartz block and a block of your choice to use as a visual guide.  Make the monument  Launch Minecraft Editor and find a relatively flat spot in the world.  Use the Selection tool to delete a large rectangle of terrain where you want to put the Arc de Triomphe. Make sure you delete an area of at least 99 x 99 to provide enough space for the final structure you'll build.   Use the Selection tool to create a 23 x 30 x 23 rectangular prism.   Double-click a block on the block picker and choose a quartz block, then press CTRL+F to fill the selection.  Change your target to Adjacent if it's not already, then select the top of one of the corner blocks of the monolith.   CTRL + click the corner block diagonal from the one you selected in the last step, then expand the selection one block along the X and Z axes on both corners. Fill the selection.   Select the top of the monument's corner block and use the Repeater to create a grid that repeats 12 times along the X and Z axes only.   Change the X and Z axis spacing to 2, then place the selection.  Use the Selection tool to delete all but the outermost repeated blocks, creating a border around the top of the monument.   (Optional) Select a line of 12 blocks from the bottom corner towards the center with a different block type of your choosing. Repeat the process vertically from the horizontal center point of the monument to mark the center block.   (Optional) Select and copy the blocks that make up the guides and use Paste Preview to rotate and copy the selection on all four faces of the monument.  Use the Block Picker to choose quartz stairs.  Use the Selection tool and change your target to Adjacent to select the corner block beneath the overhang at the top of the monument.  Double-click the selected block and drag the blue slider horizontally to the opposite corner, then press CTRL+F to fill the selection.   Use the Workbench to hover over the stairs and SHIFT+CTRL+CLICK to properly orient them.  Copy the stairs and use Paste Preview to place a row of stairs at the bottom and near the center of the monument face.  Use the Workbench to hover over the bottom row of stairs and SHIFT+CTRL+CLICK to properly orient them.  Use the Selection tool and change your target to Block to select and copy the three rows of stairs you just placed.  Use Paste Preview to copy the selection to the opposite face, then rotate the selection 90 degrees to repeat the process on the remaining two faces.  Carve the arc  Choose the Brush and select a uniform cylinder brush with a height of 12.   Use the Extrude tool to select Decrease Extrusion, then CTRL+ CLICK a monument face. Align the top of the preview with where you want the arc's apex to be.   Use the Selection tool to make a rectangle that extends to the bottom of the monument, then drag the slider through the monument to the opposite face.  Press DELETE to clear the rest of the blocks and complete the arc.   Repeat steps 2-4 on the other faces. You'll need to change the axis of extrusion.  Add some detail  Use the Block Picker to select quartz blocks, then use the Selection tool with your target set to Adjacent and place a rectangle that fills the space above the arc.  Switch your target to Block, then select and delete the interior quartz blocks of your new rectangle to create a border.   Set your target back to Adjacent, then place a border in one of the spaces on either side of the arc.   Copy the smaller border and use Paste Preview to paste it on the other side of the monument.  Set your target to block and select all three borders, then use Paste Preview to place the selection on the remaining three faces.   Use the Brush to select Single Block and set your target to Adjacent, then add details inside the borders of your Arc De Triomphe.   What's Next?  Select the entire structure, then use the Repeater to build at a massive scale!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editoractionbar?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Action Bar 08/29/2024  The Action Bar has quick functions like undo and redo that affect the things you do to the world, including some of the actions you can do in Crosshair Mode.  Expand table Command\tShortcut Undo\tCtrl Z Redo\tCtrl Y Attach Debugger\t- Input Mapping\t- Reload\t- Crosshair Mode\tCtrl Tab  To add an action to the bar, press the [+] on either the right or left side and choose the action you want to add to the bar from the menu. To remove an Action, click the little triangle in the lower left corner of the action and choose Clear from the drop-down menu.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editoractionbar?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Action Bar 08/29/2024  The Action Bar has quick functions like undo and redo that affect the things you do to the world, including some of the actions you can do in Crosshair Mode.  Expand table Command\tShortcut Undo\tCtrl Z Redo\tCtrl Y Attach Debugger\t- Input Mapping\t- Reload\t- Crosshair Mode\tCtrl Tab  To add an action to the bar, press the [+] on either the right or left side and choose the action you want to add to the bar from the menu. To remove an Action, click the little triangle in the lower left corner of the action and choose Clear from the drop-down menu.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorvibrantvisuals?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Vibrant Visuals in Bedrock Editor 06/11/2025  Vibrant Visuals (previously Advanced Rendering: Deferred Lighting) is a complete overhaul to the Minecraft graphics system that officially rolled out in Editor v1.0.  Open Minecraft Editor and add Vibrant Visuals to the Action Bar to get started, then select the graphical element you want to start editing.  When you click Generate Resource Pack, a link appears beneath the button that takes you to a template on mctools.dev for a new resource pack with the Vibrant Visuals settings you've configured.  Selecting Export to Clipboard copys the JSON of the current visual setting to your device's clipboard. You can use this to quickly modify parts of a resource pack without the need to generate a completely new one.   Tip  You can reset the current visual settings to the Editor default by clicking Revert Changes near the top of the Vibrant Visuals menu at any time.  Water  Water Settings Particle Concentration  Chromophoric Dissolved Organic Matter (CDOM)  Represents the organic matter suspended in the water. Increasing this value increases the strength of the organic matter’s blue wavelength absorption, turning the water yellow to yellow-brown (CDOM values range from 1 – 15).  Chlorophyll  Represents the amount of chlorophyll present in a body of water. Chlorophyll absorbs blue and red wavelengths, turning the water green according to the slider’s value (ranges from 1 – 10).  Suspended Sediment  Represents the amount of sediment suspended in the water. Sediment absorbs blue and green light wavelengths, so adding more Suspended Sediment will turn the water red to red-brown (sediment values range from 1 – 300).  Caustics  Enabling Caustics lets light rays project onto underwater surfaces.  Frame length  Represents the time spent (in seconds) on a single frame of animation in the caustics sprite sheet texture.   Tip  A larger frame length results in a slower animation.  Power  Adjusts the brightness of the caustic effect (ranges from 1 - 6).  Scale  Adjusts the caustics texture projection size.   Tip  Larger scale values make the texture repeat/tile more frequently, making it appear smaller. Smaller scale values make the texture cover a larger area.  Texture  Reveals the texture used for the caustics animation.  Waves  When enabled, bodies of water in your world generate waves, which you can edit by adjusting the following settings:  Depth  Adjusts the amount the water’s surface is displaced by waves. Larger values make bigger waves (ranges from 0 - 3)  Direction Increment  Represents the degree each heading changes between each octave.  Frequency  Adjusts the number of waves that fit in a single block of water. Larger values pack the waves tighter together, resulting in more total waves per water block.  Frequency Scaling  Adjusts the change in wave frequency between octaves. A value of 1 is neutral, while anything below it reduces wave frequency and anything above it increases wave frequency.  Mix  Controls the amount of blending between adjacent octaves.  Octaves  Controls how many wave layers are simulated. Larger values yield more complex wave structures.  Pull  Adjusts the pull of larger waves is on smaller waves. A value of 0 is neutral; positive values pull smaller waves in a concave (cresting) while negative ones pull smaller waves convexly (pillowing).  Sample Width  Controls the resolution of the fractal effect on your world’s waves. A higher value results in a lower resolution, causing waves to appear smoother and more uniform.  Shape  Alters the core shape of your world’s waves. A value of 1 yields a true sine wave while values lower than 1 sharpen wave peaks and valleys.  Speed  Determines both the movement speed of the first wave in a sequence and the starting point for Speed Scaling.  Speed Scaling  Controls how much faster each subsequent wave moves. A value of 1 is neutral, while anything below it reduces wave speed and anything above it increases wave speed.  Global Lighting  Lighting Settings Directional Lights  Orbital  Sun  Illuminance:  Measures the brightness of the sun’s surface (in lux).  Color:  The color your world’s Sun contributes to direct surface lighting.   Note  Supports RGB Array and hex strings.  Moon  Illuminance:  Measures the brightness of the moon’s surface (in lux)  Color:  The color your world’s Moon contributes to direct surface lighting.   Note  Supports RGB Array and hex strings.  Orbital Offset Degrees  Controls the angle the moon and sun are offset from their typical orbital paths, relative to the earth.  Flash  Use to adjust the color of the flash in the End  Emissive  Use the Desaturation slider to adjust the desaturation of emissive light sources in your world. By default, Desaturation is set to 0 (the lowest value).  Ambient  Controls how the surfaces of objects in your world are lit when no direct light source is present.  Sky  Use the Intensity slider to adjust the brilliance of your world’s sun. By default, your world’s Intensity is set to 1 (the highest value).  Atmospheric Scattering  Atmosphere Settings Sky Zenith Color  Controls the color of the atmosphere’s zenith.  Sky Horizon Color  Controls the color of the atmosphere’s horizon.  Rayleigh Strength  Adjusts the strength of the atmosphere’s Rayleigh scattering.   Tip  Rayleigh scattering refers to the way that particles that are significantly smaller/larger than a light ray’s wavelength scatter that light as it passes through them. For a more technical explanation, check out this article on Rayleigh scattering.  Sun Mie Strength  Adjusts the strength of the Sun’s Mie scattering.   Tip  Mie scattering refers to the way that particles about the size of a light ray’s wavelength scatter light as it passes through them. For a more technical explanation, check out this article on Mie scattering.  Moon Mie Strength  Adjusts the strength of your world’s Moon Mie scattering.   Tip  Mie scattering refers to the way that particles about the size of a light ray’s wavelength scatter light as it passes through them. For a more technical explanation, check out this article on Mie scattering.  Sun Glare Shape  Adjusts the shape of your world’s Mie scattering lobe.  Horizon Blend Stops  Adjusts how your world’s atmosphere layers are divided.  Color Grading  Lets you adjust things like saturation, contrast, gain, and pixel offset to fine-tune the look of your world.  Color Grading Settings  Color Grading  Midtones  You can adjust the RGB values for each of the following fields to fine-tune the look and feel of your world:  Contrast Gain Gamma Saturation Offset  Highlight  When enabled, the average luminance of the scene is multiplied by this factor to determine which pixels are considered highlights (ranges from 1 - 20). You can adjust the RGB values for each of the following fields to fine-tune the look and feel of your world:  Contrast Gain Gamma Saturation Offset  Shadows  When enabled, the average luminance of the scene is multiplied by this factor to determine which pixels are considered shadows (ranges from 0 - 1). You can adjust the RGB values for each of the following fields to fine-tune the look and feel of your world:  Contrast Gain Gamma Saturation Offset  Temperature  When enabled, this sets the temperature of your world in Kelvin (ranging from 1000 – 15000).  Temperature  Adjusts the value of color temperature or the white balance according to the slider.  Type  Determines whether the color temperature or the white balance is affected by the temperature slider.  Tone Mapping  Use the Operator to define how a color gets remapped from HDR-space to SDR-space for modern displays.  Aces Hable Reinhard Rreinhard Luma Reinhard Luminance Generic PBR Fallbacks  PBR Fallbacks Settings  You can configure the default MERS values for the following entities in your world when they're not specifically defined with a textureset:  Blocks Actors Particles Items   Tip  You can use either an RGBA array or a hex string to set values for Metallics, Emissives, Reflectives, and Subsurface Scattering (MERS).  Shadows  Shadow Settings Shadow Style  Changes the way shadows render in your world.  Blocky Shadows  Shadows render with hard edges that reflect the shape of the object casting them.  Soft Shadows  Shadows render with softened edges that are inspired by shape of the object casting them.  Texel Size  Changes the size of texel-based shadows (ranges from 1 - 1024).   Tip  A texel is basically a pixel, but for a texture pack instead of an image. For a more detailed explanation, check out Mozilla’s article on Texels.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorvibrantvisuals?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Vibrant Visuals in Bedrock Editor 06/11/2025  Vibrant Visuals (previously Advanced Rendering: Deferred Lighting) is a complete overhaul to the Minecraft graphics system that officially rolled out in Editor v1.0.  Open Minecraft Editor and add Vibrant Visuals to the Action Bar to get started, then select the graphical element you want to start editing.  When you click Generate Resource Pack, a link appears beneath the button that takes you to a template on mctools.dev for a new resource pack with the Vibrant Visuals settings you've configured.  Selecting Export to Clipboard copys the JSON of the current visual setting to your device's clipboard. You can use this to quickly modify parts of a resource pack without the need to generate a completely new one.   Tip  You can reset the current visual settings to the Editor default by clicking Revert Changes near the top of the Vibrant Visuals menu at any time.  Water  Water Settings Particle Concentration  Chromophoric Dissolved Organic Matter (CDOM)  Represents the organic matter suspended in the water. Increasing this value increases the strength of the organic matter’s blue wavelength absorption, turning the water yellow to yellow-brown (CDOM values range from 1 – 15).  Chlorophyll  Represents the amount of chlorophyll present in a body of water. Chlorophyll absorbs blue and red wavelengths, turning the water green according to the slider’s value (ranges from 1 – 10).  Suspended Sediment  Represents the amount of sediment suspended in the water. Sediment absorbs blue and green light wavelengths, so adding more Suspended Sediment will turn the water red to red-brown (sediment values range from 1 – 300).  Caustics  Enabling Caustics lets light rays project onto underwater surfaces.  Frame length  Represents the time spent (in seconds) on a single frame of animation in the caustics sprite sheet texture.   Tip  A larger frame length results in a slower animation.  Power  Adjusts the brightness of the caustic effect (ranges from 1 - 6).  Scale  Adjusts the caustics texture projection size.   Tip  Larger scale values make the texture repeat/tile more frequently, making it appear smaller. Smaller scale values make the texture cover a larger area.  Texture  Reveals the texture used for the caustics animation.  Waves  When enabled, bodies of water in your world generate waves, which you can edit by adjusting the following settings:  Depth  Adjusts the amount the water’s surface is displaced by waves. Larger values make bigger waves (ranges from 0 - 3)  Direction Increment  Represents the degree each heading changes between each octave.  Frequency  Adjusts the number of waves that fit in a single block of water. Larger values pack the waves tighter together, resulting in more total waves per water block.  Frequency Scaling  Adjusts the change in wave frequency between octaves. A value of 1 is neutral, while anything below it reduces wave frequency and anything above it increases wave frequency.  Mix  Controls the amount of blending between adjacent octaves.  Octaves  Controls how many wave layers are simulated. Larger values yield more complex wave structures.  Pull  Adjusts the pull of larger waves is on smaller waves. A value of 0 is neutral; positive values pull smaller waves in a concave (cresting) while negative ones pull smaller waves convexly (pillowing).  Sample Width  Controls the resolution of the fractal effect on your world’s waves. A higher value results in a lower resolution, causing waves to appear smoother and more uniform.  Shape  Alters the core shape of your world’s waves. A value of 1 yields a true sine wave while values lower than 1 sharpen wave peaks and valleys.  Speed  Determines both the movement speed of the first wave in a sequence and the starting point for Speed Scaling.  Speed Scaling  Controls how much faster each subsequent wave moves. A value of 1 is neutral, while anything below it reduces wave speed and anything above it increases wave speed.  Global Lighting  Lighting Settings Directional Lights  Orbital  Sun  Illuminance:  Measures the brightness of the sun’s surface (in lux).  Color:  The color your world’s Sun contributes to direct surface lighting.   Note  Supports RGB Array and hex strings.  Moon  Illuminance:  Measures the brightness of the moon’s surface (in lux)  Color:  The color your world’s Moon contributes to direct surface lighting.   Note  Supports RGB Array and hex strings.  Orbital Offset Degrees  Controls the angle the moon and sun are offset from their typical orbital paths, relative to the earth.  Flash  Use to adjust the color of the flash in the End  Emissive  Use the Desaturation slider to adjust the desaturation of emissive light sources in your world. By default, Desaturation is set to 0 (the lowest value).  Ambient  Controls how the surfaces of objects in your world are lit when no direct light source is present.  Sky  Use the Intensity slider to adjust the brilliance of your world’s sun. By default, your world’s Intensity is set to 1 (the highest value).  Atmospheric Scattering  Atmosphere Settings Sky Zenith Color  Controls the color of the atmosphere’s zenith.  Sky Horizon Color  Controls the color of the atmosphere’s horizon.  Rayleigh Strength  Adjusts the strength of the atmosphere’s Rayleigh scattering.   Tip  Rayleigh scattering refers to the way that particles that are significantly smaller/larger than a light ray’s wavelength scatter that light as it passes through them. For a more technical explanation, check out this article on Rayleigh scattering.  Sun Mie Strength  Adjusts the strength of the Sun’s Mie scattering.   Tip  Mie scattering refers to the way that particles about the size of a light ray’s wavelength scatter light as it passes through them. For a more technical explanation, check out this article on Mie scattering.  Moon Mie Strength  Adjusts the strength of your world’s Moon Mie scattering.   Tip  Mie scattering refers to the way that particles about the size of a light ray’s wavelength scatter light as it passes through them. For a more technical explanation, check out this article on Mie scattering.  Sun Glare Shape  Adjusts the shape of your world’s Mie scattering lobe.  Horizon Blend Stops  Adjusts how your world’s atmosphere layers are divided.  Color Grading  Lets you adjust things like saturation, contrast, gain, and pixel offset to fine-tune the look of your world.  Color Grading Settings  Color Grading  Midtones  You can adjust the RGB values for each of the following fields to fine-tune the look and feel of your world:  Contrast Gain Gamma Saturation Offset  Highlight  When enabled, the average luminance of the scene is multiplied by this factor to determine which pixels are considered highlights (ranges from 1 - 20). You can adjust the RGB values for each of the following fields to fine-tune the look and feel of your world:  Contrast Gain Gamma Saturation Offset  Shadows  When enabled, the average luminance of the scene is multiplied by this factor to determine which pixels are considered shadows (ranges from 0 - 1). You can adjust the RGB values for each of the following fields to fine-tune the look and feel of your world:  Contrast Gain Gamma Saturation Offset  Temperature  When enabled, this sets the temperature of your world in Kelvin (ranging from 1000 – 15000).  Temperature  Adjusts the value of color temperature or the white balance according to the slider.  Type  Determines whether the color temperature or the white balance is affected by the temperature slider.  Tone Mapping  Use the Operator to define how a color gets remapped from HDR-space to SDR-space for modern displays.  Aces Hable Reinhard Rreinhard Luma Reinhard Luminance Generic PBR Fallbacks  PBR Fallbacks Settings  You can configure the default MERS values for the following entities in your world when they're not specifically defined with a textureset:  Blocks Actors Particles Items   Tip  You can use either an RGBA array or a hex string to set values for Metallics, Emissives, Reflectives, and Subsurface Scattering (MERS).  Shadows  Shadow Settings Shadow Style  Changes the way shadows render in your world.  Blocky Shadows  Shadows render with hard edges that reflect the shape of the object casting them.  Soft Shadows  Shadows render with softened edges that are inspired by shape of the object casting them.  Texel Size  Changes the size of texel-based shadows (ranges from 1 - 1024).   Tip  A texel is basically a pixel, but for a texture pack instead of an image. For a more detailed explanation, check out Mozilla’s article on Texels.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorkeyboardinputs?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Hotkeys 05/21/2025  You can use the Keyboard Settings to view the default keyboard shortcuts and set custom keyboard shortcuts. Custom shortcuts are available in Editor and all Editor extensions!  To set a custom keyboard shortcut:  Add the Keyboard Settings action to the hotbar if it's not already active, then open Keyboard Settings.  Use the left pane to locate the input you want to map.  Click the Shortcut field for the input.  Press the keyboard buttons that you want to use for your custom shortcut.  Click Save.   Note  All custom shortcuts must be saved before closing the Keyboard Settings window. If you do not save your custom shortcuts, they will revert to the default shortcuts when the window is closed.  To clear a keyboard shortcut, right-click it or click the Unbind button in the far-right column. Both methods for clearing a shortcut will remove it entirely, including the default key binding.  Input Mapping Expand table Function\tDescription Name\tThe name of the action you want to perform. Shortcut\tClick on the input field and press the keys you want to bind. Press ENTER or unfocus to confirm the binding, or press Esc to reset it. Right-clicking while focused on the field will unbind the current binding. Exclusive\tWhen the Exclusive toggle is enabled, single-key actions will only activate if no other modifiers are present or if the specified modifier combination is used alongside the key. Save All\tSaves all of the new bindings. Reset All\tRestores all bindings to the previous setting. Save\tSaves the new bindings. Reset\tResets the bindings on the current page. Restore All Defaults\tRestores all default bindings for all pages of the mappings. Restore Defaults\tRestores default bindings for this page.  Input Maps fall into one of two main groups — Core Tools and Modal Tools.  Core Tools Project Expand table Name\tShortcut\tExclusive Delete Selection Contents\tDelete\tOn Redo\tCtrl+Y\t- Toggle Mode\tCtrl+Tab\t- Undo\tCtrl+Z\t- Tool Mode Expand table Name\tShortcut\tExclusive Add Navigation Position\tCtrl+K\t- Copy Selection\tCtrl+C\t- Cut Selection\tCtrl+X\t- Deselect Selection\tCtrl+D\t- Fill Selection Contents\tCtrl+F\t- Go To Next Navigation Position\tCtrl+]\t- Go To Previous Navigation Position\tCtrl+[\t- Open Console\t/\tOn Paste Preview\tCtrl+Shift+V\t- Paste\tCtrl+V\t- Select Hotbar 1\t1\tOn Select Hotbar 2\t2\tOn Select Hotbar 3\t3\tOn Select Hotbar 4\t4\tOn Select Hotbar 5\t5\tOn Select Hotbar 6\t6\tOn Select Hotbar 7\t7\tOn Select Hotbar 8\t8\tOn Select Hotbar 9\t9\tOn Show Game Menu\tCtrl+Q\t- Show Log Panel\tCtrl+H\t- Toggle Selection Tool\tCtrl+S\t- Toggle Summon Tool\tCtrl+Shift+S\t- Viewport Expand table Name\tShortcut\tExclusive Fly to Cursor\tG\tOn Fly to Selection\tCtrl+Shift+F\tOn Move Back\tS or Shift+S\tOn Move Up\tE\tOn Move Down\tQ\tOn Move Forward\tW or Shift+W\tOn Move Left\tA or Shift+A\tOn Move Right\tD or Shift+D\tOn Modal Tools Selection Expand table Name\tShortcut\tExclusive Move Cursor Up\tPgUp\tOn Move Cursor Down\tPgDn\tOn Move Cursor Back\tDown Arrow\tOn Move Cursor Forward\tUp Arrow\tOn Move Cursor Left\tLeft Arrow\tOn Move Cursor Right\tRight Arrow\tOn Move Selection Up\tAlt+PgUp\t- Move Selection Down\tAlt+PgDn\t- Move Selection Back\tAlt+Down Arrow\t- Move Selection Forward\tAlt+Up Arrow\t- Move Selection Left\tAlt+Left Arrow\t- Move Selection Right\tAlt+Right Arrow\t- Grow Selection Up\tShift+PgUp\t- Grow Selection Down\tShift+PgDn\t- Grow Selection Back\tShift+Down Arrow\t- Grow Selection Forward\tShift+Up Arrow\t- Grow Selection Left\tShift+Left Arrow\t- Grow Selection Right\tShift+Right Arrow\t- Shrink Selection Up\tCtrl+PgUp\t- Shrink Selection Down\tCtrl+PgDn\t- Shrink Selection Back\tCtrl+Down Arrow\t- Shrink Selection Forward\tCtrl+Up Arrow\t- Shrink Selection Left\tCtrl+Left Arrow\t- Shrink Selection Right\tCtrl+Right Arrow\t- Brush Paint Expand table Name\tShortcut\tExclusive Brush Paint Tool\tCtrl+B\t- Paste Preview Expand table Name\tShortcut\tExclusive Clear Preview\tCtrl+D\t- Enable Fixed Distance\tF\t- Adjacent Target Mode\t-\tOn Block Target Mode\tB\tOn Mouse Tracking\tC\tOn Move Offset Back\tCtrl+Shift+Down Arrow\t- Move Offset Down\tCtrl+Shift+PgDn\t- Move Offset Forward\tCtrl+Shift+Up Arrow\t- Move Offset Left\tCtrl+Shift+Left Arrow\t- Move Offset Right\tCtrl+Shift+Right Arrow\t- Move Offset Up\tCtrl+Shift+PgUp\t- Move Origin Back\tCtrl+Shift+Down Arrow\t- Move Origin Down\tCtrl+Shift+PgDn\t- Move Origin Forward\tCtrl+Up Arrow\t- Move Origin Left\tCtrl+Left Arrow\t- Move Origin Right\tCtrl+Right Arrow\t- Move Origin Up\tCtrl+PgUp\t- Move Preview Back\tDown Arrow\tOn Move Preview Down\tPgDn\tOn Move Preview Forward\tUp Arrow\tOn Move Preview Left\tLeft Arrow\tOn Move Preview Right\tRight Arrow\tOn Move Preview Up\tPgUp\tOn Paste at Cursor\tCtrl+F\t- Rotate Preview Clockwise\tR\tOn Rotate Preview Counter Clockwise\tShift+R\t- Toggle Mirror X\tX\tOn Toggle Mirror Z\tZ\tOn Line Expand table Name\tShortcut\tExclusive Line Tool\tCtrl+L\t- Fill Line\tCtrl+F\t- Convert to Selection\tAlt+S\t- Adjust Line Thickness\tShift+Up/Down/Left/Right\t- Select All\tCtrl+A\t- Deselect\tCtrl+D\t- Deselect All\tCtrl+Shift+D\t- Clear All\tCtrl+BACKSPACE\t- Clear selected\tCtrl+Shift+BACKSPACE\t- Delete Contents\tShift+Delete\t- Delete Contents and Deselect\tDelete\tOn Delete Selected\tDelete\t- Move Selected Back\tDown Arrow\tOn Move Selected Up\tPgUp\tOn Move Selected Down\tPgDn\tOn Move Selected Forward\tUp Arrow\tOn Move Selected Left\tLeft Arrow\tOn Move Selected Right\tRight Arrow\tOn Terrain Expand table Name\tShortcut\tExclusive Terrain Tool\tCtrl+T\t- Toggle Smooth/Roughen\tR\t- Flatten Brush Expand table Name\tShortcut\tExclusive Flatten Tool\tCtrl+Shift+H\t Extrude Expand table Name\tShortcut\tExclusive Extrude Tool\tCtrl+Shift+E\t- Summon Tool Expand table Name\tShortcut\tExclusive Summon Tool\tCtrl+Shift+S\t- Clear Selection\tCtrl+D\t- Delete Entity\tDelete\tOn Move Selected Back\tDown Arrow\tOn Move Selected Down\tPgDn\tOn Move Selected Forward\tUp Arrow\tOn Move Selected Left\tLeft Arrow\tOn Move Selected Right\tRight Arrow\tOn Move Selected Up\tPgUp\tOn Legacy Mapping List Expand table Action\tKeyboard Shortcut\tMode Forward\tW (Tool: Hold down right mouse button)\tTool + Crosshair Left\tA (Tool: Hold down right mouse button)\tTool + Crosshair Backward\tS (Tool: Hold down right mouse button)\tTool + Crosshair Right\tD (Tool: Hold down right mouse button)\tTool + Crosshair Up\tSpace (Tool: Hold down right mouse button)\tTool + Crosshair Down\tShift (Tool: Hold down right mouse button)\tTool + Crosshair Increase speed\tQuickly press W twice (*Tool: Hold down right mouse button)\tTool + Crosshair Fly toggle\tQuickly press space twice\tCrosshair Display 3D cursor - baseline for Tool Mode\tEsc\tTool only Selection mode\tCtrl S\tTool only Selection: Single block\tSingle left mouse click\tTool only Selection: 2-step XZ region selection\tLeft mouse click while holding Shift\tTool only Selection: 3-step XZY region selection\tLeft mouse click while holding Shift for XZ, and to select Y move your cursor and press Alt while left clicking\tTool only Deselect\tCtrl D\tTool only Fill\tSelect an area and either Ctrl F while in Selection mode or use Fill in the Selection panel\tTool only Undo\tCtrl Z or Ctrl Delete (if /effect is applied)\tTool + Crosshair Redo\tCtrl Y\tTool + Crosshair Cut\tCtrl X\tTool only Copy\tCtrl C\tTool only Paste\tCtrl V\tTool only Delete\tDelete\tTool only Grapple teleport\tPoint at something and press G\tTool only Brush\tCtrl B\tTool only Open cmd window\t/\tTool + Crosshair Toggle from Tool to Crosshair Mode\tCrosshair Mode button or Ctrl Tab\tTool only Toggle from Crosshair Mode to Tool\tEsc\tCrosshair only Get to Tool Mode from Crosshair Mode\tEsc\tTool only Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorkeyboardinputs?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Hotkeys 05/21/2025  You can use the Keyboard Settings to view the default keyboard shortcuts and set custom keyboard shortcuts. Custom shortcuts are available in Editor and all Editor extensions!  To set a custom keyboard shortcut:  Add the Keyboard Settings action to the hotbar if it's not already active, then open Keyboard Settings.  Use the left pane to locate the input you want to map.  Click the Shortcut field for the input.  Press the keyboard buttons that you want to use for your custom shortcut.  Click Save.   Note  All custom shortcuts must be saved before closing the Keyboard Settings window. If you do not save your custom shortcuts, they will revert to the default shortcuts when the window is closed.  To clear a keyboard shortcut, right-click it or click the Unbind button in the far-right column. Both methods for clearing a shortcut will remove it entirely, including the default key binding.  Input Mapping Expand table Function\tDescription Name\tThe name of the action you want to perform. Shortcut\tClick on the input field and press the keys you want to bind. Press ENTER or unfocus to confirm the binding, or press Esc to reset it. Right-clicking while focused on the field will unbind the current binding. Exclusive\tWhen the Exclusive toggle is enabled, single-key actions will only activate if no other modifiers are present or if the specified modifier combination is used alongside the key. Save All\tSaves all of the new bindings. Reset All\tRestores all bindings to the previous setting. Save\tSaves the new bindings. Reset\tResets the bindings on the current page. Restore All Defaults\tRestores all default bindings for all pages of the mappings. Restore Defaults\tRestores default bindings for this page.  Input Maps fall into one of two main groups — Core Tools and Modal Tools.  Core Tools Project Expand table Name\tShortcut\tExclusive Delete Selection Contents\tDelete\tOn Redo\tCtrl+Y\t- Toggle Mode\tCtrl+Tab\t- Undo\tCtrl+Z\t- Tool Mode Expand table Name\tShortcut\tExclusive Add Navigation Position\tCtrl+K\t- Copy Selection\tCtrl+C\t- Cut Selection\tCtrl+X\t- Deselect Selection\tCtrl+D\t- Fill Selection Contents\tCtrl+F\t- Go To Next Navigation Position\tCtrl+]\t- Go To Previous Navigation Position\tCtrl+[\t- Open Console\t/\tOn Paste Preview\tCtrl+Shift+V\t- Paste\tCtrl+V\t- Select Hotbar 1\t1\tOn Select Hotbar 2\t2\tOn Select Hotbar 3\t3\tOn Select Hotbar 4\t4\tOn Select Hotbar 5\t5\tOn Select Hotbar 6\t6\tOn Select Hotbar 7\t7\tOn Select Hotbar 8\t8\tOn Select Hotbar 9\t9\tOn Show Game Menu\tCtrl+Q\t- Show Log Panel\tCtrl+H\t- Toggle Selection Tool\tCtrl+S\t- Toggle Summon Tool\tCtrl+Shift+S\t- Viewport Expand table Name\tShortcut\tExclusive Fly to Cursor\tG\tOn Fly to Selection\tCtrl+Shift+F\tOn Move Back\tS or Shift+S\tOn Move Up\tE\tOn Move Down\tQ\tOn Move Forward\tW or Shift+W\tOn Move Left\tA or Shift+A\tOn Move Right\tD or Shift+D\tOn Modal Tools Selection Expand table Name\tShortcut\tExclusive Move Cursor Up\tPgUp\tOn Move Cursor Down\tPgDn\tOn Move Cursor Back\tDown Arrow\tOn Move Cursor Forward\tUp Arrow\tOn Move Cursor Left\tLeft Arrow\tOn Move Cursor Right\tRight Arrow\tOn Move Selection Up\tAlt+PgUp\t- Move Selection Down\tAlt+PgDn\t- Move Selection Back\tAlt+Down Arrow\t- Move Selection Forward\tAlt+Up Arrow\t- Move Selection Left\tAlt+Left Arrow\t- Move Selection Right\tAlt+Right Arrow\t- Grow Selection Up\tShift+PgUp\t- Grow Selection Down\tShift+PgDn\t- Grow Selection Back\tShift+Down Arrow\t- Grow Selection Forward\tShift+Up Arrow\t- Grow Selection Left\tShift+Left Arrow\t- Grow Selection Right\tShift+Right Arrow\t- Shrink Selection Up\tCtrl+PgUp\t- Shrink Selection Down\tCtrl+PgDn\t- Shrink Selection Back\tCtrl+Down Arrow\t- Shrink Selection Forward\tCtrl+Up Arrow\t- Shrink Selection Left\tCtrl+Left Arrow\t- Shrink Selection Right\tCtrl+Right Arrow\t- Brush Paint Expand table Name\tShortcut\tExclusive Brush Paint Tool\tCtrl+B\t- Paste Preview Expand table Name\tShortcut\tExclusive Clear Preview\tCtrl+D\t- Enable Fixed Distance\tF\t- Adjacent Target Mode\t-\tOn Block Target Mode\tB\tOn Mouse Tracking\tC\tOn Move Offset Back\tCtrl+Shift+Down Arrow\t- Move Offset Down\tCtrl+Shift+PgDn\t- Move Offset Forward\tCtrl+Shift+Up Arrow\t- Move Offset Left\tCtrl+Shift+Left Arrow\t- Move Offset Right\tCtrl+Shift+Right Arrow\t- Move Offset Up\tCtrl+Shift+PgUp\t- Move Origin Back\tCtrl+Shift+Down Arrow\t- Move Origin Down\tCtrl+Shift+PgDn\t- Move Origin Forward\tCtrl+Up Arrow\t- Move Origin Left\tCtrl+Left Arrow\t- Move Origin Right\tCtrl+Right Arrow\t- Move Origin Up\tCtrl+PgUp\t- Move Preview Back\tDown Arrow\tOn Move Preview Down\tPgDn\tOn Move Preview Forward\tUp Arrow\tOn Move Preview Left\tLeft Arrow\tOn Move Preview Right\tRight Arrow\tOn Move Preview Up\tPgUp\tOn Paste at Cursor\tCtrl+F\t- Rotate Preview Clockwise\tR\tOn Rotate Preview Counter Clockwise\tShift+R\t- Toggle Mirror X\tX\tOn Toggle Mirror Z\tZ\tOn Line Expand table Name\tShortcut\tExclusive Line Tool\tCtrl+L\t- Fill Line\tCtrl+F\t- Convert to Selection\tAlt+S\t- Adjust Line Thickness\tShift+Up/Down/Left/Right\t- Select All\tCtrl+A\t- Deselect\tCtrl+D\t- Deselect All\tCtrl+Shift+D\t- Clear All\tCtrl+BACKSPACE\t- Clear selected\tCtrl+Shift+BACKSPACE\t- Delete Contents\tShift+Delete\t- Delete Contents and Deselect\tDelete\tOn Delete Selected\tDelete\t- Move Selected Back\tDown Arrow\tOn Move Selected Up\tPgUp\tOn Move Selected Down\tPgDn\tOn Move Selected Forward\tUp Arrow\tOn Move Selected Left\tLeft Arrow\tOn Move Selected Right\tRight Arrow\tOn Terrain Expand table Name\tShortcut\tExclusive Terrain Tool\tCtrl+T\t- Toggle Smooth/Roughen\tR\t- Flatten Brush Expand table Name\tShortcut\tExclusive Flatten Tool\tCtrl+Shift+H\t Extrude Expand table Name\tShortcut\tExclusive Extrude Tool\tCtrl+Shift+E\t- Summon Tool Expand table Name\tShortcut\tExclusive Summon Tool\tCtrl+Shift+S\t- Clear Selection\tCtrl+D\t- Delete Entity\tDelete\tOn Move Selected Back\tDown Arrow\tOn Move Selected Down\tPgDn\tOn Move Selected Forward\tUp Arrow\tOn Move Selected Left\tLeft Arrow\tOn Move Selected Right\tRight Arrow\tOn Move Selected Up\tPgUp\tOn Legacy Mapping List Expand table Action\tKeyboard Shortcut\tMode Forward\tW (Tool: Hold down right mouse button)\tTool + Crosshair Left\tA (Tool: Hold down right mouse button)\tTool + Crosshair Backward\tS (Tool: Hold down right mouse button)\tTool + Crosshair Right\tD (Tool: Hold down right mouse button)\tTool + Crosshair Up\tSpace (Tool: Hold down right mouse button)\tTool + Crosshair Down\tShift (Tool: Hold down right mouse button)\tTool + Crosshair Increase speed\tQuickly press W twice (*Tool: Hold down right mouse button)\tTool + Crosshair Fly toggle\tQuickly press space twice\tCrosshair Display 3D cursor - baseline for Tool Mode\tEsc\tTool only Selection mode\tCtrl S\tTool only Selection: Single block\tSingle left mouse click\tTool only Selection: 2-step XZ region selection\tLeft mouse click while holding Shift\tTool only Selection: 3-step XZY region selection\tLeft mouse click while holding Shift for XZ, and to select Y move your cursor and press Alt while left clicking\tTool only Deselect\tCtrl D\tTool only Fill\tSelect an area and either Ctrl F while in Selection mode or use Fill in the Selection panel\tTool only Undo\tCtrl Z or Ctrl Delete (if /effect is applied)\tTool + Crosshair Redo\tCtrl Y\tTool + Crosshair Cut\tCtrl X\tTool only Copy\tCtrl C\tTool only Paste\tCtrl V\tTool only Delete\tDelete\tTool only Grapple teleport\tPoint at something and press G\tTool only Brush\tCtrl B\tTool only Open cmd window\t/\tTool + Crosshair Toggle from Tool to Crosshair Mode\tCrosshair Mode button or Ctrl Tab\tTool only Toggle from Crosshair Mode to Tool\tEsc\tCrosshair only Get to Tool Mode from Crosshair Mode\tEsc\tTool only Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorpastepreview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Paste Preview 06/11/2025  Ctrl+Shift+V opens the Paste Preview window.  After you create a selection and copy it (Ctrl+C) or cut it (Ctrl+X), you can use Paste Preview to change how the selection appears before you paste it.  Select something interesting, like a village house, with any of the selection modes.   Copy or cut the selection (Ctrl+C or Ctrl+X).  Open Paste Preview (Ctrl+Shift+V).  Click the ground where you want the copied or cut blocks to be pasted. The paste preview selection is displayed.   You can use the arrow keys and PgUp/PgDn to move the Paste Preview to exactly where you want it.   Click Confirm Paste.    Tip  You can Transform your copied selection by editing the Origin coordinates, Rotating the selection, or mirroring the selection along the x or z axis.   Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorpastepreview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Paste Preview 06/11/2025  Ctrl+Shift+V opens the Paste Preview window.  After you create a selection and copy it (Ctrl+C) or cut it (Ctrl+X), you can use Paste Preview to change how the selection appears before you paste it.  Select something interesting, like a village house, with any of the selection modes.   Copy or cut the selection (Ctrl+C or Ctrl+X).  Open Paste Preview (Ctrl+Shift+V).  Click the ground where you want the copied or cut blocks to be pasted. The paste preview selection is displayed.   You can use the arrow keys and PgUp/PgDn to move the Paste Preview to exactly where you want it.   Click Confirm Paste.    Tip  You can Transform your copied selection by editing the Origin coordinates, Rotating the selection, or mirroring the selection along the x or z axis.   Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editortoolmode?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Tool Mode and Crosshair Mode 05/21/2025  The two modes within Editor are Tool Mode and Crosshair Mode.  Tool Mode has multi-block editing tools and the user interface. When you move the mouse without holding any mouse buttons, your cursor is freely available to use the user interface.  Crosshair Mode has more precise, single-block editing capabilities. It also uses the usual Minecraft keybindings you can see on the Settings > Controls > Keyboard & Mouse screen. Move the mouse to look around.  In a new project, before you touch anything, you are in Tool Mode.  If you're ever not sure which mode you are in, press Esc. If you're in Crosshair mode, you'll go back into Tool Mode - if you're in Tool Mode already, nothing will happen.  [!PRACTICE] In the top right corner of the screen, select the \"Crosshair Mode\" button or press Ctrl+Tab to go into Crosshair Mode. Note the differences. To go back to Tool Mode, you can press Ctrl+Tab again or press Esc. You can also go from Tool Mode to Crosshair Mode by clicking the Crosshair Mode button in the upper right corner.  Think of the Tool Mode UI as a collection of containers. The menu bar contains menus. The action bar contains buttons that do simple functions like Undo and Redo. The toolrail contains more complicated tools that have their own configuration windows where you can change the settings.   Note  The contents of these containers will change as Editor is developed.  Menu bar: Located at the top of the screen. Currently has File, Edit, World Options, and Help.  Action bar: Located below the menu bar. Currently has Undo, Redo, Attach Debugger, Input Mapping, Reload, and Crosshair Mode.  Toolrail: Located on the left side of the screen. Currently holds Selection, Brush, Paste Preview, Line, and Summon Tool. You can also select these tools using keyboard shortcuts, if they have one.  Menu bar File Export as:  When you're ready to share your project (or just see it in-game) select File > Export as > Playable world to create a .mcworld file. Save your new file to the projectbackups folder located inside com.mojang.   Note  If you don't know how to find your com.mojang folder, there are instructions in the Bedrock Getting Started tutorial.  Editor has its own filetype for projecrs: .mcproject. These files always open in Editor if it's installed on your computer. To import projects from the editor screen, select Create New Project, then click the button to the right of Create New Project.  Navigate to a .mcworld, .mctemplate, or .mcproject files. After the file is imported, it is converted to an .mcproject file.  Visit Minecraft File Types to learn more about Minecraft file types like .mcproject and .mcworld.  UI settings - This is where you can adjust the UI Scale, Font, and Theme color settings of the Editor UI.  Cursor Settings - This gives you the option to toggle Project through Liquid on or off.  Game menu - Brings up the menu where you can Resume Editing, go into Minecraft settings, or Save & Quit.  Edit  These are some of the main functions you'll use as you work in Tool Mode.  Expand table Command\tShortcut Undo\tCtrl+Z Redo\tCtrl+Y Quick Fill\tSelect an area and either Ctrl+F while in Selection mode or use Fill in the Selection panel Deselect\tCtrl+D or use the Deselect button in the Selection panel Delete\tDelete  Check out our other guide for a complete list of the Bedrock Editor hotkeys.  View  Log Panel (Ctrl+H)  Navigation Logging - Toggles this feature on or off.  Deferred Lighting Settings - Opens the Settings Editor.  World Options  Pause  Change Dimension  Test World  Time of Day Settings  Navigation Panel  Weather  For more information about World Options, take a look at Editor World Options.  Help  Quick start: Select this to reopen the welcome menu.  Documentation: A quick link to our Editor documentation.  Feedback: Links to the public GitHub repository where you can share feedback directly with our team!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editortoolmode?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Tool Mode and Crosshair Mode 05/21/2025  The two modes within Editor are Tool Mode and Crosshair Mode.  Tool Mode has multi-block editing tools and the user interface. When you move the mouse without holding any mouse buttons, your cursor is freely available to use the user interface.  Crosshair Mode has more precise, single-block editing capabilities. It also uses the usual Minecraft keybindings you can see on the Settings > Controls > Keyboard & Mouse screen. Move the mouse to look around.  In a new project, before you touch anything, you are in Tool Mode.  If you're ever not sure which mode you are in, press Esc. If you're in Crosshair mode, you'll go back into Tool Mode - if you're in Tool Mode already, nothing will happen.  [!PRACTICE] In the top right corner of the screen, select the \"Crosshair Mode\" button or press Ctrl+Tab to go into Crosshair Mode. Note the differences. To go back to Tool Mode, you can press Ctrl+Tab again or press Esc. You can also go from Tool Mode to Crosshair Mode by clicking the Crosshair Mode button in the upper right corner.  Think of the Tool Mode UI as a collection of containers. The menu bar contains menus. The action bar contains buttons that do simple functions like Undo and Redo. The toolrail contains more complicated tools that have their own configuration windows where you can change the settings.   Note  The contents of these containers will change as Editor is developed.  Menu bar: Located at the top of the screen. Currently has File, Edit, World Options, and Help.  Action bar: Located below the menu bar. Currently has Undo, Redo, Attach Debugger, Input Mapping, Reload, and Crosshair Mode.  Toolrail: Located on the left side of the screen. Currently holds Selection, Brush, Paste Preview, Line, and Summon Tool. You can also select these tools using keyboard shortcuts, if they have one.  Menu bar File Export as:  When you're ready to share your project (or just see it in-game) select File > Export as > Playable world to create a .mcworld file. Save your new file to the projectbackups folder located inside com.mojang.   Note  If you don't know how to find your com.mojang folder, there are instructions in the Bedrock Getting Started tutorial.  Editor has its own filetype for projecrs: .mcproject. These files always open in Editor if it's installed on your computer. To import projects from the editor screen, select Create New Project, then click the button to the right of Create New Project.  Navigate to a .mcworld, .mctemplate, or .mcproject files. After the file is imported, it is converted to an .mcproject file.  Visit Minecraft File Types to learn more about Minecraft file types like .mcproject and .mcworld.  UI settings - This is where you can adjust the UI Scale, Font, and Theme color settings of the Editor UI.  Cursor Settings - This gives you the option to toggle Project through Liquid on or off.  Game menu - Brings up the menu where you can Resume Editing, go into Minecraft settings, or Save & Quit.  Edit  These are some of the main functions you'll use as you work in Tool Mode.  Expand table Command\tShortcut Undo\tCtrl+Z Redo\tCtrl+Y Quick Fill\tSelect an area and either Ctrl+F while in Selection mode or use Fill in the Selection panel Deselect\tCtrl+D or use the Deselect button in the Selection panel Delete\tDelete  Check out our other guide for a complete list of the Bedrock Editor hotkeys.  View  Log Panel (Ctrl+H)  Navigation Logging - Toggles this feature on or off.  Deferred Lighting Settings - Opens the Settings Editor.  World Options  Pause  Change Dimension  Test World  Time of Day Settings  Navigation Panel  Weather  For more information about World Options, take a look at Editor World Options.  Help  Quick start: Select this to reopen the welcome menu.  Documentation: A quick link to our Editor documentation.  Feedback: Links to the public GitHub repository where you can share feedback directly with our team!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorworkflow?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor File Operations - Create, Import, and Export 05/21/2025  Here are the steps to create a project, make a quick edit, export the file, and then open that file in Minecraft and then again in Minecraft Editor.  Launch Minecraft Bedrock Editor.  Select \"Create New Project\".  Name and open the project.  Select the brush tool (Ctrl+B) and draw something by clicking on the ground a few times.  Go to the File menu and select Export.  Select Playable World in the Export type field to export a playable Minecraft world. Configure the world's settings, then click Export. For more information on the export world settings, see Export World Settings below.  You will receive messages confirming that the export started and when it has finished, and a temporary chat message will display the path to projectbackups in your com.mojang folder.  From File, select Game menu (Ctrl+Q) and choose Save & Quit to close the Editor.  Go to projectbackups in your com.mojang folder. You should find a file with the name you gave it appended to the date, time, and a .mcworld extension.  The projectbackups folder does not exist until the first time you export a project from Editor. If you need a reminder about how to find the com.mojang folder on your computer, there are some steps in the Getting Started article.  Export World Settings  When you export your editor project, you can configure the settings that you would like to apply to your world. Go to File -> Export to open the Export Panel. From there, you can adjust the settings and then finish exporting your world.  Export Notes  The Export Notes section tells you what version of Minecraft your world will be exported as. If you want to create a playable world for a previous version, you'll have to use Chunker.  General Settings  World name: You can type in the name that you want for your new world.  Game Mode: Use the drop-down to choose Survival, Creative, or Adventure mode.  Difficulty: Use the drop-down to choose Peaceful, Easy, Normal, or Hard.  Hardcore: Check this box to export your world as a Hardcore world. When you check this box, the Game Mode is automatically set to Survival (but you can also choose Adventure difficulty) and the Difficulty is set to Hard and Cheats are disabled.  Advanced Settings  Starting map: Check this box to give your players a map in their inventory when they start in your world.   Note  This setting cannot be enabled in Hardcore worlds.  Bonus chest: Check this box to give your players a bonus chest in their inventory when they start in your world.   Note  This setting cannot be enabled in Hardcore worlds.  Show coordinates: Check this box to show players their position coordinates in your world.  Show days played: Check this box to show players their playtime in your world.  Recipe unlocking: Check this box to unlock all crafting recipes for players when they start in your world.  Fire spreads: Check this box to enable fire spreading in your world. If this is not checked, fire will not spread to flammable blocks and remain on the block where it was set.  TNT explodes: Check this box to enable TNT explosions after it is set. If this is not checked, TNT will not explode after it is set.  Respawn blocks explode: Check this box to enable bed and respawn anchor explosions in other dimensions. If this is not checked, beds and respawn anchors will not explode in other dimensions, but they will still not work in other dimensions.  Mob loot: Check this box to enable mobs dropping items in your world. If this is not checked, mobs will not drop items when killed.  Natural regeneration: Check this box to enable natural regeneration (healing) for players in your world. If this is not checked, players will not heal passively.  Tile drops: Check this box to enable block drops when blocks or tiles are destroyed. If this is not checked, blocks and tiles will not drop when they are destroyed.  Immediate respawn: Check this box to enable skipping the death screen for players in your world. If this is not checked, players will see the death screen when they are killed and can click a button to respawn when they choose.  Respawn radius: Enter a distance (in blocks) to determine how far away a player can randomly respawn from the nearest respawn block.  Simulation radius: Enter a distance (in blocks) to determine how far away mobs can spawn or despawn from players. This distance must be an even number from 4 to 12.  Multiplayer Settings  Multiplayer game: Check this box to enable multiplayer in your world.  Player Access: Use the drop-down to choose who can join your world. You can choose Invite only, Friends only, or Friends of friends.  Player permissions: Use the drop-down to choose what permissions new players are given when they join your world. You can choose Visitor, Member, Operator, or Custom.  Visible to LAN players: Check this box to make your world visible to players on your local network.  Friendly fire: Check this box to enable players damaging one another.  Cheats Settings  Cheats: Check this box to enable cheats in your world.   Note  This setting cannot be enabled in Hardcore worlds.  Daylight Cycle: Use the drop-down to choose how the daylight cycle behaves in your world. You can choose Normal, Always day, or Lock time.  Keep inventory: Check this box to enable players to keep their inventory after they die. If this is not checked, players will lose all items in their inventory upon death.  Mob spawning: Check this box to enable mobs spawning in your world. If this is not checked, mobs will not spawn anywhere in your world.  Mob griefing: Check this box to enable mobs to destroy or damage blocks in your world. If this is not checked, mobs will not be able to damage blocks.  Entities drop loot: Check this box to enable non-mob entities to drop loot when killed. If this is not checked, non-mob entities will not drop loot upon death.  Weather cycle: Check this box to enable the weather cycle in your world. If this is not checked, your world will always have sunny weather and will not change.  Command blocks: Check this box to enable command blocks in your world. If this is not checked, players will not be able to use command blocks in your world.  Education features: Check this box to enable the features found in Minecraft Education Edition in your world.  Random tick speed: Enter a time (in ticks) for the world to choose random blocks for event updates. This controls world events like how fast crops and tress grow. Each tick in Minecraft is 50 milliseconds (or 0.05 seconds).  Minecraft File Extensions  If you want to know more, check out this article to help you learn all about Minecraft File Extensions.  If the editor is closed when you double-click the .mcworld file, Minecraft will launch normally and automatically import the file to your world. The world you created in Editor will be listed among any other Minecraft worlds you already have. However, if Editor is still running, double-clicking the file will cause it to be imported into Editor instead.  To send your project file to someone else so they can work with it in Editor, go back to the projectbackups file in your com.mojang folder.  Copy and paste the file and change the file extension to .mcproject. When you send this file to someone else, they can double-click it to open it directly in Editor (if they have Editor installed).  Importing a file into Editor  Launch Editor and click the Play button.  Click the import icon next to the Create New Project button to open the Windows file explorer.  In the file explorer, choose the .mcworld, .mctemplate, or .mcproject you want to import.  When the file is imported, a success message is displayed.  The newly imported map will be available in the list.  Open the map. It will load into Editor with default settings, which can be modified within Editor.  File structure information  As you probably already know, when you create a world in Minecraft, that world is stored in the minecraftWorlds folder in your com.Mojang folder. When you create a project in Editor, that file is also a world, so it is also stored in the minecraftWorlds folder but it is invisible to non-Editor Minecraft unless you import it. The Editor project file goes into the projectbackups folder only when you export it.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorworkflow?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor File Operations - Create, Import, and Export 05/21/2025  Here are the steps to create a project, make a quick edit, export the file, and then open that file in Minecraft and then again in Minecraft Editor.  Launch Minecraft Bedrock Editor.  Select \"Create New Project\".  Name and open the project.  Select the brush tool (Ctrl+B) and draw something by clicking on the ground a few times.  Go to the File menu and select Export.  Select Playable World in the Export type field to export a playable Minecraft world. Configure the world's settings, then click Export. For more information on the export world settings, see Export World Settings below.  You will receive messages confirming that the export started and when it has finished, and a temporary chat message will display the path to projectbackups in your com.mojang folder.  From File, select Game menu (Ctrl+Q) and choose Save & Quit to close the Editor.  Go to projectbackups in your com.mojang folder. You should find a file with the name you gave it appended to the date, time, and a .mcworld extension.  The projectbackups folder does not exist until the first time you export a project from Editor. If you need a reminder about how to find the com.mojang folder on your computer, there are some steps in the Getting Started article.  Export World Settings  When you export your editor project, you can configure the settings that you would like to apply to your world. Go to File -> Export to open the Export Panel. From there, you can adjust the settings and then finish exporting your world.  Export Notes  The Export Notes section tells you what version of Minecraft your world will be exported as. If you want to create a playable world for a previous version, you'll have to use Chunker.  General Settings  World name: You can type in the name that you want for your new world.  Game Mode: Use the drop-down to choose Survival, Creative, or Adventure mode.  Difficulty: Use the drop-down to choose Peaceful, Easy, Normal, or Hard.  Hardcore: Check this box to export your world as a Hardcore world. When you check this box, the Game Mode is automatically set to Survival (but you can also choose Adventure difficulty) and the Difficulty is set to Hard and Cheats are disabled.  Advanced Settings  Starting map: Check this box to give your players a map in their inventory when they start in your world.   Note  This setting cannot be enabled in Hardcore worlds.  Bonus chest: Check this box to give your players a bonus chest in their inventory when they start in your world.   Note  This setting cannot be enabled in Hardcore worlds.  Show coordinates: Check this box to show players their position coordinates in your world.  Show days played: Check this box to show players their playtime in your world.  Recipe unlocking: Check this box to unlock all crafting recipes for players when they start in your world.  Fire spreads: Check this box to enable fire spreading in your world. If this is not checked, fire will not spread to flammable blocks and remain on the block where it was set.  TNT explodes: Check this box to enable TNT explosions after it is set. If this is not checked, TNT will not explode after it is set.  Respawn blocks explode: Check this box to enable bed and respawn anchor explosions in other dimensions. If this is not checked, beds and respawn anchors will not explode in other dimensions, but they will still not work in other dimensions.  Mob loot: Check this box to enable mobs dropping items in your world. If this is not checked, mobs will not drop items when killed.  Natural regeneration: Check this box to enable natural regeneration (healing) for players in your world. If this is not checked, players will not heal passively.  Tile drops: Check this box to enable block drops when blocks or tiles are destroyed. If this is not checked, blocks and tiles will not drop when they are destroyed.  Immediate respawn: Check this box to enable skipping the death screen for players in your world. If this is not checked, players will see the death screen when they are killed and can click a button to respawn when they choose.  Respawn radius: Enter a distance (in blocks) to determine how far away a player can randomly respawn from the nearest respawn block.  Simulation radius: Enter a distance (in blocks) to determine how far away mobs can spawn or despawn from players. This distance must be an even number from 4 to 12.  Multiplayer Settings  Multiplayer game: Check this box to enable multiplayer in your world.  Player Access: Use the drop-down to choose who can join your world. You can choose Invite only, Friends only, or Friends of friends.  Player permissions: Use the drop-down to choose what permissions new players are given when they join your world. You can choose Visitor, Member, Operator, or Custom.  Visible to LAN players: Check this box to make your world visible to players on your local network.  Friendly fire: Check this box to enable players damaging one another.  Cheats Settings  Cheats: Check this box to enable cheats in your world.   Note  This setting cannot be enabled in Hardcore worlds.  Daylight Cycle: Use the drop-down to choose how the daylight cycle behaves in your world. You can choose Normal, Always day, or Lock time.  Keep inventory: Check this box to enable players to keep their inventory after they die. If this is not checked, players will lose all items in their inventory upon death.  Mob spawning: Check this box to enable mobs spawning in your world. If this is not checked, mobs will not spawn anywhere in your world.  Mob griefing: Check this box to enable mobs to destroy or damage blocks in your world. If this is not checked, mobs will not be able to damage blocks.  Entities drop loot: Check this box to enable non-mob entities to drop loot when killed. If this is not checked, non-mob entities will not drop loot upon death.  Weather cycle: Check this box to enable the weather cycle in your world. If this is not checked, your world will always have sunny weather and will not change.  Command blocks: Check this box to enable command blocks in your world. If this is not checked, players will not be able to use command blocks in your world.  Education features: Check this box to enable the features found in Minecraft Education Edition in your world.  Random tick speed: Enter a time (in ticks) for the world to choose random blocks for event updates. This controls world events like how fast crops and tress grow. Each tick in Minecraft is 50 milliseconds (or 0.05 seconds).  Minecraft File Extensions  If you want to know more, check out this article to help you learn all about Minecraft File Extensions.  If the editor is closed when you double-click the .mcworld file, Minecraft will launch normally and automatically import the file to your world. The world you created in Editor will be listed among any other Minecraft worlds you already have. However, if Editor is still running, double-clicking the file will cause it to be imported into Editor instead.  To send your project file to someone else so they can work with it in Editor, go back to the projectbackups file in your com.mojang folder.  Copy and paste the file and change the file extension to .mcproject. When you send this file to someone else, they can double-click it to open it directly in Editor (if they have Editor installed).  Importing a file into Editor  Launch Editor and click the Play button.  Click the import icon next to the Create New Project button to open the Windows file explorer.  In the file explorer, choose the .mcworld, .mctemplate, or .mcproject you want to import.  When the file is imported, a success message is displayed.  The newly imported map will be available in the list.  Open the map. It will load into Editor with default settings, which can be modified within Editor.  File structure information  As you probably already know, when you create a world in Minecraft, that world is stored in the minecraftWorlds folder in your com.Mojang folder. When you create a project in Editor, that file is also a world, so it is also stored in the minecraftWorlds folder but it is invisible to non-Editor Minecraft unless you import it. The Editor project file goes into the projectbackups folder only when you export it.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorworldoptions?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor World Options 05/21/2025 Pause  If you want to pause or unpause entities.  Change dimension  You start in the Overworld by default. Go here to change to the Nether or the End.  Test World  Opens the Test World panel, where you can test your Editor project as a playable Minecraft world. You can set the game mode and difficulty settings and use the Advanced Settings to set things like Daylight Settings, Time of Day, and Weather. Show Coordinates lets you display your current position.  While you are playing, you can press Esc and click Return to Editor at any time to end your test and resume editing your project. No changes you make while testing will be saved to your project.   Note  Available only when hosting a single player world.  Game Mode  Choose Survival, Creative, or Adventure.  Difficulty  Choose Peaceful, Easy, Normal, or Hard.  Spawn at Current Location  If unchecked, the player spawns at the usual spawnpoint for that world.  Advanced Settings  Daylight Cycle  Normal, Always Day, or LockTime.  Custom Time  This will be enabled if you choose Custom from the Time of Day option.  Time of Day  Choose Default, Day, Noon, Sunset, Night, Midnight, or Sunrise, or Custom.  Weather Cycle  Toggle on or off.  Time of Day Settings  Opens Time Settings, where you can set the Clock Type (24hr, 12hr, or Minecraft Clock) and choose whether the Daylight Cycle will be locked in the current position, always daytime, or proceed normally. You can also set the time of day to one of the available presets or use the slider to set a custom time.  Navigation Panel  Contains a toggle that shows a birds-eye view mini-map you can use to teleport to the coordinates you click. You can add markers to locations in your world and they will show up as colored flags within your mini-map in Stored Locations.  Weather  This option lets you instantly change the weather in your project to Clear, Rain, or Thunder.  Practice: Test a world  After selecting the options you want, click the Test World button.  Your world loads much as it will in regular Minecraft.  Whenever you're ready to continue editing, press Esc. From here, you can choose to Resume Testing or Return to Editor.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorworldoptions?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor World Options 05/21/2025 Pause  If you want to pause or unpause entities.  Change dimension  You start in the Overworld by default. Go here to change to the Nether or the End.  Test World  Opens the Test World panel, where you can test your Editor project as a playable Minecraft world. You can set the game mode and difficulty settings and use the Advanced Settings to set things like Daylight Settings, Time of Day, and Weather. Show Coordinates lets you display your current position.  While you are playing, you can press Esc and click Return to Editor at any time to end your test and resume editing your project. No changes you make while testing will be saved to your project.   Note  Available only when hosting a single player world.  Game Mode  Choose Survival, Creative, or Adventure.  Difficulty  Choose Peaceful, Easy, Normal, or Hard.  Spawn at Current Location  If unchecked, the player spawns at the usual spawnpoint for that world.  Advanced Settings  Daylight Cycle  Normal, Always Day, or LockTime.  Custom Time  This will be enabled if you choose Custom from the Time of Day option.  Time of Day  Choose Default, Day, Noon, Sunset, Night, Midnight, or Sunrise, or Custom.  Weather Cycle  Toggle on or off.  Time of Day Settings  Opens Time Settings, where you can set the Clock Type (24hr, 12hr, or Minecraft Clock) and choose whether the Daylight Cycle will be locked in the current position, always daytime, or proceed normally. You can also set the time of day to one of the available presets or use the slider to set a custom time.  Navigation Panel  Contains a toggle that shows a birds-eye view mini-map you can use to teleport to the coordinates you click. You can add markers to locations in your world and they will show up as colored flags within your mini-map in Stored Locations.  Weather  This option lets you instantly change the weather in your project to Clear, Rain, or Thunder.  Practice: Test a world  After selecting the options you want, click the Test World button.  Your world loads much as it will in regular Minecraft.  Whenever you're ready to continue editing, press Esc. From here, you can choose to Resume Testing or Return to Editor.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorextensionsintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Editor Extensions 05/21/2025  Wondering where to get started with Editor Extensions? Well, that depends on what you already know. There are a lot of parts to it and the more you know about each part, the easier it will be. Let's assume...  You have Minecraft Bedrock running on a Windows PC. You know what an Application Programming Interface (API) is. You would like to change the functionality of one or more of the Editor tools or at least know more about how to do it. You have worked with Resource Packs and Behavior Packs to change something in Minecraft. If not, you should start with Getting Started with Minecraft Add-ons. You know how to use slash commands in Minecraft as shown in the Commands Introduction. You have taken a look at Minecraft scripting and set up your programming environment so you can try it. You have used Editor to edit a world. If not, you should start with the Editor Tutorial.  The Bedrock Editor is a framework that is built into certain platform versions of Minecraft: Bedrock Edition, designed to allow creators to use more complex tools than the ones found in simple gameplay to build, edit, and test worlds. In fact, the Editor framework even lets creators build their own tools to better suit your individual building style!  An Editor Extension is a catch-all for a set of Resource and Behavior Packs that contain script and binary assets that get loaded into Editor at start-up. Extensions are written in TypeScript and are compiled into JavaScript before loading into the game. The compiler tools and various libraries required to do this are supplied in the Editor Extension Starter Kit.  Minecraft has a Scripting API that can be used to do some pretty amazing stuff. Editor has an API, too, and these two APIs are connected. Minecraft uses existing server-side scripting APIs (like SetBlock, Spawn, Camera, and slash commands) and enhances them with APIs specific to Editor. See server-editor for a full reference of Editor-specific APIs.  If you've never worked with APIs before, it's worth taking the time to learn about them. It involves scripting (writing small amounts of code), so if you're new to that, you can find some excellent free resources on the Web to learn JavaScript and TypeScript.  Then, you could go through the Scripting tutorial.  After you get all the prerequisites out of the way, you could take a look at some examples of Extensions - there is a starter kit and GitHub repo.  Now you're ready to try one of the examples or get started building your own!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorextensionsintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Editor Extensions 05/21/2025  Wondering where to get started with Editor Extensions? Well, that depends on what you already know. There are a lot of parts to it and the more you know about each part, the easier it will be. Let's assume...  You have Minecraft Bedrock running on a Windows PC. You know what an Application Programming Interface (API) is. You would like to change the functionality of one or more of the Editor tools or at least know more about how to do it. You have worked with Resource Packs and Behavior Packs to change something in Minecraft. If not, you should start with Getting Started with Minecraft Add-ons. You know how to use slash commands in Minecraft as shown in the Commands Introduction. You have taken a look at Minecraft scripting and set up your programming environment so you can try it. You have used Editor to edit a world. If not, you should start with the Editor Tutorial.  The Bedrock Editor is a framework that is built into certain platform versions of Minecraft: Bedrock Edition, designed to allow creators to use more complex tools than the ones found in simple gameplay to build, edit, and test worlds. In fact, the Editor framework even lets creators build their own tools to better suit your individual building style!  An Editor Extension is a catch-all for a set of Resource and Behavior Packs that contain script and binary assets that get loaded into Editor at start-up. Extensions are written in TypeScript and are compiled into JavaScript before loading into the game. The compiler tools and various libraries required to do this are supplied in the Editor Extension Starter Kit.  Minecraft has a Scripting API that can be used to do some pretty amazing stuff. Editor has an API, too, and these two APIs are connected. Minecraft uses existing server-side scripting APIs (like SetBlock, Spawn, Camera, and slash commands) and enhances them with APIs specific to Editor. See server-editor for a full reference of Editor-specific APIs.  If you've never worked with APIs before, it's worth taking the time to learn about them. It involves scripting (writing small amounts of code), so if you're new to that, you can find some excellent free resources on the Web to learn JavaScript and TypeScript.  Then, you could go through the Scripting tutorial.  After you get all the prerequisites out of the way, you could take a look at some examples of Extensions - there is a starter kit and GitHub repo.  Now you're ready to try one of the examples or get started building your own!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorsettings?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Settings Pane 02/12/2025  The Settings Pane can be opened via the Action Bar or File -> Settings.  The Settings Pane includes these options:  Show Invisible Blocks - Some blocks don't render by default. This setting allows you to view these blocks for ease of editing. Show Chunk Boundries - Shows the boundry between chunks. Show Compass - Toggles the directional compass found at the top right. Fly Speed - Changes the vertical and horizonal fly speed to navigate around your world faster. Night Vision - Turns on night vision to make editing under ground and in dark places easier.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorsettings?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Settings Pane 02/12/2025  The Settings Pane can be opened via the Action Bar or File -> Settings.  The Settings Pane includes these options:  Show Invisible Blocks - Some blocks don't render by default. This setting allows you to view these blocks for ease of editing. Show Chunk Boundries - Shows the boundry between chunks. Show Compass - Toggles the directional compass found at the top right. Fly Speed - Changes the vertical and horizonal fly speed to navigate around your world faster. Night Vision - Turns on night vision to make editing under ground and in dark places easier.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorselectiontool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Selection Tool 06/11/2025  Use Selection to select any of the blocks in the world (including air). The Selection menu lets you change the Selection Mode, Transform the selection, Fill the selection with blocks, or Deselect your selection.   Tip  Pressing Ctrl+S switches to Selection when you're using a different tool.  Selection Modes  Editor supports three different Selection modes so you can pick the one that makes the most sense for your project's needs.  Marquee Selection  Marquee creates a selection area when you choose the X, Y, and Z coordinates (in that order). Selections can include air, but you can't choose air as a coordinate.  There's more than one way to specify the coordinates in Marquee mode thanks to the Selection helper features.  Gizmos  When you make a selection and click on one of the white corners, a blue, red, and green arrow appears — that's the Resize Gizmo! You can click and drag the Resize Gizmo to adjust the size of your selection with your mouse.  You might have noticed another white box, hovering in the center of your selection — that's a Move Gizmo! You can click and drag the Move Gizmo around to move your selection with the mouse.  Practice using Marquee Selection:  Choose Marquee as the Selection Mode.  Click a block on the ground in front of you with your cursor to choose the block that will hold the X coordinate.  Hold Shift and click another block to chooses the Z coordinate. A square with X and Z as opposite corners will appear on the ground.  To add the Y coordinate, hold Alt and click somewhere above the square.  Deselect the selection (Ctrl+D) before moving on to the next practice.  Freehand Brush Selection  Creates a selection with the same mechanic as the Brush Paint Tool to create a more seamless integration for creators that heavily rely on Brush Paint in their workflow.  Brush Settings   Note  These settings are only visible in the Selection menu when Freehand Brush Mode is selected.  Brush  Choose a cursor with one of the six supported brush shapes.  Ellipsoid  Cuboid  Cylinder  Cone  Pyramid  Single Block  Offset  Specify the selection's offset from the cursor location.  Shape Settings  Uniform  Combines the following three fields into a single one that defines the shape's radius.  Width  Defines the selection's width (X-Axis), in blocks.  Height  Defines the selection's height (Y Axis), in blocks.  Depth  Defines the selection's depth (Z Axis), in blocks.  Fill Constraints (Block Filters)  Block Filters determine what type of blocks are included/excluded from the Brush Paint action and how your selection is filled.  Disabled  Uses the type of block currently selected in the Block Picker to fill the entirety of your selection with.  Mask  Lets you specify a list of block types to exclude from the Brush Paint action, preventing them from changing even when included in your selection.  Replace  Lets you specify what type of blocks to replace and the type of block to replace them with.  Magic Select Mode  Used to select entire structures from blocks that are connected to each other in the world. Magic Select can help you quickly adjust, copy, or paste structures to add richness your world.   Note  Magic Select is best used to select isolated structures since it creats a selection out of all connected blocks beside and above the initial selected block. All connected structures will be grouped together (i.e. adjacent trees that are connected by touching leaf blocks).  Quick Actions  These are some of the helper tools you'll use the most with Selection, so we put them together at the top to make them easy to find.  Deselect  Deselects the current selection.  Fill  Fills the selection with the block selected in the Block Picker.  Practice using Fill  Create a selection with any of the selection modes.  Use the Block Picker to choose the Block Type you want to fill your selection with.   Note  The default Block Type is stone.  Click Fill to fill the current selection with your chosen Block Type.  Deselect the shape before moving on.   Note  You can undo a Fill action by pressing Ctrl+Z.  Delete  Deletes the blocks in the current selection, leaving only air behind.  Trim Actions  Trim Selection  ???  Remove Air  ???  Hollow Selection  Retains the outline of your selection while changing all interior blocks to air.  Cursor Settings  Input Modes  Keyboard Only  Uses the directional keys to move the cursor around the world. The mouse and W, A, S, and D keys are still used to move and look around the world, but they're not involved in selecting a block.  Mouse & Keys  Selects blocks based on the location of the cursor. You can click and drag the mouse to create an initial selection larger than one block, and you can use either Gizmos or the Keyboard to adjust your initial selection.  Fixed Distance  Selects blocks, air, or a combination of both, based on your Selection Settings, at a fixed location at the center of the Editor screen.  You can use the scroll wheel on the mouse to increase or decrease the distance between you and the selection cube.   Tip  Fixed distance is the easiest mode to use if you want to select only air blocks.  Practice using Fixed Distance:  Select Fixed Distance from the Input Mode drop-down menu. You should see a thinly-outlined cube shape in front of you.  Hold down the right mouse button while you move the mouse look around the world. Notice how the pre-selection cube stays in the center of the screen?  Next, roll the mouse's scroll wheel back and forth to zoom in and out.  Next, hold Shift while your repeat step 3. See how the fixed distance pre-selection cube changes size and position?  Click to make a selection where the pre-seletion cube is on the screen.  Click the Deselect button (or Ctrl+D) before moving on to the next practice.  Target  Block  Selects the block you highlight with the cursor.  Adjacent  Selects the air next to, above, or below solid blocks that you highlight with the cursor.  Practice using Adjacent:  Make sure the Selection Target is set to Adjacent.   Note  When you move the mouse around, you will see a faint cube outline move around with the cursor.  Click to choose the outlined cube as your selection.  Deselect the Selection (Ctrl+D) before moving on to the next practice.  Transform  In the Transform section, you can move and fine-tune your selection by entering Origin coordinates or changing the selection Size.  Origin  Represents the world-coordinates for the center of your selection.  Practice transforming the selection's origin:  Create a selection with any of the selection modes.  Look in the lower left corner of the UI to see your cursor's coordinates. Compare the position coordinates with the X, Y, and Z coordinates in the Origin.  Increase the X coordinate and press enter. Notice how the selection moves.  Change the Y and Z coordinates to better understand how the selection is affected.  Deselect the selection (Ctrl+D) before moving on to the next practice.  Size  Used to adjust the size of your selection based on the length of each axis.  Practice changing the selection's size:  Create a selection with any of the selection modes.  Increase or decrease each coordinate and notice how the size and shape of the selection is affected.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorselectiontool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Selection Tool 06/11/2025  Use Selection to select any of the blocks in the world (including air). The Selection menu lets you change the Selection Mode, Transform the selection, Fill the selection with blocks, or Deselect your selection.   Tip  Pressing Ctrl+S switches to Selection when you're using a different tool.  Selection Modes  Editor supports three different Selection modes so you can pick the one that makes the most sense for your project's needs.  Marquee Selection  Marquee creates a selection area when you choose the X, Y, and Z coordinates (in that order). Selections can include air, but you can't choose air as a coordinate.  There's more than one way to specify the coordinates in Marquee mode thanks to the Selection helper features.  Gizmos  When you make a selection and click on one of the white corners, a blue, red, and green arrow appears — that's the Resize Gizmo! You can click and drag the Resize Gizmo to adjust the size of your selection with your mouse.  You might have noticed another white box, hovering in the center of your selection — that's a Move Gizmo! You can click and drag the Move Gizmo around to move your selection with the mouse.  Practice using Marquee Selection:  Choose Marquee as the Selection Mode.  Click a block on the ground in front of you with your cursor to choose the block that will hold the X coordinate.  Hold Shift and click another block to chooses the Z coordinate. A square with X and Z as opposite corners will appear on the ground.  To add the Y coordinate, hold Alt and click somewhere above the square.  Deselect the selection (Ctrl+D) before moving on to the next practice.  Freehand Brush Selection  Creates a selection with the same mechanic as the Brush Paint Tool to create a more seamless integration for creators that heavily rely on Brush Paint in their workflow.  Brush Settings   Note  These settings are only visible in the Selection menu when Freehand Brush Mode is selected.  Brush  Choose a cursor with one of the six supported brush shapes.  Ellipsoid  Cuboid  Cylinder  Cone  Pyramid  Single Block  Offset  Specify the selection's offset from the cursor location.  Shape Settings  Uniform  Combines the following three fields into a single one that defines the shape's radius.  Width  Defines the selection's width (X-Axis), in blocks.  Height  Defines the selection's height (Y Axis), in blocks.  Depth  Defines the selection's depth (Z Axis), in blocks.  Fill Constraints (Block Filters)  Block Filters determine what type of blocks are included/excluded from the Brush Paint action and how your selection is filled.  Disabled  Uses the type of block currently selected in the Block Picker to fill the entirety of your selection with.  Mask  Lets you specify a list of block types to exclude from the Brush Paint action, preventing them from changing even when included in your selection.  Replace  Lets you specify what type of blocks to replace and the type of block to replace them with.  Magic Select Mode  Used to select entire structures from blocks that are connected to each other in the world. Magic Select can help you quickly adjust, copy, or paste structures to add richness your world.   Note  Magic Select is best used to select isolated structures since it creats a selection out of all connected blocks beside and above the initial selected block. All connected structures will be grouped together (i.e. adjacent trees that are connected by touching leaf blocks).  Quick Actions  These are some of the helper tools you'll use the most with Selection, so we put them together at the top to make them easy to find.  Deselect  Deselects the current selection.  Fill  Fills the selection with the block selected in the Block Picker.  Practice using Fill  Create a selection with any of the selection modes.  Use the Block Picker to choose the Block Type you want to fill your selection with.   Note  The default Block Type is stone.  Click Fill to fill the current selection with your chosen Block Type.  Deselect the shape before moving on.   Note  You can undo a Fill action by pressing Ctrl+Z.  Delete  Deletes the blocks in the current selection, leaving only air behind.  Trim Actions  Trim Selection  ???  Remove Air  ???  Hollow Selection  Retains the outline of your selection while changing all interior blocks to air.  Cursor Settings  Input Modes  Keyboard Only  Uses the directional keys to move the cursor around the world. The mouse and W, A, S, and D keys are still used to move and look around the world, but they're not involved in selecting a block.  Mouse & Keys  Selects blocks based on the location of the cursor. You can click and drag the mouse to create an initial selection larger than one block, and you can use either Gizmos or the Keyboard to adjust your initial selection.  Fixed Distance  Selects blocks, air, or a combination of both, based on your Selection Settings, at a fixed location at the center of the Editor screen.  You can use the scroll wheel on the mouse to increase or decrease the distance between you and the selection cube.   Tip  Fixed distance is the easiest mode to use if you want to select only air blocks.  Practice using Fixed Distance:  Select Fixed Distance from the Input Mode drop-down menu. You should see a thinly-outlined cube shape in front of you.  Hold down the right mouse button while you move the mouse look around the world. Notice how the pre-selection cube stays in the center of the screen?  Next, roll the mouse's scroll wheel back and forth to zoom in and out.  Next, hold Shift while your repeat step 3. See how the fixed distance pre-selection cube changes size and position?  Click to make a selection where the pre-seletion cube is on the screen.  Click the Deselect button (or Ctrl+D) before moving on to the next practice.  Target  Block  Selects the block you highlight with the cursor.  Adjacent  Selects the air next to, above, or below solid blocks that you highlight with the cursor.  Practice using Adjacent:  Make sure the Selection Target is set to Adjacent.   Note  When you move the mouse around, you will see a faint cube outline move around with the cursor.  Click to choose the outlined cube as your selection.  Deselect the Selection (Ctrl+D) before moving on to the next practice.  Transform  In the Transform section, you can move and fine-tune your selection by entering Origin coordinates or changing the selection Size.  Origin  Represents the world-coordinates for the center of your selection.  Practice transforming the selection's origin:  Create a selection with any of the selection modes.  Look in the lower left corner of the UI to see your cursor's coordinates. Compare the position coordinates with the X, Y, and Z coordinates in the Origin.  Increase the X coordinate and press enter. Notice how the selection moves.  Change the Y and Z coordinates to better understand how the selection is affected.  Deselect the selection (Ctrl+D) before moving on to the next practice.  Size  Used to adjust the size of your selection based on the length of each axis.  Practice changing the selection's size:  Create a selection with any of the selection modes.  Increase or decrease each coordinate and notice how the size and shape of the selection is affected.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorbrushtool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Brush Tool 06/11/2025  Brush is used to draw shapes with a selected block type.  You can change the brush size, ranging from 1 to 16. Brush sizes are rendered as squares of the selected brush size. This means a brush size of 1 draws a 1x1 block shape. If you select a brush size of 3, you get a 3x3 block shape, or 9 total blocks arranged as a cube.  You can click once once to place one block shape, or click and drag to place blocks everywhere you touch. This should make it easier to build up shapes from the ground - like mountains!  Cursor Settings  Input Methods  Keyboard Only  Uses the directional keys to move the cursor around the world. The mouse and W,A,S,D keys are still used to move and look around the world, but they're not involved in determining block placement.  Mouse & Keys  Places blocks based on the location of the cursor. You can click and drag the mouse to create a cascade of blocks with the shape you specify across a wide area.  Fixed Distance  Places the blocks at a fixed location away from you, in the center of the Editor screen.   Tip  You can use the scroll wheel on the mouse to increase or decrease the distance between you and the selection cube.  Brush Target  Block  Replaces the block(s) you highlight with the cursor with Brush contents.  Adjacent  Places the blocks next to, above, or below solid blocks that you highlight with the cursor.  Brush Settings  Brush Types  Choose a cursor with one of the six supported shapes:  Ellipsoid  Cuboid  Cylinder  Cone  Pyramid  Single Block  Offset  Specify the selection's offset from the cursor location.  Shape Settings  Shape Settings apply to all Brush Types except for Single Block. Here, you'll find sliders that adjust the radius of each of the Brush's axes to fine-tune the shape to suit your needs.   Note  Cylinder, Cone, and Pyramid Brushes also include an option to specify the axis of extrusion.  Uniform  Normalizes the depth field with the length field, resulting in a single radius/length field (regular polyhedrons) or both a length and height field (irregular polyhedrons).  Width  Defines the selection's width (X-Axis), in blocks.  Height  Defines the selection's height (Y Axis), in blocks.  Depth  Defines the selection's depth (Z Axis), in blocks.  Fill Constraints  Block Filters determine what type of blocks are included/excluded from the Brush Paint action and how your selection is filled.  Disabled  Uses the type of block currently selected in the Block Picker to fill the entirety of your selection with.  Mask  Lets you specify a list of block types to exclude from the Brush Paint action, preventing them from changing even when included in your selection.  Replace  Lets you specify what type of blocks to replace and the type of block to replace them with.  Practice: A humble tree...  Move to a clear area.  Switch to Brush by clicking the button in the toolbar on the left of the Editor.   Tip  Pressing Ctrl+B also switches to Brush.  Set the Brush Size to 1, check the box for Face Mode, and choose Log for the Block Type.  Find a clear place on the ground and place one log block.  Place some more log blocks on top of each other to create a tree trunk.  Change the Block Size to 3 and the Block Type to Leaves, then click the top of your log blocks to put leaves around the top of your tree.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorbrushtool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Brush Tool 06/11/2025  Brush is used to draw shapes with a selected block type.  You can change the brush size, ranging from 1 to 16. Brush sizes are rendered as squares of the selected brush size. This means a brush size of 1 draws a 1x1 block shape. If you select a brush size of 3, you get a 3x3 block shape, or 9 total blocks arranged as a cube.  You can click once once to place one block shape, or click and drag to place blocks everywhere you touch. This should make it easier to build up shapes from the ground - like mountains!  Cursor Settings  Input Methods  Keyboard Only  Uses the directional keys to move the cursor around the world. The mouse and W,A,S,D keys are still used to move and look around the world, but they're not involved in determining block placement.  Mouse & Keys  Places blocks based on the location of the cursor. You can click and drag the mouse to create a cascade of blocks with the shape you specify across a wide area.  Fixed Distance  Places the blocks at a fixed location away from you, in the center of the Editor screen.   Tip  You can use the scroll wheel on the mouse to increase or decrease the distance between you and the selection cube.  Brush Target  Block  Replaces the block(s) you highlight with the cursor with Brush contents.  Adjacent  Places the blocks next to, above, or below solid blocks that you highlight with the cursor.  Brush Settings  Brush Types  Choose a cursor with one of the six supported shapes:  Ellipsoid  Cuboid  Cylinder  Cone  Pyramid  Single Block  Offset  Specify the selection's offset from the cursor location.  Shape Settings  Shape Settings apply to all Brush Types except for Single Block. Here, you'll find sliders that adjust the radius of each of the Brush's axes to fine-tune the shape to suit your needs.   Note  Cylinder, Cone, and Pyramid Brushes also include an option to specify the axis of extrusion.  Uniform  Normalizes the depth field with the length field, resulting in a single radius/length field (regular polyhedrons) or both a length and height field (irregular polyhedrons).  Width  Defines the selection's width (X-Axis), in blocks.  Height  Defines the selection's height (Y Axis), in blocks.  Depth  Defines the selection's depth (Z Axis), in blocks.  Fill Constraints  Block Filters determine what type of blocks are included/excluded from the Brush Paint action and how your selection is filled.  Disabled  Uses the type of block currently selected in the Block Picker to fill the entirety of your selection with.  Mask  Lets you specify a list of block types to exclude from the Brush Paint action, preventing them from changing even when included in your selection.  Replace  Lets you specify what type of blocks to replace and the type of block to replace them with.  Practice: A humble tree...  Move to a clear area.  Switch to Brush by clicking the button in the toolbar on the left of the Editor.   Tip  Pressing Ctrl+B also switches to Brush.  Set the Brush Size to 1, check the box for Face Mode, and choose Log for the Block Type.  Find a clear place on the ground and place one log block.  Place some more log blocks on top of each other to create a tree trunk.  Change the Block Size to 3 and the Block Type to Leaves, then click the top of your log blocks to put leaves around the top of your tree.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorlinetool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Line Tool 06/11/2025  Use the Line to quickly draw borders, outlines, and other line-based shapes in your world.  Algorithm Direct  Draws a straight line from your Start to End point.  StaggeredCountour  Draws a zig-zag line from your Start to End point.   Note  Surface Contour is always enabled when using a Staggered Algorithm.  Line Weight:  The Line Weight sliders let you adjust line thickness vertically and horizontally from 1 to 5. When you select Uniform Line Weight, the Editor compresses the sliders into a single option and applies the same value to both horizontal and vertical thickness.  Line Weight sliders can be adjusted by dragging them with the mouse or pressing Shift+Up/Down/Left/Right keys. Up/Down increases/decreases the Vertical Thickness, while Left/Right will increase/decrease the Horizontal Thickness.   Note  The line will grow in the positive axis direction when the weight is an even number, and in the negative axis direction when the weight is an odd number.  Quick Actions Fill  Fills the selection with the block selected in the Block Picker.  Delete  Deletes the blocks within the line selected.  Add to Selection  Adds the current line preview to your selection.  Clear Selected  Removes the selected line, resetting the cursor.  Clear All  Removes all items from the curent selection, resetting the cursor.  Cursor Settings  Input Modes  Keyboard Only  Uses the directional keys to move the cursor around the world. The mouse and W, A, S, and D keys are still used to move and look around the world, but they're not involved in selecting a block.  Mouse & Keys  Selects blocks based on the location of the cursor. You can click and drag the mouse to create an initial selection larger than one block, and you can use either Gizmos or the Keyboard to adjust your initial selection.  Fixed Distance  Selects blocks, air, or a combination of both, based on your Selection Settings, at a fixed location at the center of the Editor screen.  You can use the scroll wheel on the mouse to increase or decrease the distance between you and the selection cube.   Tip  Fixed distance is the easiest mode to use if you want to select only air blocks.  Target  Block  Selects the block you highlight with the cursor.  Adjacent  Selects the air next to, above, or below solid blocks that you highlight with the cursor.  Integrated mouse functionality  You can add new line segments by simply clicking where you'd like to place them. Holding Ctrl while you click around the world lets you create detatched points that have gizmos you can use to create new lines.  When multiple points are selected, you can click and drag with the mouse or use the hotkeys (Ctrl+Shift+Up/Down/Left/Right/PgUp/PgDown) to move the entire selection.   Note  You can place up to 80 points at one time. Line segments between any two points must be under 100 blocks long.     Hotkeys Expand table Command\tShortcut Toggle line tool\tCtrl+L Clear all points\tCtrl+Backspace Clear selected\tCtrl+Shift+Backspace Fill selected\tCtrl+F Delete selected\tDelete Add to selection\tAlt+S Adjust line thickness\tShift+Up/Down/Left/Right Select all points\tCtrl+A Undo\tCtrl+Z Redo\tCtrl+Y  Check out Keyboard Inputs for a complete list of Editor keyboard shortcuts.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorlinetool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Line Tool 06/11/2025  Use the Line to quickly draw borders, outlines, and other line-based shapes in your world.  Algorithm Direct  Draws a straight line from your Start to End point.  StaggeredCountour  Draws a zig-zag line from your Start to End point.   Note  Surface Contour is always enabled when using a Staggered Algorithm.  Line Weight:  The Line Weight sliders let you adjust line thickness vertically and horizontally from 1 to 5. When you select Uniform Line Weight, the Editor compresses the sliders into a single option and applies the same value to both horizontal and vertical thickness.  Line Weight sliders can be adjusted by dragging them with the mouse or pressing Shift+Up/Down/Left/Right keys. Up/Down increases/decreases the Vertical Thickness, while Left/Right will increase/decrease the Horizontal Thickness.   Note  The line will grow in the positive axis direction when the weight is an even number, and in the negative axis direction when the weight is an odd number.  Quick Actions Fill  Fills the selection with the block selected in the Block Picker.  Delete  Deletes the blocks within the line selected.  Add to Selection  Adds the current line preview to your selection.  Clear Selected  Removes the selected line, resetting the cursor.  Clear All  Removes all items from the curent selection, resetting the cursor.  Cursor Settings  Input Modes  Keyboard Only  Uses the directional keys to move the cursor around the world. The mouse and W, A, S, and D keys are still used to move and look around the world, but they're not involved in selecting a block.  Mouse & Keys  Selects blocks based on the location of the cursor. You can click and drag the mouse to create an initial selection larger than one block, and you can use either Gizmos or the Keyboard to adjust your initial selection.  Fixed Distance  Selects blocks, air, or a combination of both, based on your Selection Settings, at a fixed location at the center of the Editor screen.  You can use the scroll wheel on the mouse to increase or decrease the distance between you and the selection cube.   Tip  Fixed distance is the easiest mode to use if you want to select only air blocks.  Target  Block  Selects the block you highlight with the cursor.  Adjacent  Selects the air next to, above, or below solid blocks that you highlight with the cursor.  Integrated mouse functionality  You can add new line segments by simply clicking where you'd like to place them. Holding Ctrl while you click around the world lets you create detatched points that have gizmos you can use to create new lines.  When multiple points are selected, you can click and drag with the mouse or use the hotkeys (Ctrl+Shift+Up/Down/Left/Right/PgUp/PgDown) to move the entire selection.   Note  You can place up to 80 points at one time. Line segments between any two points must be under 100 blocks long.     Hotkeys Expand table Command\tShortcut Toggle line tool\tCtrl+L Clear all points\tCtrl+Backspace Clear selected\tCtrl+Shift+Backspace Fill selected\tCtrl+F Delete selected\tDelete Add to selection\tAlt+S Adjust line thickness\tShift+Up/Down/Left/Right Select all points\tCtrl+A Undo\tCtrl+Z Redo\tCtrl+Y  Check out Keyboard Inputs for a complete list of Editor keyboard shortcuts.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorrulertool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Ruler Tool 06/11/2025  The Ruler is a quick way to measure the distance between blocks in the Editor.  Select the Ruler by clicking the button on the left side of the Editor.   Tip  Pressing Ctrl+Shift+R also switches to Ruler.  Use the cursor to select the starting point of the distance you want to measure.  Navigate to the end point you want to measure and click it to reveal the distance. The Ruler’s measurement field will display the coordinates of the Start (S) and End (E) points, the line's Depth (D), and the total Length (L) of the line.  Click anywhere to deselect the measurement.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorrulertool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Ruler Tool 06/11/2025  The Ruler is a quick way to measure the distance between blocks in the Editor.  Select the Ruler by clicking the button on the left side of the Editor.   Tip  Pressing Ctrl+Shift+R also switches to Ruler.  Use the cursor to select the starting point of the distance you want to measure.  Navigate to the end point you want to measure and click it to reveal the distance. The Ruler’s measurement field will display the coordinates of the Start (S) and End (E) points, the line's Depth (D), and the total Length (L) of the line.  Click anywhere to deselect the measurement.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorfilltool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fill Tool 06/11/2025  Use Fill to replace a selection with the block type selected in the Block Picker.  You can open the fill tool window by clicking the fill tool button on the left side of the Editor.  Area Limit: The number of blocks around the cursor that will be replaced in all directions. This value can range from 1 to 16.  To use the fill tool to replace blocks with another block type:  Select the Fill tool from the toolbar on the left of the Editor.  Choose the Area Limit in the fill tool window.  Use the Block Picker to choose the type of block you want to replace the terrain with.  Click a block to replace the blocks around it with your selected block type.   Note  Only contiguous blocks of the same type will be replaced. For example, if you click a stone block to replace, all of the stone blocks within the area limit will be replaced with your selected block type. If there are any iron ore blocks within the area limit, they will not be replaced.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorfilltool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Fill Tool 06/11/2025  Use Fill to replace a selection with the block type selected in the Block Picker.  You can open the fill tool window by clicking the fill tool button on the left side of the Editor.  Area Limit: The number of blocks around the cursor that will be replaced in all directions. This value can range from 1 to 16.  To use the fill tool to replace blocks with another block type:  Select the Fill tool from the toolbar on the left of the Editor.  Choose the Area Limit in the fill tool window.  Use the Block Picker to choose the type of block you want to replace the terrain with.  Click a block to replace the blocks around it with your selected block type.   Note  Only contiguous blocks of the same type will be replaced. For example, if you click a stone block to replace, all of the stone blocks within the area limit will be replaced with your selected block type. If there are any iron ore blocks within the area limit, they will not be replaced.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorterraintool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Terrain Tool 06/11/2025  The terrain tool is used to smooth and roughen the terrain. Smooth mode allows you to blend sheer or steep terrain into a graded slope, while roughen does the opposite, making terrain less uniform.  Smooth/Roughen Strength: The number of blocks around the cursor that will be smoothed or roughened. This value can range from 1 to 9.  Brush Settings: You can use the Brush drop-down to select the shape you want to use for smoothing or roughening. Once you choose a brush, you can configure additional settings, such as the offset from the cursor as well as the radius of the cursor shape.  Use Terrain to smooth/roughen the terrain:  Open Terrain by clicking the button on the left side of the Editor.   Tip  Pressing Ctrl+T also switches to Terrain.  Select Terrain Mode and choose Smooth or Roughen.   Tip  Pressing R with Terrain selected toggles between Smooth and Roughen.  Choose the Smooth/Roughen Strength and the Brush. You can also set the offset and radius to adjust the specific area.  Click and drag the cursor along the ground to alter the terrain.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorterraintool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Terrain Tool 06/11/2025  The terrain tool is used to smooth and roughen the terrain. Smooth mode allows you to blend sheer or steep terrain into a graded slope, while roughen does the opposite, making terrain less uniform.  Smooth/Roughen Strength: The number of blocks around the cursor that will be smoothed or roughened. This value can range from 1 to 9.  Brush Settings: You can use the Brush drop-down to select the shape you want to use for smoothing or roughening. Once you choose a brush, you can configure additional settings, such as the offset from the cursor as well as the radius of the cursor shape.  Use Terrain to smooth/roughen the terrain:  Open Terrain by clicking the button on the left side of the Editor.   Tip  Pressing Ctrl+T also switches to Terrain.  Select Terrain Mode and choose Smooth or Roughen.   Tip  Pressing R with Terrain selected toggles between Smooth and Roughen.  Choose the Smooth/Roughen Strength and the Brush. You can also set the offset and radius to adjust the specific area.  Click and drag the cursor along the ground to alter the terrain.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorflattentool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Flatten Tool 06/11/2025  The flatten tool is used to create an area of flat terrain around the cursor.  Height Threshold: The number of blocks above the cursor that will be flattened when you click. This value ranges from 1 to 32.  Radius: The number of blocks around the cursor that will be flattened when you click. This value ranges from 1 to 5.  Use Flatten to adjust the terrain:  Switch to Flatten by clicking the button in the toolbar on the left of the Editor.   Tip  Pressing Ctrl+Shift+H also switches to Flatten.  Select the Radius for the area you want to flatten, then adjust the Height Threshold.  Click and drag the cursor along the ground to flatten the terrain according to your preferences.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorflattentool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Flatten Tool 06/11/2025  The flatten tool is used to create an area of flat terrain around the cursor.  Height Threshold: The number of blocks above the cursor that will be flattened when you click. This value ranges from 1 to 32.  Radius: The number of blocks around the cursor that will be flattened when you click. This value ranges from 1 to 5.  Use Flatten to adjust the terrain:  Switch to Flatten by clicking the button in the toolbar on the left of the Editor.   Tip  Pressing Ctrl+Shift+H also switches to Flatten.  Select the Radius for the area you want to flatten, then adjust the Height Threshold.  Click and drag the cursor along the ground to flatten the terrain according to your preferences.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorextrudetool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Extrude Tool 06/11/2025  The extrude tool is used to add or subract blocks of the same type around the cursor.  Face Size: Determines the number of blocks that will be extruded around the cursor. This value represents the radius size from the block face that you click (i.e., if you click the top face of a block, it will add or subtract blocks using the top face as the center of the radius). This value can range from 1 to 32.  Layer Count: The number of layers that will be added or subtracted from the block that you click. This value can range from 1 to 16.  Contiguous Selection Type: You can use this drop-down to set which types of blocks are added or subtracted.  Use Extrude to adjust terrain elevation:  Open Extrude by clicking the button from the toolbar on the left of the Editor.   Tip  Pressing Ctrl+Shift+E also switches to Extrude.  Set the Height Threshold and the Layer Count.  Click the block you want to Extrude from.   Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorextrudetool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Extrude Tool 06/11/2025  The extrude tool is used to add or subract blocks of the same type around the cursor.  Face Size: Determines the number of blocks that will be extruded around the cursor. This value represents the radius size from the block face that you click (i.e., if you click the top face of a block, it will add or subtract blocks using the top face as the center of the radius). This value can range from 1 to 32.  Layer Count: The number of layers that will be added or subtracted from the block that you click. This value can range from 1 to 16.  Contiguous Selection Type: You can use this drop-down to set which types of blocks are added or subtracted.  Use Extrude to adjust terrain elevation:  Open Extrude by clicking the button from the toolbar on the left of the Editor.   Tip  Pressing Ctrl+Shift+E also switches to Extrude.  Set the Height Threshold and the Layer Count.  Click the block you want to Extrude from.   Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorrepeatertool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Repeater Tool 06/11/2025  The Repeater is used to repeat a selection of blocks to make pattern across a specific volume. You can use this tool to make repetitive block placement much more efficient.  Spacing: The size of the area between each repetition. If you leave the value for an axis at 0, the selection will not repeat along that axis. The maximum value for each axis is the size of your world, but keep in mind that setting very high values will likely cause the Editor to work considerably slower.  Repetitions: The number of times the pattern should repeat across the specified axes.  Use the Repeater to create patterns:  Open the Repeater by clicking the button on the left side of the Editor.   Tip  Pressing Ctrl+R also switches to the Repeater.  Select the group of blocks that you want to repeat.  Set the Spacing and Repetitions in the repeater tool window.  Click Apply.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorrepeatertool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Repeater Tool 06/11/2025  The Repeater is used to repeat a selection of blocks to make pattern across a specific volume. You can use this tool to make repetitive block placement much more efficient.  Spacing: The size of the area between each repetition. If you leave the value for an axis at 0, the selection will not repeat along that axis. The maximum value for each axis is the size of your world, but keep in mind that setting very high values will likely cause the Editor to work considerably slower.  Repetitions: The number of times the pattern should repeat across the specified axes.  Use the Repeater to create patterns:  Open the Repeater by clicking the button on the left side of the Editor.   Tip  Pressing Ctrl+R also switches to the Repeater.  Select the group of blocks that you want to repeat.  Set the Spacing and Repetitions in the repeater tool window.  Click Apply.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorsummontool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Summon Tool 06/11/2025  Select Summon by clicking the button in the toolbar on the left side of the Editor.   Tip  Pressing Ctrl+Shift+S switches to Summon.  Select an Entity Type.  Click where you want to place the entity. If the entity is something with random variations like a horse or sheep, you'll get a random entity on each click.  With the entity selected, you can use Rotation to set which direction the entity is facing (until you un-pause entities).  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorsummontool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Summon Tool 06/11/2025  Select Summon by clicking the button in the toolbar on the left side of the Editor.   Tip  Pressing Ctrl+Shift+S switches to Summon.  Select an Entity Type.  Click where you want to place the entity. If the entity is something with random variations like a horse or sheep, you'll get a random entity on each click.  With the entity selected, you can use Rotation to set which direction the entity is facing (until you un-pause entities).  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorfarmtool?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Farm Tool 06/11/2025  The farm tool is used to create a farm with specified crops and/or animals.  Crops: Check the box for each crop you want to grow on your farm. Crops will be placed randomly within the farm area.  Animals: Check the box for each type of animal that you want to include on your farm. Animals will be placed in random quantities.  Length: The length of your farm.  Width: The width of your farm.  Fence: The type of fence surrounding your farm.  Irrigation: Check this box to add irrigation channels between the crops on your farm.  To use the farm generator tool to create a farm:  Open Farm by clicking the button in the toolbar on the left side of the Editor.   Tip  Pressing Ctrl+P also switches to Farm.  Choose the crops, animals, size, fence, and irrigation settings that you want for your farm.  Click a block on the ground to place a farm with that block at its center.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorfarmtool?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Farm Tool 06/11/2025  The farm tool is used to create a farm with specified crops and/or animals.  Crops: Check the box for each crop you want to grow on your farm. Crops will be placed randomly within the farm area.  Animals: Check the box for each type of animal that you want to include on your farm. Animals will be placed in random quantities.  Length: The length of your farm.  Width: The width of your farm.  Fence: The type of fence surrounding your farm.  Irrigation: Check this box to add irrigation channels between the crops on your farm.  To use the farm generator tool to create a farm:  Open Farm by clicking the button in the toolbar on the left side of the Editor.   Tip  Pressing Ctrl+P also switches to Farm.  Choose the crops, animals, size, fence, and irrigation settings that you want for your farm.  Click a block on the ground to place a farm with that block at its center.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorblockinspector?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Block Inspector 05/21/2025  The Block Inspector lets you view and modify block properties to fine tune block details.   Note  Not all properties are customizable for all blocks.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorblockinspector?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Block Inspector 05/21/2025  The Block Inspector lets you view and modify block properties to fine tune block details.   Note  Not all properties are customizable for all blocks.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorentityinspector?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Entity Inspector 05/21/2025  The Entity Inspector lets you view and modify entity properties, giving you more control over things like entity variants.   Note  Not all properties are customizable for all entities.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorentityinspector?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Entity Inspector 05/21/2025  The Entity Inspector lets you view and modify entity properties, giving you more control over things like entity variants.   Note  Not all properties are customizable for all entities.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorstructures?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structures 05/21/2025  The Structures panel is designed to hold structures so you can move them to and from the clipboard. This helps you rapidly build complex scenes by stamping prebuilt structures instead of relying on copy/paste or rebuilding them each from scratch.  The Structures Panel is routinely synchronized, so you'll also be able to see and use the structures that other players save in your world.   Note  The Structures panel is not added to the Action Bar by default. Click the + button to add the Structures panel to the Action Bar.  Saving a structure  Select the area or structure in the world you want to save.  Press Ctrl+C to copy the selection to your clipboard.  From Structures, name your structure and click New from Clipboard.  Deploying a structure  From Structures, check the box next to the structure you want to use.  Click Copy to Clipboard.  Press Ctrl+Shift+V to begin Paste Preview.  Right-click to place the structure.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorstructures?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structures 05/21/2025  The Structures panel is designed to hold structures so you can move them to and from the clipboard. This helps you rapidly build complex scenes by stamping prebuilt structures instead of relying on copy/paste or rebuilding them each from scratch.  The Structures Panel is routinely synchronized, so you'll also be able to see and use the structures that other players save in your world.   Note  The Structures panel is not added to the Action Bar by default. Click the + button to add the Structures panel to the Action Bar.  Saving a structure  Select the area or structure in the world you want to save.  Press Ctrl+C to copy the selection to your clipboard.  From Structures, name your structure and click New from Clipboard.  Deploying a structure  From Structures, check the box next to the structure you want to use.  Click Copy to Clipboard.  Press Ctrl+Shift+V to begin Paste Preview.  Right-click to place the structure.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorworkbench?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Workbench Tool 05/21/2025  The Workbench tool lets you toggle the state of blocks with modifiable properties like doors, fences, snow, and candles. You can use the Workbench tool to conveniently change a block's properties without switching to Crosshair mode.  Use the following quick-actions with Workbench to change block states:  Left-click Shift+Left-click Ctrl+Left-click Shift+Ctrl+Left-click   Note  Each block has unique states.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/editorworkbench?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Workbench Tool 05/21/2025  The Workbench tool lets you toggle the state of blocks with modifiable properties like doors, fences, snow, and candles. You can use the Workbench tool to conveniently change a block's properties without switching to Crosshair mode.  Use the following quick-actions with Workbench to change block states:  Left-click Shift+Left-click Ctrl+Left-click Shift+Ctrl+Left-click   Note  Each block has unique states.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/EditorOverview?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Overview 12/04/2024  This overview is intended to introduce you to the parts of the Editor interface and the tools. The keyboard shortcuts, also known as keybindings, have been provided with each tool and in the table at the end of this document.  For a more in-depth experience using the tools to accomplish basic tasks, take a look at the Editor Tutorial.  There's more information about Editor on the Minecraft: Bedrock Editor GitHub site!   Important  The Editor is in beta and we're working to add more capabilities. It will continue to change as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  In this manual, you will learn the following:  What the difference is between a project and a world How to create a project How to customize the user interface and project world settings What all the parts of the UI are and where to find them How to save a project How to open an existing project How to export a project as a world How to open a world created from a project Where Editor stores exported and saved files Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  It's recommended that the following be completed before beginning this tutorial.  How to get Minecraft Bedrock Editor Creating an Editor Project  After you launch Editor, you get a screen that says \"Create New Project.\"  While you're creating a project, you can configure the name, export settings, and the usual settings for a Minecraft world.  Export settings will apply when you export as a playable world from the Editor (.mcworld).  New projects load with a Welcome/Quick Start screen. If you close it and you want it open again, go to the Help menu and select Quick Start.  First Things First: UI Settings  Editor looks like your usual Minecraft game with a user interface (UI) on top of it. Before we get started, let's make sure that UI looks okay for your monitor resolution and preferences.  Go to the File menu and select UI Settings.  UI Scale - Makes the menu bar and windows larger or smaller in relation to the project world. Font - Changes the size of the text in the windows. Theme - Changes the colors used in the UI.  After you make a selection from the UI Settings menu, your changes are reflected immediately.  Hint: If you accidentally adjust things to where you can't read the settings to fix it, press the Alt F4 keys on your keyboard to close Editor. Then, launch Editor again and create a new project. (This is part of why we're doing this first.)  Editor works with Minecraft Accessibility features.  When you're happy with the UI Settings, you can click the X to close the UI Settings window.  Editor UI Windows: Move, Minimize, Close  You can move Editor windows by clicking and dragging them by the title bar.  Click the double \"up arrows\" in the corner to collapse the windows upwards so you can tuck them out of the way if you don't want to close them.  If you do want to close the window, click the X in the corner. Some windows can be re-opened with a keyboard shortcut.  Welcome/Quick Start  Expand table Tab\tContent Introduction\tWelcome to the Minecraft Editor Beta, a tool designed to help you create stunning worlds in Bedrock with ease.  You may find these links helpful on your journey:   Documentation Report problems and give feedback Editor Community  To reopen Quick Start, you can find it under the 'Help' menu. Movement\tTo navigate in the Editor, you'll need a keyboard and mouse. Trackpads or controllers aren't recommended.  To move around in Editor:   Hold down the right mouse button to look around. While holding the right mouse button, move horizontally with WASD and vertically with SHIFT and SPACE.  Tools\tYou can find tools on the left rail. Each tool allows you to edit your world in different ways.  Click on the Information button (\"i\") at the top right corner of each tool to learn more about how it works. Actions\tActions are shortcuts that live at the top of your screen. Hit the “+” button in the Action Bar to customize which are displayed.  At the top center of your screen is the Block Hotbar. Click once to change the active block, click twice to open the Block Picker to customize the Hotbar.  You can create a new Hotbar by clicking the Hotbar Menu button to the right. \t Movement  Before we dive into the Tool Mode UI, you might want to take a moment to familiarize yourself with how to look around and move around in the different modes.  Unlock the camera: In Tool mode, hold down the right mouse button to look around. In Crosshair Mode, you do not need to hold down the right mouse button.  Moving around: In Tool Mode, hold the right mouse button down while you press W, A, S, D, Space, and Shift keys. You do not need to hold down the right mouse button to use the same keys to move around in Crosshair Mode.  Fly Speed: In Tool Mode, click the View menu and select View Settings to open the View Settings panel. From here, you can set your fly speed from 1 to 10 so that you can navigate your project faster.  Look-to-teleport: In Tool Mode, point your cursor at a block in the distance, and hit G on your keyboard. You will be \"Grapple teleported\" there. This function does not work in Crosshair Mode.  Directional Compass: In the upper-right corner of the editor window, the directional compass will show you which cardinal direction you are facing. You can even click a direction to snap your view to face it.  Editor and Bedrock Dedicated Server  Editor is only enabled in the preview version of Win32 Bedrock Dedicated Server (BDS). There are two ways to launch it:  Launch the .exe with the command line, like this:  bedrock_server.exe Editor=true  This will only work if you're launching BDS from scratch with no existing world.  You should see the output say:  Copy ##################################################### #                                                   # #              CREATING EDITOR PROJECT              # #                                                   # #####################################################  Create an Editor project from Minecraft Launch Editor from the usual desktop shortcut. Create a new Editor Project. Locate the Editor Project in the com.mojang/minecraftWorlds folder and copy it into the BDS worlds folder Ensure that server.properties has the correct world name. Execute bedrock_server.exe.  If correctly set up, you should see the output say  [2023-10-24 07:21:43:977 INFO] Enabling Editor Services  Editor Mode is controlled by a flag in the level data (not by the command line), so you need to launch the server either by having the server create a new Editor project, or by launching the server using an existing Editor project.  When the server is up and running, any client connections from Minecraft Bedrock Edition will connect as editor sessions and present the editor interface. If using a Preview version, connections from Non-Preview editions of Minecraft will be refused.  What's Next?  Now that you know more about the parts of Editor, let's use the tools to do some editing!  Editor Tutorial  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/bedrockeditor/EditorOverview?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Editor Overview 12/04/2024  This overview is intended to introduce you to the parts of the Editor interface and the tools. The keyboard shortcuts, also known as keybindings, have been provided with each tool and in the table at the end of this document.  For a more in-depth experience using the tools to accomplish basic tasks, take a look at the Editor Tutorial.  There's more information about Editor on the Minecraft: Bedrock Editor GitHub site!   Important  The Editor is in beta and we're working to add more capabilities. It will continue to change as we get feedback from creators like you. Also, the images of Editor in this document might vary a little from what you have on your screen.  In this manual, you will learn the following:  What the difference is between a project and a world How to create a project How to customize the user interface and project world settings What all the parts of the UI are and where to find them How to save a project How to open an existing project How to export a project as a world How to open a world created from a project Where Editor stores exported and saved files Requirements  To get started, you need the following:  A Windows 10 (or higher) computer with Minecraft Bedrock Editor Keyboard and mouse   Important  Editor is PC only and not available on mobile or console.  It's recommended that the following be completed before beginning this tutorial.  How to get Minecraft Bedrock Editor Creating an Editor Project  After you launch Editor, you get a screen that says \"Create New Project.\"  While you're creating a project, you can configure the name, export settings, and the usual settings for a Minecraft world.  Export settings will apply when you export as a playable world from the Editor (.mcworld).  New projects load with a Welcome/Quick Start screen. If you close it and you want it open again, go to the Help menu and select Quick Start.  First Things First: UI Settings  Editor looks like your usual Minecraft game with a user interface (UI) on top of it. Before we get started, let's make sure that UI looks okay for your monitor resolution and preferences.  Go to the File menu and select UI Settings.  UI Scale - Makes the menu bar and windows larger or smaller in relation to the project world. Font - Changes the size of the text in the windows. Theme - Changes the colors used in the UI.  After you make a selection from the UI Settings menu, your changes are reflected immediately.  Hint: If you accidentally adjust things to where you can't read the settings to fix it, press the Alt F4 keys on your keyboard to close Editor. Then, launch Editor again and create a new project. (This is part of why we're doing this first.)  Editor works with Minecraft Accessibility features.  When you're happy with the UI Settings, you can click the X to close the UI Settings window.  Editor UI Windows: Move, Minimize, Close  You can move Editor windows by clicking and dragging them by the title bar.  Click the double \"up arrows\" in the corner to collapse the windows upwards so you can tuck them out of the way if you don't want to close them.  If you do want to close the window, click the X in the corner. Some windows can be re-opened with a keyboard shortcut.  Welcome/Quick Start  Expand table Tab\tContent Introduction\tWelcome to the Minecraft Editor Beta, a tool designed to help you create stunning worlds in Bedrock with ease.  You may find these links helpful on your journey:   Documentation Report problems and give feedback Editor Community  To reopen Quick Start, you can find it under the 'Help' menu. Movement\tTo navigate in the Editor, you'll need a keyboard and mouse. Trackpads or controllers aren't recommended.  To move around in Editor:   Hold down the right mouse button to look around. While holding the right mouse button, move horizontally with WASD and vertically with SHIFT and SPACE.  Tools\tYou can find tools on the left rail. Each tool allows you to edit your world in different ways.  Click on the Information button (\"i\") at the top right corner of each tool to learn more about how it works. Actions\tActions are shortcuts that live at the top of your screen. Hit the “+” button in the Action Bar to customize which are displayed.  At the top center of your screen is the Block Hotbar. Click once to change the active block, click twice to open the Block Picker to customize the Hotbar.  You can create a new Hotbar by clicking the Hotbar Menu button to the right. \t Movement  Before we dive into the Tool Mode UI, you might want to take a moment to familiarize yourself with how to look around and move around in the different modes.  Unlock the camera: In Tool mode, hold down the right mouse button to look around. In Crosshair Mode, you do not need to hold down the right mouse button.  Moving around: In Tool Mode, hold the right mouse button down while you press W, A, S, D, Space, and Shift keys. You do not need to hold down the right mouse button to use the same keys to move around in Crosshair Mode.  Fly Speed: In Tool Mode, click the View menu and select View Settings to open the View Settings panel. From here, you can set your fly speed from 1 to 10 so that you can navigate your project faster.  Look-to-teleport: In Tool Mode, point your cursor at a block in the distance, and hit G on your keyboard. You will be \"Grapple teleported\" there. This function does not work in Crosshair Mode.  Directional Compass: In the upper-right corner of the editor window, the directional compass will show you which cardinal direction you are facing. You can even click a direction to snap your view to face it.  Editor and Bedrock Dedicated Server  Editor is only enabled in the preview version of Win32 Bedrock Dedicated Server (BDS). There are two ways to launch it:  Launch the .exe with the command line, like this:  bedrock_server.exe Editor=true  This will only work if you're launching BDS from scratch with no existing world.  You should see the output say:  Copy ##################################################### #                                                   # #              CREATING EDITOR PROJECT              # #                                                   # #####################################################  Create an Editor project from Minecraft Launch Editor from the usual desktop shortcut. Create a new Editor Project. Locate the Editor Project in the com.mojang/minecraftWorlds folder and copy it into the BDS worlds folder Ensure that server.properties has the correct world name. Execute bedrock_server.exe.  If correctly set up, you should see the output say  [2023-10-24 07:21:43:977 INFO] Enabling Editor Services  Editor Mode is controlled by a flag in the level data (not by the command line), so you need to launch the server either by having the server create a new Editor project, or by launching the server using an existing Editor project.  When the server is up and running, any client connections from Minecraft Bedrock Edition will connect as editor sessions and present the editor interface. If using a Preview version, connections from Non-Preview editions of Minecraft will be refused.  What's Next?  Now that you know more about the parts of Editor, let's use the tools to do some editing!  Editor Tutorial  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/camerapresetfree?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Free Camera Preset Tutorial 08/16/2024  In this tutorial you will learn how the free camera preset command works.  You can find more information about the camera command in the Camera Command Introduction.  Free Camera Functionality  The free camera preset can be used to accomplish many gameplay scenarios by setting the camera at a distance away from players and entities to show more of the environment. You can even set up cutscenes and use easing methods to have the camera flyover a scene.  The free camera preset can be set up in JSON to be executed in the game at the exact parameters and settings you choose. In this tutorial we'll focus on how the commands work in the game first.  In this tutorial you will learn how to:  Set the camera's position and facing direction Set the easing method Combine easing, position, and facing direction for a flyover camera effect Disable player movement, as needed Apply a fade effect with a custom time and color Teleport during a fade  To practice these features and see how they work in the game, let's try out a cutscene scenario. Say you want to make a cutscene where the camera transitions from the player's view to show a flyover of the landscape and then turn to face the player. Let's try it!  Step 1: Frame your Cutscene  First, find the location for your scene. Think about the position you want to show and the direction you want the viewer to face.  To get the coordinates you'll use to set the position of the camera, go into a world in creative mode (with coordinates toggled on), find a location you like, and make a note of those coordinates.  Position  The camera command supports adjusting the position relative to the world or to the player in these three ways:  1. World coordinates  The world map is on a grid, with every location in space plotted to a spot on the x, y, and z axis.  You will use these coordinates to place the camera at that location on the grid.  x (west and east, or longitude) y (above or below the player) z (north and south, or latitude)  The command will look something like this, but with your own values for x, y, and z.  /camera @s set minecraft:free pos -65 70 17  2. Distance from the player, in a cardinal direction  The world itself has a true North, South, East, and West.  Using ~ ~ ~ lets you set the distance away from the target determined by cardinal direction.  This command will set the camera to be 5 blocks North from the player using the z coordinate:  /camera @s set minecraft:free pos ~ ~ ~5  To set the camera to be 5 blocks South, use a negative z coordinate like this:  /camera @s set minecraft:free pos ~ ~ ~-5  3. Distance from the player, in the direction the player is facing  This command sets the camera to be 5 blocks in front of the player:  /camera @s set minecraft:free pos ^ ^ ^5  To find coordinates and set the location of the free camera to those coordinates.  Go into creative mode and note the coordinates.  Return your player to the starting area.  Use a command like this to position the camera at the coordinates:  /camera @s set minecraft:free pos -51 80 22  @s set minecraft:free pos -51 80 22\" />  In this example, the camera is in the right location. Now, we need to set the facing direction or rotation.  Step 2: Set the Camera's Facing Direction  To angle the camera so it points in the direction you want, there are a few options:  Face the nearest player @p Face yourself @s Face entities @e Set the rotation Face yourself  This is the same command from the previous step, with the addition of facing @s so the camera faces you:  /camera @s set minecraft:free pos -51 80 22 facing @s  Set the camera rotation  It's important to note that rotation values are X and Y but those are not the same as x and y coordinate/cardinal values.  Y = yaw  The rotation of the camera 360 degrees around the target parallel to the earth. The yaw value can be up to 180 to point directly to the right, and up to -180 to point directly to the left.  X = pitch  The angle up or down, perpendicular to the earth. Pitch is limited to a range of 90 facing straight down to -90 facing straight up. This limitation is to prevent rolling the camera upside down.  A couple of notes about position:  When adjusting the camera position, the camera is not limited to whole numbers. Try setting the camera at 5.75 or 1.95 to fine tune the positioning of the camera to your needs. When setting the camera relative to the player's position, you many notice an offset that may place the camera not relative to 0 but relative to some offset from the player.  In this example, the camera is in position and facing the player, but the movement of the camera was not smooth - it was immediate. To fix this, let's add a transition to make the movement more cinematic.  Step 3: Set up a Camera Transition  The camera is set up to capture the scene, but without an easing transition, the movement is abrupt. This step adds an easing method to transition from the player to the camera position in a smooth way.  Transitions need 2 variables: time and an ease method, also known as an \"easing.\"  Time -This is the amount of time the camera will take to move into position. This allows you to set the camera to move slowly or quickly. You enter the time in seconds as a number. Ease method - There are 32 different easings to choose from. You can find a list on the Easing Functions Website. Play around to find your favorite!  This example shows how to add an easing transition to the position and facing direction.  /camera @s set minecraft:free ease 8 linear pos -51 80 22 facing @s  Enter the command with your coordinates, time, and an ease to demonstrate the difference between the transition with and without easing.  Then, you can try the command again to demonstrate how it looks when the camera is going fast or slow.  After that, try changing the position coordinates to demonstrate how the distance changes the speed or how the easing transition behaves.  Step 4: Use Fades  In this step, we return the player to their last camera perspective while using a fade.  Fade time is used to configure the lengths of the phases of the fade, and fade color is used to specify what single, solid color you want the scene to fade to.  Fade time  To set the time, you need to include how many seconds for each phase of the fade: fade-in, hold, and fade-out.  Fade-in will dim the scene and fade in the color, hold will keep the color on the screen, then fade-out will dissolve the fade color and restore the scene.  This example shows the effect of setting all three values to 5 seconds:  /camera @a fade time 5 5 5  This example will set the fade-in to 3 seconds, the hold to 2 seconds, and the fade-out to 3 seconds:  /camera @a fade time 3 2 3  The target is set to @a, so that the fade will be seen by all players. You can also set it so that only the player sees the fade.  Fade color  In addition to the length of the fade, you can set the color of the fade by adjusting the amounts of red, blue, and green that will be mixed to create your fade color. The amounts go from 0 to 255 for each of the three colors.  /camera @a fade color 0 0 0 would make a classic fade to black.  /camera @a fade color 255 255 255 makes the screen fade to white.  To make a red fade, set red to 255, green to 0, and blue to 0 like this:  /camera @a fade color 255 0 0  Step 5: Prevent the Player from Moving  During a fade, the player can't see anything but they can still move. That can be dangerous! If you don't want the player to move during a fade, you can disable player movement.  Do this by using another command before the camera command.  Inputpermission movement disabled disables the player from moving their feet and body.  /inputpermission set @s movement disabled  To allow them to move again, do the same command but add enabled instead of disabled.  /inputpermission set @s movement enabled  Inputpermission camera disabled disables player head movement.  /inputpermission set @s camera disabled  To allow them to move their head again, do the same command but use enabled instead of disabled.  /inputpermission set @s camera enabled  When the cutscene is over, enable input permissions to allow the player to move again.  Step 6: Using Fades and Teleports Together  When teleporting a player to a location, it's nice to have a transition that makes that smoother.  Here is the example of the first part - configuring a 10-second fade...  This is the result showing that when the player's screen fades in, they have been teleported to an entirely new location.  Focus Target  Focus target adds the ability to target and track an entity with various options. Focus target will first be built on top of the existing minecraft:free camera. This behavior would mimic a security camera where the creator could choose what entity they want to track with customizable features  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/camerapresetfree?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Free Camera Preset Tutorial 08/16/2024  In this tutorial you will learn how the free camera preset command works.  You can find more information about the camera command in the Camera Command Introduction.  Free Camera Functionality  The free camera preset can be used to accomplish many gameplay scenarios by setting the camera at a distance away from players and entities to show more of the environment. You can even set up cutscenes and use easing methods to have the camera flyover a scene.  The free camera preset can be set up in JSON to be executed in the game at the exact parameters and settings you choose. In this tutorial we'll focus on how the commands work in the game first.  In this tutorial you will learn how to:  Set the camera's position and facing direction Set the easing method Combine easing, position, and facing direction for a flyover camera effect Disable player movement, as needed Apply a fade effect with a custom time and color Teleport during a fade  To practice these features and see how they work in the game, let's try out a cutscene scenario. Say you want to make a cutscene where the camera transitions from the player's view to show a flyover of the landscape and then turn to face the player. Let's try it!  Step 1: Frame your Cutscene  First, find the location for your scene. Think about the position you want to show and the direction you want the viewer to face.  To get the coordinates you'll use to set the position of the camera, go into a world in creative mode (with coordinates toggled on), find a location you like, and make a note of those coordinates.  Position  The camera command supports adjusting the position relative to the world or to the player in these three ways:  1. World coordinates  The world map is on a grid, with every location in space plotted to a spot on the x, y, and z axis.  You will use these coordinates to place the camera at that location on the grid.  x (west and east, or longitude) y (above or below the player) z (north and south, or latitude)  The command will look something like this, but with your own values for x, y, and z.  /camera @s set minecraft:free pos -65 70 17  2. Distance from the player, in a cardinal direction  The world itself has a true North, South, East, and West.  Using ~ ~ ~ lets you set the distance away from the target determined by cardinal direction.  This command will set the camera to be 5 blocks North from the player using the z coordinate:  /camera @s set minecraft:free pos ~ ~ ~5  To set the camera to be 5 blocks South, use a negative z coordinate like this:  /camera @s set minecraft:free pos ~ ~ ~-5  3. Distance from the player, in the direction the player is facing  This command sets the camera to be 5 blocks in front of the player:  /camera @s set minecraft:free pos ^ ^ ^5  To find coordinates and set the location of the free camera to those coordinates.  Go into creative mode and note the coordinates.  Return your player to the starting area.  Use a command like this to position the camera at the coordinates:  /camera @s set minecraft:free pos -51 80 22  @s set minecraft:free pos -51 80 22\" />  In this example, the camera is in the right location. Now, we need to set the facing direction or rotation.  Step 2: Set the Camera's Facing Direction  To angle the camera so it points in the direction you want, there are a few options:  Face the nearest player @p Face yourself @s Face entities @e Set the rotation Face yourself  This is the same command from the previous step, with the addition of facing @s so the camera faces you:  /camera @s set minecraft:free pos -51 80 22 facing @s  Set the camera rotation  It's important to note that rotation values are X and Y but those are not the same as x and y coordinate/cardinal values.  Y = yaw  The rotation of the camera 360 degrees around the target parallel to the earth. The yaw value can be up to 180 to point directly to the right, and up to -180 to point directly to the left.  X = pitch  The angle up or down, perpendicular to the earth. Pitch is limited to a range of 90 facing straight down to -90 facing straight up. This limitation is to prevent rolling the camera upside down.  A couple of notes about position:  When adjusting the camera position, the camera is not limited to whole numbers. Try setting the camera at 5.75 or 1.95 to fine tune the positioning of the camera to your needs. When setting the camera relative to the player's position, you many notice an offset that may place the camera not relative to 0 but relative to some offset from the player.  In this example, the camera is in position and facing the player, but the movement of the camera was not smooth - it was immediate. To fix this, let's add a transition to make the movement more cinematic.  Step 3: Set up a Camera Transition  The camera is set up to capture the scene, but without an easing transition, the movement is abrupt. This step adds an easing method to transition from the player to the camera position in a smooth way.  Transitions need 2 variables: time and an ease method, also known as an \"easing.\"  Time -This is the amount of time the camera will take to move into position. This allows you to set the camera to move slowly or quickly. You enter the time in seconds as a number. Ease method - There are 32 different easings to choose from. You can find a list on the Easing Functions Website. Play around to find your favorite!  This example shows how to add an easing transition to the position and facing direction.  /camera @s set minecraft:free ease 8 linear pos -51 80 22 facing @s  Enter the command with your coordinates, time, and an ease to demonstrate the difference between the transition with and without easing.  Then, you can try the command again to demonstrate how it looks when the camera is going fast or slow.  After that, try changing the position coordinates to demonstrate how the distance changes the speed or how the easing transition behaves.  Step 4: Use Fades  In this step, we return the player to their last camera perspective while using a fade.  Fade time is used to configure the lengths of the phases of the fade, and fade color is used to specify what single, solid color you want the scene to fade to.  Fade time  To set the time, you need to include how many seconds for each phase of the fade: fade-in, hold, and fade-out.  Fade-in will dim the scene and fade in the color, hold will keep the color on the screen, then fade-out will dissolve the fade color and restore the scene.  This example shows the effect of setting all three values to 5 seconds:  /camera @a fade time 5 5 5  This example will set the fade-in to 3 seconds, the hold to 2 seconds, and the fade-out to 3 seconds:  /camera @a fade time 3 2 3  The target is set to @a, so that the fade will be seen by all players. You can also set it so that only the player sees the fade.  Fade color  In addition to the length of the fade, you can set the color of the fade by adjusting the amounts of red, blue, and green that will be mixed to create your fade color. The amounts go from 0 to 255 for each of the three colors.  /camera @a fade color 0 0 0 would make a classic fade to black.  /camera @a fade color 255 255 255 makes the screen fade to white.  To make a red fade, set red to 255, green to 0, and blue to 0 like this:  /camera @a fade color 255 0 0  Step 5: Prevent the Player from Moving  During a fade, the player can't see anything but they can still move. That can be dangerous! If you don't want the player to move during a fade, you can disable player movement.  Do this by using another command before the camera command.  Inputpermission movement disabled disables the player from moving their feet and body.  /inputpermission set @s movement disabled  To allow them to move again, do the same command but add enabled instead of disabled.  /inputpermission set @s movement enabled  Inputpermission camera disabled disables player head movement.  /inputpermission set @s camera disabled  To allow them to move their head again, do the same command but use enabled instead of disabled.  /inputpermission set @s camera enabled  When the cutscene is over, enable input permissions to allow the player to move again.  Step 6: Using Fades and Teleports Together  When teleporting a player to a location, it's nice to have a transition that makes that smoother.  Here is the example of the first part - configuring a 10-second fade...  This is the result showing that when the player's screen fades in, they have been teleported to an entirely new location.  Focus Target  Focus target adds the ability to target and track an entity with various options. Focus target will first be built on top of the existing minecraft:free camera. This behavior would mimic a security camera where the creator could choose what entity they want to track with customizable features  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Camera System  The Camera System section features content about cameras.  Pages TRAINING Camera System Introduction Free Camera Command Tutorial Free Camera Script API Tutorial Third Person Presets Overview Camera APIs REFERENCE minecraft/server.Camera Class minecraft/server.CameraDefaultOptions Interface minecraft/server.CameraEaseOptions Interface minecraft/server.CameraFadeOptions Interface minecraft/server.CameraFadeTimeOptions Interface minecraft/server.CameraSetFacingOptions Interface minecraft/server.CameraSetLocationOptions Interface minecraft/server.CameraSetPosOptions Interface minecraft/server.CameraSetRotOptions Interface"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Camera System  The Camera System section features content about cameras.  Pages TRAINING Camera System Introduction Free Camera Command Tutorial Free Camera Script API Tutorial Third Person Presets Overview Camera APIs REFERENCE minecraft/server.Camera Class minecraft/server.CameraDefaultOptions Interface minecraft/server.CameraEaseOptions Interface minecraft/server.CameraFadeOptions Interface minecraft/server.CameraFadeTimeOptions Interface minecraft/server.CameraSetFacingOptions Interface minecraft/server.CameraSetLocationOptions Interface minecraft/server.CameraSetPosOptions Interface minecraft/server.CameraSetRotOptions Interface"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/cameracommandintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn The Camera System 02/12/2025  The Bedrock version of Minecraft has a /camera command that adds the ability to control how players view the game or adds full-screen fades for a more polished experience. This document goes into all the relevant detail of how it works and can be used to make interesting new experiences.  This new feature adds the concept of Camera Presets, plus a new command to interact with those presets.  Camera Presets  Camera Presets define individual cameras which can be specified by the camera command. They can be built-in or can be defined by creator content in behavior packs.  The built-in Camera Preset names are:  \"minecraft:first_person\" \"minecraft:third_person\" \"minecraft:third_person_front\" \"minecraft:free\"  The first three names correspond to the standard gameplay perspective options which you can cycle through by pressing F5 on the keyboard, pressing \"up\" on the controller directional pad, or by selecting the perspective you want in the Settings menu.  The last name is for the new free camera, which just floats in space and does nothing.  Custom content can define its own Camera Presets. For example, an \"example:sky\" camera might be defined based on the \"minecraft:free\" camera, but with a custom position and rotation to view the world at a specific angle.  Adding one or more Camera Presets to a Behavior Pack  Inside the com.mojang folder for the version of Minecraft you want the camera to appear in, open your development_behavior_packs folder and do this:  Create a Behavior Pack folder, as shown in the Behavior Pack tutorial.  Inside the Behavior Pack folder, create another folder and name it Cameras.  On the same level as the Cameras folder, add a manifest.json file. This manifest file should not reference a resource pack.  Inside the Cameras folder, create another folder and name it Presets.  Inside the Presets folder, create a text file and name it camera.json. (It does not have to be this name, but it should be different from the built-in preset camera names listed in the Camera Presets section.)  Open the camera.json file and paste in the example JSON below. Then, adjust the variables as you like.  Your folder structure should look like this:  You should now be able to create a world using this add-on and transition to the camera by using the identifier in the JSON.  You can add multiple camera files to the Presets folder and call to the different cameras in the game by giving each one a unique identifier.  If everything is working, your custom camera preset should show up in the auto-complete list when typing the camera command.  Camera Presets are specified in JSON files in the game's behavior packs, for example:  JSON Copy {    \"format_version\": \"1.19.50\",    \"minecraft:camera_preset\": {      \"identifier\": \"example:custom\",      \"inherit_from\": \"minecraft:free\",      \"pos_x\": 30,      \"pos_y\": 90,      \"pos_z\": -20,      \"rot_x\": 10,      \"rot_y\": 40    }  }    This defines a new Camera Preset named \"example:custom\" which inherits settings and behaviors from the \"minecraft:free\" camera, then specifies its own default position as \"x=30\", \"y=90\", \"z=-20\" and a rotation of \"x=10\", \"y=40\".  \"format_version\" behaves like it does in many other Bedrock Minecraft JSON files. It allows Mojang to change the expected JSON format of the file without invalidating old files. For now, you can just use \"1.19.50\".  \"identifier\" names the Camera Preset. All Camera Preset identifiers must be namespace-qualified, and like with other content, custom presets must use a namespace other than \"minecraft\".  \"inherit_from\" says what other Camera Preset to inherit values and behaviors from. A custom Camera Preset can inherit from other custom Camera Presets, or from the \"minecraft:free\" preset. For now, the other built-in camera perspectives can't be specified here. This can let a creator define a hierarchy of Camera Presets if they desire, for example an \"example:security_base\" camera could have an elevation and pitch defined in its \"pos_y\" and \"rot_x\" fields, and \"example_security_1\" through \"example_security_5\" could use \"inherit_from\" to use that preset's values, and only specify their X/Z positions via \"pos_x\" and \"pos_z\" and the yaw via \"rot_y\". With something like that set up, it would only take one edit to the base security camera to modify the elevation of all the security cameras.  \"pos_x\", \"pos_y\", and \"pos_z\" specify the default constant x, y, and z positions of the camera. If these are omitted, the value from the \"inherit_from\" Camera Preset will be used. \"minecraft:free\" uses a value of zero for all of its position settings. Be sure to set more useful positions here or via the camera command or your camera perspective will be underground.  \"rot_x\" and \"rot_y\" specify the default rotations of the camera, around each of those axes. \"rot_x\" is equivalent to the pitch of the camera, though with positive values looking downward and negative values looking up, which matches the convention of the teleport command. \"rot_y\" is equivalent to the yaw, or compass direction of the camera, also matching the behavior of the teleport command. Both values are specified in degrees, and \"rot_x\" must be no lower than –90 and no higher than 90, to prevent the camera from going upside-down.   Note  See more reference samples at the end of this article.  Player state affecting rendering  With this version of Minecraft, the minecraft:free Preset (and any presets based on it, which includes all custom presets) will not by default use the state of the player when the game is rendered. This includes a number of effects such as night vision and blindness. This can be enabled by adding \"player_effects\": true to the Camera Preset's JSON file.  Player inside block rendering  In typical Minecraft gameplay, there is a screen effect that covers the screen when the player's head is inside of a block and the camera is in a third-person perspective. Since the minecraft:free camera is not directly connected to the player, this was somewhat confusing to users, for example if the minecraft:free camera was active and the player teleported inside a mountain, the screen would go black. This functionality has been disabled for the minecraft:free camera and other custom Camera Presets.  Player-camera distance affecting entity rendering  The game typically only renders entities, players, and chunks in an area surrounding the player's position. Because of this, setting the camera a long distance from the player or moving the player a long distance from the camera could result in unexpected visual results. If you have Content Log messages enabled, you may see a warning alerting you to this, but players typically do not have those messages enabled and will probably not see the warning.  In addition, for entities to render, they need to be in loaded and ticking chunks. When a camera is set to move away from the player, it should sync player and entity data resulting in performant rendering at most gameplay distances.  In the camera.json file, extend_player_rendering extends this maximum distance. As long as the camera and entities are in chunks that are loaded and ticking, they will render on the client when the camera moves. This has been optimized to show the player and any rides or entities connected by a leash. This may also show mobs and other entities that are between the player and the camera. This is an enhancement, and no action is needed to apply this functionality. This will make it possible to do a cutscene with the free camera flying over a large distance away from the player.  Audio listener position  With Minecraft 1.20.10, the position and orientation of the camera is now used by default for how the game's audio system directs sounds to your device's speakers. For example, if a sound is to the left of the camera it should play out of the left speaker regardless of the player's position or rotation in the world. Previously this was based on the player's head position and rotation. If you want a custom Camera Preset to use the player position for the audio listener position, simply add \"listener\":\"player\" to the Preset's JSON file. An example \"example:example_player_listener\" JSON has been included in the experimental Cameras behavior pack to demonstrate this feature.  Camera Command Syntax  This command has the following syntax options:  /camera <players> set <preset> [ease <easeTime> <easeType>] [pos <x> <y> <z>] [rot <xRot> <yRot>]  /camera <players> set <preset> [ease <easeTime> <easeType>] [default]  /camera <players> clear  /camera <players> fade [time <fadeInSeconds> <holdSeconds> <fadeOutSeconds>] [color <red> <green> <blue>]  Every version of the camera command starts with a player selector, which is used to specify the player or players who will be affected by the command. After that, there are three options that you can specify: \"set\", \"clear\", or \"fade\". \"set\" will cause the targeted player(s) to use a specified camera perspective. \"clear\" will return the targeted player(s) back to their usual camera mode. \"fade\" will cause a full-screen fade, like what players see when sleeping in a bed.  The \"set\" Option  The \"set\" option for the camera command will cause the selected players to view the game through the specified Camera Preset. Until they disconnect from the game or a camera command using \"clear\" is used, they will use the specified Preset. This overrides things that normally control camera perspective like the settings menu option.  When no additional parameters are specified, this will cause the user's camera perspective to immediately snap to the specified Camera Preset. There are several additional options that can be used with the \"set\" option.  The \"ease\" sub-option  The ease option will cause the transition between the views to be done over some specified number of seconds, rather than instantly. It requires specifying an 'easeType', which is the name of one of the various easing methods available. The 32 different options are \"linear\", \"spring\", or the thirty other options that can be viewed at on Easing Functions Cheat Sheet (easings.net)  Eased motions always start from where the camera currently is, so an ease from A to B which is interrupted with another ease to C will start from somewhere in between A and B.  Eased transitions to the three standard gameplay perspectives are not allowed, as they are tied strongly to the player, and if the player moves or turns in drastic ways, the eased transition to those perspectives can be very unpleasant to experience.  The \"pos\" sub-option  This sub-option of the \"set\" option allows the camera command to specify an override to the position that is defined in the Camera Preset's JSON file. It supports the \"~\" and \"^\" characters like other commands do, allowing the command to set the camera to a dynamically calculated position.  Warning: Setting the position of a camera to an area of the world that isn't loaded is not a supported scenario, though there is not a plan currently to programmatically prevent it. The chunks of the world will still only load if the player is nearby and the device's render distance option is high enough. Positioning the camera in ways that look beyond what is loaded is something that may not function consistently in the future. It's recommended to keep the camera somewhat near the player and to double-check content on lower-end devices or with a lower render distance setting to ensure that things will work for all users.  The \"rot\" sub-option  Like the \"pos\" sub-option, the \"rot\" sub-option overrides the rotation of the Camera Preset. The \"~\" character is supported here to specify relative rotations. The \"xRot\" and \"yRot\" values in this command correspond to the \"rot_x\" and \"rot_y\" properties in the Camera Preset JSON file. As with the \"rot_x\" property, the result of the \"xRot\" value is clamped to no less than –90 degrees and no more than 90 degrees, to prevent the camera from going upside-down.  Camera Pitch Limits  To avoid the camera going fully upside-down, the pitch of the camera has been limited to not more than 90 degrees and not less than negative 90 degrees. This applies to the \"rot_x\" rotation specified in a Camera Preset JSON file and to values specified in the /camera command. If a value outside of this range is specified directly in JSON or a command, a content error message will be displayed and the Preset or command won't work. If a relative rotation (like ~20) happens to go outside of this range, the resulting pitch value will be clamped to the [–90,90] range and the command will work.  The \"default\" sub-option  This sub-option of the \"set\" option will use the position and rotation of the Camera Preset according to its JSON definition in the behavior pack. In other words, this causes any previous \"pos\" or \"rot\" overrides to be discarded.  The facing alternative for the /camera command  To make it easier to point a camera at a particular location, a ‘facing' option has been added to the /camera command. Wherever a rotation could be previously specified with the ‘rot' option, now ‘facing' can be used instead. ‘facing' should be followed either by an entity selector like [type=cow] or by x y z coordinates. This works a similar way the ‘facing' option functions with the /teleport command. The x y z position or the center of the targeted entity's bounding box is put through some math relative to the camera's current position, and an equivalent x and y rotation are calculated and used as if the ‘rot' option was used in the first place with those desired angles.  The \"clear\" Option  The \"clear\" option for the camera command takes no additional arguments. It causes the specified players to end any in-progress camera perspectives, including any eased camera motions, and return to normal. For example, to return all players back to normal camera functionality, run:  /camera @a clear  After a \"clear\" command, players will see the game through the perspective they have selected in the option menu, and will be able to resume using the perspective change key (i.e., F5 on keyboard) to change that setting. VR users will also be able to transition from the virtual Living Room back to the Immersive first-person view if desired.  The \"fade\" Option  The \"fade\" option of the camera command causes a full-screen color to fade in, wait, then fade out. It uses the same effect as when the player sleeps in a bed.  /camera <players> fade [time <fadeInSeconds> <holdSeconds> <fadeOutSeconds>] [color <red> <green> <blue>]  The \"time\" sub-option  This sub-option allows for customizing the timing of the fade effect. If not specified, this will use a 1 second fade in, a 0.5 second hold, and a 1 second fade out. Fade in, hold, and fade out are each limited to no more than 10 seconds. If a longer fade (or dynamically timed fade out) is needed, multiple fade commands can be used – see the \"Combining fades\" section.  The \"color\" sub-option  This sub-option allows for customizing the color of the fade effect. The red, green, and blue values should each be an integer value from 0 to 255. The target opacity of the fade is always fully opaque. If this is not specified, it will use 0 for each value, which causes a fade to black.  Fade timing, networked gameplay, and game performance  Because Minecraft content can be played over a network connection or on a device that isn't running at a perfect frame rate, it's important to keep in mind that the timing of camera fades may not always show up at exactly the desired moment. When authoring a fade effect, it's a good idea to consider adding more time to the ‘holdSeconds' value or to test on less powerful platforms to check that the presentation is acceptable.  Camera Fade Changes  The fade command parameters are now integers that can be as low as 0 and as high as 255.  The timing of fades has had a limit added, which is that none of the three timing values can exceed 10 seconds. This is to avoid accidental fades that last far longer than intended. As before, issuing multiple fade instructions will continue to combine the timing together, so fades beyond ten seconds are still possible.  Combining fades  It's possible (and valid) to issue a camera fade command while a camera fade is already in progress. When that happens, the fades are combined with the following logic. This can be useful for extending fades dynamically until some other event takes place.  The timing of the fade will combine in a way that will fade in with the faster of either the remaining fade-in time or the new fade's fade-in time. The fade out will start when both fades are ready to fade out (whichever is later). The fade out will similarly complete when both fades would complete (whichever is later).  The amount of fade transparency will always start with the current fade amount. For example, if a slow fade is in progress and half complete, and a new quick fade command is received, the user will see a quick fade from half opaque to fully opaque.  The target color (red, green, blue) of a combined fade is always the color of the in-progress fade. See \"Limitations on fades\" below.  Limitations on fades  For user comfort, fades follow two additional rules.  First, all fades must take at least 0.5 seconds so they won't happen more than two times per second. If a camera fade starts where the combined fade in plus hold plus fade out time is less than 0.5 seconds, the hold time will be increased to make up the difference.  Second, if a fade is already in progress, new fades will continue to use the same color as the in-progress fade effect. This prevents full-screen changes between different colors.  Additional Notes and Nuances Targeting  Aim Assist  Aim assist allows content creators to enable aim assist for players with specified settings. The Aim assist will find a target in a specified range and allow players to interact with them directly. When in free cam, for example a bird's-eye view, it can be hard to target things like levers and buttons so aim assist will help highlight whatever the player is aiming at in any given moment. It should improve players' aiming experience that allows players to target and interact with blocks and actors easily regardless of the camera preset chosen by the creator.  For more information, see Introduction to Aim Assist.  Focus Target  Focus target adds the ability to target and track a singular entity with various options.  Focus target is built on top of the existing minecraft:free camera. This behavior mimics a security camera where the creator can choose what entity they want to track with customizable features.  Here are options you can use within the Minecraft console:  Add a target: /camera @s target_entity <entity>  Apply an offset from the entity’s center (optional): /camera @s target_entity <entity> target_center_offset <x, y, z>  Remove the targeting logic from the free camera: /camera @s remove_target  Additionally, you can use the /camera @s clear command to remove the targeting logic, or when a target is 64 chunks (1024 blocks) away from the target camera's location it will automatically be removed.  In addition to these commands, you can also control a variety of options through a behavior pack:  \"rotation_speed\": is a float value that controls the rotation speed of the target camera is degrees per second. Must be > 0.0f. By default this is set to 0.0f which is \"perfect\" tracking and will always keep up with the target no matter the speed.  \"snap_to_target\": is a Boolean that, if true and used in combination with a valid rotation speed, will make the camera snap to the target in the first frame of tracking, then continue to track at the given rotation speed. This value defaults to false where the camera will always rotate at the given valid rotation speed.  Note for horizontal rotation limits: The direction the free camera is initially facing when spawned in will be what the target camera considers as 'zero' rotation. That means that if you were to have horizontal rotation limits, they would be based relative to where the target camera was FIRST looking.  \"horizontal_rotation_limit\": is a Vec2 of floats where the default is 360.0 degrees. The x value of the Vec2 is the rotation allowed to the left (CCW) turning of the target camera. The y value of the Vec2 is the rotation allowed to the right (CW) of the target camera. The sum of the x and y values cannot exceed 360.0 degrees. The default values are [ 0.0, 360.0 ]. For example if you wanted 45.0 degrees of rotation to the left and 30.0 degrees of rotation to the right of where the free camera was first spawned in, you would enter \"horizontal_rotation_limit\": [ 45.0, 30.0 ]. Notice that both values are positive.  For vertical rotation limits, this rotation limit is based on world space, meaning that it does not depend on the initial rotation of the free camera:  0.0 degrees equates to straight down  90.0 degrees is the horizon  180.0 degrees is straight up  \"vertical_rotation_limit\": is a Vec2 of floats where the default is 180.0 degrees rotation up and down. The sum of the x and y values cannot exceed 180.0 degrees. The default values are [ 0.0, 180.0 ]. For example if you wanted 45.0 degrees of rotation down from the horizon and 30.0 degrees of rotation up from the horizon, you would enter \"vertical_rotation_limit\": [ 45.0, 120.0 ].  \"continue_targeting\": is a Boolean that will try to continually target the entity if it leaves either a valid rotation limit or tracking radius. Defaults to false meaning that after the entity has left valid rotation limits or tracking radius, the target camera will return to where it was initially looking.  \"tracking_radius\": is a float value denoting the block distance from the target camera that you want it to listen for the specified entity. Default value is 50.0 blocks.  Here is an example camera file from a behavior pack with the default values:  JSON Copy {   \"format_version\": \"1.21.30\",     \"minecraft:camera_preset\": {     \"identifier\": \"example:custom_target\",     \"inherit_from\": \"minecraft:free\",     \"rotation_speed\": 0.0,     \"snap_to_target\": false,     \"horizontal_rotation_limit\": [ 0.0, 360.0 ],     \"vertical_rotation_limit\": [ 0.0, 180.0 ],     \"continue_targeting\": false,     \"tracking_radius\": 50.0   } }  User Input  When the \"minecraft:free\" camera (or a custom camera based on it) is used via the \"set\" option of the Camera command, user input will be handled as if the player is in the first-person camera view. This means that the player can continue to turn around, place blocks, or otherwise interact with the world as usual, they just will not see it from the typical viewpoint.  If player input is not desired when the \"minecraft:free\" camera is active, other commands can be used to limit the player's abilities. See the \"Combining Multiple Commands Together\" section for some suggestions.  Persistence of Camera State  There will be no persistence of camera state for players across game sessions. For example, if a player is under the effect of \"/camera … set\", then they exit the game in any way and rejoin later, they will load into the world as if no camera command is active. It will be up to the created world's logic to put rejoined players back into the desired camera state.  During the time a player is loaded into a particular world, it will persist any position or rotation values that have been specified to override a camera's default JSON state.  For example, if a player is set to a custom camera with a custom position like this:  /camera @a set example:my_camera pos 100 100 100  ... then the player is put back to normal:  /camera @a clear  Later, the camera is put back to the custom camera:  /camera @a set example:my_camera  The example:my_camera camera will be at 100 100 100 instead of its default position specified in the JSON file.  To return that camera back to normal, the player could either exit and rejoin the game, or the following command could activate the camera while returning it back to its default state:  /camera @a set example:my_camera default  How the Camera Command Affects VR Users  When using a Virtual Reality headset, players can be in an immersive first-person view, or in a virtual living room with a virtual television that displays a flat view of the game. When a camera command using \"set\" targets a VR player in the immersive first-person view, they will be transitioned to the virtual living room and the specified Camera Preset will appear on the virtual screen. While a \"set\" is active to force the player to a particular perspective (including \"minecraft:first_person\"), pressing the perspective change button will display a message explaining the situation, and the transition to the immersive view will be prevented.  Camera commands using \"fade\" will not do anything for VR users in the immersive first-person mode, but players in the virtual living room will still see it.  Combining Multiple Commands Together  The new Camera Command allows for a variety of new simple features, but combining multiple commands together can allow for a wider array of possibilities. Here are some examples:  Making a simple non-interactive cutscene  To make a simple non-interactive cutscene, a camera command can be combined with the /inputpermission command to disable player movement and rotation:  /camera @a set example:cutscene_camera  /inputpermission @a camera disabled  /inputpermission @a movement disabled  Then at the end of the cutscene animations:  /camera @a clear  /inputpermission @a camera enabled  /inputpermission @a movement enabled  Hiding a teleport  To hide a player or other mob teleport, use the camera fade command combined with some delayed teleport commands:  /camera @a fade time 0.5 0.5 0.5  Then after half a second, teleport the player to the desired location:  /tp @a <x y z coordinates here>  If this is being used to teleport the player to an area that may not have loaded yet, increase the middle number (the \"holdSeconds\") to give the player's device enough time to load the surrounding area.  Transitioning to and from a flyover camera  When a player encounters a new part of an adventure map, showing a dramatic flyover of the area can add some interest to the upcoming experience. This can be done with a series of camera commands:  First, start a camera fade to hide the next transition...  /camera @a fade time 0.5 0.2 0.5  After 0.5 seconds (the \"fadeInSeconds\" time), issue a command to cut to one position and another command to start an eased camera motion. This assumes that Camera Presets named \"example:flyover_start\" and \"example:flyover_end\" have been defined in a behavior pack.  /camera @a set example:flyover_start  /camera @a set example:flyover_end ease 5 linear  Then after three seconds (before that five second movement ends and with enough time to fade again) issue another fade command.  /camera @a fade time 0.5 0.2 0.5  Then after another 0.5 seconds, return the camera back to normal.  /camera @a clear  The Camera Command and Split-screen Gameplay  When multiple people are playing in split-screen on the same device, they have separate cameras and separate targetable player entities. When the new Camera command is used (whether for \"set\" or \"fade\" options), that separation is not changed. Each player's camera can be separately affected. There are no plans for combining views in split-screen scenarios, or for supporting multiple split-screen-like views for individual players.  Additional free camera preset examples: Player listener  This controls what is used for the audio listener.  Creators will sometimes want the player's position to continue being where the audio system's \"ears\" are, and other times they will want this listener position to be where the camera is.  JSON Copy {   \"format_version\": \"1.19.50\",   \"minecraft:camera_preset\": {     \"identifier\": \"example:example_player_listener\",     \"inherit_from\": \"minecraft:free\",     \"listener\": \"player\"   } }  Player effect  Optional, defaults to false. Specify true to allow effects on the player to affect how the game renders when this preset is active.  Basically, it determines whether the player state can affect rendering. A security camera's view of a player who is on fire shouldn't look like the security camera is on fire, for example.  JSON Copy {   \"format_version\": \"1.19.50\",   \"minecraft:camera_preset\": {     \"identifier\": \"example:example_player_effects\",     \"inherit_from\": \"minecraft:free\",     \"player_effects\": true   } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/cameracommandintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn The Camera System 02/12/2025  The Bedrock version of Minecraft has a /camera command that adds the ability to control how players view the game or adds full-screen fades for a more polished experience. This document goes into all the relevant detail of how it works and can be used to make interesting new experiences.  This new feature adds the concept of Camera Presets, plus a new command to interact with those presets.  Camera Presets  Camera Presets define individual cameras which can be specified by the camera command. They can be built-in or can be defined by creator content in behavior packs.  The built-in Camera Preset names are:  \"minecraft:first_person\" \"minecraft:third_person\" \"minecraft:third_person_front\" \"minecraft:free\"  The first three names correspond to the standard gameplay perspective options which you can cycle through by pressing F5 on the keyboard, pressing \"up\" on the controller directional pad, or by selecting the perspective you want in the Settings menu.  The last name is for the new free camera, which just floats in space and does nothing.  Custom content can define its own Camera Presets. For example, an \"example:sky\" camera might be defined based on the \"minecraft:free\" camera, but with a custom position and rotation to view the world at a specific angle.  Adding one or more Camera Presets to a Behavior Pack  Inside the com.mojang folder for the version of Minecraft you want the camera to appear in, open your development_behavior_packs folder and do this:  Create a Behavior Pack folder, as shown in the Behavior Pack tutorial.  Inside the Behavior Pack folder, create another folder and name it Cameras.  On the same level as the Cameras folder, add a manifest.json file. This manifest file should not reference a resource pack.  Inside the Cameras folder, create another folder and name it Presets.  Inside the Presets folder, create a text file and name it camera.json. (It does not have to be this name, but it should be different from the built-in preset camera names listed in the Camera Presets section.)  Open the camera.json file and paste in the example JSON below. Then, adjust the variables as you like.  Your folder structure should look like this:  You should now be able to create a world using this add-on and transition to the camera by using the identifier in the JSON.  You can add multiple camera files to the Presets folder and call to the different cameras in the game by giving each one a unique identifier.  If everything is working, your custom camera preset should show up in the auto-complete list when typing the camera command.  Camera Presets are specified in JSON files in the game's behavior packs, for example:  JSON Copy {    \"format_version\": \"1.19.50\",    \"minecraft:camera_preset\": {      \"identifier\": \"example:custom\",      \"inherit_from\": \"minecraft:free\",      \"pos_x\": 30,      \"pos_y\": 90,      \"pos_z\": -20,      \"rot_x\": 10,      \"rot_y\": 40    }  }    This defines a new Camera Preset named \"example:custom\" which inherits settings and behaviors from the \"minecraft:free\" camera, then specifies its own default position as \"x=30\", \"y=90\", \"z=-20\" and a rotation of \"x=10\", \"y=40\".  \"format_version\" behaves like it does in many other Bedrock Minecraft JSON files. It allows Mojang to change the expected JSON format of the file without invalidating old files. For now, you can just use \"1.19.50\".  \"identifier\" names the Camera Preset. All Camera Preset identifiers must be namespace-qualified, and like with other content, custom presets must use a namespace other than \"minecraft\".  \"inherit_from\" says what other Camera Preset to inherit values and behaviors from. A custom Camera Preset can inherit from other custom Camera Presets, or from the \"minecraft:free\" preset. For now, the other built-in camera perspectives can't be specified here. This can let a creator define a hierarchy of Camera Presets if they desire, for example an \"example:security_base\" camera could have an elevation and pitch defined in its \"pos_y\" and \"rot_x\" fields, and \"example_security_1\" through \"example_security_5\" could use \"inherit_from\" to use that preset's values, and only specify their X/Z positions via \"pos_x\" and \"pos_z\" and the yaw via \"rot_y\". With something like that set up, it would only take one edit to the base security camera to modify the elevation of all the security cameras.  \"pos_x\", \"pos_y\", and \"pos_z\" specify the default constant x, y, and z positions of the camera. If these are omitted, the value from the \"inherit_from\" Camera Preset will be used. \"minecraft:free\" uses a value of zero for all of its position settings. Be sure to set more useful positions here or via the camera command or your camera perspective will be underground.  \"rot_x\" and \"rot_y\" specify the default rotations of the camera, around each of those axes. \"rot_x\" is equivalent to the pitch of the camera, though with positive values looking downward and negative values looking up, which matches the convention of the teleport command. \"rot_y\" is equivalent to the yaw, or compass direction of the camera, also matching the behavior of the teleport command. Both values are specified in degrees, and \"rot_x\" must be no lower than –90 and no higher than 90, to prevent the camera from going upside-down.   Note  See more reference samples at the end of this article.  Player state affecting rendering  With this version of Minecraft, the minecraft:free Preset (and any presets based on it, which includes all custom presets) will not by default use the state of the player when the game is rendered. This includes a number of effects such as night vision and blindness. This can be enabled by adding \"player_effects\": true to the Camera Preset's JSON file.  Player inside block rendering  In typical Minecraft gameplay, there is a screen effect that covers the screen when the player's head is inside of a block and the camera is in a third-person perspective. Since the minecraft:free camera is not directly connected to the player, this was somewhat confusing to users, for example if the minecraft:free camera was active and the player teleported inside a mountain, the screen would go black. This functionality has been disabled for the minecraft:free camera and other custom Camera Presets.  Player-camera distance affecting entity rendering  The game typically only renders entities, players, and chunks in an area surrounding the player's position. Because of this, setting the camera a long distance from the player or moving the player a long distance from the camera could result in unexpected visual results. If you have Content Log messages enabled, you may see a warning alerting you to this, but players typically do not have those messages enabled and will probably not see the warning.  In addition, for entities to render, they need to be in loaded and ticking chunks. When a camera is set to move away from the player, it should sync player and entity data resulting in performant rendering at most gameplay distances.  In the camera.json file, extend_player_rendering extends this maximum distance. As long as the camera and entities are in chunks that are loaded and ticking, they will render on the client when the camera moves. This has been optimized to show the player and any rides or entities connected by a leash. This may also show mobs and other entities that are between the player and the camera. This is an enhancement, and no action is needed to apply this functionality. This will make it possible to do a cutscene with the free camera flying over a large distance away from the player.  Audio listener position  With Minecraft 1.20.10, the position and orientation of the camera is now used by default for how the game's audio system directs sounds to your device's speakers. For example, if a sound is to the left of the camera it should play out of the left speaker regardless of the player's position or rotation in the world. Previously this was based on the player's head position and rotation. If you want a custom Camera Preset to use the player position for the audio listener position, simply add \"listener\":\"player\" to the Preset's JSON file. An example \"example:example_player_listener\" JSON has been included in the experimental Cameras behavior pack to demonstrate this feature.  Camera Command Syntax  This command has the following syntax options:  /camera <players> set <preset> [ease <easeTime> <easeType>] [pos <x> <y> <z>] [rot <xRot> <yRot>]  /camera <players> set <preset> [ease <easeTime> <easeType>] [default]  /camera <players> clear  /camera <players> fade [time <fadeInSeconds> <holdSeconds> <fadeOutSeconds>] [color <red> <green> <blue>]  Every version of the camera command starts with a player selector, which is used to specify the player or players who will be affected by the command. After that, there are three options that you can specify: \"set\", \"clear\", or \"fade\". \"set\" will cause the targeted player(s) to use a specified camera perspective. \"clear\" will return the targeted player(s) back to their usual camera mode. \"fade\" will cause a full-screen fade, like what players see when sleeping in a bed.  The \"set\" Option  The \"set\" option for the camera command will cause the selected players to view the game through the specified Camera Preset. Until they disconnect from the game or a camera command using \"clear\" is used, they will use the specified Preset. This overrides things that normally control camera perspective like the settings menu option.  When no additional parameters are specified, this will cause the user's camera perspective to immediately snap to the specified Camera Preset. There are several additional options that can be used with the \"set\" option.  The \"ease\" sub-option  The ease option will cause the transition between the views to be done over some specified number of seconds, rather than instantly. It requires specifying an 'easeType', which is the name of one of the various easing methods available. The 32 different options are \"linear\", \"spring\", or the thirty other options that can be viewed at on Easing Functions Cheat Sheet (easings.net)  Eased motions always start from where the camera currently is, so an ease from A to B which is interrupted with another ease to C will start from somewhere in between A and B.  Eased transitions to the three standard gameplay perspectives are not allowed, as they are tied strongly to the player, and if the player moves or turns in drastic ways, the eased transition to those perspectives can be very unpleasant to experience.  The \"pos\" sub-option  This sub-option of the \"set\" option allows the camera command to specify an override to the position that is defined in the Camera Preset's JSON file. It supports the \"~\" and \"^\" characters like other commands do, allowing the command to set the camera to a dynamically calculated position.  Warning: Setting the position of a camera to an area of the world that isn't loaded is not a supported scenario, though there is not a plan currently to programmatically prevent it. The chunks of the world will still only load if the player is nearby and the device's render distance option is high enough. Positioning the camera in ways that look beyond what is loaded is something that may not function consistently in the future. It's recommended to keep the camera somewhat near the player and to double-check content on lower-end devices or with a lower render distance setting to ensure that things will work for all users.  The \"rot\" sub-option  Like the \"pos\" sub-option, the \"rot\" sub-option overrides the rotation of the Camera Preset. The \"~\" character is supported here to specify relative rotations. The \"xRot\" and \"yRot\" values in this command correspond to the \"rot_x\" and \"rot_y\" properties in the Camera Preset JSON file. As with the \"rot_x\" property, the result of the \"xRot\" value is clamped to no less than –90 degrees and no more than 90 degrees, to prevent the camera from going upside-down.  Camera Pitch Limits  To avoid the camera going fully upside-down, the pitch of the camera has been limited to not more than 90 degrees and not less than negative 90 degrees. This applies to the \"rot_x\" rotation specified in a Camera Preset JSON file and to values specified in the /camera command. If a value outside of this range is specified directly in JSON or a command, a content error message will be displayed and the Preset or command won't work. If a relative rotation (like ~20) happens to go outside of this range, the resulting pitch value will be clamped to the [–90,90] range and the command will work.  The \"default\" sub-option  This sub-option of the \"set\" option will use the position and rotation of the Camera Preset according to its JSON definition in the behavior pack. In other words, this causes any previous \"pos\" or \"rot\" overrides to be discarded.  The facing alternative for the /camera command  To make it easier to point a camera at a particular location, a ‘facing' option has been added to the /camera command. Wherever a rotation could be previously specified with the ‘rot' option, now ‘facing' can be used instead. ‘facing' should be followed either by an entity selector like [type=cow] or by x y z coordinates. This works a similar way the ‘facing' option functions with the /teleport command. The x y z position or the center of the targeted entity's bounding box is put through some math relative to the camera's current position, and an equivalent x and y rotation are calculated and used as if the ‘rot' option was used in the first place with those desired angles.  The \"clear\" Option  The \"clear\" option for the camera command takes no additional arguments. It causes the specified players to end any in-progress camera perspectives, including any eased camera motions, and return to normal. For example, to return all players back to normal camera functionality, run:  /camera @a clear  After a \"clear\" command, players will see the game through the perspective they have selected in the option menu, and will be able to resume using the perspective change key (i.e., F5 on keyboard) to change that setting. VR users will also be able to transition from the virtual Living Room back to the Immersive first-person view if desired.  The \"fade\" Option  The \"fade\" option of the camera command causes a full-screen color to fade in, wait, then fade out. It uses the same effect as when the player sleeps in a bed.  /camera <players> fade [time <fadeInSeconds> <holdSeconds> <fadeOutSeconds>] [color <red> <green> <blue>]  The \"time\" sub-option  This sub-option allows for customizing the timing of the fade effect. If not specified, this will use a 1 second fade in, a 0.5 second hold, and a 1 second fade out. Fade in, hold, and fade out are each limited to no more than 10 seconds. If a longer fade (or dynamically timed fade out) is needed, multiple fade commands can be used – see the \"Combining fades\" section.  The \"color\" sub-option  This sub-option allows for customizing the color of the fade effect. The red, green, and blue values should each be an integer value from 0 to 255. The target opacity of the fade is always fully opaque. If this is not specified, it will use 0 for each value, which causes a fade to black.  Fade timing, networked gameplay, and game performance  Because Minecraft content can be played over a network connection or on a device that isn't running at a perfect frame rate, it's important to keep in mind that the timing of camera fades may not always show up at exactly the desired moment. When authoring a fade effect, it's a good idea to consider adding more time to the ‘holdSeconds' value or to test on less powerful platforms to check that the presentation is acceptable.  Camera Fade Changes  The fade command parameters are now integers that can be as low as 0 and as high as 255.  The timing of fades has had a limit added, which is that none of the three timing values can exceed 10 seconds. This is to avoid accidental fades that last far longer than intended. As before, issuing multiple fade instructions will continue to combine the timing together, so fades beyond ten seconds are still possible.  Combining fades  It's possible (and valid) to issue a camera fade command while a camera fade is already in progress. When that happens, the fades are combined with the following logic. This can be useful for extending fades dynamically until some other event takes place.  The timing of the fade will combine in a way that will fade in with the faster of either the remaining fade-in time or the new fade's fade-in time. The fade out will start when both fades are ready to fade out (whichever is later). The fade out will similarly complete when both fades would complete (whichever is later).  The amount of fade transparency will always start with the current fade amount. For example, if a slow fade is in progress and half complete, and a new quick fade command is received, the user will see a quick fade from half opaque to fully opaque.  The target color (red, green, blue) of a combined fade is always the color of the in-progress fade. See \"Limitations on fades\" below.  Limitations on fades  For user comfort, fades follow two additional rules.  First, all fades must take at least 0.5 seconds so they won't happen more than two times per second. If a camera fade starts where the combined fade in plus hold plus fade out time is less than 0.5 seconds, the hold time will be increased to make up the difference.  Second, if a fade is already in progress, new fades will continue to use the same color as the in-progress fade effect. This prevents full-screen changes between different colors.  Additional Notes and Nuances Targeting  Aim Assist  Aim assist allows content creators to enable aim assist for players with specified settings. The Aim assist will find a target in a specified range and allow players to interact with them directly. When in free cam, for example a bird's-eye view, it can be hard to target things like levers and buttons so aim assist will help highlight whatever the player is aiming at in any given moment. It should improve players' aiming experience that allows players to target and interact with blocks and actors easily regardless of the camera preset chosen by the creator.  For more information, see Introduction to Aim Assist.  Focus Target  Focus target adds the ability to target and track a singular entity with various options.  Focus target is built on top of the existing minecraft:free camera. This behavior mimics a security camera where the creator can choose what entity they want to track with customizable features.  Here are options you can use within the Minecraft console:  Add a target: /camera @s target_entity <entity>  Apply an offset from the entity’s center (optional): /camera @s target_entity <entity> target_center_offset <x, y, z>  Remove the targeting logic from the free camera: /camera @s remove_target  Additionally, you can use the /camera @s clear command to remove the targeting logic, or when a target is 64 chunks (1024 blocks) away from the target camera's location it will automatically be removed.  In addition to these commands, you can also control a variety of options through a behavior pack:  \"rotation_speed\": is a float value that controls the rotation speed of the target camera is degrees per second. Must be > 0.0f. By default this is set to 0.0f which is \"perfect\" tracking and will always keep up with the target no matter the speed.  \"snap_to_target\": is a Boolean that, if true and used in combination with a valid rotation speed, will make the camera snap to the target in the first frame of tracking, then continue to track at the given rotation speed. This value defaults to false where the camera will always rotate at the given valid rotation speed.  Note for horizontal rotation limits: The direction the free camera is initially facing when spawned in will be what the target camera considers as 'zero' rotation. That means that if you were to have horizontal rotation limits, they would be based relative to where the target camera was FIRST looking.  \"horizontal_rotation_limit\": is a Vec2 of floats where the default is 360.0 degrees. The x value of the Vec2 is the rotation allowed to the left (CCW) turning of the target camera. The y value of the Vec2 is the rotation allowed to the right (CW) of the target camera. The sum of the x and y values cannot exceed 360.0 degrees. The default values are [ 0.0, 360.0 ]. For example if you wanted 45.0 degrees of rotation to the left and 30.0 degrees of rotation to the right of where the free camera was first spawned in, you would enter \"horizontal_rotation_limit\": [ 45.0, 30.0 ]. Notice that both values are positive.  For vertical rotation limits, this rotation limit is based on world space, meaning that it does not depend on the initial rotation of the free camera:  0.0 degrees equates to straight down  90.0 degrees is the horizon  180.0 degrees is straight up  \"vertical_rotation_limit\": is a Vec2 of floats where the default is 180.0 degrees rotation up and down. The sum of the x and y values cannot exceed 180.0 degrees. The default values are [ 0.0, 180.0 ]. For example if you wanted 45.0 degrees of rotation down from the horizon and 30.0 degrees of rotation up from the horizon, you would enter \"vertical_rotation_limit\": [ 45.0, 120.0 ].  \"continue_targeting\": is a Boolean that will try to continually target the entity if it leaves either a valid rotation limit or tracking radius. Defaults to false meaning that after the entity has left valid rotation limits or tracking radius, the target camera will return to where it was initially looking.  \"tracking_radius\": is a float value denoting the block distance from the target camera that you want it to listen for the specified entity. Default value is 50.0 blocks.  Here is an example camera file from a behavior pack with the default values:  JSON Copy {   \"format_version\": \"1.21.30\",     \"minecraft:camera_preset\": {     \"identifier\": \"example:custom_target\",     \"inherit_from\": \"minecraft:free\",     \"rotation_speed\": 0.0,     \"snap_to_target\": false,     \"horizontal_rotation_limit\": [ 0.0, 360.0 ],     \"vertical_rotation_limit\": [ 0.0, 180.0 ],     \"continue_targeting\": false,     \"tracking_radius\": 50.0   } }  User Input  When the \"minecraft:free\" camera (or a custom camera based on it) is used via the \"set\" option of the Camera command, user input will be handled as if the player is in the first-person camera view. This means that the player can continue to turn around, place blocks, or otherwise interact with the world as usual, they just will not see it from the typical viewpoint.  If player input is not desired when the \"minecraft:free\" camera is active, other commands can be used to limit the player's abilities. See the \"Combining Multiple Commands Together\" section for some suggestions.  Persistence of Camera State  There will be no persistence of camera state for players across game sessions. For example, if a player is under the effect of \"/camera … set\", then they exit the game in any way and rejoin later, they will load into the world as if no camera command is active. It will be up to the created world's logic to put rejoined players back into the desired camera state.  During the time a player is loaded into a particular world, it will persist any position or rotation values that have been specified to override a camera's default JSON state.  For example, if a player is set to a custom camera with a custom position like this:  /camera @a set example:my_camera pos 100 100 100  ... then the player is put back to normal:  /camera @a clear  Later, the camera is put back to the custom camera:  /camera @a set example:my_camera  The example:my_camera camera will be at 100 100 100 instead of its default position specified in the JSON file.  To return that camera back to normal, the player could either exit and rejoin the game, or the following command could activate the camera while returning it back to its default state:  /camera @a set example:my_camera default  How the Camera Command Affects VR Users  When using a Virtual Reality headset, players can be in an immersive first-person view, or in a virtual living room with a virtual television that displays a flat view of the game. When a camera command using \"set\" targets a VR player in the immersive first-person view, they will be transitioned to the virtual living room and the specified Camera Preset will appear on the virtual screen. While a \"set\" is active to force the player to a particular perspective (including \"minecraft:first_person\"), pressing the perspective change button will display a message explaining the situation, and the transition to the immersive view will be prevented.  Camera commands using \"fade\" will not do anything for VR users in the immersive first-person mode, but players in the virtual living room will still see it.  Combining Multiple Commands Together  The new Camera Command allows for a variety of new simple features, but combining multiple commands together can allow for a wider array of possibilities. Here are some examples:  Making a simple non-interactive cutscene  To make a simple non-interactive cutscene, a camera command can be combined with the /inputpermission command to disable player movement and rotation:  /camera @a set example:cutscene_camera  /inputpermission @a camera disabled  /inputpermission @a movement disabled  Then at the end of the cutscene animations:  /camera @a clear  /inputpermission @a camera enabled  /inputpermission @a movement enabled  Hiding a teleport  To hide a player or other mob teleport, use the camera fade command combined with some delayed teleport commands:  /camera @a fade time 0.5 0.5 0.5  Then after half a second, teleport the player to the desired location:  /tp @a <x y z coordinates here>  If this is being used to teleport the player to an area that may not have loaded yet, increase the middle number (the \"holdSeconds\") to give the player's device enough time to load the surrounding area.  Transitioning to and from a flyover camera  When a player encounters a new part of an adventure map, showing a dramatic flyover of the area can add some interest to the upcoming experience. This can be done with a series of camera commands:  First, start a camera fade to hide the next transition...  /camera @a fade time 0.5 0.2 0.5  After 0.5 seconds (the \"fadeInSeconds\" time), issue a command to cut to one position and another command to start an eased camera motion. This assumes that Camera Presets named \"example:flyover_start\" and \"example:flyover_end\" have been defined in a behavior pack.  /camera @a set example:flyover_start  /camera @a set example:flyover_end ease 5 linear  Then after three seconds (before that five second movement ends and with enough time to fade again) issue another fade command.  /camera @a fade time 0.5 0.2 0.5  Then after another 0.5 seconds, return the camera back to normal.  /camera @a clear  The Camera Command and Split-screen Gameplay  When multiple people are playing in split-screen on the same device, they have separate cameras and separate targetable player entities. When the new Camera command is used (whether for \"set\" or \"fade\" options), that separation is not changed. Each player's camera can be separately affected. There are no plans for combining views in split-screen scenarios, or for supporting multiple split-screen-like views for individual players.  Additional free camera preset examples: Player listener  This controls what is used for the audio listener.  Creators will sometimes want the player's position to continue being where the audio system's \"ears\" are, and other times they will want this listener position to be where the camera is.  JSON Copy {   \"format_version\": \"1.19.50\",   \"minecraft:camera_preset\": {     \"identifier\": \"example:example_player_listener\",     \"inherit_from\": \"minecraft:free\",     \"listener\": \"player\"   } }  Player effect  Optional, defaults to false. Specify true to allow effects on the player to affect how the game renders when this preset is active.  Basically, it determines whether the player state can affect rendering. A security camera's view of a player who is on fire shouldn't look like the security camera is on fire, for example.  JSON Copy {   \"format_version\": \"1.19.50\",   \"minecraft:camera_preset\": {     \"identifier\": \"example:example_player_effects\",     \"inherit_from\": \"minecraft:free\",     \"player_effects\": true   } }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/freecamerascriptapitutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Free Camera Script API Tutorial 08/16/2024  In this tutorial you will learn how to set up a basic free camera script API. You can find more information at Camera Command Introduction.  Free Camera Functionality  The free camera preset can be used to accomplish many gameplay scenarios by setting the camera at a distance away from players and entities to show more of the environment. One use could even be setting up cutscenes and using easing methods to have the camera do a flyover a scene.  In this tutorial we will focus on how the free camera preset can be set up in TypeScript to be executed in the game at the exact parameters and settings you choose.  In this tutorial, you will learn how to:  Set the position of the camera Set the position and facing direction Set the easing method Add easing, position, and facing direction together for a flyover Disable player input during a flyover Apply a fade Clear camera during a fade Teleport during a fade Activate a camera based on a player's distance from a location Set up an NPC to activate a camera  To practice these features and see what they look like in the game, let's try out a cutscene scenario. Say you want to make a cutscene where the camera transitions from the player's view to show a flyover of the landscape and then turn to face the player. Let's try it!  Step 1: Set up your Script API workspace  To get started, you will need to make some adjustments to your workspace so you can work with Script APIs.  Follow the Build a Gameplay Experience with TypeScript tutorial from the beginning through Chapter 3 and then stop. Keep the behavior pack you create handy.  After you have completed the tutorial, continue to Step 2.  Step 2: Create your own JSON Preset  If you're using one of the vanilla camera types or built-in examples, you can skip this step. Using the built-in examples requires activation of the Camera experimental toggle.  To add your own camera preset, follow the instructions below.  In VSCode, right click the behavior pack and add a new folder at file path behavior_packs\\starterbp called cameras.  Add a new folder under behavior_packs\\starterbp\\cameras called presets.  Add a new file under the presets folder called example_free.json.  Inside of that file, add the following code example:  JSON Copy {   \"format_version\": \"1.19.50\",   \"minecraft:camera_preset\": {     \"identifier\": \"demo:example_free\",     \"inherit_from\": \"minecraft:free\",     \"pos_y\": 90,     \"rot_x\": 10,     \"rot_y\": 40   } }   Step 3: Set up your Script API workspace  Remove all the existing script code in main.ts and replace it with this:  TypeScript Copy enum CameraTypes {   Vanilla = 0,   NPCGreeter = 1,   TownCutScene = 2,   TownStaticCamera = 3,   TonCenterStaticCamera = 4, }   We are creating an enum to easily reference the different types of cameras that we'll have active in our gameplay session. This assigns reference numbers to the individual camera types. Setting them equal to numeric values allows us to iterate through them if we use the camera types in an array.  Add the following code example below the enum: TypeScript Copy interface CameraState {   p: Player;   previous: CameraTypes;   current: CameraTypes; }   A TypeScript interfaces is an object that holds multiple variables at once. The CameraState interface will hold on to the Camera State of any player, allowing this camera system to work nicely in multiplayer.  The CameraState interface includes a reference to a specific player, as well as the previous camera type that they had and the current camera type. This will allow you to go back to a previous camera type without needing to put tags on a player.  Add the following code below the interface: TypeScript Copy let playerCameraStates: CameraState[] = []; let curTick = 0; const ticksPerSecond = 20;  // Gameplay Data const townCenterLocation = { x: -1003, y: 65, z: -1355 }; const townCenterRadius = 8; const townRadius = 35; const defaultCameraType = CameraTypes.Vanilla;   playerCameraStates - Tracks the current state of the player camera; if null, no players have entered the game  curTick - Keeps track of the current tick of the game  ticksPerSecond - Tracks the number of ticks that happen in the game per second  townCenterLocation - Tracks location of the town center; can be used to determine proximity to town  townCenterRadius - Tracks the area around the town center and is a subset of the townRadius variable  townRadius - Tracks the area around the town  defaultCameraType - Represents the default Vanilla camera  Step 4: Create initial event subscriptions and functions  After the previous code snippet add this code: TypeScript Copy function PlayerSpawnCameraSetup(currentPlayer: Player) {}  world.afterEvents.playerSpawn.subscribe((event) => { const player = event.player; PlayerSpawnCameraSetup(player);} );   To setup a camera for the player, we need to know when they've joined the game. But we actually want to be able to reset the camera state when they've died as well, so we can capture both of those scenarios by subscribing to the playerSpawn after event.  To setup the camera per player we will replace the empty PlayerSpawnCameraSetup with this snippet: TypeScript Copy function PlayerSpawnCameraSetup(currentPlayer: Player) {   // Set the default camera state   let setDefaultCameraState: CameraState = {   p: currentPlayer,   current: CameraTypes.Vanilla,   previous: CameraTypes.Vanilla,   counter: 0,   };  // Check to see if this player previously had their creator camera setup let foundplayer = false; if (PlayerCameraStates != null && PlayerCameraStates.length > 0) {   for (let pcs of PlayerCameraStates) {     if (pcs.p == currentPlayer) {        // Existing player found, reset their state to default       foundplayer = true;       currentPlayer.camera.clear();       pcs.current = setDefaultCameraState.current;       pcs.previous = setDefaultCameraState.previous;       pcs.counter = 0;   break;      }} } else {   if (!foundplayer) {  // if no player was found, add & setup the default camera state    PlayerCameraStates.push(setDefaultCameraState); }}}   For this function we are passing the player in, this both allows us to check if they are already initialized in our camera state system, but has the added benefit of allowing us to do this at a per player level meaning this setup will work in multiplayer.  We check the existing PlayerCameraStates array for the player, if they are stored in the array we will reset their state back to the default camera state defined earlier in this function. If they are new player who is not captured in the camera states, we'll add them to the array with the default settings.  Add the following function below the PlayerSpawnCameraSetup function: TypeScript Copy function ApplyPlayerCamera(ct: CameraTypes, currentPlayer: Player) {   let currentPCS = GetPlayerCameraState(currentPlayer);   let revert = false;      switch (ct) {       case CameraTypes.NPCGreeter:         // Check if we are already talking to the NPC Greeter          if (currentPCS.current != CameraTypes.NPCGreeter) {           currentPCS.p.camera.setCamera(\"example:example_free\", {             location: { x: -1054.87, y: 71.27, z: -1343.5 },             rotation: { x: 35, y: 230 },           });         } else {           // We've finished talking to the greeter           revert = true;         }         break;       case CameraTypes.TownCutscene:          if (currentPCS.current != CameraTypes.TownCutscene) {           //camera @a fade time 1 1 1 color 0 0 0           currentPCS.p.camera.fade({ fadeTime: { fadeInTime: 1, holdTime: 1, fadeOutTime: 1 } });           const transitionTime = 5;           currentPCS.counter = transitionTime * TicksPerSecond;            system.runTimeout(() => {             if (currentPCS != null) {               CameraCutScene(currentPCS, transitionTime);             }           }, 1 * TicksPerSecond);         }         break;       case CameraTypes.TownCenterStaticCamera:          if (currentPCS.current != CameraTypes.TownCenterStaticCamera) {           currentPCS.p.camera.setCamera(\"example:example_free\", {             location: { x: -1009.03, y: 69.9, z: -1345.82 },             rotation: { x: 35, y: 210 },           });         }         break;       case CameraTypes.TownStaticCamera:          if (currentPCS.current != CameraTypes.TownStaticCamera) {           currentPCS.p.camera.setCamera(\"example:example_free\", {             location: { x: -1042, y: 81.78, z: -1323.33 },             rotation: { x: 30, y: 220 },           });         }         break;       case CameraTypes.Vanilla:         currentPCS.p.camera.clear();         break;     }      // There are some instances where we are switching back the camera, do that for all here     if (revert) {       RevertCurrentCamera(currentPCS);     } else {       currentPCS.previous = currentPCS.current.valueOf();       currentPCS.current = ct;     } }   The ApplyPlayerCamera function sets the player's camera to a specific camera type. This function takes the parameters for the cameraType enum that we created and a player, allowing it to be run for any player uniquely.  The switch state inside of the function sets up different configurations for the player depending on the camera being selected. In this logic we also set the previous state of the camera, allowing for reverting the camera state to it's previous form when needed. Like when looking at the NPC Greeter in a close up camera and then reverting back to whatever camera the player was using last when the dialogue is completed.  Add the following function below playerSpawn subscriber: TypeScript Copy system.afterEvents.scriptEventReceive.subscribe((event) => {   // Player that interacted with an NPC   let player = event.initiator as Player;    // Apply Camera depending on NPC   switch (event.id) {     case \"demo:greet\":       ApplyPlayerCamera(CameraTypes.NPCGreeter, player);       break;     case \"demo:cutscene\":       ApplyPlayerCamera(CameraTypes.TownCutscene, player);       break;     case \"demo:debug\":       player.sendMessage(`[DEBUG] Resetting ${player.name}`);       PlayerSpawnCameraSetup (player);       player.camera.clear();       break;   } });   There are two ways that we are going to apply the camera to a player. One of them is from receiving an event from a player interacting with an NPC. The NPC will fire a /scriptevent that uses the specific camera name with a namespace.  After the event is fired, the scriptEventRecieve after event will capture the player who initiated the interaction and apply the appropriate camera based on the camera type.  Step 5: Creating camera code to affect players  Below the code currently in main.ts, add the following snippet.  TypeScript Copy function gameTick() {   try {     curTick++;      // Check to see if there are PlayerCameraStates setup (ie. are there players in the game yet?)     if (PlayerCameraStates != null && PlayerCameraStates.length > 0) {       for (let pcs of PlayerCameraStates) {         // If in a Cutscene, don't update any proximity cameras         if(pcs.current == CameraTypes.TownCutscene) {           // Check to see if Cutscene countdown is complete           if (pcs.counter <= 0) {             // Fade the camera out & revert camera type to previous camera             pcs.p.camera.fade({ fadeTime: { fadeInTime: 1, holdTime: 1, fadeOutTime: 1 } });             system.runTimeout(() => {               RevertCurrentCamera(pcs);             }, 1 * TicksPerSecond);           } else {             // Continue to countdown until cutscene is complete             pcs.counter--;           }         }         else {           // The only other camera to check in a ticking scenario are proximity cameras                     // Checking player to camera distance every other tick for better performance           if (curTick % 2) {              // Are we in proximity of the town?             if (Utilities.distance(pcs.p.location, TownCenterLocation) <= TownRadius) {               // We are in the town, but which static camera should be active?               if (Utilities.distance(pcs.p.location, TownCenterLocation) <= TownCenterRadius) {                 // If we aren't already in Town Center camera, switch to it                 if (pcs.current != CameraTypes.TownCenterStaticCamera) {                   ApplyPlayerCamera(CameraTypes.TownCenterStaticCamera, pcs.p);                 }               } else {                 // If we aren't already in the Town camera, switch to it                 if (pcs.current != CameraTypes.TownStaticCamera) {                   ApplyPlayerCamera(CameraTypes.TownStaticCamera, pcs.p);                 }               }             } else {               // We are no longer inside the camera proximity, so reset the camera to the Vanilla Camera               if (pcs.current == CameraTypes.TownStaticCamera) {                 ApplyPlayerCamera(defaultCameraType, pcs.p);               }             }           }        }       }     }   } catch (e) {     // Throw an error if there is a problem in the looping code       console.warn(\"Tick error: \" + e);   }   // Allow the gameTick function to keep re-running every tick   system.run(gameTick); } // Runs the main gameTick function for the first time system.run(gameTick);   Using system.run we will start a function that is called every tick. To improve performance inside of that gameTick function we won't do our logic every tick, but instead every other tick. This is represented by the %2 in the if(curtick % 2) statement, if the number is bigger the check will happen less often, but doing this check becomes less taxing. The player has 3 camera types that are either updated constantly or need to have an action taken during the time of the camera transitioning.  For the cutscene camera, we need to countdown until it's complete, to be able to to reset the camera to a different state.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/freecamerascriptapitutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Free Camera Script API Tutorial 08/16/2024  In this tutorial you will learn how to set up a basic free camera script API. You can find more information at Camera Command Introduction.  Free Camera Functionality  The free camera preset can be used to accomplish many gameplay scenarios by setting the camera at a distance away from players and entities to show more of the environment. One use could even be setting up cutscenes and using easing methods to have the camera do a flyover a scene.  In this tutorial we will focus on how the free camera preset can be set up in TypeScript to be executed in the game at the exact parameters and settings you choose.  In this tutorial, you will learn how to:  Set the position of the camera Set the position and facing direction Set the easing method Add easing, position, and facing direction together for a flyover Disable player input during a flyover Apply a fade Clear camera during a fade Teleport during a fade Activate a camera based on a player's distance from a location Set up an NPC to activate a camera  To practice these features and see what they look like in the game, let's try out a cutscene scenario. Say you want to make a cutscene where the camera transitions from the player's view to show a flyover of the landscape and then turn to face the player. Let's try it!  Step 1: Set up your Script API workspace  To get started, you will need to make some adjustments to your workspace so you can work with Script APIs.  Follow the Build a Gameplay Experience with TypeScript tutorial from the beginning through Chapter 3 and then stop. Keep the behavior pack you create handy.  After you have completed the tutorial, continue to Step 2.  Step 2: Create your own JSON Preset  If you're using one of the vanilla camera types or built-in examples, you can skip this step. Using the built-in examples requires activation of the Camera experimental toggle.  To add your own camera preset, follow the instructions below.  In VSCode, right click the behavior pack and add a new folder at file path behavior_packs\\starterbp called cameras.  Add a new folder under behavior_packs\\starterbp\\cameras called presets.  Add a new file under the presets folder called example_free.json.  Inside of that file, add the following code example:  JSON Copy {   \"format_version\": \"1.19.50\",   \"minecraft:camera_preset\": {     \"identifier\": \"demo:example_free\",     \"inherit_from\": \"minecraft:free\",     \"pos_y\": 90,     \"rot_x\": 10,     \"rot_y\": 40   } }   Step 3: Set up your Script API workspace  Remove all the existing script code in main.ts and replace it with this:  TypeScript Copy enum CameraTypes {   Vanilla = 0,   NPCGreeter = 1,   TownCutScene = 2,   TownStaticCamera = 3,   TonCenterStaticCamera = 4, }   We are creating an enum to easily reference the different types of cameras that we'll have active in our gameplay session. This assigns reference numbers to the individual camera types. Setting them equal to numeric values allows us to iterate through them if we use the camera types in an array.  Add the following code example below the enum: TypeScript Copy interface CameraState {   p: Player;   previous: CameraTypes;   current: CameraTypes; }   A TypeScript interfaces is an object that holds multiple variables at once. The CameraState interface will hold on to the Camera State of any player, allowing this camera system to work nicely in multiplayer.  The CameraState interface includes a reference to a specific player, as well as the previous camera type that they had and the current camera type. This will allow you to go back to a previous camera type without needing to put tags on a player.  Add the following code below the interface: TypeScript Copy let playerCameraStates: CameraState[] = []; let curTick = 0; const ticksPerSecond = 20;  // Gameplay Data const townCenterLocation = { x: -1003, y: 65, z: -1355 }; const townCenterRadius = 8; const townRadius = 35; const defaultCameraType = CameraTypes.Vanilla;   playerCameraStates - Tracks the current state of the player camera; if null, no players have entered the game  curTick - Keeps track of the current tick of the game  ticksPerSecond - Tracks the number of ticks that happen in the game per second  townCenterLocation - Tracks location of the town center; can be used to determine proximity to town  townCenterRadius - Tracks the area around the town center and is a subset of the townRadius variable  townRadius - Tracks the area around the town  defaultCameraType - Represents the default Vanilla camera  Step 4: Create initial event subscriptions and functions  After the previous code snippet add this code: TypeScript Copy function PlayerSpawnCameraSetup(currentPlayer: Player) {}  world.afterEvents.playerSpawn.subscribe((event) => { const player = event.player; PlayerSpawnCameraSetup(player);} );   To setup a camera for the player, we need to know when they've joined the game. But we actually want to be able to reset the camera state when they've died as well, so we can capture both of those scenarios by subscribing to the playerSpawn after event.  To setup the camera per player we will replace the empty PlayerSpawnCameraSetup with this snippet: TypeScript Copy function PlayerSpawnCameraSetup(currentPlayer: Player) {   // Set the default camera state   let setDefaultCameraState: CameraState = {   p: currentPlayer,   current: CameraTypes.Vanilla,   previous: CameraTypes.Vanilla,   counter: 0,   };  // Check to see if this player previously had their creator camera setup let foundplayer = false; if (PlayerCameraStates != null && PlayerCameraStates.length > 0) {   for (let pcs of PlayerCameraStates) {     if (pcs.p == currentPlayer) {        // Existing player found, reset their state to default       foundplayer = true;       currentPlayer.camera.clear();       pcs.current = setDefaultCameraState.current;       pcs.previous = setDefaultCameraState.previous;       pcs.counter = 0;   break;      }} } else {   if (!foundplayer) {  // if no player was found, add & setup the default camera state    PlayerCameraStates.push(setDefaultCameraState); }}}   For this function we are passing the player in, this both allows us to check if they are already initialized in our camera state system, but has the added benefit of allowing us to do this at a per player level meaning this setup will work in multiplayer.  We check the existing PlayerCameraStates array for the player, if they are stored in the array we will reset their state back to the default camera state defined earlier in this function. If they are new player who is not captured in the camera states, we'll add them to the array with the default settings.  Add the following function below the PlayerSpawnCameraSetup function: TypeScript Copy function ApplyPlayerCamera(ct: CameraTypes, currentPlayer: Player) {   let currentPCS = GetPlayerCameraState(currentPlayer);   let revert = false;      switch (ct) {       case CameraTypes.NPCGreeter:         // Check if we are already talking to the NPC Greeter          if (currentPCS.current != CameraTypes.NPCGreeter) {           currentPCS.p.camera.setCamera(\"example:example_free\", {             location: { x: -1054.87, y: 71.27, z: -1343.5 },             rotation: { x: 35, y: 230 },           });         } else {           // We've finished talking to the greeter           revert = true;         }         break;       case CameraTypes.TownCutscene:          if (currentPCS.current != CameraTypes.TownCutscene) {           //camera @a fade time 1 1 1 color 0 0 0           currentPCS.p.camera.fade({ fadeTime: { fadeInTime: 1, holdTime: 1, fadeOutTime: 1 } });           const transitionTime = 5;           currentPCS.counter = transitionTime * TicksPerSecond;            system.runTimeout(() => {             if (currentPCS != null) {               CameraCutScene(currentPCS, transitionTime);             }           }, 1 * TicksPerSecond);         }         break;       case CameraTypes.TownCenterStaticCamera:          if (currentPCS.current != CameraTypes.TownCenterStaticCamera) {           currentPCS.p.camera.setCamera(\"example:example_free\", {             location: { x: -1009.03, y: 69.9, z: -1345.82 },             rotation: { x: 35, y: 210 },           });         }         break;       case CameraTypes.TownStaticCamera:          if (currentPCS.current != CameraTypes.TownStaticCamera) {           currentPCS.p.camera.setCamera(\"example:example_free\", {             location: { x: -1042, y: 81.78, z: -1323.33 },             rotation: { x: 30, y: 220 },           });         }         break;       case CameraTypes.Vanilla:         currentPCS.p.camera.clear();         break;     }      // There are some instances where we are switching back the camera, do that for all here     if (revert) {       RevertCurrentCamera(currentPCS);     } else {       currentPCS.previous = currentPCS.current.valueOf();       currentPCS.current = ct;     } }   The ApplyPlayerCamera function sets the player's camera to a specific camera type. This function takes the parameters for the cameraType enum that we created and a player, allowing it to be run for any player uniquely.  The switch state inside of the function sets up different configurations for the player depending on the camera being selected. In this logic we also set the previous state of the camera, allowing for reverting the camera state to it's previous form when needed. Like when looking at the NPC Greeter in a close up camera and then reverting back to whatever camera the player was using last when the dialogue is completed.  Add the following function below playerSpawn subscriber: TypeScript Copy system.afterEvents.scriptEventReceive.subscribe((event) => {   // Player that interacted with an NPC   let player = event.initiator as Player;    // Apply Camera depending on NPC   switch (event.id) {     case \"demo:greet\":       ApplyPlayerCamera(CameraTypes.NPCGreeter, player);       break;     case \"demo:cutscene\":       ApplyPlayerCamera(CameraTypes.TownCutscene, player);       break;     case \"demo:debug\":       player.sendMessage(`[DEBUG] Resetting ${player.name}`);       PlayerSpawnCameraSetup (player);       player.camera.clear();       break;   } });   There are two ways that we are going to apply the camera to a player. One of them is from receiving an event from a player interacting with an NPC. The NPC will fire a /scriptevent that uses the specific camera name with a namespace.  After the event is fired, the scriptEventRecieve after event will capture the player who initiated the interaction and apply the appropriate camera based on the camera type.  Step 5: Creating camera code to affect players  Below the code currently in main.ts, add the following snippet.  TypeScript Copy function gameTick() {   try {     curTick++;      // Check to see if there are PlayerCameraStates setup (ie. are there players in the game yet?)     if (PlayerCameraStates != null && PlayerCameraStates.length > 0) {       for (let pcs of PlayerCameraStates) {         // If in a Cutscene, don't update any proximity cameras         if(pcs.current == CameraTypes.TownCutscene) {           // Check to see if Cutscene countdown is complete           if (pcs.counter <= 0) {             // Fade the camera out & revert camera type to previous camera             pcs.p.camera.fade({ fadeTime: { fadeInTime: 1, holdTime: 1, fadeOutTime: 1 } });             system.runTimeout(() => {               RevertCurrentCamera(pcs);             }, 1 * TicksPerSecond);           } else {             // Continue to countdown until cutscene is complete             pcs.counter--;           }         }         else {           // The only other camera to check in a ticking scenario are proximity cameras                     // Checking player to camera distance every other tick for better performance           if (curTick % 2) {              // Are we in proximity of the town?             if (Utilities.distance(pcs.p.location, TownCenterLocation) <= TownRadius) {               // We are in the town, but which static camera should be active?               if (Utilities.distance(pcs.p.location, TownCenterLocation) <= TownCenterRadius) {                 // If we aren't already in Town Center camera, switch to it                 if (pcs.current != CameraTypes.TownCenterStaticCamera) {                   ApplyPlayerCamera(CameraTypes.TownCenterStaticCamera, pcs.p);                 }               } else {                 // If we aren't already in the Town camera, switch to it                 if (pcs.current != CameraTypes.TownStaticCamera) {                   ApplyPlayerCamera(CameraTypes.TownStaticCamera, pcs.p);                 }               }             } else {               // We are no longer inside the camera proximity, so reset the camera to the Vanilla Camera               if (pcs.current == CameraTypes.TownStaticCamera) {                 ApplyPlayerCamera(defaultCameraType, pcs.p);               }             }           }        }       }     }   } catch (e) {     // Throw an error if there is a problem in the looping code       console.warn(\"Tick error: \" + e);   }   // Allow the gameTick function to keep re-running every tick   system.run(gameTick); } // Runs the main gameTick function for the first time system.run(gameTick);   Using system.run we will start a function that is called every tick. To improve performance inside of that gameTick function we won't do our logic every tick, but instead every other tick. This is represented by the %2 in the if(curtick % 2) statement, if the number is bigger the check will happen less often, but doing this check becomes less taxing. The player has 3 camera types that are either updated constantly or need to have an action taken during the time of the camera transitioning.  For the cutscene camera, we need to countdown until it's complete, to be able to to reset the camera to a different state.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/camerapresetthirdperson?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Third Person Camera Preset Overview 09/12/2024  In this overview, you will learn about the third_person camera presets.   Important  This feature is experimental. To use the presets explained here, the following experimental toggle must be turned on: Creator Cameras: New Third Person Presets  The third_person camera presets were designed to provide a detached camera that can be set at a customizable range from the player, and attached to the player or other non-player entities, with the option of camera-relative player controls de-coupled from player facing direction.  You can find more information about the camera system in the Camera System Introduction and in the Free Camera Preset tutorial, using commands and script.  The third_person presets can be applied using commands, JSON, and script APIs.  The two third_person presets are:  Minecraft:follow_orbit Minecraft:third_person_boom Parameters and definitions of the third person camera Radius: Sets the camera distance from the player, measured in blocks. Rotation: Sets the degree to which the camera can rotate around the player. Yaw: Sets the rotation of the camera 360 degrees around the target parallel to the earth. The yaw value can be up to 180 to point directly to the right, and up to -180 to point directly to the left. Pitch: Sets the angle up or down, perpendicular to the earth. Pitch is limited to a range of 90 (facing straight down) to -90 (facing straight up). This limitation is to prevent rolling the camera upside down. Starting rotation: Sets the initial rotation around the player. Offset: Sets the reference point that the camera is anchored to, relative to the player. Entity offset anchors to the player position, while view offset anchors to a point on the screen. Follow Orbit  The follow orbit preset lets you 'attach' the camera to a player, apply an offset, and set a variable radius (distance from player) and rotation. The pitch will be customizable within bounds and the yaw will allow a range of 360 degrees. This preset maintains the parameters you set as it rotates around the player. See below for a JSON sample.  Command  /camera @s set minecraft:follow_orbit  Third Person Boom (or Fixed Boom)  The boom preset is more specialized with fewer parameters to set up. As with the follow orbit, it also let's you 'attach' the camera to a player, apply an offset and set the radius (distance), pitch and yaw, but this preset does not rotate around the player. See below for a JSON sample.  Command  /camera @s set Minecraft:fixed_boom  Radius, Rotation  Both presets allow you to set the radius to be a customized distance from the player, but only the follow_orbit preset allows you to set the rotation.  The default radius and rotation are determined by the resource pack but can be defined in the behavior pack. Radius and rotation for follow orbit and fixed boom, how the camera rotates around the player, have a default radius of 10 but can be overwritten for both presets in the behavior pack.  Setting the rotation will set a default starting rotation for:  The follow orbit camera's first spawn The angles at which the camera will follow the player for the fixed boom camera  Because you can set the rotation of the camera in the follow orbit preset, the starting rotation will be overwritten immediately when the mouse is moved.  Radius  The radius, distance from player, is customizable within a minimum radius of 0.1 and a maximum radius of 100, allowing you to set the camera any distance from the player.  Rotation Limits  The rotation, or the arc around the player, is not limited, allowing you to set the camera to rotate 360 degrees around the player. When rotating, the camera facing-direction will face the player by default.  View Offset  The view offset allows you to anchor the camera to a point in the focal view that is not the player. This offset will force the player to be shifted to the side of the offset and stay to the side even as the player moves.  View offset – anchored to a pivot point on the screen. Player is shifted to stay on the side of the offset.  Entity Offset  The entity offset allows you to set the camera to anchor to a pivot point on the player (0, 0, 0 is the center of the player). This is helpful when determining the precise rotation of the camera around the player. While you can set the view offset with either preset, the entity offset is only usable with the follow_orbit preset as that is the only preset that allows you to rotate around the player.  The maximum entity offset is equal to the maximum radius of 100.  Entity offset – additional option that anchors to a pivot point on the player.  Setting the Radius and Offset  You can set the starting radius for either camera, as well as a variable radius. Here are a few examples.  Command  /camera @s set minecraft:follow_orbit view_offset viewX viewY  Script  JavaScript Copy player.camera.setCamera('minecraft:follow_orbit', { viewOffset: { x: 3, y: 3 } });   JSON  The following code sample shows the follow_orbit camera with a view offset, radius, and rotation.  JSON Copy {   \"format_version\": \"1.21.0\",    \"minecraft:camera_preset\": {      \"identifier\": \"test:follow_orbit_test\",      \"inherit_from\": \"minecraft:follow_orbit\",      \"view_offset\":  [2.0, 2.0],     \"radius\": 12     }  }   JSON Copy {    \"format_version\": \"1.21.0\",    \"minecraft:camera_preset\": {      \"identifier\": \"example:follow_orbit\",      \"view_offset\":  [0.0, 0.0],      \"entity_offset\":  [0.0, 5.0, 0.0],      \"radius\": 5.0    }  }   JSON Copy {    \"format_version\": \"1.19.50\",    \"minecraft:camera_preset\": {      \"identifier\": \"minecraft:follow_orbit\",      \"starting_rot_x\": 10,     \"starting_rot_y\": 10   }  }   Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/camerapresetthirdperson?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Third Person Camera Preset Overview 09/12/2024  In this overview, you will learn about the third_person camera presets.   Important  This feature is experimental. To use the presets explained here, the following experimental toggle must be turned on: Creator Cameras: New Third Person Presets  The third_person camera presets were designed to provide a detached camera that can be set at a customizable range from the player, and attached to the player or other non-player entities, with the option of camera-relative player controls de-coupled from player facing direction.  You can find more information about the camera system in the Camera System Introduction and in the Free Camera Preset tutorial, using commands and script.  The third_person presets can be applied using commands, JSON, and script APIs.  The two third_person presets are:  Minecraft:follow_orbit Minecraft:third_person_boom Parameters and definitions of the third person camera Radius: Sets the camera distance from the player, measured in blocks. Rotation: Sets the degree to which the camera can rotate around the player. Yaw: Sets the rotation of the camera 360 degrees around the target parallel to the earth. The yaw value can be up to 180 to point directly to the right, and up to -180 to point directly to the left. Pitch: Sets the angle up or down, perpendicular to the earth. Pitch is limited to a range of 90 (facing straight down) to -90 (facing straight up). This limitation is to prevent rolling the camera upside down. Starting rotation: Sets the initial rotation around the player. Offset: Sets the reference point that the camera is anchored to, relative to the player. Entity offset anchors to the player position, while view offset anchors to a point on the screen. Follow Orbit  The follow orbit preset lets you 'attach' the camera to a player, apply an offset, and set a variable radius (distance from player) and rotation. The pitch will be customizable within bounds and the yaw will allow a range of 360 degrees. This preset maintains the parameters you set as it rotates around the player. See below for a JSON sample.  Command  /camera @s set minecraft:follow_orbit  Third Person Boom (or Fixed Boom)  The boom preset is more specialized with fewer parameters to set up. As with the follow orbit, it also let's you 'attach' the camera to a player, apply an offset and set the radius (distance), pitch and yaw, but this preset does not rotate around the player. See below for a JSON sample.  Command  /camera @s set Minecraft:fixed_boom  Radius, Rotation  Both presets allow you to set the radius to be a customized distance from the player, but only the follow_orbit preset allows you to set the rotation.  The default radius and rotation are determined by the resource pack but can be defined in the behavior pack. Radius and rotation for follow orbit and fixed boom, how the camera rotates around the player, have a default radius of 10 but can be overwritten for both presets in the behavior pack.  Setting the rotation will set a default starting rotation for:  The follow orbit camera's first spawn The angles at which the camera will follow the player for the fixed boom camera  Because you can set the rotation of the camera in the follow orbit preset, the starting rotation will be overwritten immediately when the mouse is moved.  Radius  The radius, distance from player, is customizable within a minimum radius of 0.1 and a maximum radius of 100, allowing you to set the camera any distance from the player.  Rotation Limits  The rotation, or the arc around the player, is not limited, allowing you to set the camera to rotate 360 degrees around the player. When rotating, the camera facing-direction will face the player by default.  View Offset  The view offset allows you to anchor the camera to a point in the focal view that is not the player. This offset will force the player to be shifted to the side of the offset and stay to the side even as the player moves.  View offset – anchored to a pivot point on the screen. Player is shifted to stay on the side of the offset.  Entity Offset  The entity offset allows you to set the camera to anchor to a pivot point on the player (0, 0, 0 is the center of the player). This is helpful when determining the precise rotation of the camera around the player. While you can set the view offset with either preset, the entity offset is only usable with the follow_orbit preset as that is the only preset that allows you to rotate around the player.  The maximum entity offset is equal to the maximum radius of 100.  Entity offset – additional option that anchors to a pivot point on the player.  Setting the Radius and Offset  You can set the starting radius for either camera, as well as a variable radius. Here are a few examples.  Command  /camera @s set minecraft:follow_orbit view_offset viewX viewY  Script  JavaScript Copy player.camera.setCamera('minecraft:follow_orbit', { viewOffset: { x: 3, y: 3 } });   JSON  The following code sample shows the follow_orbit camera with a view offset, radius, and rotation.  JSON Copy {   \"format_version\": \"1.21.0\",    \"minecraft:camera_preset\": {      \"identifier\": \"test:follow_orbit_test\",      \"inherit_from\": \"minecraft:follow_orbit\",      \"view_offset\":  [2.0, 2.0],     \"radius\": 12     }  }   JSON Copy {    \"format_version\": \"1.21.0\",    \"minecraft:camera_preset\": {      \"identifier\": \"example:follow_orbit\",      \"view_offset\":  [0.0, 0.0],      \"entity_offset\":  [0.0, 5.0, 0.0],      \"radius\": 5.0    }  }   JSON Copy {    \"format_version\": \"1.19.50\",    \"minecraft:camera_preset\": {      \"identifier\": \"minecraft:follow_orbit\",      \"starting_rot_x\": 10,     \"starting_rot_y\": 10   }  }   Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/introtoaimassist?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Aim Assist 03/06/2025  The aim assist feature helps you target blocks and entities while using third-person camera modes by displaying a targeting reticle over the target. Aim assist will select targets within a defined distance and view angle that you can control using the /aimassist command. Remember that aim assist will select targets based on the direction that the player character is facing, not the direction that the camera is facing. This can sometimes be confusing, since third-person camera modes allow you to look in a different direction than your player character.  The /aimassist command  You have a lot of control over what entities and blocks are targeted by aim assist. To adjust these settings, use the /aimassist command and set the following parameters to your liking:  Expand table Name\tDefault Value\tDescription Max Distance\t\tThe distance (in blocks) from the player where entities and blocks will be considered for targeting by aim assist. This creates a cone-shaped area in front of the player that can be adjusted using the X angle and Y angle parameters. Entities and blocks outside this cone will not be targeted. Range is from 1 to 16. Players\tnone\tThe ids of the players who will benefit from the aim assist settings. Preset id\tnone\tAn optional parameter that allows you to specify an aim assist preset to use. Presets can provide more details for how targets should be selected, such as changing what targets are prioritized when holding certain items or excluding specific blocks or entities entirely. For more information on aim assist presets, see Aim Assist Presets. Target mode\tnone\tAn optional parameter that defines how how targets are evaluated by the aim assist feature. Uses either distance or angle. - distance: Blocks and entities that are closest to the player will be evaluated first. - angle: Blocks and entities that are closest to the center of the targeting cone will be evaluated first. X angle\t\tThe horizontal angle for the aim assist targeting cone in a range from 10 to 90 degrees. Y angle\t\tThe vertical angle for the aim assist targeting cone in a range from 10 to 90 degrees. Customizing The Targeting Reticle  You can also customize the appearance of the aim assist targeting reticle. Here is an example of the default reticles for blocks and entities:  If you want to replace the targeting reticle with a different shape or color, you can create or update a resource pack to include custom textures.  Create a resourcepack/textures/ui folder.  Add your textures with the names aimassist_block_highlight and aimassist_entity_highlight to replace the appropriate targeting reticle.  Next Steps  You can adjust aim assist settings even further using behavior packs and aim assist presets. Aim assist presets are pre-defined configurations that go further than the /aimassist command and can create granular rules for evaluating targets, such as excluding entities or blocks entirely or creating aim assist rules for specific items. For example, you can have a custom Holy Sword item that can only target undead enemies! For an in-depth tutorial about aim assist presets, see Aim Assist Presets.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/introtoaimassist?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Aim Assist 03/06/2025  The aim assist feature helps you target blocks and entities while using third-person camera modes by displaying a targeting reticle over the target. Aim assist will select targets within a defined distance and view angle that you can control using the /aimassist command. Remember that aim assist will select targets based on the direction that the player character is facing, not the direction that the camera is facing. This can sometimes be confusing, since third-person camera modes allow you to look in a different direction than your player character.  The /aimassist command  You have a lot of control over what entities and blocks are targeted by aim assist. To adjust these settings, use the /aimassist command and set the following parameters to your liking:  Expand table Name\tDefault Value\tDescription Max Distance\t\tThe distance (in blocks) from the player where entities and blocks will be considered for targeting by aim assist. This creates a cone-shaped area in front of the player that can be adjusted using the X angle and Y angle parameters. Entities and blocks outside this cone will not be targeted. Range is from 1 to 16. Players\tnone\tThe ids of the players who will benefit from the aim assist settings. Preset id\tnone\tAn optional parameter that allows you to specify an aim assist preset to use. Presets can provide more details for how targets should be selected, such as changing what targets are prioritized when holding certain items or excluding specific blocks or entities entirely. For more information on aim assist presets, see Aim Assist Presets. Target mode\tnone\tAn optional parameter that defines how how targets are evaluated by the aim assist feature. Uses either distance or angle. - distance: Blocks and entities that are closest to the player will be evaluated first. - angle: Blocks and entities that are closest to the center of the targeting cone will be evaluated first. X angle\t\tThe horizontal angle for the aim assist targeting cone in a range from 10 to 90 degrees. Y angle\t\tThe vertical angle for the aim assist targeting cone in a range from 10 to 90 degrees. Customizing The Targeting Reticle  You can also customize the appearance of the aim assist targeting reticle. Here is an example of the default reticles for blocks and entities:  If you want to replace the targeting reticle with a different shape or color, you can create or update a resource pack to include custom textures.  Create a resourcepack/textures/ui folder.  Add your textures with the names aimassist_block_highlight and aimassist_entity_highlight to replace the appropriate targeting reticle.  Next Steps  You can adjust aim assist settings even further using behavior packs and aim assist presets. Aim assist presets are pre-defined configurations that go further than the /aimassist command and can create granular rules for evaluating targets, such as excluding entities or blocks entirely or creating aim assist rules for specific items. For example, you can have a custom Holy Sword item that can only target undead enemies! For an in-depth tutorial about aim assist presets, see Aim Assist Presets.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/aimassistpresets?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Aim Assist Presets 03/06/2025  Aim assist presets are pre-defined configurations for the aim assist feature in Minecraft. Presets are handy because they allow you to set aim assist parameters in specific situations without having to use the /aimassist command repeatedly. Presets also go beyond the capabilities of the /aimassist command in a number of cool ways, such as allowing you to exclude certain entities or blocks from targeting rules or choosing which items can target liquids!  Aim Assist presets are part of the behavior pack and preset files should be placed in the same folder as your camera presets in your behavior pack:  Aim Assist Preset Settings  Aim assist preset settings determine how potential targets are evaluated by the aim assist feature. You can define what aim assist category to use and when to use them, as well as what blocks or entities can be targeted by a specific preset. To begin, create a json file called aim_assist_preset.json. It should look something like this:  JSON Copy \"minecarft:aim_assist_preset\": {     \"identifier\": \"test:test_preset\",     \"item_settings\": {},     \"default_item_settings\": \"default\",     \"hand_settings\": \"default\",     \"exclusion_list\": {},     \"liquid_targeting_list\": {} }   Let's take a look at these settings.  identifier: The unique name for this aim assist preset. You can use this id in the /aimassist command or in your camera preset file. item_settings: The items that should use special preset categories when held and the category that they should use. default_item_settings: The settings used by any other item not specified in item_settings. hand_settings: The settings used when not holding any items. exclusion_list: The list of blocks or entities that should never be targeted when using this aim assist preset. liquid_targeting_list: The list of items that can target liquids when held. Aim Assist Categories  Aim assist categories are where you define the priority for each type of block or entity when using the aim assist feature. To create an aim assist category, create a categories.json file and place it in the same directory as your aim_assist_preset.json file. This file will contain all of your aim assist categories. Each category is a predefined group of settings and only one category can be active at any time. The active category is determined by what item the player is holding at any given time.  Let's try creating an aim assist category that helps us target logs over other block types when we're holding an axe. Your categories.json file should look like this:  JSON Copy \"minecraft:aim_assist_categories\": {     \"categories\": [         {             \"name\": \"default\",             \"priorities\": {}         }         {             \"name\": \"test:axe_priorities\",             \"entity_default\": 1,             \"block_dafault\": 1,             \"priorities\": {                 \"blocks\": {                     \"minecraft:oak_log\": 6,                     \"minecraft:birch_log\": 6,                     \"minecraft:acacia_log\": 6,                 }             }         }     ] }   Let's take a closer look at our test:axe_priorities category in this file to help understand the parts of an aim assist category.  name: The unique identifier for the aim assist category. entity_default: The default priority to be used for entities by this aim assist category. This should usually be 1. block_default: The default priority to be used for blocks by this aim assist category. This should usually be 1. priorities: The list blocks and entities that should override the default priorities when this category evaluates targets. entities: The list of entities that should override the entity_default priority when this category evaluates targets. blocks: The list of blocks that should override the block_default priority when this category evaluates targets.   Important  The number used for priority values works by modifying the targeting criteria by the specified value. For example, in this aim assist category, we've given oak logs a priority of 6. This setting will make the aim assist feature treat oak logs as if they are 6 times closer to the player (or the center of the targeting cone, in angle aim assist mode) than any other block. This does not mean that oak logs will always be targeted over other blocks, it simply means that they will be treated as if they are much closer than they actually are and blocks that are closer than even the modified distance of an oak log could still be targeted. You should fine tune the priority numbers in your categories to get them feeling right.  Aim Assist in Camera Presets  When you use camera presets, you can use the aim_assist field in your camera.json file:  JSON Copy \"minecraft:camera_preset\": {     \"identifier\": \"test:third_person\",     \"inherit_from\": \"minecraft:follow_orbit\",     \"aim_assist\": {         \"preset\": \"test:axe_priorities\",         \"target_mode\": \"distance\",         \"angle\": [30, 30],         \"distance\": 10     } }   The aim assist settings defined in this preset will override any settings set by the aim assist command when this camera preset is active. Other aim assist commands or presets will only be active when the camera preset does not have a defined aim_assist object.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/camerasystem/aimassistpresets?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Aim Assist Presets 03/06/2025  Aim assist presets are pre-defined configurations for the aim assist feature in Minecraft. Presets are handy because they allow you to set aim assist parameters in specific situations without having to use the /aimassist command repeatedly. Presets also go beyond the capabilities of the /aimassist command in a number of cool ways, such as allowing you to exclude certain entities or blocks from targeting rules or choosing which items can target liquids!  Aim Assist presets are part of the behavior pack and preset files should be placed in the same folder as your camera presets in your behavior pack:  Aim Assist Preset Settings  Aim assist preset settings determine how potential targets are evaluated by the aim assist feature. You can define what aim assist category to use and when to use them, as well as what blocks or entities can be targeted by a specific preset. To begin, create a json file called aim_assist_preset.json. It should look something like this:  JSON Copy \"minecarft:aim_assist_preset\": {     \"identifier\": \"test:test_preset\",     \"item_settings\": {},     \"default_item_settings\": \"default\",     \"hand_settings\": \"default\",     \"exclusion_list\": {},     \"liquid_targeting_list\": {} }   Let's take a look at these settings.  identifier: The unique name for this aim assist preset. You can use this id in the /aimassist command or in your camera preset file. item_settings: The items that should use special preset categories when held and the category that they should use. default_item_settings: The settings used by any other item not specified in item_settings. hand_settings: The settings used when not holding any items. exclusion_list: The list of blocks or entities that should never be targeted when using this aim assist preset. liquid_targeting_list: The list of items that can target liquids when held. Aim Assist Categories  Aim assist categories are where you define the priority for each type of block or entity when using the aim assist feature. To create an aim assist category, create a categories.json file and place it in the same directory as your aim_assist_preset.json file. This file will contain all of your aim assist categories. Each category is a predefined group of settings and only one category can be active at any time. The active category is determined by what item the player is holding at any given time.  Let's try creating an aim assist category that helps us target logs over other block types when we're holding an axe. Your categories.json file should look like this:  JSON Copy \"minecraft:aim_assist_categories\": {     \"categories\": [         {             \"name\": \"default\",             \"priorities\": {}         }         {             \"name\": \"test:axe_priorities\",             \"entity_default\": 1,             \"block_dafault\": 1,             \"priorities\": {                 \"blocks\": {                     \"minecraft:oak_log\": 6,                     \"minecraft:birch_log\": 6,                     \"minecraft:acacia_log\": 6,                 }             }         }     ] }   Let's take a closer look at our test:axe_priorities category in this file to help understand the parts of an aim assist category.  name: The unique identifier for the aim assist category. entity_default: The default priority to be used for entities by this aim assist category. This should usually be 1. block_default: The default priority to be used for blocks by this aim assist category. This should usually be 1. priorities: The list blocks and entities that should override the default priorities when this category evaluates targets. entities: The list of entities that should override the entity_default priority when this category evaluates targets. blocks: The list of blocks that should override the block_default priority when this category evaluates targets.   Important  The number used for priority values works by modifying the targeting criteria by the specified value. For example, in this aim assist category, we've given oak logs a priority of 6. This setting will make the aim assist feature treat oak logs as if they are 6 times closer to the player (or the center of the targeting cone, in angle aim assist mode) than any other block. This does not mean that oak logs will always be targeted over other blocks, it simply means that they will be treated as if they are much closer than they actually are and blocks that are closer than even the modified distance of an oak log could still be targeted. You should fine tune the priority numbers in your categories to get them feeling right.  Aim Assist in Camera Presets  When you use camera presets, you can use the aim_assist field in your camera.json file:  JSON Copy \"minecraft:camera_preset\": {     \"identifier\": \"test:third_person\",     \"inherit_from\": \"minecraft:follow_orbit\",     \"aim_assist\": {         \"preset\": \"test:axe_priorities\",         \"target_mode\": \"distance\",         \"angle\": [30, 30],         \"distance\": 10     } }   The aim assist settings defined in this preset will override any settings set by the aim assist command when this camera preset is active. Other aim assist commands or presets will only be active when the camera preset does not have a defined aim_assist object.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/craftingitemcatalogdocumentation?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Crafting Item Catalog - Overview 02/12/2025  The crafting item catalog is a file used to define the creative inventory/recipe book. With this, you can define a new collapsible group with an item, add items to an existing group, or simply add the items outside of a group in the order that you determine.  While you get the ability to add new items, you don't get to change the order of existing items. Whether you are adding a new group, an existing group, or as a set of loose items, your additions will be added to the end of the list.  The creative inventory and recipe book both share the same list of items. The creative inventory will show all items, while the recipe book will only show items that are able to be crafted.  This file goes into your behavior pack in the item_catalog folder. The file we are reading is called crafting_item_catalog.json.  Categories  You can add new items to the existing categories of construction, nature, equipment, and items, but you can't create new categories, or modify the order that the categories show in the UI.  Adding New Group  If you have a set of new items, you can add them to a new group. This new group will be added to the category you specify at the end of all existing items/groups.  You get a new group if you specify a group_identifier field within your group.  Group Name  The name of the group serves two purposes:  The first is as an identifier for your group. If there are two groups with the same name within a category, they will merge.  The second is that it is the localization string that is display when you hover over your group name. The localization string needs to include the namespace.  Example 1: item_catalog/crafting_item_catalog.json  This is an example of adding an entirely new group to the construction category  JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"construction\",         \"groups\": [           {             \"group_identifier\": {               \"icon\": \"mynamespace:my_item1\",               \"name\": \"mynamespace:my_group_name\"             },             \"items\": [               \"mynamespace:my_item1\",               \"mynamespace:my_item2\"             ]           }         ]       }     ]   } }  Localization File  mynamespace:my_group_name=My Group  This shows our new group using the item \"1\". When the user hovers over the group, the localized name is displayed.  This shows our new group expanded and the items inside of it:  Inserting an Item into an Existing Group  You can also add items to an existing group. You specify this the same way as making a new group, the only difference is that you need to specify a name of an already existing group in a category. When you are inserting into an existing group, like with minecraft:itemGroup.name.helmet, your items are added to the end of the group.  At the end of this page, there is the list of all existing groups currently used by Minecraft Bedrock.  Example 2: item_catalog/crafting_item_catalog.json JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"equipment\",         \"groups\": [           {             \"group_identifier\": {               \"name\": \"minecraft:itemGroup.name.helmet\"             },             \"items\": [               \"mynamespace:my_item3\"             ]           }         ]       }     ]   } }   Our new item \"3\" shows up when expanding the helmet group.  Adding Loose Items as Loose Groups  You don't need to add your items to a group, you can add them to a loose group. These aren't represented with a collapsible group.  Example 3: item_catalog/crafting_item_catalog.json JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"construction\",         \"groups\": [           {             \"items\": [               \"mynamespace:my_item4\",               \"mynamespace:my_item5\",               \"mynamespace:my_item6\"             ]           }         ]       }     ]   } }   Items 4, 5, and 6 are all added outside of a group as loose items.  Multiple Categories and Groups  In all the previous examples we've only done one group and one category at a time. You are able to add multiple groups within a category, as well as add to multiple categories. The order in which groups are added to a category is the order that they will show up in game.  Example 4: item_catalog/crafting_item_catalog.json  The following is an accumulation of all the above examples.  JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"construction\",         \"groups\": [            {             \"items\": [               \"mynamespace:my_item4\",               \"mynamespace:my_item5\",               \"mynamespace:my_item6\"             ]           },           {             \"group_identifier\": {               \"icon\": \"mynamespace:my_item1\",               \"name\": \"mynamespace:my_group_name\"             },             \"items\": [               \"mynamespace:my_item1\",               \"mynamespace:my_item2\"             ]           }         ]       },       {         \"category_name\": \"equipment\",         \"groups\": [           {             \"group_identifier\": {               \"name\": \"minecraft:itemGroup.name.helmet\"             },             \"items\": [               \"mynamespace:my_item3\"             ]           }         ]       }     ]   } }   This shows the new items we added to the Construction tab. The order that we added the loose items and group are what we defined in the file, so the loose items are first and then the group.  Not pictured is the equipment category and adding to an existing group.  Defining a Category and Group for Item and Block Definitions  If you do not care about the order for your items and blocks, you can define the category and group in the definition of your items and blocks instead.  If you define a category and/or group for your item/block and you change it with the crafting item catalog feature, you will get a content warning stating that the category and/or group changed. You can leave the category and group blank if you intend to use the crafting item catalog feature to avoid this from happening.  Both the following examples for the item and block will add these to the planks group in construction category.  Item Example JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:item\": {    \"description\": {     \"identifier\": \"mynamespace:my_item1\",     \"menu_category\": {       \"category\": \"construction\",       \"group\": \"minecraft:itemGroup.name.planks\"     }    },    \"components\": {    }   } }   Block Example JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"mynamespace:my_block\",       \"menu_category\": {         \"category\": \"construction\",         \"group\": \"minecraft:itemGroup.name.planks\"       }     },     \"components\": {     }   } }  Item and Block Format Versions Before 1.21.60  For blocks and items if you did not specify menu_category, or left the category field blank, the category would default to the \"Items\" category. This means that if you were to add this block or item to a category other than \"Items\", you will get the warning mentioned above.  Vanilla Groups  This is a list of all the groups used by Vanilla.  Expand table Group Name minecraft:itemGroup.name.planks minecraft:itemGroup.name.walls minecraft:itemGroup.name.fence minecraft:itemGroup.name.fenceGate minecraft:itemGroup.name.stairs minecraft:itemGroup.name.door minecraft:itemGroup.name.trapdoor minecraft:itemGroup.name.glass minecraft:itemGroup.name.glassPane minecraft:itemGroup.name.slab minecraft:itemGroup.name.stoneBrick minecraft:itemGroup.name.sandstone minecraft:itemGroup.name.copper minecraft:itemGroup.name.wool minecraft:itemGroup.name.woolCarpet minecraft:itemGroup.name.concretePowder minecraft:itemGroup.name.concrete minecraft:itemGroup.name.stainedClay minecraft:itemGroup.name.glazedTerracotta minecraft:itemGroup.name.ore minecraft:itemGroup.name.stone minecraft:itemGroup.name.log minecraft:itemGroup.name.wood minecraft:itemGroup.name.leaves minecraft:itemGroup.name.sapling minecraft:itemGroup.name.seed minecraft:itemGroup.name.crop minecraft:itemGroup.name.grass minecraft:itemGroup.name.coral_decorations minecraft:itemGroup.name.flower minecraft:itemGroup.name.dye minecraft:itemGroup.name.rawFood minecraft:itemGroup.name.mushroom minecraft:itemGroup.name.monsterStoneEgg minecraft:itemGroup.name.mobEgg minecraft:itemGroup.name.coral minecraft:itemGroup.name.sculk minecraft:itemGroup.name.helmet minecraft:itemGroup.name.chestplate minecraft:itemGroup.name.leggings minecraft:itemGroup.name.boots minecraft:itemGroup.name.sword minecraft:itemGroup.name.axe minecraft:itemGroup.name.pickaxe minecraft:itemGroup.name.shovel minecraft:itemGroup.name.hoe minecraft:itemGroup.name.arrow minecraft:itemGroup.name.cookedFood minecraft:itemGroup.name.miscFood minecraft:itemGroup.name.goatHorn minecraft:itemGroup.name.bundles minecraft:itemGroup.name.horseArmor minecraft:itemGroup.name.potion minecraft:itemGroup.name.splashPotion minecraft:itemGroup.name.lingeringPotion minecraft:itemGroup.name.ominousBottle minecraft:itemGroup.name.bed minecraft:itemGroup.name.candles minecraft:itemGroup.name.anvil minecraft:itemGroup.name.chest minecraft:itemGroup.name.shulkerBox minecraft:itemGroup.name.record minecraft:itemGroup.name.sign minecraft:itemGroup.name.hanging_sign minecraft:itemGroup.name.skull minecraft:itemGroup.name.boat minecraft:itemGroup.name.chestboat minecraft:itemGroup.name.rail minecraft:itemGroup.name.minecart minecraft:itemGroup.name.buttons minecraft:itemGroup.name.pressurePlate minecraft:itemGroup.name.banner_pattern minecraft:itemGroup.name.potterySherds minecraft:itemGroup.name.smithing_templates Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/craftingitemcatalogdocumentation?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Crafting Item Catalog - Overview 02/12/2025  The crafting item catalog is a file used to define the creative inventory/recipe book. With this, you can define a new collapsible group with an item, add items to an existing group, or simply add the items outside of a group in the order that you determine.  While you get the ability to add new items, you don't get to change the order of existing items. Whether you are adding a new group, an existing group, or as a set of loose items, your additions will be added to the end of the list.  The creative inventory and recipe book both share the same list of items. The creative inventory will show all items, while the recipe book will only show items that are able to be crafted.  This file goes into your behavior pack in the item_catalog folder. The file we are reading is called crafting_item_catalog.json.  Categories  You can add new items to the existing categories of construction, nature, equipment, and items, but you can't create new categories, or modify the order that the categories show in the UI.  Adding New Group  If you have a set of new items, you can add them to a new group. This new group will be added to the category you specify at the end of all existing items/groups.  You get a new group if you specify a group_identifier field within your group.  Group Name  The name of the group serves two purposes:  The first is as an identifier for your group. If there are two groups with the same name within a category, they will merge.  The second is that it is the localization string that is display when you hover over your group name. The localization string needs to include the namespace.  Example 1: item_catalog/crafting_item_catalog.json  This is an example of adding an entirely new group to the construction category  JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"construction\",         \"groups\": [           {             \"group_identifier\": {               \"icon\": \"mynamespace:my_item1\",               \"name\": \"mynamespace:my_group_name\"             },             \"items\": [               \"mynamespace:my_item1\",               \"mynamespace:my_item2\"             ]           }         ]       }     ]   } }  Localization File  mynamespace:my_group_name=My Group  This shows our new group using the item \"1\". When the user hovers over the group, the localized name is displayed.  This shows our new group expanded and the items inside of it:  Inserting an Item into an Existing Group  You can also add items to an existing group. You specify this the same way as making a new group, the only difference is that you need to specify a name of an already existing group in a category. When you are inserting into an existing group, like with minecraft:itemGroup.name.helmet, your items are added to the end of the group.  At the end of this page, there is the list of all existing groups currently used by Minecraft Bedrock.  Example 2: item_catalog/crafting_item_catalog.json JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"equipment\",         \"groups\": [           {             \"group_identifier\": {               \"name\": \"minecraft:itemGroup.name.helmet\"             },             \"items\": [               \"mynamespace:my_item3\"             ]           }         ]       }     ]   } }   Our new item \"3\" shows up when expanding the helmet group.  Adding Loose Items as Loose Groups  You don't need to add your items to a group, you can add them to a loose group. These aren't represented with a collapsible group.  Example 3: item_catalog/crafting_item_catalog.json JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"construction\",         \"groups\": [           {             \"items\": [               \"mynamespace:my_item4\",               \"mynamespace:my_item5\",               \"mynamespace:my_item6\"             ]           }         ]       }     ]   } }   Items 4, 5, and 6 are all added outside of a group as loose items.  Multiple Categories and Groups  In all the previous examples we've only done one group and one category at a time. You are able to add multiple groups within a category, as well as add to multiple categories. The order in which groups are added to a category is the order that they will show up in game.  Example 4: item_catalog/crafting_item_catalog.json  The following is an accumulation of all the above examples.  JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:crafting_items_catalog\": {     \"categories\": [       {         \"category_name\": \"construction\",         \"groups\": [            {             \"items\": [               \"mynamespace:my_item4\",               \"mynamespace:my_item5\",               \"mynamespace:my_item6\"             ]           },           {             \"group_identifier\": {               \"icon\": \"mynamespace:my_item1\",               \"name\": \"mynamespace:my_group_name\"             },             \"items\": [               \"mynamespace:my_item1\",               \"mynamespace:my_item2\"             ]           }         ]       },       {         \"category_name\": \"equipment\",         \"groups\": [           {             \"group_identifier\": {               \"name\": \"minecraft:itemGroup.name.helmet\"             },             \"items\": [               \"mynamespace:my_item3\"             ]           }         ]       }     ]   } }   This shows the new items we added to the Construction tab. The order that we added the loose items and group are what we defined in the file, so the loose items are first and then the group.  Not pictured is the equipment category and adding to an existing group.  Defining a Category and Group for Item and Block Definitions  If you do not care about the order for your items and blocks, you can define the category and group in the definition of your items and blocks instead.  If you define a category and/or group for your item/block and you change it with the crafting item catalog feature, you will get a content warning stating that the category and/or group changed. You can leave the category and group blank if you intend to use the crafting item catalog feature to avoid this from happening.  Both the following examples for the item and block will add these to the planks group in construction category.  Item Example JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:item\": {    \"description\": {     \"identifier\": \"mynamespace:my_item1\",     \"menu_category\": {       \"category\": \"construction\",       \"group\": \"minecraft:itemGroup.name.planks\"     }    },    \"components\": {    }   } }   Block Example JSON Copy {   \"format_version\": \"1.21.60\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"mynamespace:my_block\",       \"menu_category\": {         \"category\": \"construction\",         \"group\": \"minecraft:itemGroup.name.planks\"       }     },     \"components\": {     }   } }  Item and Block Format Versions Before 1.21.60  For blocks and items if you did not specify menu_category, or left the category field blank, the category would default to the \"Items\" category. This means that if you were to add this block or item to a category other than \"Items\", you will get the warning mentioned above.  Vanilla Groups  This is a list of all the groups used by Vanilla.  Expand table Group Name minecraft:itemGroup.name.planks minecraft:itemGroup.name.walls minecraft:itemGroup.name.fence minecraft:itemGroup.name.fenceGate minecraft:itemGroup.name.stairs minecraft:itemGroup.name.door minecraft:itemGroup.name.trapdoor minecraft:itemGroup.name.glass minecraft:itemGroup.name.glassPane minecraft:itemGroup.name.slab minecraft:itemGroup.name.stoneBrick minecraft:itemGroup.name.sandstone minecraft:itemGroup.name.copper minecraft:itemGroup.name.wool minecraft:itemGroup.name.woolCarpet minecraft:itemGroup.name.concretePowder minecraft:itemGroup.name.concrete minecraft:itemGroup.name.stainedClay minecraft:itemGroup.name.glazedTerracotta minecraft:itemGroup.name.ore minecraft:itemGroup.name.stone minecraft:itemGroup.name.log minecraft:itemGroup.name.wood minecraft:itemGroup.name.leaves minecraft:itemGroup.name.sapling minecraft:itemGroup.name.seed minecraft:itemGroup.name.crop minecraft:itemGroup.name.grass minecraft:itemGroup.name.coral_decorations minecraft:itemGroup.name.flower minecraft:itemGroup.name.dye minecraft:itemGroup.name.rawFood minecraft:itemGroup.name.mushroom minecraft:itemGroup.name.monsterStoneEgg minecraft:itemGroup.name.mobEgg minecraft:itemGroup.name.coral minecraft:itemGroup.name.sculk minecraft:itemGroup.name.helmet minecraft:itemGroup.name.chestplate minecraft:itemGroup.name.leggings minecraft:itemGroup.name.boots minecraft:itemGroup.name.sword minecraft:itemGroup.name.axe minecraft:itemGroup.name.pickaxe minecraft:itemGroup.name.shovel minecraft:itemGroup.name.hoe minecraft:itemGroup.name.arrow minecraft:itemGroup.name.cookedFood minecraft:itemGroup.name.miscFood minecraft:itemGroup.name.goatHorn minecraft:itemGroup.name.bundles minecraft:itemGroup.name.horseArmor minecraft:itemGroup.name.potion minecraft:itemGroup.name.splashPotion minecraft:itemGroup.name.lingeringPotion minecraft:itemGroup.name.ominousBottle minecraft:itemGroup.name.bed minecraft:itemGroup.name.candles minecraft:itemGroup.name.anvil minecraft:itemGroup.name.chest minecraft:itemGroup.name.shulkerBox minecraft:itemGroup.name.record minecraft:itemGroup.name.sign minecraft:itemGroup.name.hanging_sign minecraft:itemGroup.name.skull minecraft:itemGroup.name.boat minecraft:itemGroup.name.chestboat minecraft:itemGroup.name.rail minecraft:itemGroup.name.minecart minecraft:itemGroup.name.buttons minecraft:itemGroup.name.pressurePlate minecraft:itemGroup.name.banner_pattern minecraft:itemGroup.name.potterySherds minecraft:itemGroup.name.smithing_templates Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/recipeintroduction?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Recipe Introduction 06/19/2025  Recipes in Minecraft are very similar to recipes in real life. You gather a variety of components, prepare them in a specific and unique way, and in the end you create something new and wonderful. The main difference is that in Minecraft, recipes aren't limited to food — you use them to build furniture, complex resources, and more!  In this article, we'll look at the basic components of a recipe and go over the different recipe types to help you get started.  Recipe Parameters  Recipe parameters are the building blocks that make up the recipe. To continue the analogy from earlier — these are our ingredients! While all recipes have parameters, not all recipes share the SAME parameters.  Expand table Name\tDescription\tType(s) Input\tDefines the items used to create a recipe\tFurnace; Potion Output\tDefines the item a certain recipe creates\tFurnace; Potion Tags\tDefine items that can be used to create a recipe\tAll Pattern\tRepresents the item and pattern configuration required to produce the result you assign\tShaped Key\tAssigns a Minecraft item to the key(s) you used in the pattern\tShaped Priority\tSets the priority level of a recipe (lower numbers represent a higher priority)\tShaped; Shapeless Result\tWhen input items match the pattern, these items are the result\tShaped; Shapeless; Smithing Transform Ingredients\tDefine the items required to complete a recipe (regardless of their orientation in the table)\tShapeless Reagent\tDefines the items combined with a potion in a brewing container recipe\tPotion Addition\tDefines the items used to perform the transformation\tSmithing Transform Base\tDefines the item that will be transformed\tSmithing Transform Recipe Tags  Recipe tags let you group similar elements together. For example, you can combine different types of wood stairs to construct a recipe that can adapt to a variety of parameters. See this article for more information on recipe tags.  Recipe Types Shaped vs. Shapeless Recipes  Players use Shaped Recipes at a crafting table, and must place recipe components in a dedicated pattern to generate the output assigned to them. As a creator, you can use resource and behavior packs to tweak pattern assignments and output parameters to make them perfect for your world.   Note  The maximum recipe size supported is 3x3, so anything after the third character in a pattern is ignored.  Shapeless recipes are any recipes that don't require a dedicated pattern to generate the output assigned to them. As a creator, you can also leverage resource and behavior packs to edit and create new shapeless recipes, but the parameters used differ slightly.  Parameters Expand table Name\tDescription\tType(s) Tags\tDefine items that can be used to create a recipe\tBoth Pattern\tRepresents the item and pattern configuration required to produce the result you assign\tShaped Key\tAssigns a Minecraft item to the key(s) you used in the pattern\tShaped Ingredients\tDefine the items required to complete a recipe (regardless of their orientation in the table)\tShapeless Priority\tSets the priority level of a recipe (lower numbers represent a higher priority)\tBoth Result\tWhen input items match the pattern, these items are the result\tBoth Furnace Recipes  These are recipes that require a furnace to generate the output assigned to them. When players place the correct item(s) into the furnace (the ones you define as an input in the table's JSON), they transform into the corresponding output assigned in the table. Check out the furnace reference documentation for examples and a more detailed explanation of furnace recipe tables.  Parameters Expand table Name\tDescription Tags\tDefine items that can be used to create a recipe Input\tDefines the items used to create a recipe Output\tDefines the item a certain recipe creates Potion Brewing Recipes  Potions require players to use both a potion brewing mix and a potion brewing container, which is created at a potion brewing station. As a creator, you can use resource and behavior packs to tweak the parameters for these potions, stations, and containers. Check out our potion brewing mix reference documentation for examples and a more detailed explanation of potion brewing tables.  Parameters Expand table Name\tDescription Tags\tDefine items that can be used to create a recipe Input\tDefines the items used to create a recipe Reagent\tDefines the items combined with a potion in a brewing container recipe Output\tDefines the item a certain recipe creates Smithing Transform Recipes  Players use Smithing Transform recipes at a smithing table to retain an item's properties while transforming it into another item. Check out our reference documentation for examples and a more detailed explanation of smithing transform recipes.  Parameters Expand table Name\tDescription Base\tDefines the item that will be transformed Addition\tDefines the items used to perform the transformation Result\tWhen input items match the pattern, these items are the result Smithing Trim Recipes  Players use Smithing Trim recipes at a smithing table to add a color trim to an item while retaining the item's properties. Check out our smithing trim reference documentation for examples and a more detailed explanation of smithing trim recipes.  Recipe Unlocking  As of v1.20.10, players can \"unlock\" recipes ranging from basic starters (like a wooden pickaxe) to some of the most sophisticated items Minecraft has to offer (like diamond ore or enchanted golden apples)! As part of the item and recipe design process, you can define the requirements for unlocking an item with the unlock element in your recipe JSON.   Tip  You can choose an unlock strategy for a recipe based on either the discovery of an item or a specific in-world context.  Unlocking Examples  An item specifies the item to unlock. Optionally you can add a data tag to filter down to a specific type of item.  Acacia Planks:  JSON Copy   \"unlock\": [     {       \"item\": \"minecraft:wood\",       \"data\": 4     }   ]   A context can be one of the following three values:  AlwaysUnlocked: Always unlocks the item when the specified context is met  PlayerInWater: Unlocks the item the first time the player enters the water  PlayerHasManyItems: Player has more than 10 items in their inventory  Crafting table:  JSON Copy   \"unlock\": {     \"context\": \"AlwaysUnlocked\"   }   Chest:  JSON Copy   \"unlock\": {     \"context\": \"PlayerHasManyItems\"   }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/recipeintroduction?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Recipe Introduction 06/19/2025  Recipes in Minecraft are very similar to recipes in real life. You gather a variety of components, prepare them in a specific and unique way, and in the end you create something new and wonderful. The main difference is that in Minecraft, recipes aren't limited to food — you use them to build furniture, complex resources, and more!  In this article, we'll look at the basic components of a recipe and go over the different recipe types to help you get started.  Recipe Parameters  Recipe parameters are the building blocks that make up the recipe. To continue the analogy from earlier — these are our ingredients! While all recipes have parameters, not all recipes share the SAME parameters.  Expand table Name\tDescription\tType(s) Input\tDefines the items used to create a recipe\tFurnace; Potion Output\tDefines the item a certain recipe creates\tFurnace; Potion Tags\tDefine items that can be used to create a recipe\tAll Pattern\tRepresents the item and pattern configuration required to produce the result you assign\tShaped Key\tAssigns a Minecraft item to the key(s) you used in the pattern\tShaped Priority\tSets the priority level of a recipe (lower numbers represent a higher priority)\tShaped; Shapeless Result\tWhen input items match the pattern, these items are the result\tShaped; Shapeless; Smithing Transform Ingredients\tDefine the items required to complete a recipe (regardless of their orientation in the table)\tShapeless Reagent\tDefines the items combined with a potion in a brewing container recipe\tPotion Addition\tDefines the items used to perform the transformation\tSmithing Transform Base\tDefines the item that will be transformed\tSmithing Transform Recipe Tags  Recipe tags let you group similar elements together. For example, you can combine different types of wood stairs to construct a recipe that can adapt to a variety of parameters. See this article for more information on recipe tags.  Recipe Types Shaped vs. Shapeless Recipes  Players use Shaped Recipes at a crafting table, and must place recipe components in a dedicated pattern to generate the output assigned to them. As a creator, you can use resource and behavior packs to tweak pattern assignments and output parameters to make them perfect for your world.   Note  The maximum recipe size supported is 3x3, so anything after the third character in a pattern is ignored.  Shapeless recipes are any recipes that don't require a dedicated pattern to generate the output assigned to them. As a creator, you can also leverage resource and behavior packs to edit and create new shapeless recipes, but the parameters used differ slightly.  Parameters Expand table Name\tDescription\tType(s) Tags\tDefine items that can be used to create a recipe\tBoth Pattern\tRepresents the item and pattern configuration required to produce the result you assign\tShaped Key\tAssigns a Minecraft item to the key(s) you used in the pattern\tShaped Ingredients\tDefine the items required to complete a recipe (regardless of their orientation in the table)\tShapeless Priority\tSets the priority level of a recipe (lower numbers represent a higher priority)\tBoth Result\tWhen input items match the pattern, these items are the result\tBoth Furnace Recipes  These are recipes that require a furnace to generate the output assigned to them. When players place the correct item(s) into the furnace (the ones you define as an input in the table's JSON), they transform into the corresponding output assigned in the table. Check out the furnace reference documentation for examples and a more detailed explanation of furnace recipe tables.  Parameters Expand table Name\tDescription Tags\tDefine items that can be used to create a recipe Input\tDefines the items used to create a recipe Output\tDefines the item a certain recipe creates Potion Brewing Recipes  Potions require players to use both a potion brewing mix and a potion brewing container, which is created at a potion brewing station. As a creator, you can use resource and behavior packs to tweak the parameters for these potions, stations, and containers. Check out our potion brewing mix reference documentation for examples and a more detailed explanation of potion brewing tables.  Parameters Expand table Name\tDescription Tags\tDefine items that can be used to create a recipe Input\tDefines the items used to create a recipe Reagent\tDefines the items combined with a potion in a brewing container recipe Output\tDefines the item a certain recipe creates Smithing Transform Recipes  Players use Smithing Transform recipes at a smithing table to retain an item's properties while transforming it into another item. Check out our reference documentation for examples and a more detailed explanation of smithing transform recipes.  Parameters Expand table Name\tDescription Base\tDefines the item that will be transformed Addition\tDefines the items used to perform the transformation Result\tWhen input items match the pattern, these items are the result Smithing Trim Recipes  Players use Smithing Trim recipes at a smithing table to add a color trim to an item while retaining the item's properties. Check out our smithing trim reference documentation for examples and a more detailed explanation of smithing trim recipes.  Recipe Unlocking  As of v1.20.10, players can \"unlock\" recipes ranging from basic starters (like a wooden pickaxe) to some of the most sophisticated items Minecraft has to offer (like diamond ore or enchanted golden apples)! As part of the item and recipe design process, you can define the requirements for unlocking an item with the unlock element in your recipe JSON.   Tip  You can choose an unlock strategy for a recipe based on either the discovery of an item or a specific in-world context.  Unlocking Examples  An item specifies the item to unlock. Optionally you can add a data tag to filter down to a specific type of item.  Acacia Planks:  JSON Copy   \"unlock\": [     {       \"item\": \"minecraft:wood\",       \"data\": 4     }   ]   A context can be one of the following three values:  AlwaysUnlocked: Always unlocks the item when the specified context is met  PlayerInWater: Unlocks the item the first time the player enters the water  PlayerHasManyItems: Player has more than 10 items in their inventory  Crafting table:  JSON Copy   \"unlock\": {     \"context\": \"AlwaysUnlocked\"   }   Chest:  JSON Copy   \"unlock\": {     \"context\": \"PlayerHasManyItems\"   }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introtoenchantments?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Enchantments 01/31/2025  Enchantments are a property of items in Minecraft that improve an item's existing abilities or give them additional abilities. Players can obtain items that are enchanted by various means, but they can also enchant items themselves.  The main methods to enchant an item are:  Using an enchanting table: Players can use the enchanting table item and pay experience points and lapis lazuli to enchant an item. Only items with no enchantments can be enchanted this way. Librarian villager: The librarian villager will enchant books for players at the cost of emeralds, rather than experience points and lapis lazuli. Using an anvil: Players can combine an item with an enchanted book or with another identical item that has a different enchantment. The resulting item will have both enchantments. /enchant command: The /enchant command will enchant the item held in the main hand of the target player. List of Enchantments  Here is a list of all enchantments in vanilla Minecraft. In Survival mode, enchantments can be added to certain items that are equipped to certain slots. For example, some enchantments can only be granted to items for the helmet slot, while others can be granted to tools such as pickaxes, shovels, axes, and hoes. The following table lists the enchantments available, their effect on the items they're granted to, and the item types (slots) that they can be enchanted onto.  Expand table Name\tEffect\t\tEligible Slots Aqua Affinity\tIncreases speed when mining under water.\t \tHelmet, Turtle Shell Bane of Arthropods\tIncreases the damage dealt to mobs in the arthropod family and applies slowness to them when hit.\t \tSword, Axe Blast Protection\tReduces the damage and knockback from explosions.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Breach\tReduces the protection granted by armor.\t\tMace Channeling\tThrown trident will summon a lightning bolt when the target is hit.\t\tTrident Cleaving\tIncreases the damage dealt by melee attacks and the increases the length of time that shields are disabled after performing a melee attack.\t\tAxe Curse of Binding\tItem cannot be removed once it is equipped. The item can only be removed when it breaks or when the wearer dies.\t\t Curse of Vanishing\tItem will disappear on death.\t\t Depth Strider\tIncreases movement speed under water.\t\tBoots Density\tIncreases the damage dealt by maces per block fallen when performing smashing attacks.\t\tMace Efficiency\tIncreases the speed with which a tool will break a block. The proper tool for the block must be used in order to receive the bonus from this enchantment.\t   \tPickaxe, Shovel, Axe, Hoe Feather Falling\tReduces the damage taken from falling.\t\tBoots Fire Aspect\tSets the target on fire after performing a melee attack.\t \tSword, Axe Fire Protection\tReduces the damage taken from fire and reduces burning time.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Flame\tArrows are ignited when shot and deal fire damage.\t\tBow Fortune\tIncreases the amount of blocks dropped.\t   \tPickaxe, Shovel, Axe, Hoe Frost Walker\tFreezes water as players walk on it.\t\t Impaling\tIncreases the damage dealt to mobs in water or during rain.\t\tTrident Infinity\tNormal arrows will not be consumed when shooting.\t\tBow Knockback\tIncreases the knockback dealt by melee attacks.\t\tSowrd Looting\tIncreases the chances of finding good loot when mobs are killed.\t\tSword Loyalty\tThrown trident will return.\t\tTrident Luck of the Sea\tIncreases the chances of finding good loot when fishing.\t\tFishing Rod Lure\tDecreases the time it takes for fish to bite.\t\tFishing Rod Mending\tItem will be repaired at the cost of experience.\t\t Multishot\tFires three arrows per shot.\t\tCrossbow Piercing\tArrows will pierce through entities and continue to travel. Arrows can pierce multiple entities.\t\tCrossbow Power\tIncreases the damage dealt by arrows.\t\tBow Projectile Protection\tReduces the damage taken from projectiles.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Protection\tReduces the damage taken.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Punch\tIncreases the knockback dealt by arrows.\t\tBow Quick Charge\tDecreases crossbow charging time.\t\tCrossbow Respiration\tIncreases underwater breathing time.\t \tHelmet, Turtle Shell Riptide\tThrown trident will launch the player with it while standing in water or during rain.\t\tTrident Sharpness\tIncreases damage dealt by melee attacks.\t \tSword, Axe Silk Touch\tMined blocks will drop to the ground when destroyed.\t   \tPickaxe, Shovel, Axe, Hoe Smite\tIncreases damage dealt to mobs in the undead family.\t \tSword, Axe Soul Speed\tIncreases movement speed on soul sand and soul soil.\t\t Swift Sneak\tIncreases sneaking speed.\t\t Thorns\tTaking damage deals damage to the attacker.\t\tChestplate Unbreaking\tReduces the durability damage this item takes.\t             \tHelmet, Chestplate, Leggings, Boots, Pickaxe, Shovel, Axe, Hoe, Fishing Rod, Sword, Trident, Bow, Crossbow, Turtle Shell Wind Burst\tLaunches the player into the air after performing a smash attack.\t\tMace Adding Enchanted Items  Custom items can be enchanted, as well. Enchanted custom items are a great way to introduce story elements to a Minecraft experience or to add puzzle-solving or strategy elements to other types of Minecraft worlds. For example, you can use a Riptide trident to help players traverse a jumping puzzle with carefully placed water or localized rain. You could also include airdrops containing items with powerful enchantments like Multishot or Protection and combine them with a Curse of Vanishing so that they disappear when the player who looted them dies - the possibilities are endless!  To refresh your memory on how to add custom items, see Adding Custom Items.  Once you have created your resource pack and added your items, make sure that your item's .json file contains the minecraft:enchantable component. Here's an example of an enchanted chest armor that has the Blast Protection enchantment.  JSON Copy \"minecraft:enchantable\": {   \"value\": 3,   \"slot\": \"armor_torso\" }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introtoenchantments?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Enchantments 01/31/2025  Enchantments are a property of items in Minecraft that improve an item's existing abilities or give them additional abilities. Players can obtain items that are enchanted by various means, but they can also enchant items themselves.  The main methods to enchant an item are:  Using an enchanting table: Players can use the enchanting table item and pay experience points and lapis lazuli to enchant an item. Only items with no enchantments can be enchanted this way. Librarian villager: The librarian villager will enchant books for players at the cost of emeralds, rather than experience points and lapis lazuli. Using an anvil: Players can combine an item with an enchanted book or with another identical item that has a different enchantment. The resulting item will have both enchantments. /enchant command: The /enchant command will enchant the item held in the main hand of the target player. List of Enchantments  Here is a list of all enchantments in vanilla Minecraft. In Survival mode, enchantments can be added to certain items that are equipped to certain slots. For example, some enchantments can only be granted to items for the helmet slot, while others can be granted to tools such as pickaxes, shovels, axes, and hoes. The following table lists the enchantments available, their effect on the items they're granted to, and the item types (slots) that they can be enchanted onto.  Expand table Name\tEffect\t\tEligible Slots Aqua Affinity\tIncreases speed when mining under water.\t \tHelmet, Turtle Shell Bane of Arthropods\tIncreases the damage dealt to mobs in the arthropod family and applies slowness to them when hit.\t \tSword, Axe Blast Protection\tReduces the damage and knockback from explosions.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Breach\tReduces the protection granted by armor.\t\tMace Channeling\tThrown trident will summon a lightning bolt when the target is hit.\t\tTrident Cleaving\tIncreases the damage dealt by melee attacks and the increases the length of time that shields are disabled after performing a melee attack.\t\tAxe Curse of Binding\tItem cannot be removed once it is equipped. The item can only be removed when it breaks or when the wearer dies.\t\t Curse of Vanishing\tItem will disappear on death.\t\t Depth Strider\tIncreases movement speed under water.\t\tBoots Density\tIncreases the damage dealt by maces per block fallen when performing smashing attacks.\t\tMace Efficiency\tIncreases the speed with which a tool will break a block. The proper tool for the block must be used in order to receive the bonus from this enchantment.\t   \tPickaxe, Shovel, Axe, Hoe Feather Falling\tReduces the damage taken from falling.\t\tBoots Fire Aspect\tSets the target on fire after performing a melee attack.\t \tSword, Axe Fire Protection\tReduces the damage taken from fire and reduces burning time.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Flame\tArrows are ignited when shot and deal fire damage.\t\tBow Fortune\tIncreases the amount of blocks dropped.\t   \tPickaxe, Shovel, Axe, Hoe Frost Walker\tFreezes water as players walk on it.\t\t Impaling\tIncreases the damage dealt to mobs in water or during rain.\t\tTrident Infinity\tNormal arrows will not be consumed when shooting.\t\tBow Knockback\tIncreases the knockback dealt by melee attacks.\t\tSowrd Looting\tIncreases the chances of finding good loot when mobs are killed.\t\tSword Loyalty\tThrown trident will return.\t\tTrident Luck of the Sea\tIncreases the chances of finding good loot when fishing.\t\tFishing Rod Lure\tDecreases the time it takes for fish to bite.\t\tFishing Rod Mending\tItem will be repaired at the cost of experience.\t\t Multishot\tFires three arrows per shot.\t\tCrossbow Piercing\tArrows will pierce through entities and continue to travel. Arrows can pierce multiple entities.\t\tCrossbow Power\tIncreases the damage dealt by arrows.\t\tBow Projectile Protection\tReduces the damage taken from projectiles.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Protection\tReduces the damage taken.\t    \tHelmet, Chestplate, Leggings, Boots, Turtle Shell Punch\tIncreases the knockback dealt by arrows.\t\tBow Quick Charge\tDecreases crossbow charging time.\t\tCrossbow Respiration\tIncreases underwater breathing time.\t \tHelmet, Turtle Shell Riptide\tThrown trident will launch the player with it while standing in water or during rain.\t\tTrident Sharpness\tIncreases damage dealt by melee attacks.\t \tSword, Axe Silk Touch\tMined blocks will drop to the ground when destroyed.\t   \tPickaxe, Shovel, Axe, Hoe Smite\tIncreases damage dealt to mobs in the undead family.\t \tSword, Axe Soul Speed\tIncreases movement speed on soul sand and soul soil.\t\t Swift Sneak\tIncreases sneaking speed.\t\t Thorns\tTaking damage deals damage to the attacker.\t\tChestplate Unbreaking\tReduces the durability damage this item takes.\t             \tHelmet, Chestplate, Leggings, Boots, Pickaxe, Shovel, Axe, Hoe, Fishing Rod, Sword, Trident, Bow, Crossbow, Turtle Shell Wind Burst\tLaunches the player into the air after performing a smash attack.\t\tMace Adding Enchanted Items  Custom items can be enchanted, as well. Enchanted custom items are a great way to introduce story elements to a Minecraft experience or to add puzzle-solving or strategy elements to other types of Minecraft worlds. For example, you can use a Riptide trident to help players traverse a jumping puzzle with carefully placed water or localized rain. You could also include airdrops containing items with powerful enchantments like Multishot or Protection and combine them with a Curse of Vanishing so that they disappear when the player who looted them dies - the possibilities are endless!  To refresh your memory on how to add custom items, see Adding Custom Items.  Once you have created your resource pack and added your items, make sure that your item's .json file contains the minecraft:enchantable component. Here's an example of an enchanted chest armor that has the Blast Protection enchantment.  JSON Copy \"minecraft:enchantable\": {   \"value\": 3,   \"slot\": \"armor_torso\" }  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontosound?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Sounds 09/20/2023  Welcome to the world of sound! In this introduction, we will go over the very basics of sounds in Minecraft: Bedrock Edition. Note that this is in no way intended to be an all-encompassing or in-depth examination, and is more of the first step on a long path.  Sounds in Minecraft: Bedrock Edition work, in the broadest of terms, by playing audio files that are stored in the file structure of the game. These files are played in response to in-game events such as player actions, environmental changes, and the actions of other players.  The playback volume of sounds can be adjusted using in-game settings, while sounds can be further edited or replaced completely with resource packs.  Sound Layout  Sounds in Minecraft: Bedrock Edition are organized in multiple ways, and can contain multiple components. To begin, let's take a look at the 'ambient.weather.rain' sound event:  JSON Copy \"ambient.weather.rain\": {     \"category\": \"weather\",     \"min_distance\": 100.0,     \"sounds\": [       {         \"name\": \"sounds/ambient/weather/rain1\",         \"volume\": 0.02,         \"load_on_low_memory\": true       },       {         \"name\": \"sounds/ambient/weather/rain2\",         \"volume\": 0.02       },       {         \"name\": \"sounds/ambient/weather/rain3\",         \"volume\": 0.02       },       {         \"name\": \"sounds/ambient/weather/rain4\",         \"volume\": 0.02       }     ]   }   Most of the basic information we need regarding sound is included in the sample json.  Sounds: These are the individual sound files that constitute everything a player hears in-game. Minecraft: Bedrock Edition supports .wav, .ogg, and .fsb sound files, and up to 32 sounds can be played in-game simultaneously. In the example, you can see the names of the sounds that can potentially play during this event, such as 'sounds/ambient/weather/rain2' and the other named files. Sound Events: The totality of the sample constitutes a sound event, which is an in-game event involving one or more sounds. Multiple sound events can contain the same sound; for example, both the 'mob.drowned.sim' and 'random.swim' sound events contain the 'sounds/random/swim1' sound. Sound Categories: Sound categories are broad fields where sounds are organized, and those fields can then be further organized in a chain. In our example, you can see that the category in the example is 'Weather.' The 'Weather' category contains sounds such as 'Thunder1' and 'Rain3.' In turn, 'Weather' is a child category of the broader 'Ambient' designation. The main function of sound categories is to set the volume for a group of sounds as opposed to configuring volumes for each sound individually. Distance: The distance that sounds fade in and fade out, also known as attenuation, can be controlled using the 'min_distance' and 'max_distance' parameters. The default values of attenuation occur at a minimum of 1.0 meters and a maximum of 10,000 meters. In the example, you can see that we have a defined minimum distance of 100.0, which means that the sound will start to fade in once the player is 100 meters from the source of the sound. Volume: Volume, in the context of what we see in the example, is interesting. Instead of being used to determine the intensity of the sound, volume is used here to define how far away a sound can be before the game will attempt to play it. By default, a listener must be <= 16 blocks from the source of the sound before the engine will attempt to play it. Playing Sounds  There are multiple ways to play sounds in Minecraft: Bedrock Edition. The most basic method is to use the '/playsound' command, which will allow you to play a chosen sound for a player or players. To cause sounds to play automatically with events, they need to be added to the 'sounds.json' file.  Additionally, with the use of resource packs custom sounds can be added to replace regular sounds. For a more in-depth look at this process, be sure to read our How to Add Custom Sounds article.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontosound?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Introduction to Sounds 09/20/2023  Welcome to the world of sound! In this introduction, we will go over the very basics of sounds in Minecraft: Bedrock Edition. Note that this is in no way intended to be an all-encompassing or in-depth examination, and is more of the first step on a long path.  Sounds in Minecraft: Bedrock Edition work, in the broadest of terms, by playing audio files that are stored in the file structure of the game. These files are played in response to in-game events such as player actions, environmental changes, and the actions of other players.  The playback volume of sounds can be adjusted using in-game settings, while sounds can be further edited or replaced completely with resource packs.  Sound Layout  Sounds in Minecraft: Bedrock Edition are organized in multiple ways, and can contain multiple components. To begin, let's take a look at the 'ambient.weather.rain' sound event:  JSON Copy \"ambient.weather.rain\": {     \"category\": \"weather\",     \"min_distance\": 100.0,     \"sounds\": [       {         \"name\": \"sounds/ambient/weather/rain1\",         \"volume\": 0.02,         \"load_on_low_memory\": true       },       {         \"name\": \"sounds/ambient/weather/rain2\",         \"volume\": 0.02       },       {         \"name\": \"sounds/ambient/weather/rain3\",         \"volume\": 0.02       },       {         \"name\": \"sounds/ambient/weather/rain4\",         \"volume\": 0.02       }     ]   }   Most of the basic information we need regarding sound is included in the sample json.  Sounds: These are the individual sound files that constitute everything a player hears in-game. Minecraft: Bedrock Edition supports .wav, .ogg, and .fsb sound files, and up to 32 sounds can be played in-game simultaneously. In the example, you can see the names of the sounds that can potentially play during this event, such as 'sounds/ambient/weather/rain2' and the other named files. Sound Events: The totality of the sample constitutes a sound event, which is an in-game event involving one or more sounds. Multiple sound events can contain the same sound; for example, both the 'mob.drowned.sim' and 'random.swim' sound events contain the 'sounds/random/swim1' sound. Sound Categories: Sound categories are broad fields where sounds are organized, and those fields can then be further organized in a chain. In our example, you can see that the category in the example is 'Weather.' The 'Weather' category contains sounds such as 'Thunder1' and 'Rain3.' In turn, 'Weather' is a child category of the broader 'Ambient' designation. The main function of sound categories is to set the volume for a group of sounds as opposed to configuring volumes for each sound individually. Distance: The distance that sounds fade in and fade out, also known as attenuation, can be controlled using the 'min_distance' and 'max_distance' parameters. The default values of attenuation occur at a minimum of 1.0 meters and a maximum of 10,000 meters. In the example, you can see that we have a defined minimum distance of 100.0, which means that the sound will start to fade in once the player is 100 meters from the source of the sound. Volume: Volume, in the context of what we see in the example, is interesting. Instead of being used to determine the intensity of the sound, volume is used here to define how far away a sound can be before the game will attempt to play it. By default, a listener must be <= 16 blocks from the source of the sound before the engine will attempt to play it. Playing Sounds  There are multiple ways to play sounds in Minecraft: Bedrock Edition. The most basic method is to use the '/playsound' command, which will allow you to play a chosen sound for a player or players. To cause sounds to play automatically with events, they need to be added to the 'sounds.json' file.  Additionally, with the use of resource packs custom sounds can be added to replace regular sounds. For a more in-depth look at this process, be sure to read our How to Add Custom Sounds article.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customblockrenderlighting?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks: Render and Lighting Options 09/26/2024  Okay, so we can make blocks that are different shapes, which is awesome! But what if we want more cool options? How does a stained glass block work, anyhow?  Let's explore some fun effects using the render options available through the material_instances component.  Prerequisites  It's recommended that the following be completed before beginning this tutorial:  Custom Blocks Part One: The Simplest Block Custom Blocks Part Two: Geometry and Material Instances  In this tutorial, we will focus on understanding how the different render methods in the material_instances component affect the rendering of our custom block. To exemplify this, we will be using the bubble fish block shown below because it has a wide range of pixel types that are affected differently by each render method.  Say \"Hello\" to the bubble fish!  Bubble fish is made of several blocks.  The bubble is made up of a 16x16x16 block. Then, there's an internal fish that's a 3x4x5 block with five 1x1x1 blocks added for a tail. The geometry is laid out in the UV map to correctly appear as we want it to in-game.  The bubble's texture was created in Paint3D to be able to create opaque, translucent, and transparent pixels.  You can create your own transparent block, or check out the minecraft-samples page for more information.  Another tutorial, another excellent follow-along video!  Complete Setup in Resource Pack  This isn't our first time setting up a custom block, so this time we're giving you shortened steps. If at any point you get lost, please refer back to the previous custom block tutorials or the minecraft-samples page noted above.  Export the file in Blockbench just as we did for the sushi block. Add the downloaded geometry file by navigating to custom_block_resource_pack/models/blocks and copying the file in. JSON Copy {   \"format_version\": \"1.12.0\",   \"minecraft:geometry\": [     {       \"description\": {         \"identifier\": \"geometry.bubble_fish\",         \"texture_width\": 64,         \"texture_height\": 64,         \"visible_bounds_width\": 2,         \"visible_bounds_height\": 2.5,         \"visible_bounds_offset\": [0, 0.75, 0]       },       \"bones\": [         {           \"name\": \"bb_main\",           \"pivot\": [0, 0, 0],           \"cubes\": [             { \"origin\": [-8, 0, -8], \"size\": [16, 16, 16], \"uv\": [0, 0] }           ]         },         {           \"name\": \"fish\",           \"pivot\": [0, -14, 0],           \"cubes\": [             { \"origin\": [-4, 6, -1], \"size\": [5, 4, 3], \"uv\": [0, 34] },             { \"origin\": [1, 7, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [2, 8, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [3, 9, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [3, 5, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [2, 6, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] }           ]         }       ]     }   ] }  Add the bubble fish texture in the custom_block_resource_pack/textures/blocks folder.  Add a friendly name in terrain_texture.json by navigating to custom_block_resource_pack/textures and editing the terrain_texture.json file. Navigate to custom_block_resource_pack/texts/en_US.lang and add a localized named for the bubble fish. Finally, you can add an entry to blocks.json to give this block a sound. Remember, if you are using custom geometry and materials an entry in blocks.json is completely optional, so we did not add one for this block.  Whew, that was a lot to cover... Great work!  Behavior Pack  Create a JSON file for the custom block  Now it's time to create the behavior pack custom block JSON file.  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:bubble_fish\"     },     \"components\": {       \"minecraft:geometry\": \"geometry.bubble_fish\",       \"minecraft:material_instances\": {         \"*\": {           \"texture\": \"bubble_fish\"         }       }     }   } }   As always, we identify the block, reference the geometry, and then include the texture. In this case, we'll use bubble_fish on all sides.  Render methods  Now we're onto the good stuff! Render methods using the material_instances component.  We'll be exploring the render_methods parameter available to textures. The default is opaque, so let's see how that renders our bubble fish block.  Opaque  JSON Copy   \"minecraft:material_instances\": {      \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"opaque\"      }     }   As you can see, transparency and translucency are not respected. Those colors are rendered in the nearest opaque color.  Double-Sided  JSON Copy \"minecraft:material_instances\": {   \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"double_sided\"      } }   Double-sided disables backface culling.  'Backface culling' is a rendering technique used to improve performance, where only the side of the block that you can see is rendered.  The 'opaque' render method does backface culling by default to improve performance, but if you want the backface to render, or make your block \"double sided\", you can use the \"double_sided\" render method.  However, you can only tell the difference between \"opaque\" and \"double_sided\" if your head is inside the block. For \"opaque,\" you will NOT be able to see the inside of the block around you. For \"double_sided,\" you WILL be able to see the inside of the block around you. But from the outside, these two render methods look identical.  render_method: alpha_test  JSON Copy \"minecraft:material_instances\": {   \"*\": {        \"texture\": \"bubble_fish\",    \"render_method\": \"alpha_test\"   } }   Alpha test doesn't respect translucency, which affects the transparent teal pixels of this block. But it does respect transparent and opaque pixels. This render method also disables backface culling, which is why you can see the back of the bubble through the transparent parts. At least we can see the fish!  render_method: alpha_test_single_sided  render method: alpha_test_single_sided is very similar to alpha test. It doesn't respect translucency, which affects the transparent teal pixels of this block. But it does respect transparent and opaque pixels. This render method enables backface culling, which is why you can't see the back of the bubble through the transparent parts. Just like a regular glass block!  render_method: blend  JSON Copy \"minecraft:material_instances\": {   \"*\": {     \"texture\": \"bubble_fish\",     \"render_method\": \"blend\"   } }   Blend allows transparent, translucent, and opaque to show and does backface culling by default, which is why you can not see the backface through the transparent parts.  This render method is perfect for our bubble block that contains all 3 types of pixels: Transparent, translucent, and opaque!  Lighting Options  There are also two different lighting options to explore.  ambient_occlusion  If true, shadows will be created around and underneath the block.  JSON Copy \"minecraft:material_instances\": {      \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"blend\",       \"ambient_occlusion\": true      }     }   Here you can see our block on the left has ambient occlusion set to 'true,' while the block on the right has ambient occlusion set to 'false.'  face_dimming  Should the material be dimmed by the side it's facing?  JSON Copy \"minecraft:material_instances\": {      \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"blend\",       \"face_dimming\": true      }     }   Similar to our ambient occlusion example, you can see the block on the left has face dimming set to 'true,' while the right block has the option set to 'false'.  Next Steps  Wow, there's been a lot to explore! We have one more fun, new feature to check out: LARGE BLOCKS!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customblockrenderlighting?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks: Render and Lighting Options 09/26/2024  Okay, so we can make blocks that are different shapes, which is awesome! But what if we want more cool options? How does a stained glass block work, anyhow?  Let's explore some fun effects using the render options available through the material_instances component.  Prerequisites  It's recommended that the following be completed before beginning this tutorial:  Custom Blocks Part One: The Simplest Block Custom Blocks Part Two: Geometry and Material Instances  In this tutorial, we will focus on understanding how the different render methods in the material_instances component affect the rendering of our custom block. To exemplify this, we will be using the bubble fish block shown below because it has a wide range of pixel types that are affected differently by each render method.  Say \"Hello\" to the bubble fish!  Bubble fish is made of several blocks.  The bubble is made up of a 16x16x16 block. Then, there's an internal fish that's a 3x4x5 block with five 1x1x1 blocks added for a tail. The geometry is laid out in the UV map to correctly appear as we want it to in-game.  The bubble's texture was created in Paint3D to be able to create opaque, translucent, and transparent pixels.  You can create your own transparent block, or check out the minecraft-samples page for more information.  Another tutorial, another excellent follow-along video!  Complete Setup in Resource Pack  This isn't our first time setting up a custom block, so this time we're giving you shortened steps. If at any point you get lost, please refer back to the previous custom block tutorials or the minecraft-samples page noted above.  Export the file in Blockbench just as we did for the sushi block. Add the downloaded geometry file by navigating to custom_block_resource_pack/models/blocks and copying the file in. JSON Copy {   \"format_version\": \"1.12.0\",   \"minecraft:geometry\": [     {       \"description\": {         \"identifier\": \"geometry.bubble_fish\",         \"texture_width\": 64,         \"texture_height\": 64,         \"visible_bounds_width\": 2,         \"visible_bounds_height\": 2.5,         \"visible_bounds_offset\": [0, 0.75, 0]       },       \"bones\": [         {           \"name\": \"bb_main\",           \"pivot\": [0, 0, 0],           \"cubes\": [             { \"origin\": [-8, 0, -8], \"size\": [16, 16, 16], \"uv\": [0, 0] }           ]         },         {           \"name\": \"fish\",           \"pivot\": [0, -14, 0],           \"cubes\": [             { \"origin\": [-4, 6, -1], \"size\": [5, 4, 3], \"uv\": [0, 34] },             { \"origin\": [1, 7, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [2, 8, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [3, 9, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [3, 5, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] },             { \"origin\": [2, 6, 0], \"size\": [1, 1, 1], \"uv\": [0, 41] }           ]         }       ]     }   ] }  Add the bubble fish texture in the custom_block_resource_pack/textures/blocks folder.  Add a friendly name in terrain_texture.json by navigating to custom_block_resource_pack/textures and editing the terrain_texture.json file. Navigate to custom_block_resource_pack/texts/en_US.lang and add a localized named for the bubble fish. Finally, you can add an entry to blocks.json to give this block a sound. Remember, if you are using custom geometry and materials an entry in blocks.json is completely optional, so we did not add one for this block.  Whew, that was a lot to cover... Great work!  Behavior Pack  Create a JSON file for the custom block  Now it's time to create the behavior pack custom block JSON file.  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:bubble_fish\"     },     \"components\": {       \"minecraft:geometry\": \"geometry.bubble_fish\",       \"minecraft:material_instances\": {         \"*\": {           \"texture\": \"bubble_fish\"         }       }     }   } }   As always, we identify the block, reference the geometry, and then include the texture. In this case, we'll use bubble_fish on all sides.  Render methods  Now we're onto the good stuff! Render methods using the material_instances component.  We'll be exploring the render_methods parameter available to textures. The default is opaque, so let's see how that renders our bubble fish block.  Opaque  JSON Copy   \"minecraft:material_instances\": {      \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"opaque\"      }     }   As you can see, transparency and translucency are not respected. Those colors are rendered in the nearest opaque color.  Double-Sided  JSON Copy \"minecraft:material_instances\": {   \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"double_sided\"      } }   Double-sided disables backface culling.  'Backface culling' is a rendering technique used to improve performance, where only the side of the block that you can see is rendered.  The 'opaque' render method does backface culling by default to improve performance, but if you want the backface to render, or make your block \"double sided\", you can use the \"double_sided\" render method.  However, you can only tell the difference between \"opaque\" and \"double_sided\" if your head is inside the block. For \"opaque,\" you will NOT be able to see the inside of the block around you. For \"double_sided,\" you WILL be able to see the inside of the block around you. But from the outside, these two render methods look identical.  render_method: alpha_test  JSON Copy \"minecraft:material_instances\": {   \"*\": {        \"texture\": \"bubble_fish\",    \"render_method\": \"alpha_test\"   } }   Alpha test doesn't respect translucency, which affects the transparent teal pixels of this block. But it does respect transparent and opaque pixels. This render method also disables backface culling, which is why you can see the back of the bubble through the transparent parts. At least we can see the fish!  render_method: alpha_test_single_sided  render method: alpha_test_single_sided is very similar to alpha test. It doesn't respect translucency, which affects the transparent teal pixels of this block. But it does respect transparent and opaque pixels. This render method enables backface culling, which is why you can't see the back of the bubble through the transparent parts. Just like a regular glass block!  render_method: blend  JSON Copy \"minecraft:material_instances\": {   \"*\": {     \"texture\": \"bubble_fish\",     \"render_method\": \"blend\"   } }   Blend allows transparent, translucent, and opaque to show and does backface culling by default, which is why you can not see the backface through the transparent parts.  This render method is perfect for our bubble block that contains all 3 types of pixels: Transparent, translucent, and opaque!  Lighting Options  There are also two different lighting options to explore.  ambient_occlusion  If true, shadows will be created around and underneath the block.  JSON Copy \"minecraft:material_instances\": {      \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"blend\",       \"ambient_occlusion\": true      }     }   Here you can see our block on the left has ambient occlusion set to 'true,' while the block on the right has ambient occlusion set to 'false.'  face_dimming  Should the material be dimmed by the side it's facing?  JSON Copy \"minecraft:material_instances\": {      \"*\": {       \"texture\": \"bubble_fish\",       \"render_method\": \"blend\",       \"face_dimming\": true      }     }   Similar to our ambient occlusion example, you can see the block on the left has face dimming set to 'true,' while the right block has the option set to 'false'.  Next Steps  Wow, there's been a lot to explore! We have one more fun, new feature to check out: LARGE BLOCKS!  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customblockrenderdistance?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks: Render and Distance 09/12/2024  When creating a Custom Block you have a lot of things to consider about how it is displayed in the world. One of the important ones for making it feel like a seamless integration with existing blocks is getting the right render distance.  If you're making a new crop you want it to stay visible as long as the existing vanilla crops do. To be able to control the render distance we first need to understand the relationship between render method and render distance.  Render Method  For a full walkthrough of the functionality of the different render methods, see the Custom Block Render Lighting step.  There are 5 render methods to choose from for custom blocks:  opaque double_sided blend alpha_test alpha_test_single_sided  Each has its special functionality that could make it the right choice based on the level of transparency and translucency that you are trying to achieve for your block.  The render method is also what determines the render distance where a block will be displayed.  Use this table to find see the values for each of these under \"perfect\" conditions. We call it perfect because these values can skew if we are looking through something that could effect how ideal the scenario is, such as water or fog, that can effect the render distance of blocks independently.  Expand table Groups\tRender Methods\tRender Distance Start (from player)\tRender Distance End (from player) Far\topaque\tRender Distance / 2\tRender Distance Near\tdouble_sided, blend, alpha_test, alpha_test_single_sided\t0\tRender Distance – Far Render Distance Start  Far blocks are also rendered in the near group, so there isn't a gap where far blocks aren't visible.  Blend Exceptions  For Vanilla blocks, water is a special case. It can be inserted into the far group even though it uses a blend texture. This can't be currently replicated through Custom Blocks.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customblockrenderdistance?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Custom Blocks: Render and Distance 09/12/2024  When creating a Custom Block you have a lot of things to consider about how it is displayed in the world. One of the important ones for making it feel like a seamless integration with existing blocks is getting the right render distance.  If you're making a new crop you want it to stay visible as long as the existing vanilla crops do. To be able to control the render distance we first need to understand the relationship between render method and render distance.  Render Method  For a full walkthrough of the functionality of the different render methods, see the Custom Block Render Lighting step.  There are 5 render methods to choose from for custom blocks:  opaque double_sided blend alpha_test alpha_test_single_sided  Each has its special functionality that could make it the right choice based on the level of transparency and translucency that you are trying to achieve for your block.  The render method is also what determines the render distance where a block will be displayed.  Use this table to find see the values for each of these under \"perfect\" conditions. We call it perfect because these values can skew if we are looking through something that could effect how ideal the scenario is, such as water or fog, that can effect the render distance of blocks independently.  Expand table Groups\tRender Methods\tRender Distance Start (from player)\tRender Distance End (from player) Far\topaque\tRender Distance / 2\tRender Distance Near\tdouble_sided, blend, alpha_test, alpha_test_single_sided\t0\tRender Distance – Far Render Distance Start  Far blocks are also rendered in the near group, so there isn't a gap where far blocks aren't visible.  Blend Exceptions  For Vanilla blocks, water is a special case. It can be inserted into the far group even though it uses a blend texture. This can't be currently replicated through Custom Blocks.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customblockoversized?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Advanced Block Visuals: Sizing and Culling 06/10/2025  Custom blocks are not constrained to the usual 16x16x16 Minecraft block geometry. Not only can they be larger than 16x16x16 pixels, but since release 1.20.60, you can use a feature called \"culling\" to dynamically remove parts of the block when it is placed near blocks that occlude one of the sides.  First, we will cover how to create an over-sized block, then we will use one of the examples from another custom block tuorial (the Sushi Block one) to demonstrate culling.  Prerequisites  It's recommended that the following be completed before beginning this tutorial:  Custom Blocks Part One: The Simplest Block Custom Blocks Part Two: Geometry and Material Instances Custom Blocks Part Three: Render and Lighting Options  These blocks can get tricky, but this video takes you through the whole process!  Resource Pack Create geometry in Blockbench  Let's create a 30x30x30 pixel block in Blockbench. First, we have to cover some of the limitations when it comes to creating oversized custom blocks.  Custom block limitations  Your block is limited to 30x30x30 pixels in size.  The absolute bounds of the position of your 30x30x30 block are 30 pixels in each direction from the origin. The origin is in the middle at the bottom of the base 16x16x16 block. So the absolute bounds give you 30 pixels in the +x direction, 30 pixels in the –x direction, 30 pixels in the +y direction, 30 pixels in the –y direction, 30 pixels in the +z direction, and 30 pixels in the –z direction. Your block can be placed in any position within these bounds, as long as it adheres to rule #3.  At least 1 pixel of your block on each axis must be contained by the base 16x16x16 block.  Here is a visualization of the absolute bounds your block must be contained in, in relation to the base 16x16x16 block:  Below you can see some examples of VALID 30x30x30 custom blocks that are contained in the absolute bounds, and have at least ONE CUBE contained in the 16x16x16 base block:  Next, we have an example of a 30x30x30 custom block that is contained in the absolute bounds, but is INVALID since no part of it is contained in the base 16x16x16 block:  Implement the Rest of the Giant Umbrella Block  For this last tutorial, you're on your own setting up the rest of the Giant Umbrella block. Remember, you've got this! Here are the steps you've followed each time you've made a custom block:  Resource Pack Steps Export the file in Blockbench Add geometry to Resource Packs JSON Copy {    \"format_version\": \"1.12.0\",    \"minecraft:geometry\": [      {        \"description\": {          \"identifier\": \"geometry.umbrella\",          \"texture_width\": 128,          \"texture_height\": 128,          \"visible_bounds_width\": 3,          \"visible_bounds_height\": 3.5,          \"visible_bounds_offset\": [0, 1.25, 0]        },        \"bones\": [          {            \"name\": \"umbrella\",            \"pivot\": [0, 13, 0],            \"cubes\": [              {\"origin\": [-3, 28, -5], \"size\": [6, 1, 2], \"uv\": [0, 3]},              {\"origin\": [-5, 27, -7], \"size\": [10, 1, 2], \"uv\": [66, 53]},              {\"origin\": [-5, 27, 5], \"size\": [10, 1, 2], \"uv\": [66, 37]},              {\"origin\": [5, 27, -5], \"size\": [2, 1, 10], \"uv\": [66, 42]},              {\"origin\": [-7, 27, -5], \"size\": [2, 1, 10], \"uv\": [36, 64]},              {\"origin\": [-9, 26, -7], \"size\": [2, 1, 14], \"uv\": [18, 64]},              {\"origin\": [7, 26, -7], \"size\": [2, 1, 14], \"uv\": [0, 63]},              {\"origin\": [9, 25, -9], \"size\": [2, 1, 18], \"uv\": [46, 62]},              {\"origin\": [11, 24, -10], \"size\": [1, 1, 20], \"uv\": [44, 21]},              {\"origin\": [12, 23, -10], \"size\": [1, 1, 20], \"uv\": [0, 42]},              {\"origin\": [13, 22, -10], \"size\": [1, 1, 20], \"uv\": [22, 1]},              {\"origin\": [14, 21, -10], \"size\": [1, 1, 20], \"uv\": [0, 21]},              {\"origin\": [-12, 24, -10], \"size\": [1, 1, 20], \"uv\": [44, 0]},              {\"origin\": [-13, 23, -10], \"size\": [1, 1, 20], \"uv\": [22, 43]},              {\"origin\": [-14, 22, -10], \"size\": [1, 1, 20], \"uv\": [22, 22]},              {\"origin\": [-15, 21, -10], \"size\": [1, 1, 20], \"uv\": [0, 0]},              {\"origin\": [-11, 25, -9], \"size\": [2, 1, 18], \"uv\": [44, 43]},              {\"origin\": [-9, 25, 9], \"size\": [18, 1, 2], \"uv\": [66, 21]},              {\"origin\": [-9, 25, -11], \"size\": [18, 1, 2], \"uv\": [66, 16]},              {\"origin\": [-10, 24, -12], \"size\": [20, 1, 1], \"uv\": [66, 14]},              {\"origin\": [-10, 23, -13], \"size\": [20, 1, 1], \"uv\": [66, 10]},              {\"origin\": [-10, 22, -14], \"size\": [20, 1, 1], \"uv\": [66, 6]},              {\"origin\": [-10, 21, -15], \"size\": [20, 1, 1], \"uv\": [66, 2]},              {\"origin\": [-10, 23, 12], \"size\": [20, 1, 1], \"uv\": [66, 8]},              {\"origin\": [-10, 22, 13], \"size\": [20, 1, 1], \"uv\": [66, 4]},              {\"origin\": [-10, 21, 14], \"size\": [20, 1, 1], \"uv\": [66, 0]},              {\"origin\": [-10, 24, 11], \"size\": [20, 1, 1], \"uv\": [66, 12]},              {\"origin\": [-7, 26, 7], \"size\": [14, 1, 2], \"uv\": [66, 34]},              {\"origin\": [-7, 26, -9], \"size\": [14, 1, 2], \"uv\": [66, 31]},              {\"origin\": [-7, 26, -7], \"size\": [2, 1, 2], \"uv\": [6, 16]},              {\"origin\": [-9, 25, -9], \"size\": [2, 1, 2], \"uv\": [12, 12]},              {\"origin\": [-9, 25, 7], \"size\": [2, 1, 2], \"uv\": [12, 9]},              {\"origin\": [7, 25, 7], \"size\": [2, 1, 2], \"uv\": [12, 6]},              {\"origin\": [9, 24, 9], \"size\": [2, 1, 2], \"uv\": [6, 10]},              {\"origin\": [9, 24, -11], \"size\": [2, 1, 2], \"uv\": [0, 9]},              {\"origin\": [10, 23, -12], \"size\": [1, 1, 1], \"uv\": [25, 27]},              {\"origin\": [10, 22, -13], \"size\": [1, 1, 1], \"uv\": [25, 9]},              {\"origin\": [10, 21, -14], \"size\": [1, 1, 1], \"uv\": [0, 24]},              {\"origin\": [11, 21, -13], \"size\": [1, 1, 1], \"uv\": [15, 23]},              {\"origin\": [12, 21, -12], \"size\": [1, 1, 1], \"uv\": [22, 22]},              {\"origin\": [13, 21, -11], \"size\": [1, 1, 1], \"uv\": [22, 18]},              {\"origin\": [11, 22, -12], \"size\": [1, 1, 1], \"uv\": [25, 7]},              {\"origin\": [12, 22, -11], \"size\": [1, 1, 1], \"uv\": [22, 24]},              {\"origin\": [11, 23, -11], \"size\": [1, 1, 1], \"uv\": [15, 27]},              {\"origin\": [11, 23, 10], \"size\": [1, 1, 1], \"uv\": [22, 26]},              {\"origin\": [12, 22, 10], \"size\": [1, 1, 1], \"uv\": [12, 24]},              {\"origin\": [13, 21, 10], \"size\": [1, 1, 1], \"uv\": [22, 16]},              {\"origin\": [12, 21, 11], \"size\": [1, 1, 1], \"uv\": [22, 14]},              {\"origin\": [11, 21, 12], \"size\": [1, 1, 1], \"uv\": [22, 12]},              {\"origin\": [10, 21, 13], \"size\": [1, 1, 1], \"uv\": [22, 10]},              {\"origin\": [11, 22, 11], \"size\": [1, 1, 1], \"uv\": [8, 24]},              {\"origin\": [10, 22, 12], \"size\": [1, 1, 1], \"uv\": [4, 24]},              {\"origin\": [10, 23, 11], \"size\": [1, 1, 1], \"uv\": [12, 26]},              {\"origin\": [-11, 23, 11], \"size\": [1, 1, 1], \"uv\": [8, 26]},              {\"origin\": [-11, 22, 12], \"size\": [1, 1, 1], \"uv\": [25, 23]},              {\"origin\": [-11, 21, 13], \"size\": [1, 1, 1], \"uv\": [22, 8]},              {\"origin\": [-12, 21, 12], \"size\": [1, 1, 1], \"uv\": [22, 6]},              {\"origin\": [-13, 21, 11], \"size\": [1, 1, 1], \"uv\": [14, 21]},              {\"origin\": [-14, 21, 10], \"size\": [1, 1, 1], \"uv\": [6, 21]},              {\"origin\": [-12, 22, 11], \"size\": [1, 1, 1], \"uv\": [25, 17]},              {\"origin\": [-13, 22, 10], \"size\": [1, 1, 1], \"uv\": [25, 15]},              {\"origin\": [-12, 23, 10], \"size\": [1, 1, 1], \"uv\": [4, 26]},              {\"origin\": [-12, 23, -11], \"size\": [1, 1, 1], \"uv\": [0, 26]},              {\"origin\": [-13, 22, -11], \"size\": [1, 1, 1], \"uv\": [15, 25]},              {\"origin\": [-14, 21, -11], \"size\": [1, 1, 1], \"uv\": [13, 18]},              {\"origin\": [-13, 21, -12], \"size\": [1, 1, 1], \"uv\": [0, 18]},              {\"origin\": [-12, 21, -13], \"size\": [1, 1, 1], \"uv\": [14, 3]},              {\"origin\": [-11, 21, -14], \"size\": [1, 1, 1], \"uv\": [14, 0]},              {\"origin\": [-12, 22, -12], \"size\": [1, 1, 1], \"uv\": [25, 13]},              {\"origin\": [-11, 22, -13], \"size\": [1, 1, 1], \"uv\": [25, 11]},              {\"origin\": [-11, 23, -12], \"size\": [1, 1, 1], \"uv\": [25, 25]},              {\"origin\": [-11, 24, -11], \"size\": [2, 1, 2], \"uv\": [6, 7]},              {\"origin\": [-11, 24, 9], \"size\": [2, 1, 2], \"uv\": [0, 6]},              {\"origin\": [7, 25, -9], \"size\": [2, 1, 2], \"uv\": [0, 12]},              {\"origin\": [-7, 26, 5], \"size\": [2, 1, 2], \"uv\": [12, 15]},              {\"origin\": [5, 26, 5], \"size\": [2, 1, 2], \"uv\": [0, 15]},              {\"origin\": [5, 26, -7], \"size\": [2, 1, 2], \"uv\": [6, 13]},              {\"origin\": [-5, 27, 3], \"size\": [2, 1, 2], \"uv\": [22, 3]},              {\"origin\": [-5, 27, -5], \"size\": [2, 1, 2], \"uv\": [22, 0]},              {\"origin\": [3, 27, -5], \"size\": [2, 1, 2], \"uv\": [8, 21]},              {\"origin\": [3, 27, 3], \"size\": [2, 1, 2], \"uv\": [0, 21]},              {\"origin\": [-3, 28, 3], \"size\": [6, 1, 2], \"uv\": [0, 0]},              {\"origin\": [-5, 28, -3], \"size\": [10, 1, 6], \"uv\": [66, 24]},              {\"origin\": [-1, 0, -1], \"size\": [2, 30, 2], \"uv\": [0, 78]}            ]         }       ]     }    ] }   Add textures for blocks  Remember to add a friendly name for the texture in the terrain texture file, add a display name for the block in en_US.lang, and optionally add an entry for the block in blocks.json if you want to give the block a sound. Behavior Pack Step  Create umbrella.json and fill it in using your knowledge from the previous tutorials. If you get lost, that's totally normal. Here are some troubleshooting tips:  Refer back to the custom sushi block - the steps are the same! Check back on your previous blocks Did you forget a file? Did you copy a file without updating a name? Double-check your work in minecraft-samples.  Next up, testing!  Test the Block  With the giant umbrella block defined in both the behavior pack and resource pack, you can now test it in-game.  Open the chat dialogue box (press 'T' or 'Enter' on Windows 10 OS).  Type the following command: /give @p demo:giantumbrella  Now start dropping those beautiful 'brellas!   Note  With blocks larger than the 16x16x16 pixel base cube, the parts of the block that are outside of that 16x16x16 range will overlap with other blocks. Be aware of this when creating oversized blocks to assure you are achieving your desired look, especially if your oversized blocks will be placed near other blocks.  Custom Block Sample Packs  Here is a link to the already-completed custom block sample packs.  Culling  You can make your custom blocks behave like some vanilla blocks do when several of them are placed together by removing unseen, overlapping block faces with \"culling.\"  Culling the unseen, overlapping faces of your blocks can increase performance and decrease instances of graphical glitches.  To use culling, you will need to add a few things to both the behavior pack and the resource pack.  To try this out with the \"tuna roll\" custom sushi block, add these directories and files to the packs:  Custom Block Behavior Pack  Inside the blocks folder, open the tuna_roll.json file and add \"identifier\" and \"culling\" to the minecraft:geometry: section:  JSON Copy \"components\": {   \"minecraft:geometry\": {     \"identifier\": \"geometry.sushi\",     \"culling\": \"test:sushi_cull\"   }, }   Here is the whole tuna_roll.json file:  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:tuna_roll\"     },     \"components\": {       \"minecraft:geometry\": {         \"identifier\": \"geometry.sushi\",         \"culling\": \"test:sushi_cull\"       },       \"minecraft:material_instances\": {         \"north\": \"sushi_side\",         \"south\": \"sushi_side\",         \"*\": {           \"texture\": \"sushi_wrap\"         },         \"sushi_side\": {           \"texture\": \"tuna_roll\"         }       }     }   } }   Custom Block Resource Pack  On the main level of the resource pack, add a directory called: block_culling.  Create a file in there and name it sushi_cull.json, then add these contents:  JSON Copy { \"format_version\": \"1.20.60\", \"minecraft:block_culling_rules\": {     \"description\": {         \"identifier\": \"test:sushi_cull\"     },     \"rules\": [         {          \"geometry_part\": { \"bone\": \"bb_main\", \"cube\": 0, \"face\": \"north\" },          \"direction\": \"north\"         },         {          \"geometry_part\": { \"bone\": \"bb_main\", \"cube\": 0, \"face\": \"south\" },          \"direction\": \"south\"         }     ]   } }  Save the file, and test the culled block.  If you place three culled sushi blocks, they have enough space around them and there is no culling. They will look like normal.  If you swap out the center sushi block for a full-sized block like these acacia planks, only the outer seaweed ring is left!  Next Steps  Your next step is to take this knowledge and go have some fun! We've learned so much about custom blocks during these tutorials, and we can't wait to see what you come up with using these tools and tips.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/customblockoversized?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Advanced Block Visuals: Sizing and Culling 06/10/2025  Custom blocks are not constrained to the usual 16x16x16 Minecraft block geometry. Not only can they be larger than 16x16x16 pixels, but since release 1.20.60, you can use a feature called \"culling\" to dynamically remove parts of the block when it is placed near blocks that occlude one of the sides.  First, we will cover how to create an over-sized block, then we will use one of the examples from another custom block tuorial (the Sushi Block one) to demonstrate culling.  Prerequisites  It's recommended that the following be completed before beginning this tutorial:  Custom Blocks Part One: The Simplest Block Custom Blocks Part Two: Geometry and Material Instances Custom Blocks Part Three: Render and Lighting Options  These blocks can get tricky, but this video takes you through the whole process!  Resource Pack Create geometry in Blockbench  Let's create a 30x30x30 pixel block in Blockbench. First, we have to cover some of the limitations when it comes to creating oversized custom blocks.  Custom block limitations  Your block is limited to 30x30x30 pixels in size.  The absolute bounds of the position of your 30x30x30 block are 30 pixels in each direction from the origin. The origin is in the middle at the bottom of the base 16x16x16 block. So the absolute bounds give you 30 pixels in the +x direction, 30 pixels in the –x direction, 30 pixels in the +y direction, 30 pixels in the –y direction, 30 pixels in the +z direction, and 30 pixels in the –z direction. Your block can be placed in any position within these bounds, as long as it adheres to rule #3.  At least 1 pixel of your block on each axis must be contained by the base 16x16x16 block.  Here is a visualization of the absolute bounds your block must be contained in, in relation to the base 16x16x16 block:  Below you can see some examples of VALID 30x30x30 custom blocks that are contained in the absolute bounds, and have at least ONE CUBE contained in the 16x16x16 base block:  Next, we have an example of a 30x30x30 custom block that is contained in the absolute bounds, but is INVALID since no part of it is contained in the base 16x16x16 block:  Implement the Rest of the Giant Umbrella Block  For this last tutorial, you're on your own setting up the rest of the Giant Umbrella block. Remember, you've got this! Here are the steps you've followed each time you've made a custom block:  Resource Pack Steps Export the file in Blockbench Add geometry to Resource Packs JSON Copy {    \"format_version\": \"1.12.0\",    \"minecraft:geometry\": [      {        \"description\": {          \"identifier\": \"geometry.umbrella\",          \"texture_width\": 128,          \"texture_height\": 128,          \"visible_bounds_width\": 3,          \"visible_bounds_height\": 3.5,          \"visible_bounds_offset\": [0, 1.25, 0]        },        \"bones\": [          {            \"name\": \"umbrella\",            \"pivot\": [0, 13, 0],            \"cubes\": [              {\"origin\": [-3, 28, -5], \"size\": [6, 1, 2], \"uv\": [0, 3]},              {\"origin\": [-5, 27, -7], \"size\": [10, 1, 2], \"uv\": [66, 53]},              {\"origin\": [-5, 27, 5], \"size\": [10, 1, 2], \"uv\": [66, 37]},              {\"origin\": [5, 27, -5], \"size\": [2, 1, 10], \"uv\": [66, 42]},              {\"origin\": [-7, 27, -5], \"size\": [2, 1, 10], \"uv\": [36, 64]},              {\"origin\": [-9, 26, -7], \"size\": [2, 1, 14], \"uv\": [18, 64]},              {\"origin\": [7, 26, -7], \"size\": [2, 1, 14], \"uv\": [0, 63]},              {\"origin\": [9, 25, -9], \"size\": [2, 1, 18], \"uv\": [46, 62]},              {\"origin\": [11, 24, -10], \"size\": [1, 1, 20], \"uv\": [44, 21]},              {\"origin\": [12, 23, -10], \"size\": [1, 1, 20], \"uv\": [0, 42]},              {\"origin\": [13, 22, -10], \"size\": [1, 1, 20], \"uv\": [22, 1]},              {\"origin\": [14, 21, -10], \"size\": [1, 1, 20], \"uv\": [0, 21]},              {\"origin\": [-12, 24, -10], \"size\": [1, 1, 20], \"uv\": [44, 0]},              {\"origin\": [-13, 23, -10], \"size\": [1, 1, 20], \"uv\": [22, 43]},              {\"origin\": [-14, 22, -10], \"size\": [1, 1, 20], \"uv\": [22, 22]},              {\"origin\": [-15, 21, -10], \"size\": [1, 1, 20], \"uv\": [0, 0]},              {\"origin\": [-11, 25, -9], \"size\": [2, 1, 18], \"uv\": [44, 43]},              {\"origin\": [-9, 25, 9], \"size\": [18, 1, 2], \"uv\": [66, 21]},              {\"origin\": [-9, 25, -11], \"size\": [18, 1, 2], \"uv\": [66, 16]},              {\"origin\": [-10, 24, -12], \"size\": [20, 1, 1], \"uv\": [66, 14]},              {\"origin\": [-10, 23, -13], \"size\": [20, 1, 1], \"uv\": [66, 10]},              {\"origin\": [-10, 22, -14], \"size\": [20, 1, 1], \"uv\": [66, 6]},              {\"origin\": [-10, 21, -15], \"size\": [20, 1, 1], \"uv\": [66, 2]},              {\"origin\": [-10, 23, 12], \"size\": [20, 1, 1], \"uv\": [66, 8]},              {\"origin\": [-10, 22, 13], \"size\": [20, 1, 1], \"uv\": [66, 4]},              {\"origin\": [-10, 21, 14], \"size\": [20, 1, 1], \"uv\": [66, 0]},              {\"origin\": [-10, 24, 11], \"size\": [20, 1, 1], \"uv\": [66, 12]},              {\"origin\": [-7, 26, 7], \"size\": [14, 1, 2], \"uv\": [66, 34]},              {\"origin\": [-7, 26, -9], \"size\": [14, 1, 2], \"uv\": [66, 31]},              {\"origin\": [-7, 26, -7], \"size\": [2, 1, 2], \"uv\": [6, 16]},              {\"origin\": [-9, 25, -9], \"size\": [2, 1, 2], \"uv\": [12, 12]},              {\"origin\": [-9, 25, 7], \"size\": [2, 1, 2], \"uv\": [12, 9]},              {\"origin\": [7, 25, 7], \"size\": [2, 1, 2], \"uv\": [12, 6]},              {\"origin\": [9, 24, 9], \"size\": [2, 1, 2], \"uv\": [6, 10]},              {\"origin\": [9, 24, -11], \"size\": [2, 1, 2], \"uv\": [0, 9]},              {\"origin\": [10, 23, -12], \"size\": [1, 1, 1], \"uv\": [25, 27]},              {\"origin\": [10, 22, -13], \"size\": [1, 1, 1], \"uv\": [25, 9]},              {\"origin\": [10, 21, -14], \"size\": [1, 1, 1], \"uv\": [0, 24]},              {\"origin\": [11, 21, -13], \"size\": [1, 1, 1], \"uv\": [15, 23]},              {\"origin\": [12, 21, -12], \"size\": [1, 1, 1], \"uv\": [22, 22]},              {\"origin\": [13, 21, -11], \"size\": [1, 1, 1], \"uv\": [22, 18]},              {\"origin\": [11, 22, -12], \"size\": [1, 1, 1], \"uv\": [25, 7]},              {\"origin\": [12, 22, -11], \"size\": [1, 1, 1], \"uv\": [22, 24]},              {\"origin\": [11, 23, -11], \"size\": [1, 1, 1], \"uv\": [15, 27]},              {\"origin\": [11, 23, 10], \"size\": [1, 1, 1], \"uv\": [22, 26]},              {\"origin\": [12, 22, 10], \"size\": [1, 1, 1], \"uv\": [12, 24]},              {\"origin\": [13, 21, 10], \"size\": [1, 1, 1], \"uv\": [22, 16]},              {\"origin\": [12, 21, 11], \"size\": [1, 1, 1], \"uv\": [22, 14]},              {\"origin\": [11, 21, 12], \"size\": [1, 1, 1], \"uv\": [22, 12]},              {\"origin\": [10, 21, 13], \"size\": [1, 1, 1], \"uv\": [22, 10]},              {\"origin\": [11, 22, 11], \"size\": [1, 1, 1], \"uv\": [8, 24]},              {\"origin\": [10, 22, 12], \"size\": [1, 1, 1], \"uv\": [4, 24]},              {\"origin\": [10, 23, 11], \"size\": [1, 1, 1], \"uv\": [12, 26]},              {\"origin\": [-11, 23, 11], \"size\": [1, 1, 1], \"uv\": [8, 26]},              {\"origin\": [-11, 22, 12], \"size\": [1, 1, 1], \"uv\": [25, 23]},              {\"origin\": [-11, 21, 13], \"size\": [1, 1, 1], \"uv\": [22, 8]},              {\"origin\": [-12, 21, 12], \"size\": [1, 1, 1], \"uv\": [22, 6]},              {\"origin\": [-13, 21, 11], \"size\": [1, 1, 1], \"uv\": [14, 21]},              {\"origin\": [-14, 21, 10], \"size\": [1, 1, 1], \"uv\": [6, 21]},              {\"origin\": [-12, 22, 11], \"size\": [1, 1, 1], \"uv\": [25, 17]},              {\"origin\": [-13, 22, 10], \"size\": [1, 1, 1], \"uv\": [25, 15]},              {\"origin\": [-12, 23, 10], \"size\": [1, 1, 1], \"uv\": [4, 26]},              {\"origin\": [-12, 23, -11], \"size\": [1, 1, 1], \"uv\": [0, 26]},              {\"origin\": [-13, 22, -11], \"size\": [1, 1, 1], \"uv\": [15, 25]},              {\"origin\": [-14, 21, -11], \"size\": [1, 1, 1], \"uv\": [13, 18]},              {\"origin\": [-13, 21, -12], \"size\": [1, 1, 1], \"uv\": [0, 18]},              {\"origin\": [-12, 21, -13], \"size\": [1, 1, 1], \"uv\": [14, 3]},              {\"origin\": [-11, 21, -14], \"size\": [1, 1, 1], \"uv\": [14, 0]},              {\"origin\": [-12, 22, -12], \"size\": [1, 1, 1], \"uv\": [25, 13]},              {\"origin\": [-11, 22, -13], \"size\": [1, 1, 1], \"uv\": [25, 11]},              {\"origin\": [-11, 23, -12], \"size\": [1, 1, 1], \"uv\": [25, 25]},              {\"origin\": [-11, 24, -11], \"size\": [2, 1, 2], \"uv\": [6, 7]},              {\"origin\": [-11, 24, 9], \"size\": [2, 1, 2], \"uv\": [0, 6]},              {\"origin\": [7, 25, -9], \"size\": [2, 1, 2], \"uv\": [0, 12]},              {\"origin\": [-7, 26, 5], \"size\": [2, 1, 2], \"uv\": [12, 15]},              {\"origin\": [5, 26, 5], \"size\": [2, 1, 2], \"uv\": [0, 15]},              {\"origin\": [5, 26, -7], \"size\": [2, 1, 2], \"uv\": [6, 13]},              {\"origin\": [-5, 27, 3], \"size\": [2, 1, 2], \"uv\": [22, 3]},              {\"origin\": [-5, 27, -5], \"size\": [2, 1, 2], \"uv\": [22, 0]},              {\"origin\": [3, 27, -5], \"size\": [2, 1, 2], \"uv\": [8, 21]},              {\"origin\": [3, 27, 3], \"size\": [2, 1, 2], \"uv\": [0, 21]},              {\"origin\": [-3, 28, 3], \"size\": [6, 1, 2], \"uv\": [0, 0]},              {\"origin\": [-5, 28, -3], \"size\": [10, 1, 6], \"uv\": [66, 24]},              {\"origin\": [-1, 0, -1], \"size\": [2, 30, 2], \"uv\": [0, 78]}            ]         }       ]     }    ] }   Add textures for blocks  Remember to add a friendly name for the texture in the terrain texture file, add a display name for the block in en_US.lang, and optionally add an entry for the block in blocks.json if you want to give the block a sound. Behavior Pack Step  Create umbrella.json and fill it in using your knowledge from the previous tutorials. If you get lost, that's totally normal. Here are some troubleshooting tips:  Refer back to the custom sushi block - the steps are the same! Check back on your previous blocks Did you forget a file? Did you copy a file without updating a name? Double-check your work in minecraft-samples.  Next up, testing!  Test the Block  With the giant umbrella block defined in both the behavior pack and resource pack, you can now test it in-game.  Open the chat dialogue box (press 'T' or 'Enter' on Windows 10 OS).  Type the following command: /give @p demo:giantumbrella  Now start dropping those beautiful 'brellas!   Note  With blocks larger than the 16x16x16 pixel base cube, the parts of the block that are outside of that 16x16x16 range will overlap with other blocks. Be aware of this when creating oversized blocks to assure you are achieving your desired look, especially if your oversized blocks will be placed near other blocks.  Custom Block Sample Packs  Here is a link to the already-completed custom block sample packs.  Culling  You can make your custom blocks behave like some vanilla blocks do when several of them are placed together by removing unseen, overlapping block faces with \"culling.\"  Culling the unseen, overlapping faces of your blocks can increase performance and decrease instances of graphical glitches.  To use culling, you will need to add a few things to both the behavior pack and the resource pack.  To try this out with the \"tuna roll\" custom sushi block, add these directories and files to the packs:  Custom Block Behavior Pack  Inside the blocks folder, open the tuna_roll.json file and add \"identifier\" and \"culling\" to the minecraft:geometry: section:  JSON Copy \"components\": {   \"minecraft:geometry\": {     \"identifier\": \"geometry.sushi\",     \"culling\": \"test:sushi_cull\"   }, }   Here is the whole tuna_roll.json file:  JSON Copy {   \"format_version\": \"1.19.40\",   \"minecraft:block\": {     \"description\": {       \"identifier\": \"demo:tuna_roll\"     },     \"components\": {       \"minecraft:geometry\": {         \"identifier\": \"geometry.sushi\",         \"culling\": \"test:sushi_cull\"       },       \"minecraft:material_instances\": {         \"north\": \"sushi_side\",         \"south\": \"sushi_side\",         \"*\": {           \"texture\": \"sushi_wrap\"         },         \"sushi_side\": {           \"texture\": \"tuna_roll\"         }       }     }   } }   Custom Block Resource Pack  On the main level of the resource pack, add a directory called: block_culling.  Create a file in there and name it sushi_cull.json, then add these contents:  JSON Copy { \"format_version\": \"1.20.60\", \"minecraft:block_culling_rules\": {     \"description\": {         \"identifier\": \"test:sushi_cull\"     },     \"rules\": [         {          \"geometry_part\": { \"bone\": \"bb_main\", \"cube\": 0, \"face\": \"north\" },          \"direction\": \"north\"         },         {          \"geometry_part\": { \"bone\": \"bb_main\", \"cube\": 0, \"face\": \"south\" },          \"direction\": \"south\"         }     ]   } }  Save the file, and test the culled block.  If you place three culled sushi blocks, they have enough space around them and there is no culling. They will look like normal.  If you swap out the center sushi block for a full-sized block like these acacia planks, only the outer seaweed ring is left!  Next Steps  Your next step is to take this knowledge and go have some fun! We've learned so much about custom blocks during these tutorials, and we can't wait to see what you come up with using these tools and tips.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gettingstarted?view=minecraft-bedrock-experimental&tabs=Windows10", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Add-On Development for Bedrock Edition 05/07/2025  Whether you create them yourself or get them from another creator, add-ons are the first step on the journey of bringing greater levels of customization to Minecraft: Bedrock Edition. Add-ons allow players to transform the look of their worlds and even change the behavior of entities. For example, you can change the blast radius of a creeper and the texture it's wearing.  In this article, you'll learn:  How to download add-ons for various devices. The file structure used by Minecraft add-ons. How Visual Studio Code can be used for editing JSON files. Where to find applicable extensions for Visual Studio Code. Installing add-ons  Add-ons can be installed on a variety of platforms running Minecraft. Here's how:  Windows 10 or Windows 11 Realms/Console Android iOS Oculus Rift First, you'll need a Windows 10 or Windows 11 computer with Minecraft: Bedrock Edition installed. Download the world or add-on file from the provided source. If the file downloads as a .zip file, change the file extension name to \".mcworld\" or \".mcpack\". Navigate to the directory where you downloaded the file. Open the file and the add-on should open in Minecraft. If you're opening a .mcworld that contains add-ons, the game will notify you that you've successfully imported the world. It will then be available from the \"Play\" menu. If you're opening a .mcpack, a pop-up notification will alert you that you've successfully imported the pack. Depending on the pack type, this will then be available when editing worlds in either the Behavior Pack tab or Resource Pack tab. The com.mojang folder  A folder called com.mojang was added to the AppData folder during Minecraft installation. You'll need to find this folder so you can add your content to it.  To locate the com.mojang folder on your computer, you'll need to have the Hidden items checkbox set to true, as shown below. Also, check the box for File name extensions.  Showing hidden items Open File Explorer from the taskbar. Select the View tab. In the Show/hide section, select the checkboxes for File name extensions and Hidden items.  Locating com.mojang on a Windows device Press Win+R to open Run. If you are using the main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using the preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.   Tip  This is a great time to save a shortcut to this folder on your desktop.  As shown in the image below, there are multiple subdirectories located within the com.mojang folder.   Tip  If you see more content in this folder than what is shown above, do not panic! This image shows a fresh install of Minecraft.  Behavior, Skin, and Resource Packs  There are three folders called behavior_packs, resource_packs, and skin_packs that will store finalized custom content that will be added to Minecraft: Bedrock Edition. Don't worry about these folders right now; you're going to be developing content, so you'll be working in the development versions of these folders, as discussed in the next section.  Development Packs  Use the development_resource_packs and development_behavior_packs folders for the Resource Pack and Behavior Pack tutorials. Development pack folders are updated each time Minecraft is launched, so you can quickly load and test the changes you made to their contents.  minecraftWorlds  minecraftWorlds contains each world that has been generated within the current build of Minecraft. Each folder also contains resource and behavior pack folders for any packs that may be in use within the world.   Tip  When installing a new build of Minecraft, you should save a copy of this folder as a backup to prevent any potential loss of Minecraft worlds that you may have.  Visual Studio Code  The files you'll be creating to customize Minecraft: Bedrock Edition will be written in JSON, a popular format for describing data. JSON can be edited in any text editor such as Notepad or Word, but it's easier to edit it with a programming editor that understands JSON natively. Microsoft's Visual Studio Code is a free programming editor that not only works great with JSON, it supports extensions that add functionality—including some built specifically for Bedrock development.  Installing Visual Studio Code  Follow this link to install Visual Studio Code.  Visual Studio Code Extensions  Visual Studio Code supports extensions created by the Visual Studio Code developer community. Extensions are a great way to help write and understand Minecraft syntax when working on resource and behavior packs.  Here's two recommended extensions for Minecraft development:  Blockception's Minecraft Bedrock Development Bedrock Definitions What's next?  Now that your development environment is set up, you can start creating your first add-on and learn more about resource packs.  Introduction to Resource Packs  Alternatively, if you'd like to learn how to use commands, head on over to Getting Started with Command Blocks and learn how to use command blocks to chain together different commands.  Getting Started with Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/gettingstarted?view=minecraft-bedrock-stable&tabs=Windows10", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Getting Started with Add-On Development for Bedrock Edition 05/07/2025  Whether you create them yourself or get them from another creator, add-ons are the first step on the journey of bringing greater levels of customization to Minecraft: Bedrock Edition. Add-ons allow players to transform the look of their worlds and even change the behavior of entities. For example, you can change the blast radius of a creeper and the texture it's wearing.  In this article, you'll learn:  How to download add-ons for various devices. The file structure used by Minecraft add-ons. How Visual Studio Code can be used for editing JSON files. Where to find applicable extensions for Visual Studio Code. Installing add-ons  Add-ons can be installed on a variety of platforms running Minecraft. Here's how:  Windows 10 or Windows 11 Realms/Console Android iOS Oculus Rift First, you'll need a Windows 10 or Windows 11 computer with Minecraft: Bedrock Edition installed. Download the world or add-on file from the provided source. If the file downloads as a .zip file, change the file extension name to \".mcworld\" or \".mcpack\". Navigate to the directory where you downloaded the file. Open the file and the add-on should open in Minecraft. If you're opening a .mcworld that contains add-ons, the game will notify you that you've successfully imported the world. It will then be available from the \"Play\" menu. If you're opening a .mcpack, a pop-up notification will alert you that you've successfully imported the pack. Depending on the pack type, this will then be available when editing worlds in either the Behavior Pack tab or Resource Pack tab. The com.mojang folder  A folder called com.mojang was added to the AppData folder during Minecraft installation. You'll need to find this folder so you can add your content to it.  To locate the com.mojang folder on your computer, you'll need to have the Hidden items checkbox set to true, as shown below. Also, check the box for File name extensions.  Showing hidden items Open File Explorer from the taskbar. Select the View tab. In the Show/hide section, select the checkboxes for File name extensions and Hidden items.  Locating com.mojang on a Windows device Press Win+R to open Run. If you are using the main Minecraft releases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Alternatively, if you are using the preview Minecraft preleases, copy and paste the following into the Open field: %localappdata%\\Packages\\Microsoft.MinecraftWindowsBeta_8wekyb3d8bbwe\\LocalState\\games\\com.mojang Click OK.   Tip  This is a great time to save a shortcut to this folder on your desktop.  As shown in the image below, there are multiple subdirectories located within the com.mojang folder.   Tip  If you see more content in this folder than what is shown above, do not panic! This image shows a fresh install of Minecraft.  Behavior, Skin, and Resource Packs  There are three folders called behavior_packs, resource_packs, and skin_packs that will store finalized custom content that will be added to Minecraft: Bedrock Edition. Don't worry about these folders right now; you're going to be developing content, so you'll be working in the development versions of these folders, as discussed in the next section.  Development Packs  Use the development_resource_packs and development_behavior_packs folders for the Resource Pack and Behavior Pack tutorials. Development pack folders are updated each time Minecraft is launched, so you can quickly load and test the changes you made to their contents.  minecraftWorlds  minecraftWorlds contains each world that has been generated within the current build of Minecraft. Each folder also contains resource and behavior pack folders for any packs that may be in use within the world.   Tip  When installing a new build of Minecraft, you should save a copy of this folder as a backup to prevent any potential loss of Minecraft worlds that you may have.  Visual Studio Code  The files you'll be creating to customize Minecraft: Bedrock Edition will be written in JSON, a popular format for describing data. JSON can be edited in any text editor such as Notepad or Word, but it's easier to edit it with a programming editor that understands JSON natively. Microsoft's Visual Studio Code is a free programming editor that not only works great with JSON, it supports extensions that add functionality—including some built specifically for Bedrock development.  Installing Visual Studio Code  Follow this link to install Visual Studio Code.  Visual Studio Code Extensions  Visual Studio Code supports extensions created by the Visual Studio Code developer community. Extensions are a great way to help write and understand Minecraft syntax when working on resource and behavior packs.  Here's two recommended extensions for Minecraft development:  Blockception's Minecraft Bedrock Development Bedrock Definitions What's next?  Now that your development environment is set up, you can start creating your first add-on and learn more about resource packs.  Introduction to Resource Packs  Alternatively, if you'd like to learn how to use commands, head on over to Getting Started with Command Blocks and learn how to use command blocks to chain together different commands.  Getting Started with Command Blocks  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structureblockstutorial?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/structureblockstutorial?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Structure Blocks and the Structure Command Tutorial 02/28/2025  For this tutorial, we're going to use structure blocks and the command /structure to create a village and load in an epic statue one block at a time so we can enjoy the animation effects.  We recommend reviewing the following articles before you begin:  Introduction to Commands Introduction to Structure Blocks  There is a sample Structure Blocks behavior pack available at the Minecraft Samples GitHub repo. You can download it to use the same structures used in the tutorial, or to simply get a sense of the structure of behavior packs.  In this tutorial, you will learn:  How to save a log cabin structure with a structure block. How to load a log cabin structure with a structure block. How to use the /structure command to place structures. How to animate a structure into Adventure or Survival mode using a command block and the /structure command. Create a structure  In creative mode, build a structure smaller than 64 x 384 x 64 blocks.  A log cabin is included in the Structure Blocks Samples Behavior Pack as mystructure:house2.  Let's use this as a base to build a village.  To start, we'll save the log cabin.  Choose a name for your structure. Place the structure block so that the bounding box will surround the log cabin. (Or use corner mode to detect the corners). Change the size and offset to better encapsulate the building. Leave Save Entities and Redstone Save Mode as they are, since we are not using them. Leave Show Bounding Box on. Click Save.  Now, the structure is saved and can be placed in your Minecraft world.  Load the structure  Let's begin building a village by adding another log cabin nearby.  Put a structure block on the ground. Load your structure name. We're using mystructure:house2. Adjust the offset. Leave Include Entities since this building has no entities. We won't be using Remove Blocks, Integrity, or Seed since we want to make a usable village. We rotated the building 180 degrees. No mirroring or Animation for us! Don't show bounding box so that our house loads in without it. Click Load.  We'll need another set of stairs but otherwise it's looking good! Now you can place as many copies of this log cabin as you'd like to create a village. You can also customize the look of a village by saving different sections of this building as separate structures (like roofs, eaves, and such) and then varying how they're loaded in.  Using the /structure command  So now we have a saved structure in a structure block. But what if we want to interact with a structure without using a structure block? Let's get to know the /structure command.  Save a structure  This command saves a structure and takes in a name, coordinates, and optionally a save mode, a flag to include entities, and a flag to include blocks.  structure save <name: string> <from: x y z> <to: x y z> [saveMode: StructureSaveMode] [includesEntities: Boolean][includesBlocks: Boolean]  Load a structure  This command loads a structure and takes in the name, location, and optionally rotation, mirroring, animations, entities, and information on whether blocks are include, along with integrity and integrity string.  structure load <name: string> <to: x y z> [rotation: Rotation] [mirror: Mirror] [animationMode: StructureAnimationMode] [animationSeconds: float] [includesEntites: Boolean] [includesBlocks: Boolean] [waterlogged: Boolean] [integrity: float] [seed: string]  Delete a saved structure  This command deletes the saved structure:  structure delete <name: string>  Let's use the /structure command to save and load a structure.  Return to your log cabin. Open the console and enter the /structure save command with the appropriate coordinates. We're using the following: /structure save house1 -371 120 877 -371 131 881 memory  Now, let's load that same structure elsewhere, and rotate it, just to see how that works.  Move to a new spot that needs a house. Open the console and enter the /structure load command with your coordinates. We're using /structure load house1 ~ ~ ~ 90_degrees to load the house at a 90 degree angle.  Great! Now we can build a village more quickly than before.  Load a structure with a command block and /structure command  Let's say we want to load a statue in Adventure mode, using an animation. This could be at the end of an epic adventure map to reward a player's persistence. Or maybe you want to use this as a way to give clues during gameplay.  We're going to place an impulse command block and use the /structure command to load the statue block by block. When users press a button, the statue will appear majestically.  Find a good place for a statue. Open the chat console and type /give @s command_block to give yourself a command block. Type /give @s acacia_button to give yourself an button of any type of wood, such as acacia. Place the command block and acacia button on two blocks that are directly next to each other. Right-click the command block. Enter:  /structure load statue ~ ~ ~ 0_degrees none block_by_block 10  ...into the command input.  This loads the structure called statue at the current location. It does not rotate or mirror it, but animates it in one block at a time over ten seconds. If you wanted to use this mechanic to create a timed scenario, of course you could change 10 to something else.  After you load the structure, change your world from Creative mode to Adventure mode. (Hint: Use /gamemode adventure or /gamemode a.) Click the acacia button and watch! What's next?  Now that you're familiar with structure blocks and the /structure command, you could become the village building speedrun champion, create tons of cool animations using command blocks, or even try out recursively loading structures using structure blocks. Before you get to that, however, we suggest checking out more commands.  Popular Commands Create an In-World Game  To see examples of structures, check out the Minecraft Structure Blocks Behavior Pack Samples.  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourworldwalkthrough?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Parkour Map Walkthrough 09/21/2023  Our team made a map that shows off cool parkour mechanics you can use to challenge players and create a fun gameplay loop. We'll walk through the parkour mechanics that go into this sample parkour map.  What is an objective that can drive player engagement. How challenges can add \"re-play-ability\" to a world. Examples of some (but not all!) parkour mechanics available to you in Minecraft. Objective  Establishing the overall map objective early on allows you to work your way to an end goal for the player to reach. Let's take a look at two popular gameplay loops: Survival and Parkour.  Survivor Map  In a Vanilla Minecraft Survivor map, you can say that reaching The End and slaying the Ender Dragon is the main objective that each player must complete in order to 'win' the game. In this example, we can begin to break down some of the requirements and start asking game design questions for how a player can complete their objective.  How does the player reach The End? What challenges will the player face on their journey to reach the End? What is the reward for completing the objective? Parkour Map  The objective in a parkour map could be as simple as getting across the finish line in the fastest time possible.  In the parkour example, we can also begin asking some questions about the objective and start thinking about the challenges that a player will face to complete their objective.  What is the path I want the player to take? What can I do that will challenge players but still be fun to attempt? Where are the start point and the end point (starting line and finishing line respectively)? Challenges  Simply crossing the finish line may be a rewarding task on its own, but adding player facing definition such as jumps, puzzles and traps can create unique challenges for the player to overcome in their journey to complete the map.  In a parkour map, challenges come from combining gameplay mechanics such as movement speed, jumps, blocks used, and logic puzzles, all while having to continue their journey to the finish line as fast as possible.  Examples of challenges for a parkour map:  Jump distance - Various blocks placed at certain distances requiring the player to jump block to block in order to cross a dangerous path. Or, blocks are placed at different heights to add more challenge. Block properties - Different inherent properties such as ice's reduced friction or a drip leaf's collapsing capabilities can be used to add a timed element that requires fast decision making. Logical puzzles - Redstone piston and archery puzzles can reveal the path forward only after they are solved. Sample Parkour Map  The parkour map we'll be walking through is available at the Minecraft Samples repo.  Sample Parkour World  Use the following directions to add it to your game:  Download the .mcworld file from the repo. Locate the Sample Parkour World.mcworld file and double click it. Boom! You're in.   Note  Be cautious about downloading files from the Internet!  This map uses walls and a ceiling to constrain the player to a particular path. It's very clear to any players getting started exactly where they're going, something we'll mimic in our own map.  NOW ... Let's dive in!  Start of Map 1. Food is provided  That's nice. The creator was kind enough to provide some food. Players will need it to heal from damage and sprint. You also will not simply die immediately, a nice touch.  2. Set spawn point  Clicking the Set Spawnpoint button triggers a command block that sets the closest player's spawnpoint to --2 21 4 (where we happen to be standing).  Now we know how to set spawn points all through the map. Just remember to update the coordinates and include these between particularly difficult sections of the map.  First Challenges - Player Mechanics  Once the player starts the course, they will face our first set of challenges. These challenges will be based around various jumps that the player will have to make. With a focus on 'simple' jumps, we can introduce players to how movement speed can affect jump distance. We can also vary block size to change up the difficulty. This way, players' skills can build on these early jumps later in the map.  Simple jumping challenge  Normal jumps between blocks on the same plane are a great way to start a map. These jumps can be between 1-4 blocks wide. 4 blocks, or a quad, requires players to have a running start to complete them.  2-block gap, one block up jumping challenge  Player has to jump over and up. Slightly harder.  To get started, the player jumps up on the first block so they can jump to the next one. Over one, up one. Classic. If the players fails, they can start over by jumping back on the first block.  3-block gap jumping challenge  Player must jump straight across to a platform that is a 3-block gap away. If the player fails, they have to climb back up the ladder and try again.  Really hard 4-block gap jumping challenge  To make this jump, you need to spring and hang off the block. Or, like me, you can add a ladder in Creative mode to make it.  Jumping onto floating wall blocks  Wall blocks have less space to land on and the drop distance means that failing any of the jumps means starting the section over.  Ladder jumps  Player must jump from ladder to ladder and even go around a corner.  Head Hitters  Try not to bump your head.  Second Challenges - Block Mechanics  New décor! Nice!  This next section focuses on adding difficulty through the use of different block properties. Players now have a firm grasp on some of the player mechanics. So we'll start varying some jumps by introducing some blocks with unique surface properties to alter player movement.  Soul Sand  Soul sand slows down an entity's walk and player's walk when they step on it. This can make it more challenging to make longer jumps.  Ice Blocks  Packed or blue ice is slippery and makes it harder for players to land and to jump to the next block.  Note: Ice blocks may melt in some biomes. Packed ice or blue ice won't, so be sure to use those instead.  Slime jump  Run, jump, bounce ... land?  Slime offers a soft place to land and then will let players jump from high places and land on the next block.  Honey block wall  Honey blocks add a sticky effect on landing, making them harder to jump from. The parkour map uses it to make an otherwise impossible jump by sliding down the wall and slowing the player's fall speed.  Drip leaf plants  Jump before it collapses.  Third Challenges - Redstone Puzzles  In our last set of challenges, we will introduce Redstone logic and some specific Redstone blocks to introduce more puzzle-based mechanics to the player that build upon what they have learned in the last two challenges. We will also look at ways to create traps to impede the player's progress as well.  Levers and pistons  Pull levers, see what happens, plot your course accordingly.  Use bow and arrow to activate a button  Shoot the button to activate the pistons that extend the necessary footholds.  Pressure plate arrow activation  When you land on blocks with pressure plates on them, arrows shoot out at you.  Rainbows and fireworks at the finish line  Finally, we will set up the finish line where the player reaches the end. We will also look at setting up some celebration effects such as celebration message, fireworks and other visual flair.  Go through the tripwire to trigger your well-deserved celebration.  Winning a parkour map (or any map in Minecraft) should feel like an event. There are tons of ways to make ending your map more fun.  Make a more difficult final jump or area for players Make an interesting set piece for the end A sign congratulating the player  In this sample world, we can see all three.  What's Next?  Get some guidance on how best to use gameplay development to create a parkour world you can share with your friends.  Parkour World Creation Guide  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourworldwalkthrough?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Parkour Map Walkthrough 09/21/2023  Our team made a map that shows off cool parkour mechanics you can use to challenge players and create a fun gameplay loop. We'll walk through the parkour mechanics that go into this sample parkour map.  What is an objective that can drive player engagement. How challenges can add \"re-play-ability\" to a world. Examples of some (but not all!) parkour mechanics available to you in Minecraft. Objective  Establishing the overall map objective early on allows you to work your way to an end goal for the player to reach. Let's take a look at two popular gameplay loops: Survival and Parkour.  Survivor Map  In a Vanilla Minecraft Survivor map, you can say that reaching The End and slaying the Ender Dragon is the main objective that each player must complete in order to 'win' the game. In this example, we can begin to break down some of the requirements and start asking game design questions for how a player can complete their objective.  How does the player reach The End? What challenges will the player face on their journey to reach the End? What is the reward for completing the objective? Parkour Map  The objective in a parkour map could be as simple as getting across the finish line in the fastest time possible.  In the parkour example, we can also begin asking some questions about the objective and start thinking about the challenges that a player will face to complete their objective.  What is the path I want the player to take? What can I do that will challenge players but still be fun to attempt? Where are the start point and the end point (starting line and finishing line respectively)? Challenges  Simply crossing the finish line may be a rewarding task on its own, but adding player facing definition such as jumps, puzzles and traps can create unique challenges for the player to overcome in their journey to complete the map.  In a parkour map, challenges come from combining gameplay mechanics such as movement speed, jumps, blocks used, and logic puzzles, all while having to continue their journey to the finish line as fast as possible.  Examples of challenges for a parkour map:  Jump distance - Various blocks placed at certain distances requiring the player to jump block to block in order to cross a dangerous path. Or, blocks are placed at different heights to add more challenge. Block properties - Different inherent properties such as ice's reduced friction or a drip leaf's collapsing capabilities can be used to add a timed element that requires fast decision making. Logical puzzles - Redstone piston and archery puzzles can reveal the path forward only after they are solved. Sample Parkour Map  The parkour map we'll be walking through is available at the Minecraft Samples repo.  Sample Parkour World  Use the following directions to add it to your game:  Download the .mcworld file from the repo. Locate the Sample Parkour World.mcworld file and double click it. Boom! You're in.   Note  Be cautious about downloading files from the Internet!  This map uses walls and a ceiling to constrain the player to a particular path. It's very clear to any players getting started exactly where they're going, something we'll mimic in our own map.  NOW ... Let's dive in!  Start of Map 1. Food is provided  That's nice. The creator was kind enough to provide some food. Players will need it to heal from damage and sprint. You also will not simply die immediately, a nice touch.  2. Set spawn point  Clicking the Set Spawnpoint button triggers a command block that sets the closest player's spawnpoint to --2 21 4 (where we happen to be standing).  Now we know how to set spawn points all through the map. Just remember to update the coordinates and include these between particularly difficult sections of the map.  First Challenges - Player Mechanics  Once the player starts the course, they will face our first set of challenges. These challenges will be based around various jumps that the player will have to make. With a focus on 'simple' jumps, we can introduce players to how movement speed can affect jump distance. We can also vary block size to change up the difficulty. This way, players' skills can build on these early jumps later in the map.  Simple jumping challenge  Normal jumps between blocks on the same plane are a great way to start a map. These jumps can be between 1-4 blocks wide. 4 blocks, or a quad, requires players to have a running start to complete them.  2-block gap, one block up jumping challenge  Player has to jump over and up. Slightly harder.  To get started, the player jumps up on the first block so they can jump to the next one. Over one, up one. Classic. If the players fails, they can start over by jumping back on the first block.  3-block gap jumping challenge  Player must jump straight across to a platform that is a 3-block gap away. If the player fails, they have to climb back up the ladder and try again.  Really hard 4-block gap jumping challenge  To make this jump, you need to spring and hang off the block. Or, like me, you can add a ladder in Creative mode to make it.  Jumping onto floating wall blocks  Wall blocks have less space to land on and the drop distance means that failing any of the jumps means starting the section over.  Ladder jumps  Player must jump from ladder to ladder and even go around a corner.  Head Hitters  Try not to bump your head.  Second Challenges - Block Mechanics  New décor! Nice!  This next section focuses on adding difficulty through the use of different block properties. Players now have a firm grasp on some of the player mechanics. So we'll start varying some jumps by introducing some blocks with unique surface properties to alter player movement.  Soul Sand  Soul sand slows down an entity's walk and player's walk when they step on it. This can make it more challenging to make longer jumps.  Ice Blocks  Packed or blue ice is slippery and makes it harder for players to land and to jump to the next block.  Note: Ice blocks may melt in some biomes. Packed ice or blue ice won't, so be sure to use those instead.  Slime jump  Run, jump, bounce ... land?  Slime offers a soft place to land and then will let players jump from high places and land on the next block.  Honey block wall  Honey blocks add a sticky effect on landing, making them harder to jump from. The parkour map uses it to make an otherwise impossible jump by sliding down the wall and slowing the player's fall speed.  Drip leaf plants  Jump before it collapses.  Third Challenges - Redstone Puzzles  In our last set of challenges, we will introduce Redstone logic and some specific Redstone blocks to introduce more puzzle-based mechanics to the player that build upon what they have learned in the last two challenges. We will also look at ways to create traps to impede the player's progress as well.  Levers and pistons  Pull levers, see what happens, plot your course accordingly.  Use bow and arrow to activate a button  Shoot the button to activate the pistons that extend the necessary footholds.  Pressure plate arrow activation  When you land on blocks with pressure plates on them, arrows shoot out at you.  Rainbows and fireworks at the finish line  Finally, we will set up the finish line where the player reaches the end. We will also look at setting up some celebration effects such as celebration message, fireworks and other visual flair.  Go through the tripwire to trigger your well-deserved celebration.  Winning a parkour map (or any map in Minecraft) should feel like an event. There are tons of ways to make ending your map more fun.  Make a more difficult final jump or area for players Make an interesting set piece for the end A sign congratulating the player  In this sample world, we can see all three.  What's Next?  Get some guidance on how best to use gameplay development to create a parkour world you can share with your friends.  Parkour World Creation Guide  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourworldguide?view=minecraft-bedrock-experimental", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Parkour World Creation Guide 09/21/2023  Whew! That was a lot of information. So far, we've covered gameplay creation and how to use parkour mechanics to make a fun gameplay loop.  In this tutorial, you will learn the following:  What to keep in mind while developing your own parkour map. How gameplay development uses planning, development, testing and release process to release games. Design the Map  First things first: think about a theme you'd like to create for your map. Themes could be anything, from existing biomes to water worlds to a volcanic map.  Having a sense of decorations or design in mind before getting started can help you create a unique gameplay experience.  Plan Challenges  We'll plan parkour content that gets players excited. We'll start off with themes and concepts as well as think about what our gameplay should be like. Planning includes lots of information, like deciding on a theme and which types of challenges we want players to experience.  Player Mechanics  Decide which player mechanics you want players to face. Are you creating a difficult map? Maybe lean towards the more advanced jumps we showed you, or even find others that can be even more fun.  A simple water themed world might start off slow with some basic jumps.  Block Mechanics  Block mechanics are another great way to add variation. Unlike our tutorial map, you can mix those as well.  A volcanic themed world might call for a lot of magma blocks.  Redstone Puzzles  Finally, what Redstone puzzles will you create? Lean on your theme for this.  If you were doing an archaeology adventure theme, players could hit a button with an arrow to reveal a new path.  Ending  Finally, what would be a fun place to end your map with your theme in mind? A space themed map could end with players discovering a UFO to explore.  Think about how you can make the end of the map fun too. Fireworks, signs, or anything else you can think of that would be fun for players.  Build Your World  Time to start building!  Create the Flat World  While command blocks can be used in any Minecraft world, we will be using a flat world for a simple and clean environment.  Launch Minecraft: Bedrock Edition. Select Play, select Create New, then select Create New World. In the world settings, set the world type to Flat. In the world settings, enable Show Coordinates. In the world settings, enable Activate Cheats. Select Create.  Alright! Now you have a clear, flat plane to start developing on. Time to build and iterate on your map.  Test  I test early and often. Pretty much every jump or location you put down in your level is worth testing.  Here are some things to test in a parkour map  Is your path clearly laid out? Can the jumps be completed? Is the happy path fun to run? Do the jumps feel fun together? Do players have enough food to survive treacherous challenges in their way? Are there checkpoints so that players can save progress if you want them to? If a player falls off the map you laid out, will they die? Do all your jumps work as anticipated? Now is the time to ensure the parkour path works as expected, before decorating or completing the ending of the map. Decorate Based On Theme  It's super important to test all your jumps before beginning to add decorations. You'll more than double your work if you're moving a bunch of awesome decorations on top of tweaking your jumps.  Release Prepare World for Release Turn on Keep Inventory in Settings so that players will not lose items you expect them to have in the map. Make sure the player begins at the right place on your map by using /setworldspawn in the right location and facing the right direction. Players will receive anything you have in your inventory. Change the gameplay mode to Adventure so players can't punch through your walls. Export the world to ensure you can share a copy with people and so that you have a clean copy of the world that doesn't have any items removed or puzzles triggered. Release Methods  We'll talk about sharing a world with others. There are several approaches possible:  Create a realm to invite other players to Host a game with your friends in your world Create a World Template with our handy guide What's Next?  You've created an awesome parkour map you can share with friends and other players. You've learned gameplay mechanics and have a grasp of how game development works. Now you can make your map even more fun by creating themed block designs with a custom resource pack.  Resource Pack  Feedback  Was this page helpful?  Yes No"}
{"url": "https://learn.microsoft.com/en-us/minecraft/creator/documents/parkourworldguide?view=minecraft-bedrock-stable", "text": "Learn  Minecraft Bedrock Edition  Ask Learn Parkour World Creation Guide 09/21/2023  Whew! That was a lot of information. So far, we've covered gameplay creation and how to use parkour mechanics to make a fun gameplay loop.  In this tutorial, you will learn the following:  What to keep in mind while developing your own parkour map. How gameplay development uses planning, development, testing and release process to release games. Design the Map  First things first: think about a theme you'd like to create for your map. Themes could be anything, from existing biomes to water worlds to a volcanic map.  Having a sense of decorations or design in mind before getting started can help you create a unique gameplay experience.  Plan Challenges  We'll plan parkour content that gets players excited. We'll start off with themes and concepts as well as think about what our gameplay should be like. Planning includes lots of information, like deciding on a theme and which types of challenges we want players to experience.  Player Mechanics  Decide which player mechanics you want players to face. Are you creating a difficult map? Maybe lean towards the more advanced jumps we showed you, or even find others that can be even more fun.  A simple water themed world might start off slow with some basic jumps.  Block Mechanics  Block mechanics are another great way to add variation. Unlike our tutorial map, you can mix those as well.  A volcanic themed world might call for a lot of magma blocks.  Redstone Puzzles  Finally, what Redstone puzzles will you create? Lean on your theme for this.  If you were doing an archaeology adventure theme, players could hit a button with an arrow to reveal a new path.  Ending  Finally, what would be a fun place to end your map with your theme in mind? A space themed map could end with players discovering a UFO to explore.  Think about how you can make the end of the map fun too. Fireworks, signs, or anything else you can think of that would be fun for players.  Build Your World  Time to start building!  Create the Flat World  While command blocks can be used in any Minecraft world, we will be using a flat world for a simple and clean environment.  Launch Minecraft: Bedrock Edition. Select Play, select Create New, then select Create New World. In the world settings, set the world type to Flat. In the world settings, enable Show Coordinates. In the world settings, enable Activate Cheats. Select Create.  Alright! Now you have a clear, flat plane to start developing on. Time to build and iterate on your map.  Test  I test early and often. Pretty much every jump or location you put down in your level is worth testing.  Here are some things to test in a parkour map  Is your path clearly laid out? Can the jumps be completed? Is the happy path fun to run? Do the jumps feel fun together? Do players have enough food to survive treacherous challenges in their way? Are there checkpoints so that players can save progress if you want them to? If a player falls off the map you laid out, will they die? Do all your jumps work as anticipated? Now is the time to ensure the parkour path works as expected, before decorating or completing the ending of the map. Decorate Based On Theme  It's super important to test all your jumps before beginning to add decorations. You'll more than double your work if you're moving a bunch of awesome decorations on top of tweaking your jumps.  Release Prepare World for Release Turn on Keep Inventory in Settings so that players will not lose items you expect them to have in the map. Make sure the player begins at the right place on your map by using /setworldspawn in the right location and facing the right direction. Players will receive anything you have in your inventory. Change the gameplay mode to Adventure so players can't punch through your walls. Export the world to ensure you can share a copy with people and so that you have a clean copy of the world that doesn't have any items removed or puzzles triggered. Release Methods  We'll talk about sharing a world with others. There are several approaches possible:  Create a realm to invite other players to Host a game with your friends in your world Create a World Template with our handy guide What's Next?  You've created an awesome parkour map you can share with friends and other players. You've learned gameplay mechanics and have a grasp of how game development works. Now you can make your map even more fun by creating themed block designs with a custom resource pack.  Resource Pack  Feedback  Was this page helpful?  Yes No"}
